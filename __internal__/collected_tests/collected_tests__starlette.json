{
  "tests": [
    {
      "name": "test_url_path_for",
      "module": "test_applications",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_applications.py",
      "line_number": 142,
      "end_line_number": 143,
      "source_code": "def test_url_path_for() -> None:\n    assert app.url_path_for(\"func_homepage\") == \"/func\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "os",
        "contextlib.asynccontextmanager",
        "pathlib.Path",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio.from_thread",
        "pytest",
        "starlette.status",
        "starlette.applications.Starlette",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.middleware.trustedhost.TrustedHostMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.staticfiles.StaticFiles",
        "starlette.testclient.TestClient",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.url_path_for('func_homepage') == '/func'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_func_route",
      "module": "test_applications",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_applications.py",
      "line_number": 146,
      "end_line_number": 153,
      "source_code": "def test_func_route(client: TestClient) -> None:\n    response = client.get(\"/func\")\n    assert response.status_code == 200\n    assert response.text == \"Hello, world!\"\n\n    response = client.head(\"/func\")\n    assert response.status_code == 200\n    assert response.text == \"\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "client"
      ],
      "imports": [
        "os",
        "contextlib.asynccontextmanager",
        "pathlib.Path",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio.from_thread",
        "pytest",
        "starlette.status",
        "starlette.applications.Starlette",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.middleware.trustedhost.TrustedHostMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.staticfiles.StaticFiles",
        "starlette.testclient.TestClient",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == 'Hello, world!'",
        "assert response.status_code == 200",
        "assert response.text == ''"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_async_route",
      "module": "test_applications",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_applications.py",
      "line_number": 156,
      "end_line_number": 159,
      "source_code": "def test_async_route(client: TestClient) -> None:\n    response = client.get(\"/async\")\n    assert response.status_code == 200\n    assert response.text == \"Hello, world!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "client"
      ],
      "imports": [
        "os",
        "contextlib.asynccontextmanager",
        "pathlib.Path",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio.from_thread",
        "pytest",
        "starlette.status",
        "starlette.applications.Starlette",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.middleware.trustedhost.TrustedHostMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.staticfiles.StaticFiles",
        "starlette.testclient.TestClient",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == 'Hello, world!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_class_route",
      "module": "test_applications",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_applications.py",
      "line_number": 162,
      "end_line_number": 165,
      "source_code": "def test_class_route(client: TestClient) -> None:\n    response = client.get(\"/class\")\n    assert response.status_code == 200\n    assert response.text == \"Hello, world!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "client"
      ],
      "imports": [
        "os",
        "contextlib.asynccontextmanager",
        "pathlib.Path",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio.from_thread",
        "pytest",
        "starlette.status",
        "starlette.applications.Starlette",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.middleware.trustedhost.TrustedHostMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.staticfiles.StaticFiles",
        "starlette.testclient.TestClient",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == 'Hello, world!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_mounted_route",
      "module": "test_applications",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_applications.py",
      "line_number": 168,
      "end_line_number": 171,
      "source_code": "def test_mounted_route(client: TestClient) -> None:\n    response = client.get(\"/users/\")\n    assert response.status_code == 200\n    assert response.text == \"Hello, everyone!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "client"
      ],
      "imports": [
        "os",
        "contextlib.asynccontextmanager",
        "pathlib.Path",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio.from_thread",
        "pytest",
        "starlette.status",
        "starlette.applications.Starlette",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.middleware.trustedhost.TrustedHostMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.staticfiles.StaticFiles",
        "starlette.testclient.TestClient",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == 'Hello, everyone!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_mounted_route_path_params",
      "module": "test_applications",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_applications.py",
      "line_number": 174,
      "end_line_number": 177,
      "source_code": "def test_mounted_route_path_params(client: TestClient) -> None:\n    response = client.get(\"/users/tomchristie\")\n    assert response.status_code == 200\n    assert response.text == \"Hello, tomchristie!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "client"
      ],
      "imports": [
        "os",
        "contextlib.asynccontextmanager",
        "pathlib.Path",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio.from_thread",
        "pytest",
        "starlette.status",
        "starlette.applications.Starlette",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.middleware.trustedhost.TrustedHostMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.staticfiles.StaticFiles",
        "starlette.testclient.TestClient",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == 'Hello, tomchristie!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_subdomain_route",
      "module": "test_applications",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_applications.py",
      "line_number": 180,
      "end_line_number": 185,
      "source_code": "def test_subdomain_route(test_client_factory: TestClientFactory) -> None:\n    client = test_client_factory(app, base_url=\"https://foo.example.org/\")\n\n    response = client.get(\"/\")\n    assert response.status_code == 200\n    assert response.text == \"Subdomain: foo\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "os",
        "contextlib.asynccontextmanager",
        "pathlib.Path",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio.from_thread",
        "pytest",
        "starlette.status",
        "starlette.applications.Starlette",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.middleware.trustedhost.TrustedHostMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.staticfiles.StaticFiles",
        "starlette.testclient.TestClient",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == 'Subdomain: foo'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_websocket_route",
      "module": "test_applications",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_applications.py",
      "line_number": 188,
      "end_line_number": 191,
      "source_code": "def test_websocket_route(client: TestClient) -> None:\n    with client.websocket_connect(\"/ws\") as session:\n        text = session.receive_text()\n        assert text == \"Hello, world!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "client"
      ],
      "imports": [
        "os",
        "contextlib.asynccontextmanager",
        "pathlib.Path",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio.from_thread",
        "pytest",
        "starlette.status",
        "starlette.applications.Starlette",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.middleware.trustedhost.TrustedHostMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.staticfiles.StaticFiles",
        "starlette.testclient.TestClient",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert text == 'Hello, world!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_400",
      "module": "test_applications",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_applications.py",
      "line_number": 194,
      "end_line_number": 197,
      "source_code": "def test_400(client: TestClient) -> None:\n    response = client.get(\"/404\")\n    assert response.status_code == 404\n    assert response.json() == {\"detail\": \"Not Found\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "client"
      ],
      "imports": [
        "os",
        "contextlib.asynccontextmanager",
        "pathlib.Path",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio.from_thread",
        "pytest",
        "starlette.status",
        "starlette.applications.Starlette",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.middleware.trustedhost.TrustedHostMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.staticfiles.StaticFiles",
        "starlette.testclient.TestClient",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 404",
        "assert response.json() == {'detail': 'Not Found'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_405",
      "module": "test_applications",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_applications.py",
      "line_number": 200,
      "end_line_number": 207,
      "source_code": "def test_405(client: TestClient) -> None:\n    response = client.post(\"/func\")\n    assert response.status_code == 405\n    assert response.json() == {\"detail\": \"Custom message\"}\n\n    response = client.post(\"/class\")\n    assert response.status_code == 405\n    assert response.json() == {\"detail\": \"Custom message\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "client"
      ],
      "imports": [
        "os",
        "contextlib.asynccontextmanager",
        "pathlib.Path",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio.from_thread",
        "pytest",
        "starlette.status",
        "starlette.applications.Starlette",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.middleware.trustedhost.TrustedHostMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.staticfiles.StaticFiles",
        "starlette.testclient.TestClient",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 405",
        "assert response.json() == {'detail': 'Custom message'}",
        "assert response.status_code == 405",
        "assert response.json() == {'detail': 'Custom message'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_500",
      "module": "test_applications",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_applications.py",
      "line_number": 210,
      "end_line_number": 214,
      "source_code": "def test_500(test_client_factory: TestClientFactory) -> None:\n    client = test_client_factory(app, raise_server_exceptions=False)\n    response = client.get(\"/500\")\n    assert response.status_code == 500\n    assert response.json() == {\"detail\": \"Server Error\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "os",
        "contextlib.asynccontextmanager",
        "pathlib.Path",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio.from_thread",
        "pytest",
        "starlette.status",
        "starlette.applications.Starlette",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.middleware.trustedhost.TrustedHostMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.staticfiles.StaticFiles",
        "starlette.testclient.TestClient",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 500",
        "assert response.json() == {'detail': 'Server Error'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_websocket_raise_websocket_exception",
      "module": "test_applications",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_applications.py",
      "line_number": 217,
      "end_line_number": 224,
      "source_code": "def test_websocket_raise_websocket_exception(client: TestClient) -> None:\n    with client.websocket_connect(\"/ws-raise-websocket\") as session:\n        response = session.receive()\n        assert response == {\n            \"type\": \"websocket.close\",\n            \"code\": status.WS_1003_UNSUPPORTED_DATA,\n            \"reason\": \"\",\n        }",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "client"
      ],
      "imports": [
        "os",
        "contextlib.asynccontextmanager",
        "pathlib.Path",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio.from_thread",
        "pytest",
        "starlette.status",
        "starlette.applications.Starlette",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.middleware.trustedhost.TrustedHostMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.staticfiles.StaticFiles",
        "starlette.testclient.TestClient",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response == {'type': 'websocket.close', 'code': status.WS_1003_UNSUPPORTED_DATA, 'reason': ''}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_websocket_raise_http_exception",
      "module": "test_applications",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_applications.py",
      "line_number": 227,
      "end_line_number": 232,
      "source_code": "def test_websocket_raise_http_exception(client: TestClient) -> None:\n    with pytest.raises(WebSocketDenialResponse) as exc:\n        with client.websocket_connect(\"/ws-raise-http\"):\n            pass  # pragma: no cover\n    assert exc.value.status_code == 401\n    assert exc.value.content == b'{\"detail\":\"Unauthorized\"}'",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "client"
      ],
      "imports": [
        "os",
        "contextlib.asynccontextmanager",
        "pathlib.Path",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio.from_thread",
        "pytest",
        "starlette.status",
        "starlette.applications.Starlette",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.middleware.trustedhost.TrustedHostMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.staticfiles.StaticFiles",
        "starlette.testclient.TestClient",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert exc.value.status_code == 401",
        "assert exc.value.content == b'{\"detail\":\"Unauthorized\"}'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_websocket_raise_custom_exception",
      "module": "test_applications",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_applications.py",
      "line_number": 235,
      "end_line_number": 242,
      "source_code": "def test_websocket_raise_custom_exception(client: TestClient) -> None:\n    with client.websocket_connect(\"/ws-raise-custom\") as session:\n        response = session.receive()\n        assert response == {\n            \"type\": \"websocket.close\",\n            \"code\": status.WS_1013_TRY_AGAIN_LATER,\n            \"reason\": \"\",\n        }",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "client"
      ],
      "imports": [
        "os",
        "contextlib.asynccontextmanager",
        "pathlib.Path",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio.from_thread",
        "pytest",
        "starlette.status",
        "starlette.applications.Starlette",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.middleware.trustedhost.TrustedHostMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.staticfiles.StaticFiles",
        "starlette.testclient.TestClient",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response == {'type': 'websocket.close', 'code': status.WS_1013_TRY_AGAIN_LATER, 'reason': ''}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_middleware",
      "module": "test_applications",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_applications.py",
      "line_number": 245,
      "end_line_number": 249,
      "source_code": "def test_middleware(test_client_factory: TestClientFactory) -> None:\n    client = test_client_factory(app, base_url=\"http://incorrecthost\")\n    response = client.get(\"/func\")\n    assert response.status_code == 400\n    assert response.text == \"Invalid host header\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "os",
        "contextlib.asynccontextmanager",
        "pathlib.Path",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio.from_thread",
        "pytest",
        "starlette.status",
        "starlette.applications.Starlette",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.middleware.trustedhost.TrustedHostMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.staticfiles.StaticFiles",
        "starlette.testclient.TestClient",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 400",
        "assert response.text == 'Invalid host header'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_routes",
      "module": "test_applications",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_applications.py",
      "line_number": 252,
      "end_line_number": 275,
      "source_code": "def test_routes() -> None:\n    assert app.routes == [\n        Route(\"/func\", endpoint=func_homepage, methods=[\"GET\"]),\n        Route(\"/async\", endpoint=async_homepage, methods=[\"GET\"]),\n        Route(\"/class\", endpoint=Homepage),\n        Route(\"/500\", endpoint=runtime_error, methods=[\"GET\"]),\n        WebSocketRoute(\"/ws\", endpoint=websocket_endpoint),\n        WebSocketRoute(\"/ws-raise-websocket\", endpoint=websocket_raise_websocket_exception),\n        WebSocketRoute(\"/ws-raise-http\", endpoint=websocket_raise_http_exception),\n        WebSocketRoute(\"/ws-raise-custom\", endpoint=websocket_raise_custom),\n        Mount(\n            \"/users\",\n            app=Router(\n                routes=[\n                    Route(\"/\", endpoint=all_users_page),\n                    Route(\"/{username}\", endpoint=user_page),\n                ]\n            ),\n        ),\n        Host(\n            \"{subdomain}.example.org\",\n            app=Router(routes=[Route(\"/\", endpoint=custom_subdomain)]),\n        ),\n    ]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "os",
        "contextlib.asynccontextmanager",
        "pathlib.Path",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio.from_thread",
        "pytest",
        "starlette.status",
        "starlette.applications.Starlette",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.middleware.trustedhost.TrustedHostMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.staticfiles.StaticFiles",
        "starlette.testclient.TestClient",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.routes == [Route('/func', endpoint=func_homepage, methods=['GET']), Route('/async', endpoint=async_homepage, methods=['GET']), Route('/class', endpoint=Homepage), Route('/500', endpoint=runtime_error, methods=['GET']), WebSocketRoute('/ws', endpoint=websocket_endpoint), WebSocketRoute('/ws-raise-websocket', endpoint=websocket_raise_websocket_exception), WebSocketRoute('/ws-raise-http', endpoint=websocket_raise_http_exception), WebSocketRoute('/ws-raise-custom', endpoint=websocket_raise_custom), Mount('/users', app=Router(routes=[Route('/', endpoint=all_users_page), Route('/{username}', endpoint=user_page)])), Host('{subdomain}.example.org', app=Router(routes=[Route('/', endpoint=custom_subdomain)]))]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_app_mount",
      "module": "test_applications",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_applications.py",
      "line_number": 278,
      "end_line_number": 297,
      "source_code": "def test_app_mount(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    path = os.path.join(tmpdir, \"example.txt\")\n    with open(path, \"w\") as file:\n        file.write(\"<file content>\")\n\n    app = Starlette(\n        routes=[\n            Mount(\"/static\", StaticFiles(directory=tmpdir)),\n        ]\n    )\n\n    client = test_client_factory(app)\n\n    response = client.get(\"/static/example.txt\")\n    assert response.status_code == 200\n    assert response.text == \"<file content>\"\n\n    response = client.post(\"/static/example.txt\")\n    assert response.status_code == 405\n    assert response.text == \"Method Not Allowed\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "os",
        "contextlib.asynccontextmanager",
        "pathlib.Path",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio.from_thread",
        "pytest",
        "starlette.status",
        "starlette.applications.Starlette",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.middleware.trustedhost.TrustedHostMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.staticfiles.StaticFiles",
        "starlette.testclient.TestClient",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == '<file content>'",
        "assert response.status_code == 405",
        "assert response.text == 'Method Not Allowed'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_app_debug",
      "module": "test_applications",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_applications.py",
      "line_number": 300,
      "end_line_number": 315,
      "source_code": "def test_app_debug(test_client_factory: TestClientFactory) -> None:\n    async def homepage(request: Request) -> None:\n        raise RuntimeError()\n\n    app = Starlette(\n        routes=[\n            Route(\"/\", homepage),\n        ],\n    )\n    app.debug = True\n\n    client = test_client_factory(app, raise_server_exceptions=False)\n    response = client.get(\"/\")\n    assert response.status_code == 500\n    assert \"RuntimeError\" in response.text\n    assert app.debug",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "os",
        "contextlib.asynccontextmanager",
        "pathlib.Path",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio.from_thread",
        "pytest",
        "starlette.status",
        "starlette.applications.Starlette",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.middleware.trustedhost.TrustedHostMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.staticfiles.StaticFiles",
        "starlette.testclient.TestClient",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 500",
        "assert 'RuntimeError' in response.text",
        "assert app.debug"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_app_add_route",
      "module": "test_applications",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_applications.py",
      "line_number": 318,
      "end_line_number": 331,
      "source_code": "def test_app_add_route(test_client_factory: TestClientFactory) -> None:\n    async def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"Hello, World!\")\n\n    app = Starlette(\n        routes=[\n            Route(\"/\", endpoint=homepage),\n        ]\n    )\n\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.status_code == 200\n    assert response.text == \"Hello, World!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "os",
        "contextlib.asynccontextmanager",
        "pathlib.Path",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio.from_thread",
        "pytest",
        "starlette.status",
        "starlette.applications.Starlette",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.middleware.trustedhost.TrustedHostMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.staticfiles.StaticFiles",
        "starlette.testclient.TestClient",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == 'Hello, World!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_app_add_websocket_route",
      "module": "test_applications",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_applications.py",
      "line_number": 334,
      "end_line_number": 349,
      "source_code": "def test_app_add_websocket_route(test_client_factory: TestClientFactory) -> None:\n    async def websocket_endpoint(session: WebSocket) -> None:\n        await session.accept()\n        await session.send_text(\"Hello, world!\")\n        await session.close()\n\n    app = Starlette(\n        routes=[\n            WebSocketRoute(\"/ws\", endpoint=websocket_endpoint),\n        ]\n    )\n    client = test_client_factory(app)\n\n    with client.websocket_connect(\"/ws\") as session:\n        text = session.receive_text()\n        assert text == \"Hello, world!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "os",
        "contextlib.asynccontextmanager",
        "pathlib.Path",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio.from_thread",
        "pytest",
        "starlette.status",
        "starlette.applications.Starlette",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.middleware.trustedhost.TrustedHostMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.staticfiles.StaticFiles",
        "starlette.testclient.TestClient",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert text == 'Hello, world!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_app_add_event_handler",
      "module": "test_applications",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_applications.py",
      "line_number": 352,
      "end_line_number": 376,
      "source_code": "def test_app_add_event_handler(test_client_factory: TestClientFactory) -> None:\n    startup_complete = False\n    cleanup_complete = False\n\n    def run_startup() -> None:\n        nonlocal startup_complete\n        startup_complete = True\n\n    def run_cleanup() -> None:\n        nonlocal cleanup_complete\n        cleanup_complete = True\n\n    with pytest.deprecated_call(match=\"The on_startup and on_shutdown parameters are deprecated\"):\n        app = Starlette(\n            on_startup=[run_startup],\n            on_shutdown=[run_cleanup],\n        )\n\n    assert not startup_complete\n    assert not cleanup_complete\n    with test_client_factory(app):\n        assert startup_complete\n        assert not cleanup_complete\n    assert startup_complete\n    assert cleanup_complete",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "os",
        "contextlib.asynccontextmanager",
        "pathlib.Path",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio.from_thread",
        "pytest",
        "starlette.status",
        "starlette.applications.Starlette",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.middleware.trustedhost.TrustedHostMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.staticfiles.StaticFiles",
        "starlette.testclient.TestClient",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert not startup_complete",
        "assert not cleanup_complete",
        "assert startup_complete",
        "assert cleanup_complete",
        "assert startup_complete",
        "assert not cleanup_complete"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_app_async_cm_lifespan",
      "module": "test_applications",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_applications.py",
      "line_number": 379,
      "end_line_number": 398,
      "source_code": "def test_app_async_cm_lifespan(test_client_factory: TestClientFactory) -> None:\n    startup_complete = False\n    cleanup_complete = False\n\n    @asynccontextmanager\n    async def lifespan(app: ASGIApp) -> AsyncGenerator[None, None]:\n        nonlocal startup_complete, cleanup_complete\n        startup_complete = True\n        yield\n        cleanup_complete = True\n\n    app = Starlette(lifespan=lifespan)\n\n    assert not startup_complete\n    assert not cleanup_complete\n    with test_client_factory(app):\n        assert startup_complete\n        assert not cleanup_complete\n    assert startup_complete\n    assert cleanup_complete",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "os",
        "contextlib.asynccontextmanager",
        "pathlib.Path",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio.from_thread",
        "pytest",
        "starlette.status",
        "starlette.applications.Starlette",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.middleware.trustedhost.TrustedHostMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.staticfiles.StaticFiles",
        "starlette.testclient.TestClient",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert not startup_complete",
        "assert not cleanup_complete",
        "assert startup_complete",
        "assert cleanup_complete",
        "assert startup_complete",
        "assert not cleanup_complete"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_app_async_gen_lifespan",
      "module": "test_applications",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_applications.py",
      "line_number": 411,
      "end_line_number": 429,
      "source_code": "def test_app_async_gen_lifespan(test_client_factory: TestClientFactory) -> None:\n    startup_complete = False\n    cleanup_complete = False\n\n    async def lifespan(app: ASGIApp) -> AsyncGenerator[None, None]:\n        nonlocal startup_complete, cleanup_complete\n        startup_complete = True\n        yield\n        cleanup_complete = True\n\n    app = Starlette(lifespan=lifespan)  # type: ignore\n\n    assert not startup_complete\n    assert not cleanup_complete\n    with test_client_factory(app):\n        assert startup_complete\n        assert not cleanup_complete\n    assert startup_complete\n    assert cleanup_complete",
      "docstring": null,
      "decorators": [
        "deprecated_lifespan"
      ],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "os",
        "contextlib.asynccontextmanager",
        "pathlib.Path",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio.from_thread",
        "pytest",
        "starlette.status",
        "starlette.applications.Starlette",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.middleware.trustedhost.TrustedHostMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.staticfiles.StaticFiles",
        "starlette.testclient.TestClient",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert not startup_complete",
        "assert not cleanup_complete",
        "assert startup_complete",
        "assert cleanup_complete",
        "assert startup_complete",
        "assert not cleanup_complete"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_app_sync_gen_lifespan",
      "module": "test_applications",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_applications.py",
      "line_number": 433,
      "end_line_number": 451,
      "source_code": "def test_app_sync_gen_lifespan(test_client_factory: TestClientFactory) -> None:\n    startup_complete = False\n    cleanup_complete = False\n\n    def lifespan(app: ASGIApp) -> Generator[None, None, None]:\n        nonlocal startup_complete, cleanup_complete\n        startup_complete = True\n        yield\n        cleanup_complete = True\n\n    app = Starlette(lifespan=lifespan)  # type: ignore\n\n    assert not startup_complete\n    assert not cleanup_complete\n    with test_client_factory(app):\n        assert startup_complete\n        assert not cleanup_complete\n    assert startup_complete\n    assert cleanup_complete",
      "docstring": null,
      "decorators": [
        "deprecated_lifespan"
      ],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "os",
        "contextlib.asynccontextmanager",
        "pathlib.Path",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio.from_thread",
        "pytest",
        "starlette.status",
        "starlette.applications.Starlette",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.middleware.trustedhost.TrustedHostMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.staticfiles.StaticFiles",
        "starlette.testclient.TestClient",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert not startup_complete",
        "assert not cleanup_complete",
        "assert startup_complete",
        "assert cleanup_complete",
        "assert startup_complete",
        "assert not cleanup_complete"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_decorator_deprecations",
      "module": "test_applications",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_applications.py",
      "line_number": 454,
      "end_line_number": 491,
      "source_code": "def test_decorator_deprecations() -> None:\n    app = Starlette()\n\n    with pytest.deprecated_call(\n        match=(\"The `exception_handler` decorator is deprecated, and will be removed in version 1.0.0.\")\n    ) as record:\n        app.exception_handler(500)(http_exception)\n        assert len(record) == 1\n\n    with pytest.deprecated_call(\n        match=(\"The `middleware` decorator is deprecated, and will be removed in version 1.0.0.\")\n    ) as record:\n\n        async def middleware(request: Request, call_next: RequestResponseEndpoint) -> None: ...  # pragma: no cover\n\n        app.middleware(\"http\")(middleware)\n        assert len(record) == 1\n\n    with pytest.deprecated_call(\n        match=(\"The `route` decorator is deprecated, and will be removed in version 1.0.0.\")\n    ) as record:\n        app.route(\"/\")(async_homepage)\n        assert len(record) == 1\n\n    with pytest.deprecated_call(\n        match=(\"The `websocket_route` decorator is deprecated, and will be removed in version 1.0.0.\")\n    ) as record:\n        app.websocket_route(\"/ws\")(websocket_endpoint)\n        assert len(record) == 1\n\n    with pytest.deprecated_call(\n        match=(\"The `on_event` decorator is deprecated, and will be removed in version 1.0.0.\")\n    ) as record:\n\n        async def startup() -> None: ...  # pragma: no cover\n\n        app.on_event(\"startup\")(startup)\n        assert len(record) == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "os",
        "contextlib.asynccontextmanager",
        "pathlib.Path",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio.from_thread",
        "pytest",
        "starlette.status",
        "starlette.applications.Starlette",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.middleware.trustedhost.TrustedHostMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.staticfiles.StaticFiles",
        "starlette.testclient.TestClient",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(record) == 1",
        "assert len(record) == 1",
        "assert len(record) == 1",
        "assert len(record) == 1",
        "assert len(record) == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_middleware_stack_init",
      "module": "test_applications",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_applications.py",
      "line_number": 494,
      "end_line_number": 533,
      "source_code": "def test_middleware_stack_init(test_client_factory: TestClientFactory) -> None:\n    class NoOpMiddleware:\n        def __init__(self, app: ASGIApp):\n            self.app = app\n\n        async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n            await self.app(scope, receive, send)\n\n    class SimpleInitializableMiddleware:\n        counter = 0\n\n        def __init__(self, app: ASGIApp):\n            self.app = app\n            SimpleInitializableMiddleware.counter += 1\n\n        async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n            await self.app(scope, receive, send)\n\n    def get_app() -> ASGIApp:\n        app = Starlette()\n        app.add_middleware(SimpleInitializableMiddleware)\n        app.add_middleware(NoOpMiddleware)\n        return app\n\n    app = get_app()\n\n    with test_client_factory(app):\n        pass\n\n    assert SimpleInitializableMiddleware.counter == 1\n\n    test_client_factory(app).get(\"/foo\")\n\n    assert SimpleInitializableMiddleware.counter == 1\n\n    app = get_app()\n\n    test_client_factory(app).get(\"/foo\")\n\n    assert SimpleInitializableMiddleware.counter == 2",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "os",
        "contextlib.asynccontextmanager",
        "pathlib.Path",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio.from_thread",
        "pytest",
        "starlette.status",
        "starlette.applications.Starlette",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.middleware.trustedhost.TrustedHostMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.staticfiles.StaticFiles",
        "starlette.testclient.TestClient",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert SimpleInitializableMiddleware.counter == 1",
        "assert SimpleInitializableMiddleware.counter == 1",
        "assert SimpleInitializableMiddleware.counter == 2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_app",
          "body": "def get_app() -> ASGIApp:\n    app = Starlette()\n    app.add_middleware(SimpleInitializableMiddleware)\n    app.add_middleware(NoOpMiddleware)\n    return app"
        },
        {
          "name": "get_app",
          "body": "def get_app() -> ASGIApp:\n    app = Starlette()\n    app.add_middleware(SimpleInitializableMiddleware)\n    app.add_middleware(NoOpMiddleware)\n    return app"
        },
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "self.app",
          "body": "def app(request: Request) -> Response:\n    return endpoint(request=request, **kwargs)"
        },
        {
          "name": "self.app",
          "body": "def app(request: Request) -> Response:\n    return endpoint(request=request, **kwargs)"
        }
      ]
    },
    {
      "name": "test_lifespan_app_subclass",
      "module": "test_applications",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_applications.py",
      "line_number": 536,
      "end_line_number": 547,
      "source_code": "def test_lifespan_app_subclass() -> None:\n    # This test exists to make sure that subclasses of Starlette\n    # (like FastAPI) are compatible with the types hints for Lifespan\n\n    class App(Starlette):\n        pass\n\n    @asynccontextmanager\n    async def lifespan(app: App) -> AsyncIterator[None]:  # pragma: no cover\n        yield\n\n    App(lifespan=lifespan)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "os",
        "contextlib.asynccontextmanager",
        "pathlib.Path",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio.from_thread",
        "pytest",
        "starlette.status",
        "starlette.applications.Starlette",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.middleware.trustedhost.TrustedHostMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.staticfiles.StaticFiles",
        "starlette.testclient.TestClient",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_schema_generation",
      "module": "test_schemas",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_schemas.py",
      "line_number": 133,
      "end_line_number": 188,
      "source_code": "def test_schema_generation() -> None:\n    schema = schemas.get_schema(routes=app.routes)\n    assert schema == {\n        \"openapi\": \"3.0.0\",\n        \"info\": {\"title\": \"Example API\", \"version\": \"1.0\"},\n        \"paths\": {\n            \"/orgs\": {\n                \"get\": {\n                    \"responses\": {\n                        200: {\n                            \"description\": \"A list of organisations.\",\n                            \"examples\": [{\"name\": \"Foo Corp.\"}, {\"name\": \"Acme Ltd.\"}],\n                        }\n                    }\n                },\n                \"post\": {\n                    \"responses\": {\n                        200: {\n                            \"description\": \"An organisation.\",\n                            \"examples\": {\"name\": \"Foo Corp.\"},\n                        }\n                    }\n                },\n            },\n            \"/regular-docstring-and-schema\": {\n                \"get\": {\"responses\": {200: {\"description\": \"This is included in the schema.\"}}}\n            },\n            \"/subapp/subapp-endpoint\": {\n                \"get\": {\"responses\": {200: {\"description\": \"This endpoint is part of a subapp.\"}}}\n            },\n            \"/subapp2/subapp-endpoint\": {\n                \"get\": {\"responses\": {200: {\"description\": \"This endpoint is part of a subapp.\"}}}\n            },\n            \"/users\": {\n                \"get\": {\n                    \"responses\": {\n                        200: {\n                            \"description\": \"A list of users.\",\n                            \"examples\": [{\"username\": \"tom\"}, {\"username\": \"lucy\"}],\n                        }\n                    }\n                },\n                \"post\": {\"responses\": {200: {\"description\": \"A user.\", \"examples\": {\"username\": \"tom\"}}}},\n            },\n            \"/users/{id}\": {\n                \"get\": {\n                    \"responses\": {\n                        200: {\n                            \"description\": \"A user.\",\n                            \"examples\": {\"username\": \"tom\"},\n                        }\n                    }\n                },\n            },\n        },\n    }",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "starlette.applications.Starlette",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.schemas.SchemaGenerator",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert schema == {'openapi': '3.0.0', 'info': {'title': 'Example API', 'version': '1.0'}, 'paths': {'/orgs': {'get': {'responses': {200: {'description': 'A list of organisations.', 'examples': [{'name': 'Foo Corp.'}, {'name': 'Acme Ltd.'}]}}}, 'post': {'responses': {200: {'description': 'An organisation.', 'examples': {'name': 'Foo Corp.'}}}}}, '/regular-docstring-and-schema': {'get': {'responses': {200: {'description': 'This is included in the schema.'}}}}, '/subapp/subapp-endpoint': {'get': {'responses': {200: {'description': 'This endpoint is part of a subapp.'}}}}, '/subapp2/subapp-endpoint': {'get': {'responses': {200: {'description': 'This endpoint is part of a subapp.'}}}}, '/users': {'get': {'responses': {200: {'description': 'A list of users.', 'examples': [{'username': 'tom'}, {'username': 'lucy'}]}}}, 'post': {'responses': {200: {'description': 'A user.', 'examples': {'username': 'tom'}}}}}, '/users/{id}': {'get': {'responses': {200: {'description': 'A user.', 'examples': {'username': 'tom'}}}}}}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_schema_endpoint",
      "module": "test_schemas",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_schemas.py",
      "line_number": 250,
      "end_line_number": 254,
      "source_code": "def test_schema_endpoint(test_client_factory: TestClientFactory) -> None:\n    client = test_client_factory(app)\n    response = client.get(\"/schema\")\n    assert response.headers[\"Content-Type\"] == \"application/vnd.oai.openapi\"\n    assert response.text.strip() == EXPECTED_SCHEMA.strip()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "starlette.applications.Starlette",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.schemas.SchemaGenerator",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.headers['Content-Type'] == 'application/vnd.oai.openapi'",
        "assert response.text.strip() == EXPECTED_SCHEMA.strip()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_staticfiles",
      "module": "test_staticfiles",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_staticfiles.py",
      "line_number": 22,
      "end_line_number": 31,
      "source_code": "def test_staticfiles(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    path = os.path.join(tmpdir, \"example.txt\")\n    with open(path, \"w\") as file:\n        file.write(\"<file content>\")\n\n    app = StaticFiles(directory=tmpdir)\n    client = test_client_factory(app)\n    response = client.get(\"/example.txt\")\n    assert response.status_code == 200\n    assert response.text == \"<file content>\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "os",
        "stat",
        "tempfile",
        "time",
        "typing",
        "pathlib.Path",
        "anyio",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Mount",
        "starlette.staticfiles.StaticFiles",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == '<file content>'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_staticfiles_with_pathlib",
      "module": "test_staticfiles",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_staticfiles.py",
      "line_number": 34,
      "end_line_number": 43,
      "source_code": "def test_staticfiles_with_pathlib(tmp_path: Path, test_client_factory: TestClientFactory) -> None:\n    path = tmp_path / \"example.txt\"\n    with open(path, \"w\") as file:\n        file.write(\"<file content>\")\n\n    app = StaticFiles(directory=tmp_path)\n    client = test_client_factory(app)\n    response = client.get(\"/example.txt\")\n    assert response.status_code == 200\n    assert response.text == \"<file content>\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmp_path",
        "test_client_factory"
      ],
      "imports": [
        "os",
        "stat",
        "tempfile",
        "time",
        "typing",
        "pathlib.Path",
        "anyio",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Mount",
        "starlette.staticfiles.StaticFiles",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == '<file content>'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_staticfiles_head_with_middleware",
      "module": "test_staticfiles",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_staticfiles.py",
      "line_number": 46,
      "end_line_number": 65,
      "source_code": "def test_staticfiles_head_with_middleware(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    \"\"\"\n    see https://github.com/encode/starlette/pull/935\n    \"\"\"\n    path = os.path.join(tmpdir, \"example.txt\")\n    with open(path, \"w\") as file:\n        file.write(\"x\" * 100)\n\n    async def does_nothing_middleware(request: Request, call_next: RequestResponseEndpoint) -> Response:\n        response = await call_next(request)\n        return response\n\n    routes = [Mount(\"/static\", app=StaticFiles(directory=tmpdir), name=\"static\")]\n    middleware = [Middleware(BaseHTTPMiddleware, dispatch=does_nothing_middleware)]\n    app = Starlette(routes=routes, middleware=middleware)\n\n    client = test_client_factory(app)\n    response = client.head(\"/static/example.txt\")\n    assert response.status_code == 200\n    assert response.headers.get(\"content-length\") == \"100\"",
      "docstring": "see https://github.com/encode/starlette/pull/935",
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "os",
        "stat",
        "tempfile",
        "time",
        "typing",
        "pathlib.Path",
        "anyio",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Mount",
        "starlette.staticfiles.StaticFiles",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.headers.get('content-length') == '100'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "response.headers.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_staticfiles_with_package",
      "module": "test_staticfiles",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_staticfiles.py",
      "line_number": 68,
      "end_line_number": 79,
      "source_code": "def test_staticfiles_with_package(test_client_factory: TestClientFactory) -> None:\n    app = StaticFiles(packages=[\"tests\"])\n    client = test_client_factory(app)\n    response = client.get(\"/example.txt\")\n    assert response.status_code == 200\n    assert response.text == \"123\\n\"\n\n    app = StaticFiles(packages=[(\"tests\", \"statics\")])\n    client = test_client_factory(app)\n    response = client.get(\"/example.txt\")\n    assert response.status_code == 200\n    assert response.text == \"123\\n\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "os",
        "stat",
        "tempfile",
        "time",
        "typing",
        "pathlib.Path",
        "anyio",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Mount",
        "starlette.staticfiles.StaticFiles",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == '123\\n'",
        "assert response.status_code == 200",
        "assert response.text == '123\\n'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_staticfiles_post",
      "module": "test_staticfiles",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_staticfiles.py",
      "line_number": 82,
      "end_line_number": 93,
      "source_code": "def test_staticfiles_post(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    path = os.path.join(tmpdir, \"example.txt\")\n    with open(path, \"w\") as file:\n        file.write(\"<file content>\")\n\n    routes = [Mount(\"/\", app=StaticFiles(directory=tmpdir), name=\"static\")]\n    app = Starlette(routes=routes)\n    client = test_client_factory(app)\n\n    response = client.post(\"/example.txt\")\n    assert response.status_code == 405\n    assert response.text == \"Method Not Allowed\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "os",
        "stat",
        "tempfile",
        "time",
        "typing",
        "pathlib.Path",
        "anyio",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Mount",
        "starlette.staticfiles.StaticFiles",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 405",
        "assert response.text == 'Method Not Allowed'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_staticfiles_with_directory_returns_404",
      "module": "test_staticfiles",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_staticfiles.py",
      "line_number": 96,
      "end_line_number": 107,
      "source_code": "def test_staticfiles_with_directory_returns_404(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    path = os.path.join(tmpdir, \"example.txt\")\n    with open(path, \"w\") as file:\n        file.write(\"<file content>\")\n\n    routes = [Mount(\"/\", app=StaticFiles(directory=tmpdir), name=\"static\")]\n    app = Starlette(routes=routes)\n    client = test_client_factory(app)\n\n    response = client.get(\"/\")\n    assert response.status_code == 404\n    assert response.text == \"Not Found\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "os",
        "stat",
        "tempfile",
        "time",
        "typing",
        "pathlib.Path",
        "anyio",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Mount",
        "starlette.staticfiles.StaticFiles",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 404",
        "assert response.text == 'Not Found'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_staticfiles_with_missing_file_returns_404",
      "module": "test_staticfiles",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_staticfiles.py",
      "line_number": 110,
      "end_line_number": 121,
      "source_code": "def test_staticfiles_with_missing_file_returns_404(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    path = os.path.join(tmpdir, \"example.txt\")\n    with open(path, \"w\") as file:\n        file.write(\"<file content>\")\n\n    routes = [Mount(\"/\", app=StaticFiles(directory=tmpdir), name=\"static\")]\n    app = Starlette(routes=routes)\n    client = test_client_factory(app)\n\n    response = client.get(\"/404.txt\")\n    assert response.status_code == 404\n    assert response.text == \"Not Found\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "os",
        "stat",
        "tempfile",
        "time",
        "typing",
        "pathlib.Path",
        "anyio",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Mount",
        "starlette.staticfiles.StaticFiles",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 404",
        "assert response.text == 'Not Found'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_staticfiles_instantiated_with_missing_directory",
      "module": "test_staticfiles",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_staticfiles.py",
      "line_number": 124,
      "end_line_number": 128,
      "source_code": "def test_staticfiles_instantiated_with_missing_directory(tmpdir: Path) -> None:\n    with pytest.raises(RuntimeError) as exc_info:\n        path = os.path.join(tmpdir, \"no_such_directory\")\n        StaticFiles(directory=path)\n    assert \"does not exist\" in str(exc_info.value)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir"
      ],
      "imports": [
        "os",
        "stat",
        "tempfile",
        "time",
        "typing",
        "pathlib.Path",
        "anyio",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Mount",
        "starlette.staticfiles.StaticFiles",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'does not exist' in str(exc_info.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_staticfiles_configured_with_missing_directory",
      "module": "test_staticfiles",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_staticfiles.py",
      "line_number": 131,
      "end_line_number": 137,
      "source_code": "def test_staticfiles_configured_with_missing_directory(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    path = os.path.join(tmpdir, \"no_such_directory\")\n    app = StaticFiles(directory=path, check_dir=False)\n    client = test_client_factory(app)\n    with pytest.raises(RuntimeError) as exc_info:\n        client.get(\"/example.txt\")\n    assert \"does not exist\" in str(exc_info.value)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "os",
        "stat",
        "tempfile",
        "time",
        "typing",
        "pathlib.Path",
        "anyio",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Mount",
        "starlette.staticfiles.StaticFiles",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'does not exist' in str(exc_info.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_staticfiles_configured_with_file_instead_of_directory",
      "module": "test_staticfiles",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_staticfiles.py",
      "line_number": 140,
      "end_line_number": 151,
      "source_code": "def test_staticfiles_configured_with_file_instead_of_directory(\n    tmpdir: Path, test_client_factory: TestClientFactory\n) -> None:\n    path = os.path.join(tmpdir, \"example.txt\")\n    with open(path, \"w\") as file:\n        file.write(\"<file content>\")\n\n    app = StaticFiles(directory=path, check_dir=False)\n    client = test_client_factory(app)\n    with pytest.raises(RuntimeError) as exc_info:\n        client.get(\"/example.txt\")\n    assert \"is not a directory\" in str(exc_info.value)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "os",
        "stat",
        "tempfile",
        "time",
        "typing",
        "pathlib.Path",
        "anyio",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Mount",
        "starlette.staticfiles.StaticFiles",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'is not a directory' in str(exc_info.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_staticfiles_config_check_occurs_only_once",
      "module": "test_staticfiles",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_staticfiles.py",
      "line_number": 154,
      "end_line_number": 165,
      "source_code": "def test_staticfiles_config_check_occurs_only_once(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    app = StaticFiles(directory=tmpdir)\n    client = test_client_factory(app)\n    assert not app.config_checked\n\n    with pytest.raises(HTTPException):\n        client.get(\"/\")\n\n    assert app.config_checked\n\n    with pytest.raises(HTTPException):\n        client.get(\"/\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "os",
        "stat",
        "tempfile",
        "time",
        "typing",
        "pathlib.Path",
        "anyio",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Mount",
        "starlette.staticfiles.StaticFiles",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert not app.config_checked",
        "assert app.config_checked"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_staticfiles_prevents_breaking_out_of_directory",
      "module": "test_staticfiles",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_staticfiles.py",
      "line_number": 168,
      "end_line_number": 185,
      "source_code": "def test_staticfiles_prevents_breaking_out_of_directory(tmpdir: Path) -> None:\n    directory = os.path.join(tmpdir, \"foo\")\n    os.mkdir(directory)\n\n    path = os.path.join(tmpdir, \"example.txt\")\n    with open(path, \"w\") as file:\n        file.write(\"outside root dir\")\n\n    app = StaticFiles(directory=directory)\n    # We can't test this with 'httpx', so we test the app directly here.\n    path = app.get_path({\"path\": \"/../example.txt\"})\n    scope = {\"method\": \"GET\"}\n\n    with pytest.raises(HTTPException) as exc_info:\n        anyio.run(app.get_response, path, scope)\n\n    assert exc_info.value.status_code == 404\n    assert exc_info.value.detail == \"Not Found\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir"
      ],
      "imports": [
        "os",
        "stat",
        "tempfile",
        "time",
        "typing",
        "pathlib.Path",
        "anyio",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Mount",
        "starlette.staticfiles.StaticFiles",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert exc_info.value.status_code == 404",
        "assert exc_info.value.detail == 'Not Found'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_staticfiles_never_read_file_for_head_method",
      "module": "test_staticfiles",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_staticfiles.py",
      "line_number": 188,
      "end_line_number": 198,
      "source_code": "def test_staticfiles_never_read_file_for_head_method(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    path = os.path.join(tmpdir, \"example.txt\")\n    with open(path, \"w\") as file:\n        file.write(\"<file content>\")\n\n    app = StaticFiles(directory=tmpdir)\n    client = test_client_factory(app)\n    response = client.head(\"/example.txt\")\n    assert response.status_code == 200\n    assert response.content == b\"\"\n    assert response.headers[\"content-length\"] == \"14\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "os",
        "stat",
        "tempfile",
        "time",
        "typing",
        "pathlib.Path",
        "anyio",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Mount",
        "starlette.staticfiles.StaticFiles",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.content == b''",
        "assert response.headers['content-length'] == '14'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_staticfiles_304_with_etag_match",
      "module": "test_staticfiles",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_staticfiles.py",
      "line_number": 201,
      "end_line_number": 216,
      "source_code": "def test_staticfiles_304_with_etag_match(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    path = os.path.join(tmpdir, \"example.txt\")\n    with open(path, \"w\") as file:\n        file.write(\"<file content>\")\n\n    app = StaticFiles(directory=tmpdir)\n    client = test_client_factory(app)\n    first_resp = client.get(\"/example.txt\")\n    assert first_resp.status_code == 200\n    last_etag = first_resp.headers[\"etag\"]\n    second_resp = client.get(\"/example.txt\", headers={\"if-none-match\": last_etag})\n    assert second_resp.status_code == 304\n    assert second_resp.content == b\"\"\n    second_resp = client.get(\"/example.txt\", headers={\"if-none-match\": f'W/{last_etag}, \"123\"'})\n    assert second_resp.status_code == 304\n    assert second_resp.content == b\"\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "os",
        "stat",
        "tempfile",
        "time",
        "typing",
        "pathlib.Path",
        "anyio",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Mount",
        "starlette.staticfiles.StaticFiles",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert first_resp.status_code == 200",
        "assert second_resp.status_code == 304",
        "assert second_resp.content == b''",
        "assert second_resp.status_code == 304",
        "assert second_resp.content == b''"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_staticfiles_304_with_last_modified_compare_last_req",
      "module": "test_staticfiles",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_staticfiles.py",
      "line_number": 219,
      "end_line_number": 237,
      "source_code": "def test_staticfiles_304_with_last_modified_compare_last_req(\n    tmpdir: Path, test_client_factory: TestClientFactory\n) -> None:\n    path = os.path.join(tmpdir, \"example.txt\")\n    file_last_modified_time = time.mktime(time.strptime(\"2013-10-10 23:40:00\", \"%Y-%m-%d %H:%M:%S\"))\n    with open(path, \"w\") as file:\n        file.write(\"<file content>\")\n    os.utime(path, (file_last_modified_time, file_last_modified_time))\n\n    app = StaticFiles(directory=tmpdir)\n    client = test_client_factory(app)\n    # last modified less than last request, 304\n    response = client.get(\"/example.txt\", headers={\"If-Modified-Since\": \"Thu, 11 Oct 2013 15:30:19 GMT\"})\n    assert response.status_code == 304\n    assert response.content == b\"\"\n    # last modified greater than last request, 200 with content\n    response = client.get(\"/example.txt\", headers={\"If-Modified-Since\": \"Thu, 20 Feb 2012 15:30:19 GMT\"})\n    assert response.status_code == 200\n    assert response.content == b\"<file content>\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "os",
        "stat",
        "tempfile",
        "time",
        "typing",
        "pathlib.Path",
        "anyio",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Mount",
        "starlette.staticfiles.StaticFiles",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 304",
        "assert response.content == b''",
        "assert response.status_code == 200",
        "assert response.content == b'<file content>'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_staticfiles_html_normal",
      "module": "test_staticfiles",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_staticfiles.py",
      "line_number": 240,
      "end_line_number": 270,
      "source_code": "def test_staticfiles_html_normal(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    path = os.path.join(tmpdir, \"404.html\")\n    with open(path, \"w\") as file:\n        file.write(\"<h1>Custom not found page</h1>\")\n    path = os.path.join(tmpdir, \"dir\")\n    os.mkdir(path)\n    path = os.path.join(path, \"index.html\")\n    with open(path, \"w\") as file:\n        file.write(\"<h1>Hello</h1>\")\n\n    app = StaticFiles(directory=tmpdir, html=True)\n    client = test_client_factory(app)\n\n    response = client.get(\"/dir/\")\n    assert response.url == \"http://testserver/dir/\"\n    assert response.status_code == 200\n    assert response.text == \"<h1>Hello</h1>\"\n\n    response = client.get(\"/dir\")\n    assert response.url == \"http://testserver/dir/\"\n    assert response.status_code == 200\n    assert response.text == \"<h1>Hello</h1>\"\n\n    response = client.get(\"/dir/index.html\")\n    assert response.url == \"http://testserver/dir/index.html\"\n    assert response.status_code == 200\n    assert response.text == \"<h1>Hello</h1>\"\n\n    response = client.get(\"/missing\")\n    assert response.status_code == 404\n    assert response.text == \"<h1>Custom not found page</h1>\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "os",
        "stat",
        "tempfile",
        "time",
        "typing",
        "pathlib.Path",
        "anyio",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Mount",
        "starlette.staticfiles.StaticFiles",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.url == 'http://testserver/dir/'",
        "assert response.status_code == 200",
        "assert response.text == '<h1>Hello</h1>'",
        "assert response.url == 'http://testserver/dir/'",
        "assert response.status_code == 200",
        "assert response.text == '<h1>Hello</h1>'",
        "assert response.url == 'http://testserver/dir/index.html'",
        "assert response.status_code == 200",
        "assert response.text == '<h1>Hello</h1>'",
        "assert response.status_code == 404",
        "assert response.text == '<h1>Custom not found page</h1>'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_staticfiles_html_without_index",
      "module": "test_staticfiles",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_staticfiles.py",
      "line_number": 273,
      "end_line_number": 295,
      "source_code": "def test_staticfiles_html_without_index(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    path = os.path.join(tmpdir, \"404.html\")\n    with open(path, \"w\") as file:\n        file.write(\"<h1>Custom not found page</h1>\")\n    path = os.path.join(tmpdir, \"dir\")\n    os.mkdir(path)\n\n    app = StaticFiles(directory=tmpdir, html=True)\n    client = test_client_factory(app)\n\n    response = client.get(\"/dir/\")\n    assert response.url == \"http://testserver/dir/\"\n    assert response.status_code == 404\n    assert response.text == \"<h1>Custom not found page</h1>\"\n\n    response = client.get(\"/dir\")\n    assert response.url == \"http://testserver/dir\"\n    assert response.status_code == 404\n    assert response.text == \"<h1>Custom not found page</h1>\"\n\n    response = client.get(\"/missing\")\n    assert response.status_code == 404\n    assert response.text == \"<h1>Custom not found page</h1>\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "os",
        "stat",
        "tempfile",
        "time",
        "typing",
        "pathlib.Path",
        "anyio",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Mount",
        "starlette.staticfiles.StaticFiles",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.url == 'http://testserver/dir/'",
        "assert response.status_code == 404",
        "assert response.text == '<h1>Custom not found page</h1>'",
        "assert response.url == 'http://testserver/dir'",
        "assert response.status_code == 404",
        "assert response.text == '<h1>Custom not found page</h1>'",
        "assert response.status_code == 404",
        "assert response.text == '<h1>Custom not found page</h1>'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_staticfiles_html_without_404",
      "module": "test_staticfiles",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_staticfiles.py",
      "line_number": 298,
      "end_line_number": 320,
      "source_code": "def test_staticfiles_html_without_404(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    path = os.path.join(tmpdir, \"dir\")\n    os.mkdir(path)\n    path = os.path.join(path, \"index.html\")\n    with open(path, \"w\") as file:\n        file.write(\"<h1>Hello</h1>\")\n\n    app = StaticFiles(directory=tmpdir, html=True)\n    client = test_client_factory(app)\n\n    response = client.get(\"/dir/\")\n    assert response.url == \"http://testserver/dir/\"\n    assert response.status_code == 200\n    assert response.text == \"<h1>Hello</h1>\"\n\n    response = client.get(\"/dir\")\n    assert response.url == \"http://testserver/dir/\"\n    assert response.status_code == 200\n    assert response.text == \"<h1>Hello</h1>\"\n\n    with pytest.raises(HTTPException) as exc_info:\n        response = client.get(\"/missing\")\n    assert exc_info.value.status_code == 404",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "os",
        "stat",
        "tempfile",
        "time",
        "typing",
        "pathlib.Path",
        "anyio",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Mount",
        "starlette.staticfiles.StaticFiles",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.url == 'http://testserver/dir/'",
        "assert response.status_code == 200",
        "assert response.text == '<h1>Hello</h1>'",
        "assert response.url == 'http://testserver/dir/'",
        "assert response.status_code == 200",
        "assert response.text == '<h1>Hello</h1>'",
        "assert exc_info.value.status_code == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_staticfiles_html_only_files",
      "module": "test_staticfiles",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_staticfiles.py",
      "line_number": 323,
      "end_line_number": 337,
      "source_code": "def test_staticfiles_html_only_files(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    path = os.path.join(tmpdir, \"hello.html\")\n    with open(path, \"w\") as file:\n        file.write(\"<h1>Hello</h1>\")\n\n    app = StaticFiles(directory=tmpdir, html=True)\n    client = test_client_factory(app)\n\n    with pytest.raises(HTTPException) as exc_info:\n        response = client.get(\"/\")\n    assert exc_info.value.status_code == 404\n\n    response = client.get(\"/hello.html\")\n    assert response.status_code == 200\n    assert response.text == \"<h1>Hello</h1>\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "os",
        "stat",
        "tempfile",
        "time",
        "typing",
        "pathlib.Path",
        "anyio",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Mount",
        "starlette.staticfiles.StaticFiles",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert exc_info.value.status_code == 404",
        "assert response.status_code == 200",
        "assert response.text == '<h1>Hello</h1>'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_staticfiles_cache_invalidation_for_deleted_file_html_mode",
      "module": "test_staticfiles",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_staticfiles.py",
      "line_number": 340,
      "end_line_number": 374,
      "source_code": "def test_staticfiles_cache_invalidation_for_deleted_file_html_mode(\n    tmpdir: Path, test_client_factory: TestClientFactory\n) -> None:\n    path_404 = os.path.join(tmpdir, \"404.html\")\n    with open(path_404, \"w\") as file:\n        file.write(\"<p>404 file</p>\")\n    path_some = os.path.join(tmpdir, \"some.html\")\n    with open(path_some, \"w\") as file:\n        file.write(\"<p>some file</p>\")\n\n    common_modified_time = time.mktime(time.strptime(\"2013-10-10 23:40:00\", \"%Y-%m-%d %H:%M:%S\"))\n    os.utime(path_404, (common_modified_time, common_modified_time))\n    os.utime(path_some, (common_modified_time, common_modified_time))\n\n    app = StaticFiles(directory=tmpdir, html=True)\n    client = test_client_factory(app)\n\n    resp_exists = client.get(\"/some.html\")\n    assert resp_exists.status_code == 200\n    assert resp_exists.text == \"<p>some file</p>\"\n\n    resp_cached = client.get(\n        \"/some.html\",\n        headers={\"If-Modified-Since\": resp_exists.headers[\"last-modified\"]},\n    )\n    assert resp_cached.status_code == 304\n\n    os.remove(path_some)\n\n    resp_deleted = client.get(\n        \"/some.html\",\n        headers={\"If-Modified-Since\": resp_exists.headers[\"last-modified\"]},\n    )\n    assert resp_deleted.status_code == 404\n    assert resp_deleted.text == \"<p>404 file</p>\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "os",
        "stat",
        "tempfile",
        "time",
        "typing",
        "pathlib.Path",
        "anyio",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Mount",
        "starlette.staticfiles.StaticFiles",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp_exists.status_code == 200",
        "assert resp_exists.text == '<p>some file</p>'",
        "assert resp_cached.status_code == 304",
        "assert resp_deleted.status_code == 404",
        "assert resp_deleted.text == '<p>404 file</p>'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_staticfiles_with_invalid_dir_permissions_returns_401",
      "module": "test_staticfiles",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_staticfiles.py",
      "line_number": 377,
      "end_line_number": 399,
      "source_code": "def test_staticfiles_with_invalid_dir_permissions_returns_401(\n    tmp_path: Path, test_client_factory: TestClientFactory\n) -> None:\n    (tmp_path / \"example.txt\").write_bytes(b\"<file content>\")\n\n    original_mode = tmp_path.stat().st_mode\n    tmp_path.chmod(stat.S_IRWXO)\n    try:\n        routes = [\n            Mount(\n                \"/\",\n                app=StaticFiles(directory=os.fsdecode(tmp_path)),\n                name=\"static\",\n            )\n        ]\n        app = Starlette(routes=routes)\n        client = test_client_factory(app)\n\n        response = client.get(\"/example.txt\")\n        assert response.status_code == 401\n        assert response.text == \"Unauthorized\"\n    finally:\n        tmp_path.chmod(original_mode)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmp_path",
        "test_client_factory"
      ],
      "imports": [
        "os",
        "stat",
        "tempfile",
        "time",
        "typing",
        "pathlib.Path",
        "anyio",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Mount",
        "starlette.staticfiles.StaticFiles",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 401",
        "assert response.text == 'Unauthorized'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_staticfiles_with_missing_dir_returns_404",
      "module": "test_staticfiles",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_staticfiles.py",
      "line_number": 402,
      "end_line_number": 413,
      "source_code": "def test_staticfiles_with_missing_dir_returns_404(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    path = os.path.join(tmpdir, \"example.txt\")\n    with open(path, \"w\") as file:\n        file.write(\"<file content>\")\n\n    routes = [Mount(\"/\", app=StaticFiles(directory=tmpdir), name=\"static\")]\n    app = Starlette(routes=routes)\n    client = test_client_factory(app)\n\n    response = client.get(\"/foo/example.txt\")\n    assert response.status_code == 404\n    assert response.text == \"Not Found\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "os",
        "stat",
        "tempfile",
        "time",
        "typing",
        "pathlib.Path",
        "anyio",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Mount",
        "starlette.staticfiles.StaticFiles",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 404",
        "assert response.text == 'Not Found'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_staticfiles_access_file_as_dir_returns_404",
      "module": "test_staticfiles",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_staticfiles.py",
      "line_number": 416,
      "end_line_number": 427,
      "source_code": "def test_staticfiles_access_file_as_dir_returns_404(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    path = os.path.join(tmpdir, \"example.txt\")\n    with open(path, \"w\") as file:\n        file.write(\"<file content>\")\n\n    routes = [Mount(\"/\", app=StaticFiles(directory=tmpdir), name=\"static\")]\n    app = Starlette(routes=routes)\n    client = test_client_factory(app)\n\n    response = client.get(\"/example.txt/foo\")\n    assert response.status_code == 404\n    assert response.text == \"Not Found\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "os",
        "stat",
        "tempfile",
        "time",
        "typing",
        "pathlib.Path",
        "anyio",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Mount",
        "starlette.staticfiles.StaticFiles",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 404",
        "assert response.text == 'Not Found'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_staticfiles_filename_too_long",
      "module": "test_staticfiles",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_staticfiles.py",
      "line_number": 430,
      "end_line_number": 438,
      "source_code": "def test_staticfiles_filename_too_long(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    routes = [Mount(\"/\", app=StaticFiles(directory=tmpdir), name=\"static\")]\n    app = Starlette(routes=routes)\n    client = test_client_factory(app)\n\n    path_max_size = os.pathconf(\"/\", \"PC_PATH_MAX\")\n    response = client.get(f\"/{'a' * path_max_size}.txt\")\n    assert response.status_code == 404\n    assert response.text == \"Not Found\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "os",
        "stat",
        "tempfile",
        "time",
        "typing",
        "pathlib.Path",
        "anyio",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Mount",
        "starlette.staticfiles.StaticFiles",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 404",
        "assert response.text == 'Not Found'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_staticfiles_unhandled_os_error_returns_500",
      "module": "test_staticfiles",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_staticfiles.py",
      "line_number": 441,
      "end_line_number": 461,
      "source_code": "def test_staticfiles_unhandled_os_error_returns_500(\n    tmpdir: Path,\n    test_client_factory: TestClientFactory,\n    monkeypatch: pytest.MonkeyPatch,\n) -> None:\n    def mock_timeout(*args: typing.Any, **kwargs: typing.Any) -> None:\n        raise TimeoutError\n\n    path = os.path.join(tmpdir, \"example.txt\")\n    with open(path, \"w\") as file:\n        file.write(\"<file content>\")\n\n    routes = [Mount(\"/\", app=StaticFiles(directory=tmpdir), name=\"static\")]\n    app = Starlette(routes=routes)\n    client = test_client_factory(app, raise_server_exceptions=False)\n\n    monkeypatch.setattr(\"starlette.staticfiles.StaticFiles.lookup_path\", mock_timeout)\n\n    response = client.get(\"/example.txt\")\n    assert response.status_code == 500\n    assert response.text == \"Internal Server Error\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory",
        "monkeypatch"
      ],
      "imports": [
        "os",
        "stat",
        "tempfile",
        "time",
        "typing",
        "pathlib.Path",
        "anyio",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Mount",
        "starlette.staticfiles.StaticFiles",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 500",
        "assert response.text == 'Internal Server Error'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_staticfiles_follows_symlinks",
      "module": "test_staticfiles",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_staticfiles.py",
      "line_number": 464,
      "end_line_number": 482,
      "source_code": "def test_staticfiles_follows_symlinks(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    statics_path = os.path.join(tmpdir, \"statics\")\n    os.mkdir(statics_path)\n\n    source_path = tempfile.mkdtemp()\n    source_file_path = os.path.join(source_path, \"page.html\")\n    with open(source_file_path, \"w\") as file:\n        file.write(\"<h1>Hello</h1>\")\n\n    statics_file_path = os.path.join(statics_path, \"index.html\")\n    os.symlink(source_file_path, statics_file_path)\n\n    app = StaticFiles(directory=statics_path, follow_symlink=True)\n    client = test_client_factory(app)\n\n    response = client.get(\"/index.html\")\n    assert response.url == \"http://testserver/index.html\"\n    assert response.status_code == 200\n    assert response.text == \"<h1>Hello</h1>\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "os",
        "stat",
        "tempfile",
        "time",
        "typing",
        "pathlib.Path",
        "anyio",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Mount",
        "starlette.staticfiles.StaticFiles",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.url == 'http://testserver/index.html'",
        "assert response.status_code == 200",
        "assert response.text == '<h1>Hello</h1>'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_staticfiles_follows_symlink_directories",
      "module": "test_staticfiles",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_staticfiles.py",
      "line_number": 485,
      "end_line_number": 503,
      "source_code": "def test_staticfiles_follows_symlink_directories(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    statics_path = os.path.join(tmpdir, \"statics\")\n    statics_html_path = os.path.join(statics_path, \"html\")\n    os.mkdir(statics_path)\n\n    source_path = tempfile.mkdtemp()\n    source_file_path = os.path.join(source_path, \"page.html\")\n    with open(source_file_path, \"w\") as file:\n        file.write(\"<h1>Hello</h1>\")\n\n    os.symlink(source_path, statics_html_path)\n\n    app = StaticFiles(directory=statics_path, follow_symlink=True)\n    client = test_client_factory(app)\n\n    response = client.get(\"/html/page.html\")\n    assert response.url == \"http://testserver/html/page.html\"\n    assert response.status_code == 200\n    assert response.text == \"<h1>Hello</h1>\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "os",
        "stat",
        "tempfile",
        "time",
        "typing",
        "pathlib.Path",
        "anyio",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Mount",
        "starlette.staticfiles.StaticFiles",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.url == 'http://testserver/html/page.html'",
        "assert response.status_code == 200",
        "assert response.text == '<h1>Hello</h1>'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_staticfiles_disallows_path_traversal_with_symlinks",
      "module": "test_staticfiles",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_staticfiles.py",
      "line_number": 506,
      "end_line_number": 528,
      "source_code": "def test_staticfiles_disallows_path_traversal_with_symlinks(tmpdir: Path) -> None:\n    statics_path = os.path.join(tmpdir, \"statics\")\n\n    root_source_path = tempfile.mkdtemp()\n    source_path = os.path.join(root_source_path, \"statics\")\n    os.mkdir(source_path)\n\n    source_file_path = os.path.join(root_source_path, \"index.html\")\n    with open(source_file_path, \"w\") as file:\n        file.write(\"<h1>Hello</h1>\")\n\n    os.symlink(source_path, statics_path)\n\n    app = StaticFiles(directory=statics_path, follow_symlink=True)\n    # We can't test this with 'httpx', so we test the app directly here.\n    path = app.get_path({\"path\": \"/../index.html\"})\n    scope = {\"method\": \"GET\"}\n\n    with pytest.raises(HTTPException) as exc_info:\n        anyio.run(app.get_response, path, scope)\n\n    assert exc_info.value.status_code == 404\n    assert exc_info.value.detail == \"Not Found\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir"
      ],
      "imports": [
        "os",
        "stat",
        "tempfile",
        "time",
        "typing",
        "pathlib.Path",
        "anyio",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Mount",
        "starlette.staticfiles.StaticFiles",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert exc_info.value.status_code == 404",
        "assert exc_info.value.detail == 'Not Found'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_staticfiles_avoids_path_traversal",
      "module": "test_staticfiles",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_staticfiles.py",
      "line_number": 531,
      "end_line_number": 561,
      "source_code": "def test_staticfiles_avoids_path_traversal(tmp_path: Path) -> None:\n    statics_path = tmp_path / \"static\"\n    statics_disallow_path = tmp_path / \"static_disallow\"\n\n    statics_path.mkdir()\n    statics_disallow_path.mkdir()\n\n    static_index_file = statics_path / \"index.html\"\n    statics_disallow_path_index_file = statics_disallow_path / \"index.html\"\n    static_file = tmp_path / \"static1.txt\"\n\n    static_index_file.write_text(\"<h1>Hello</h1>\")\n    statics_disallow_path_index_file.write_text(\"<h1>Private</h1>\")\n    static_file.write_text(\"Private\")\n\n    app = StaticFiles(directory=statics_path)\n\n    # We can't test this with 'httpx', so we test the app directly here.\n    path = app.get_path({\"path\": \"/../static1.txt\"})\n    with pytest.raises(HTTPException) as exc_info:\n        anyio.run(app.get_response, path, {\"method\": \"GET\"})\n\n    assert exc_info.value.status_code == 404\n    assert exc_info.value.detail == \"Not Found\"\n\n    path = app.get_path({\"path\": \"/../static_disallow/index.html\"})\n    with pytest.raises(HTTPException) as exc_info:\n        anyio.run(app.get_response, path, {\"method\": \"GET\"})\n\n    assert exc_info.value.status_code == 404\n    assert exc_info.value.detail == \"Not Found\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmp_path"
      ],
      "imports": [
        "os",
        "stat",
        "tempfile",
        "time",
        "typing",
        "pathlib.Path",
        "anyio",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Mount",
        "starlette.staticfiles.StaticFiles",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert exc_info.value.status_code == 404",
        "assert exc_info.value.detail == 'Not Found'",
        "assert exc_info.value.status_code == 404",
        "assert exc_info.value.detail == 'Not Found'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_request_url",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_requests.py",
      "line_number": 16,
      "end_line_number": 28,
      "source_code": "def test_request_url(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        request = Request(scope, receive)\n        data = {\"method\": request.method, \"url\": str(request.url)}\n        response = JSONResponse(data)\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n    response = client.get(\"/123?a=abc\")\n    assert response.json() == {\"method\": \"GET\", \"url\": \"http://testserver/123?a=abc\"}\n\n    response = client.get(\"https://example.org:123/\")\n    assert response.json() == {\"method\": \"GET\", \"url\": \"https://example.org:123/\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "sys",
        "typing.Any",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.Address",
        "starlette.datastructures.State",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.routing.Route",
        "starlette.types.ASGIApp"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'method': 'GET', 'url': 'http://testserver/123?a=abc'}",
        "assert response.json() == {'method': 'GET', 'url': 'https://example.org:123/'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_request_query_params",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_requests.py",
      "line_number": 31,
      "end_line_number": 40,
      "source_code": "def test_request_query_params(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        request = Request(scope, receive)\n        params = dict(request.query_params)\n        response = JSONResponse({\"params\": params})\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n    response = client.get(\"/?a=123&b=456\")\n    assert response.json() == {\"params\": {\"a\": \"123\", \"b\": \"456\"}}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "sys",
        "typing.Any",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.Address",
        "starlette.datastructures.State",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.routing.Route",
        "starlette.types.ASGIApp"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'params': {'a': '123', 'b': '456'}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_request_headers",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_requests.py",
      "line_number": 47,
      "end_line_number": 64,
      "source_code": "def test_request_headers(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        request = Request(scope, receive)\n        headers = dict(request.headers)\n        response = JSONResponse({\"headers\": headers})\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n    response = client.get(\"/\", headers={\"host\": \"example.org\"})\n    assert response.json() == {\n        \"headers\": {\n            \"host\": \"example.org\",\n            \"user-agent\": \"testclient\",\n            \"accept-encoding\": \"gzip, deflate\",\n            \"accept\": \"*/*\",\n            \"connection\": \"keep-alive\",\n        }\n    }",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(any((module in sys.modules for module in ('brotli', 'brotlicffi'))), reason='urllib3 includes \"br\" to the \"accept-encoding\" headers.')"
      ],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "sys",
        "typing.Any",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.Address",
        "starlette.datastructures.State",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.routing.Route",
        "starlette.types.ASGIApp"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'headers': {'host': 'example.org', 'user-agent': 'testclient', 'accept-encoding': 'gzip, deflate', 'accept': '*/*', 'connection': 'keep-alive'}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_request_client",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_requests.py",
      "line_number": 75,
      "end_line_number": 78,
      "source_code": "def test_request_client(scope: Scope, expected_client: Address | None) -> None:\n    scope.update({\"type\": \"http\"})  # required by Request's constructor\n    client = Request(scope).client\n    assert client == expected_client",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('scope,expected_client', [({'client': ['client', 42]}, Address('client', 42)), ({'client': None}, None), ({}, None)])"
      ],
      "arguments": [
        "scope",
        "expected_client"
      ],
      "imports": [
        "__future__.annotations",
        "sys",
        "typing.Any",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.Address",
        "starlette.datastructures.State",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.routing.Route",
        "starlette.types.ASGIApp"
      ],
      "fixtures": [],
      "assertions": [
        "assert client == expected_client"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_request_body",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_requests.py",
      "line_number": 81,
      "end_line_number": 97,
      "source_code": "def test_request_body(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        request = Request(scope, receive)\n        body = await request.body()\n        response = JSONResponse({\"body\": body.decode()})\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n\n    response = client.get(\"/\")\n    assert response.json() == {\"body\": \"\"}\n\n    response = client.post(\"/\", json={\"a\": \"123\"})\n    assert response.json() == {\"body\": '{\"a\": \"123\"}'}\n\n    response = client.post(\"/\", data=\"abc\")  # type: ignore\n    assert response.json() == {\"body\": \"abc\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "sys",
        "typing.Any",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.Address",
        "starlette.datastructures.State",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.routing.Route",
        "starlette.types.ASGIApp"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'body': ''}",
        "assert response.json() == {'body': '{\"a\": \"123\"}'}",
        "assert response.json() == {'body': 'abc'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_request_stream",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_requests.py",
      "line_number": 100,
      "end_line_number": 118,
      "source_code": "def test_request_stream(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        request = Request(scope, receive)\n        body = b\"\"\n        async for chunk in request.stream():\n            body += chunk\n        response = JSONResponse({\"body\": body.decode()})\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n\n    response = client.get(\"/\")\n    assert response.json() == {\"body\": \"\"}\n\n    response = client.post(\"/\", json={\"a\": \"123\"})\n    assert response.json() == {\"body\": '{\"a\": \"123\"}'}\n\n    response = client.post(\"/\", data=\"abc\")  # type: ignore\n    assert response.json() == {\"body\": \"abc\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "sys",
        "typing.Any",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.Address",
        "starlette.datastructures.State",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.routing.Route",
        "starlette.types.ASGIApp"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'body': ''}",
        "assert response.json() == {'body': '{\"a\": \"123\"}'}",
        "assert response.json() == {'body': 'abc'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_request_form_urlencoded",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_requests.py",
      "line_number": 121,
      "end_line_number": 131,
      "source_code": "def test_request_form_urlencoded(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        request = Request(scope, receive)\n        form = await request.form()\n        response = JSONResponse({\"form\": dict(form)})\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n\n    response = client.post(\"/\", data={\"abc\": \"123 @\"})\n    assert response.json() == {\"form\": {\"abc\": \"123 @\"}}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "sys",
        "typing.Any",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.Address",
        "starlette.datastructures.State",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.routing.Route",
        "starlette.types.ASGIApp"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'form': {'abc': '123 @'}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_request_form_context_manager",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_requests.py",
      "line_number": 134,
      "end_line_number": 144,
      "source_code": "def test_request_form_context_manager(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        request = Request(scope, receive)\n        async with request.form() as form:\n            response = JSONResponse({\"form\": dict(form)})\n            await response(scope, receive, send)\n\n    client = test_client_factory(app)\n\n    response = client.post(\"/\", data={\"abc\": \"123 @\"})\n    assert response.json() == {\"form\": {\"abc\": \"123 @\"}}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "sys",
        "typing.Any",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.Address",
        "starlette.datastructures.State",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.routing.Route",
        "starlette.types.ASGIApp"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'form': {'abc': '123 @'}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_request_body_then_stream",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_requests.py",
      "line_number": 147,
      "end_line_number": 160,
      "source_code": "def test_request_body_then_stream(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        request = Request(scope, receive)\n        body = await request.body()\n        chunks = b\"\"\n        async for chunk in request.stream():\n            chunks += chunk\n        response = JSONResponse({\"body\": body.decode(), \"stream\": chunks.decode()})\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n\n    response = client.post(\"/\", data=\"abc\")  # type: ignore\n    assert response.json() == {\"body\": \"abc\", \"stream\": \"abc\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "sys",
        "typing.Any",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.Address",
        "starlette.datastructures.State",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.routing.Route",
        "starlette.types.ASGIApp"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'body': 'abc', 'stream': 'abc'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_request_stream_then_body",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_requests.py",
      "line_number": 163,
      "end_line_number": 179,
      "source_code": "def test_request_stream_then_body(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        request = Request(scope, receive)\n        chunks = b\"\"\n        async for chunk in request.stream():\n            chunks += chunk\n        try:\n            body = await request.body()\n        except RuntimeError:\n            body = b\"<stream consumed>\"\n        response = JSONResponse({\"body\": body.decode(), \"stream\": chunks.decode()})\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n\n    response = client.post(\"/\", data=\"abc\")  # type: ignore\n    assert response.json() == {\"body\": \"<stream consumed>\", \"stream\": \"abc\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "sys",
        "typing.Any",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.Address",
        "starlette.datastructures.State",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.routing.Route",
        "starlette.types.ASGIApp"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'body': '<stream consumed>', 'stream': 'abc'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_request_json",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_requests.py",
      "line_number": 182,
      "end_line_number": 191,
      "source_code": "def test_request_json(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        request = Request(scope, receive)\n        data = await request.json()\n        response = JSONResponse({\"json\": data})\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n    response = client.post(\"/\", json={\"a\": \"123\"})\n    assert response.json() == {\"json\": {\"a\": \"123\"}}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "sys",
        "typing.Any",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.Address",
        "starlette.datastructures.State",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.routing.Route",
        "starlette.types.ASGIApp"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'json': {'a': '123'}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_request_scope_interface",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_requests.py",
      "line_number": 194,
      "end_line_number": 202,
      "source_code": "def test_request_scope_interface() -> None:\n    \"\"\"\n    A Request can be instantiated with a scope, and presents a `Mapping`\n    interface.\n    \"\"\"\n    request = Request({\"type\": \"http\", \"method\": \"GET\", \"path\": \"/abc/\"})\n    assert request[\"method\"] == \"GET\"\n    assert dict(request) == {\"type\": \"http\", \"method\": \"GET\", \"path\": \"/abc/\"}\n    assert len(request) == 3",
      "docstring": "A Request can be instantiated with a scope, and presents a `Mapping`\ninterface.",
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "sys",
        "typing.Any",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.Address",
        "starlette.datastructures.State",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.routing.Route",
        "starlette.types.ASGIApp"
      ],
      "fixtures": [],
      "assertions": [
        "assert request['method'] == 'GET'",
        "assert dict(request) == {'type': 'http', 'method': 'GET', 'path': '/abc/'}",
        "assert len(request) == 3"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_request_raw_path",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_requests.py",
      "line_number": 205,
      "end_line_number": 215,
      "source_code": "def test_request_raw_path(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        request = Request(scope, receive)\n        path = request.scope[\"path\"]\n        raw_path = request.scope[\"raw_path\"]\n        response = PlainTextResponse(f\"{path}, {raw_path}\")\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n    response = client.get(\"/he%2Fllo\")\n    assert response.text == \"/he/llo, b'/he%2Fllo'\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "sys",
        "typing.Any",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.Address",
        "starlette.datastructures.State",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.routing.Route",
        "starlette.types.ASGIApp"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == \"/he/llo, b'/he%2Fllo'\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_request_without_setting_receive",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_requests.py",
      "line_number": 218,
      "end_line_number": 237,
      "source_code": "def test_request_without_setting_receive(\n    test_client_factory: TestClientFactory,\n) -> None:\n    \"\"\"\n    If Request is instantiated without the receive channel, then .body()\n    is not available.\n    \"\"\"\n\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        request = Request(scope)\n        try:\n            data = await request.json()\n        except RuntimeError:\n            data = \"Receive channel not available\"\n        response = JSONResponse({\"json\": data})\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n    response = client.post(\"/\", json={\"a\": \"123\"})\n    assert response.json() == {\"json\": \"Receive channel not available\"}",
      "docstring": "If Request is instantiated without the receive channel, then .body()\nis not available.",
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "sys",
        "typing.Any",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.Address",
        "starlette.datastructures.State",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.routing.Route",
        "starlette.types.ASGIApp"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'json': 'Receive channel not available'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_request_disconnect",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_requests.py",
      "line_number": 240,
      "end_line_number": 265,
      "source_code": "def test_request_disconnect(\n    anyio_backend_name: str,\n    anyio_backend_options: dict[str, Any],\n) -> None:\n    \"\"\"\n    If a client disconnect occurs while reading request body\n    then ClientDisconnect should be raised.\n    \"\"\"\n\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        request = Request(scope, receive)\n        await request.body()\n\n    async def receiver() -> Message:\n        return {\"type\": \"http.disconnect\"}\n\n    scope = {\"type\": \"http\", \"method\": \"POST\", \"path\": \"/\"}\n    with pytest.raises(ClientDisconnect):\n        anyio.run(\n            app,  # type: ignore\n            scope,\n            receiver,\n            None,\n            backend=anyio_backend_name,\n            backend_options=anyio_backend_options,\n        )",
      "docstring": "If a client disconnect occurs while reading request body\nthen ClientDisconnect should be raised.",
      "decorators": [],
      "arguments": [
        "anyio_backend_name",
        "anyio_backend_options"
      ],
      "imports": [
        "__future__.annotations",
        "sys",
        "typing.Any",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.Address",
        "starlette.datastructures.State",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.routing.Route",
        "starlette.types.ASGIApp"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_request_is_disconnected",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_requests.py",
      "line_number": 268,
      "end_line_number": 288,
      "source_code": "def test_request_is_disconnected(test_client_factory: TestClientFactory) -> None:\n    \"\"\"\n    If a client disconnect occurs after reading request body\n    then request will be set disconnected properly.\n    \"\"\"\n    disconnected_after_response = None\n\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        nonlocal disconnected_after_response\n\n        request = Request(scope, receive)\n        body = await request.body()\n        disconnected = await request.is_disconnected()\n        response = JSONResponse({\"body\": body.decode(), \"disconnected\": disconnected})\n        await response(scope, receive, send)\n        disconnected_after_response = await request.is_disconnected()\n\n    client = test_client_factory(app)\n    response = client.post(\"/\", content=\"foo\")\n    assert response.json() == {\"body\": \"foo\", \"disconnected\": False}\n    assert disconnected_after_response",
      "docstring": "If a client disconnect occurs after reading request body\nthen request will be set disconnected properly.",
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "sys",
        "typing.Any",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.Address",
        "starlette.datastructures.State",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.routing.Route",
        "starlette.types.ASGIApp"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'body': 'foo', 'disconnected': False}",
        "assert disconnected_after_response"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_request_state_object",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_requests.py",
      "line_number": 291,
      "end_line_number": 302,
      "source_code": "def test_request_state_object() -> None:\n    scope = {\"state\": {\"old\": \"foo\"}}\n\n    s = State(scope[\"state\"])\n\n    s.new = \"value\"\n    assert s.new == \"value\"\n\n    del s.new\n\n    with pytest.raises(AttributeError):\n        s.new",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "sys",
        "typing.Any",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.Address",
        "starlette.datastructures.State",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.routing.Route",
        "starlette.types.ASGIApp"
      ],
      "fixtures": [],
      "assertions": [
        "assert s.new == 'value'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_request_state",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_requests.py",
      "line_number": 305,
      "end_line_number": 314,
      "source_code": "def test_request_state(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        request = Request(scope, receive)\n        request.state.example = 123\n        response = JSONResponse({\"state.example\": request.state.example})\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n    response = client.get(\"/123?a=abc\")\n    assert response.json() == {\"state.example\": 123}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "sys",
        "typing.Any",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.Address",
        "starlette.datastructures.State",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.routing.Route",
        "starlette.types.ASGIApp"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'state.example': 123}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_request_cookies",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_requests.py",
      "line_number": 317,
      "end_line_number": 333,
      "source_code": "def test_request_cookies(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        request = Request(scope, receive)\n        mycookie = request.cookies.get(\"mycookie\")\n        if mycookie:\n            response = Response(mycookie, media_type=\"text/plain\")\n        else:\n            response = Response(\"Hello, world!\", media_type=\"text/plain\")\n            response.set_cookie(\"mycookie\", \"Hello, cookies!\")\n\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.text == \"Hello, world!\"\n    response = client.get(\"/\")\n    assert response.text == \"Hello, cookies!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "sys",
        "typing.Any",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.Address",
        "starlette.datastructures.State",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.routing.Route",
        "starlette.types.ASGIApp"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'Hello, world!'",
        "assert response.text == 'Hello, cookies!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "request.cookies.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_cookie_lenient_parsing",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_requests.py",
      "line_number": 336,
      "end_line_number": 367,
      "source_code": "def test_cookie_lenient_parsing(test_client_factory: TestClientFactory) -> None:\n    \"\"\"\n    The following test is based on a cookie set by Okta, a well-known authorization\n    service. It turns out that it's common practice to set cookies that would be\n    invalid according to the spec.\n    \"\"\"\n    tough_cookie = (\n        \"provider-oauth-nonce=validAsciiblabla; \"\n        'okta-oauth-redirect-params={\"responseType\":\"code\",\"state\":\"somestate\",'\n        '\"nonce\":\"somenonce\",\"scopes\":[\"openid\",\"profile\",\"email\",\"phone\"],'\n        '\"urls\":{\"issuer\":\"https://subdomain.okta.com/oauth2/authServer\",'\n        '\"authorizeUrl\":\"https://subdomain.okta.com/oauth2/authServer/v1/authorize\",'\n        '\"userinfoUrl\":\"https://subdomain.okta.com/oauth2/authServer/v1/userinfo\"}}; '\n        \"importantCookie=importantValue; sessionCookie=importantSessionValue\"\n    )\n    expected_keys = {\n        \"importantCookie\",\n        \"okta-oauth-redirect-params\",\n        \"provider-oauth-nonce\",\n        \"sessionCookie\",\n    }\n\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        request = Request(scope, receive)\n        response = JSONResponse({\"cookies\": request.cookies})\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n    response = client.get(\"/\", headers={\"cookie\": tough_cookie})\n    result = response.json()\n    assert len(result[\"cookies\"]) == 4\n    assert set(result[\"cookies\"].keys()) == expected_keys",
      "docstring": "The following test is based on a cookie set by Okta, a well-known authorization\nservice. It turns out that it's common practice to set cookies that would be\ninvalid according to the spec.",
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "sys",
        "typing.Any",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.Address",
        "starlette.datastructures.State",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.routing.Route",
        "starlette.types.ASGIApp"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(result['cookies']) == 4",
        "assert set(result['cookies'].keys()) == expected_keys"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_cookies_edge_cases",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_requests.py",
      "line_number": 392,
      "end_line_number": 405,
      "source_code": "def test_cookies_edge_cases(\n    set_cookie: str,\n    expected: dict[str, str],\n    test_client_factory: TestClientFactory,\n) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        request = Request(scope, receive)\n        response = JSONResponse({\"cookies\": request.cookies})\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n    response = client.get(\"/\", headers={\"cookie\": set_cookie})\n    result = response.json()\n    assert result[\"cookies\"] == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('set_cookie,expected', [('chips=ahoy; vienna=finger', {'chips': 'ahoy', 'vienna': 'finger'}), ('keebler=\"E=mc2; L=\\\\\"Loves\\\\\"; fudge=\\\\012;\"', {'keebler': '\"E=mc2', 'L': '\\\\\"Loves\\\\\"', 'fudge': '\\\\012', '': '\"'}), ('keebler=E=mc2', {'keebler': 'E=mc2'}), ('key:term=value:term', {'key:term': 'value:term'}), ('a=b; c=[; d=r; f=h', {'a': 'b', 'c': '[', 'd': 'r', 'f': 'h'}), ('a=b; Domain=example.com', {'a': 'b', 'Domain': 'example.com'}), ('a=b; h=i; a=c', {'a': 'c', 'h': 'i'})])"
      ],
      "arguments": [
        "set_cookie",
        "expected",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "sys",
        "typing.Any",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.Address",
        "starlette.datastructures.State",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.routing.Route",
        "starlette.types.ASGIApp"
      ],
      "fixtures": [],
      "assertions": [
        "assert result['cookies'] == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_cookies_invalid",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_requests.py",
      "line_number": 431,
      "end_line_number": 449,
      "source_code": "def test_cookies_invalid(\n    set_cookie: str,\n    expected: dict[str, str],\n    test_client_factory: TestClientFactory,\n) -> None:\n    \"\"\"\n    Cookie strings that are against the RFC6265 spec but which browsers will send if set\n    via document.cookie.\n    \"\"\"\n\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        request = Request(scope, receive)\n        response = JSONResponse({\"cookies\": request.cookies})\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n    response = client.get(\"/\", headers={\"cookie\": set_cookie})\n    result = response.json()\n    assert result[\"cookies\"] == expected",
      "docstring": "Cookie strings that are against the RFC6265 spec but which browsers will send if set\nvia document.cookie.",
      "decorators": [
        "pytest.mark.parametrize('set_cookie,expected', [('abc=def; unnamed; django_language=en', {'': 'unnamed', 'abc': 'def', 'django_language': 'en'}), ('a=b; \"; c=d', {'a': 'b', '': '\"', 'c': 'd'}), ('a b c=d e = f; gh=i', {'a b c': 'd e = f', 'gh': 'i'}), ('a   b,c<>@:/[]?{}=d  \"  =e,f g', {'a   b,c<>@:/[]?{}': 'd  \"  =e,f g'}), ('  =  b  ;  ;  =  ;   c  =  ;  ', {'': 'b', 'c': ''})])"
      ],
      "arguments": [
        "set_cookie",
        "expected",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "sys",
        "typing.Any",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.Address",
        "starlette.datastructures.State",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.routing.Route",
        "starlette.types.ASGIApp"
      ],
      "fixtures": [],
      "assertions": [
        "assert result['cookies'] == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_chunked_encoding",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_requests.py",
      "line_number": 452,
      "end_line_number": 466,
      "source_code": "def test_chunked_encoding(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        request = Request(scope, receive)\n        body = await request.body()\n        response = JSONResponse({\"body\": body.decode()})\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n\n    def post_body() -> Iterator[bytes]:\n        yield b\"foo\"\n        yield b\"bar\"\n\n    response = client.post(\"/\", data=post_body())  # type: ignore\n    assert response.json() == {\"body\": \"foobar\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "sys",
        "typing.Any",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.Address",
        "starlette.datastructures.State",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.routing.Route",
        "starlette.types.ASGIApp"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'body': 'foobar'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        },
        {
          "name": "post_body",
          "body": "def post_body() -> Iterator[bytes]:\n    yield b'foo'\n    yield b'bar'"
        }
      ]
    },
    {
      "name": "test_request_send_push_promise",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_requests.py",
      "line_number": 469,
      "end_line_number": 482,
      "source_code": "def test_request_send_push_promise(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        # the server is push-enabled\n        scope[\"extensions\"][\"http.response.push\"] = {}\n\n        request = Request(scope, receive, send)\n        await request.send_push_promise(\"/style.css\")\n\n        response = JSONResponse({\"json\": \"OK\"})\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.json() == {\"json\": \"OK\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "sys",
        "typing.Any",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.Address",
        "starlette.datastructures.State",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.routing.Route",
        "starlette.types.ASGIApp"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'json': 'OK'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_request_send_push_promise_without_push_extension",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_requests.py",
      "line_number": 485,
      "end_line_number": 502,
      "source_code": "def test_request_send_push_promise_without_push_extension(\n    test_client_factory: TestClientFactory,\n) -> None:\n    \"\"\"\n    If server does not support the `http.response.push` extension,\n    .send_push_promise() does nothing.\n    \"\"\"\n\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        request = Request(scope)\n        await request.send_push_promise(\"/style.css\")\n\n        response = JSONResponse({\"json\": \"OK\"})\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.json() == {\"json\": \"OK\"}",
      "docstring": "If server does not support the `http.response.push` extension,\n.send_push_promise() does nothing.",
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "sys",
        "typing.Any",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.Address",
        "starlette.datastructures.State",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.routing.Route",
        "starlette.types.ASGIApp"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'json': 'OK'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_request_send_push_promise_without_setting_send",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_requests.py",
      "line_number": 505,
      "end_line_number": 528,
      "source_code": "def test_request_send_push_promise_without_setting_send(\n    test_client_factory: TestClientFactory,\n) -> None:\n    \"\"\"\n    If Request is instantiated without the send channel, then\n    .send_push_promise() is not available.\n    \"\"\"\n\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        # the server is push-enabled\n        scope[\"extensions\"][\"http.response.push\"] = {}\n\n        data = \"OK\"\n        request = Request(scope)\n        try:\n            await request.send_push_promise(\"/style.css\")\n        except RuntimeError:\n            data = \"Send channel not available\"\n        response = JSONResponse({\"json\": data})\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.json() == {\"json\": \"Send channel not available\"}",
      "docstring": "If Request is instantiated without the send channel, then\n.send_push_promise() is not available.",
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "sys",
        "typing.Any",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.Address",
        "starlette.datastructures.State",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.routing.Route",
        "starlette.types.ASGIApp"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'json': 'Send channel not available'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_request_url_outside_starlette_context",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_requests.py",
      "line_number": 597,
      "end_line_number": 607,
      "source_code": "def test_request_url_outside_starlette_context(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        request = Request(scope, receive)\n        request.url_for(\"index\")\n\n    client = test_client_factory(app)\n    with pytest.raises(\n        RuntimeError,\n        match=\"The `url_for` method can only be used inside a Starlette application or with a router.\",\n    ):\n        client.get(\"/\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "sys",
        "typing.Any",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.Address",
        "starlette.datastructures.State",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.routing.Route",
        "starlette.types.ASGIApp"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_request_url_starlette_context",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_requests.py",
      "line_number": 610,
      "end_line_number": 635,
      "source_code": "def test_request_url_starlette_context(test_client_factory: TestClientFactory) -> None:\n    from starlette.applications import Starlette\n    from starlette.middleware import Middleware\n    from starlette.routing import Route\n    from starlette.types import ASGIApp\n\n    url_for = None\n\n    async def homepage(request: Request) -> Response:\n        return PlainTextResponse(\"Hello, world!\")\n\n    class CustomMiddleware:\n        def __init__(self, app: ASGIApp) -> None:\n            self.app = app\n\n        async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n            nonlocal url_for\n            request = Request(scope, receive)\n            url_for = request.url_for(\"homepage\")\n            await self.app(scope, receive, send)\n\n    app = Starlette(routes=[Route(\"/home\", homepage)], middleware=[Middleware(CustomMiddleware)])\n\n    client = test_client_factory(app)\n    client.get(\"/home\")\n    assert url_for == URL(\"http://testserver/home\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "sys",
        "typing.Any",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.Address",
        "starlette.datastructures.State",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.routing.Route",
        "starlette.types.ASGIApp"
      ],
      "fixtures": [],
      "assertions": [
        "assert url_for == URL('http://testserver/home')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "self.app",
          "body": "def app(request: Request) -> Response:\n    return endpoint(request=request, **kwargs)"
        }
      ]
    },
    {
      "name": "test_accessing_context_from_threaded_sync_endpoint",
      "module": "test_concurrency",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_concurrency.py",
      "line_number": 33,
      "end_line_number": 46,
      "source_code": "def test_accessing_context_from_threaded_sync_endpoint(\n    test_client_factory: TestClientFactory,\n) -> None:\n    ctxvar: ContextVar[bytes] = ContextVar(\"ctxvar\")\n    ctxvar.set(b\"data\")\n\n    def endpoint(request: Request) -> Response:\n        return Response(ctxvar.get())\n\n    app = Starlette(routes=[Route(\"/\", endpoint)])\n    client = test_client_factory(app)\n\n    resp = client.get(\"/\")\n    assert resp.content == b\"data\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "contextvars.ContextVar",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.concurrency.iterate_in_threadpool",
        "starlette.concurrency.run_until_first_complete",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.content == b'data'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "ctxvar.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_invalid_decorator_usage",
      "module": "test_authentication",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_authentication.py",
      "line_number": 209,
      "end_line_number": 214,
      "source_code": "def test_invalid_decorator_usage() -> None:\n    with pytest.raises(Exception):\n\n        @requires(\"authenticated\")\n        def foo() -> None:\n            pass",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "base64",
        "binascii",
        "typing.Any",
        "typing.Awaitable",
        "typing.Callable",
        "urllib.parse.urlencode",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.authentication.AuthCredentials",
        "starlette.authentication.AuthenticationBackend",
        "starlette.authentication.AuthenticationError",
        "starlette.authentication.SimpleUser",
        "starlette.authentication.requires",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.middleware.Middleware",
        "starlette.middleware.authentication.AuthenticationMiddleware",
        "starlette.requests.HTTPConnection",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.routing.WebSocketRoute",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_user_interface",
      "module": "test_authentication",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_authentication.py",
      "line_number": 217,
      "end_line_number": 225,
      "source_code": "def test_user_interface(test_client_factory: TestClientFactory) -> None:\n    with test_client_factory(app) as client:\n        response = client.get(\"/\")\n        assert response.status_code == 200\n        assert response.json() == {\"authenticated\": False, \"user\": \"\"}\n\n        response = client.get(\"/\", auth=(\"tomchristie\", \"example\"))\n        assert response.status_code == 200\n        assert response.json() == {\"authenticated\": True, \"user\": \"tomchristie\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "base64",
        "binascii",
        "typing.Any",
        "typing.Awaitable",
        "typing.Callable",
        "urllib.parse.urlencode",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.authentication.AuthCredentials",
        "starlette.authentication.AuthenticationBackend",
        "starlette.authentication.AuthenticationError",
        "starlette.authentication.SimpleUser",
        "starlette.authentication.requires",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.middleware.Middleware",
        "starlette.middleware.authentication.AuthenticationMiddleware",
        "starlette.requests.HTTPConnection",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.routing.WebSocketRoute",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.json() == {'authenticated': False, 'user': ''}",
        "assert response.status_code == 200",
        "assert response.json() == {'authenticated': True, 'user': 'tomchristie'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_authentication_required",
      "module": "test_authentication",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_authentication.py",
      "line_number": 228,
      "end_line_number": 275,
      "source_code": "def test_authentication_required(test_client_factory: TestClientFactory) -> None:\n    with test_client_factory(app) as client:\n        response = client.get(\"/dashboard\")\n        assert response.status_code == 403\n\n        response = client.get(\"/dashboard\", auth=(\"tomchristie\", \"example\"))\n        assert response.status_code == 200\n        assert response.json() == {\"authenticated\": True, \"user\": \"tomchristie\"}\n\n        response = client.get(\"/dashboard/sync\")\n        assert response.status_code == 403\n\n        response = client.get(\"/dashboard/sync\", auth=(\"tomchristie\", \"example\"))\n        assert response.status_code == 200\n        assert response.json() == {\"authenticated\": True, \"user\": \"tomchristie\"}\n\n        response = client.get(\"/dashboard/class\")\n        assert response.status_code == 403\n\n        response = client.get(\"/dashboard/class\", auth=(\"tomchristie\", \"example\"))\n        assert response.status_code == 200\n        assert response.json() == {\"authenticated\": True, \"user\": \"tomchristie\"}\n\n        response = client.get(\"/dashboard/decorated\", auth=(\"tomchristie\", \"example\"))\n        assert response.status_code == 200\n        assert response.json() == {\n            \"authenticated\": True,\n            \"user\": \"tomchristie\",\n            \"additional\": \"payload\",\n        }\n\n        response = client.get(\"/dashboard/decorated\")\n        assert response.status_code == 403\n\n        response = client.get(\"/dashboard/decorated/sync\", auth=(\"tomchristie\", \"example\"))\n        assert response.status_code == 200\n        assert response.json() == {\n            \"authenticated\": True,\n            \"user\": \"tomchristie\",\n            \"additional\": \"payload\",\n        }\n\n        response = client.get(\"/dashboard/decorated/sync\")\n        assert response.status_code == 403\n\n        response = client.get(\"/dashboard\", headers={\"Authorization\": \"basic foobar\"})\n        assert response.status_code == 400\n        assert response.text == \"Invalid basic auth credentials\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "base64",
        "binascii",
        "typing.Any",
        "typing.Awaitable",
        "typing.Callable",
        "urllib.parse.urlencode",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.authentication.AuthCredentials",
        "starlette.authentication.AuthenticationBackend",
        "starlette.authentication.AuthenticationError",
        "starlette.authentication.SimpleUser",
        "starlette.authentication.requires",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.middleware.Middleware",
        "starlette.middleware.authentication.AuthenticationMiddleware",
        "starlette.requests.HTTPConnection",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.routing.WebSocketRoute",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 403",
        "assert response.status_code == 200",
        "assert response.json() == {'authenticated': True, 'user': 'tomchristie'}",
        "assert response.status_code == 403",
        "assert response.status_code == 200",
        "assert response.json() == {'authenticated': True, 'user': 'tomchristie'}",
        "assert response.status_code == 403",
        "assert response.status_code == 200",
        "assert response.json() == {'authenticated': True, 'user': 'tomchristie'}",
        "assert response.status_code == 200",
        "assert response.json() == {'authenticated': True, 'user': 'tomchristie', 'additional': 'payload'}",
        "assert response.status_code == 403",
        "assert response.status_code == 200",
        "assert response.json() == {'authenticated': True, 'user': 'tomchristie', 'additional': 'payload'}",
        "assert response.status_code == 403",
        "assert response.status_code == 400",
        "assert response.text == 'Invalid basic auth credentials'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_websocket_authentication_required",
      "module": "test_authentication",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_authentication.py",
      "line_number": 278,
      "end_line_number": 308,
      "source_code": "def test_websocket_authentication_required(\n    test_client_factory: TestClientFactory,\n) -> None:\n    with test_client_factory(app) as client:\n        with pytest.raises(WebSocketDisconnect):\n            with client.websocket_connect(\"/ws\"):\n                pass  # pragma: no cover\n\n        with pytest.raises(WebSocketDisconnect):\n            with client.websocket_connect(\"/ws\", headers={\"Authorization\": \"basic foobar\"}):\n                pass  # pragma: no cover\n\n        with client.websocket_connect(\"/ws\", auth=(\"tomchristie\", \"example\")) as websocket:\n            data = websocket.receive_json()\n            assert data == {\"authenticated\": True, \"user\": \"tomchristie\"}\n\n        with pytest.raises(WebSocketDisconnect):\n            with client.websocket_connect(\"/ws/decorated\"):\n                pass  # pragma: no cover\n\n        with pytest.raises(WebSocketDisconnect):\n            with client.websocket_connect(\"/ws/decorated\", headers={\"Authorization\": \"basic foobar\"}):\n                pass  # pragma: no cover\n\n        with client.websocket_connect(\"/ws/decorated\", auth=(\"tomchristie\", \"example\")) as websocket:\n            data = websocket.receive_json()\n            assert data == {\n                \"authenticated\": True,\n                \"user\": \"tomchristie\",\n                \"additional\": \"payload\",\n            }",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "base64",
        "binascii",
        "typing.Any",
        "typing.Awaitable",
        "typing.Callable",
        "urllib.parse.urlencode",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.authentication.AuthCredentials",
        "starlette.authentication.AuthenticationBackend",
        "starlette.authentication.AuthenticationError",
        "starlette.authentication.SimpleUser",
        "starlette.authentication.requires",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.middleware.Middleware",
        "starlette.middleware.authentication.AuthenticationMiddleware",
        "starlette.requests.HTTPConnection",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.routing.WebSocketRoute",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert data == {'authenticated': True, 'user': 'tomchristie'}",
        "assert data == {'authenticated': True, 'user': 'tomchristie', 'additional': 'payload'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_authentication_redirect",
      "module": "test_authentication",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_authentication.py",
      "line_number": 311,
      "end_line_number": 329,
      "source_code": "def test_authentication_redirect(test_client_factory: TestClientFactory) -> None:\n    with test_client_factory(app) as client:\n        response = client.get(\"/admin\")\n        assert response.status_code == 200\n        url = \"{}?{}\".format(\"http://testserver/\", urlencode({\"next\": \"http://testserver/admin\"}))\n        assert response.url == url\n\n        response = client.get(\"/admin\", auth=(\"tomchristie\", \"example\"))\n        assert response.status_code == 200\n        assert response.json() == {\"authenticated\": True, \"user\": \"tomchristie\"}\n\n        response = client.get(\"/admin/sync\")\n        assert response.status_code == 200\n        url = \"{}?{}\".format(\"http://testserver/\", urlencode({\"next\": \"http://testserver/admin/sync\"}))\n        assert response.url == url\n\n        response = client.get(\"/admin/sync\", auth=(\"tomchristie\", \"example\"))\n        assert response.status_code == 200\n        assert response.json() == {\"authenticated\": True, \"user\": \"tomchristie\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "base64",
        "binascii",
        "typing.Any",
        "typing.Awaitable",
        "typing.Callable",
        "urllib.parse.urlencode",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.authentication.AuthCredentials",
        "starlette.authentication.AuthenticationBackend",
        "starlette.authentication.AuthenticationError",
        "starlette.authentication.SimpleUser",
        "starlette.authentication.requires",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.middleware.Middleware",
        "starlette.middleware.authentication.AuthenticationMiddleware",
        "starlette.requests.HTTPConnection",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.routing.WebSocketRoute",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.url == url",
        "assert response.status_code == 200",
        "assert response.json() == {'authenticated': True, 'user': 'tomchristie'}",
        "assert response.status_code == 200",
        "assert response.url == url",
        "assert response.status_code == 200",
        "assert response.json() == {'authenticated': True, 'user': 'tomchristie'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_custom_on_error",
      "module": "test_authentication",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_authentication.py",
      "line_number": 352,
      "end_line_number": 360,
      "source_code": "def test_custom_on_error(test_client_factory: TestClientFactory) -> None:\n    with test_client_factory(other_app) as client:\n        response = client.get(\"/control-panel\", auth=(\"tomchristie\", \"example\"))\n        assert response.status_code == 200\n        assert response.json() == {\"authenticated\": True, \"user\": \"tomchristie\"}\n\n        response = client.get(\"/control-panel\", headers={\"Authorization\": \"basic foobar\"})\n        assert response.status_code == 401\n        assert response.json() == {\"error\": \"Invalid basic auth credentials\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "base64",
        "binascii",
        "typing.Any",
        "typing.Awaitable",
        "typing.Callable",
        "urllib.parse.urlencode",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.authentication.AuthCredentials",
        "starlette.authentication.AuthenticationBackend",
        "starlette.authentication.AuthenticationError",
        "starlette.authentication.SimpleUser",
        "starlette.authentication.requires",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.middleware.Middleware",
        "starlette.middleware.authentication.AuthenticationMiddleware",
        "starlette.requests.HTTPConnection",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.routing.WebSocketRoute",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.json() == {'authenticated': True, 'user': 'tomchristie'}",
        "assert response.status_code == 401",
        "assert response.json() == {'error': 'Invalid basic auth credentials'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_use_testclient_in_endpoint",
      "module": "test_testclient",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_testclient.py",
      "line_number": 52,
      "end_line_number": 69,
      "source_code": "def test_use_testclient_in_endpoint(test_client_factory: TestClientFactory) -> None:\n    \"\"\"\n    We should be able to use the test client within applications.\n\n    This is useful if we need to mock out other services,\n    during tests or in development.\n    \"\"\"\n\n    def homepage(request: Request) -> JSONResponse:\n        client = test_client_factory(mock_service)\n        response = client.get(\"/\")\n        return JSONResponse(response.json())\n\n    app = Starlette(routes=[Route(\"/\", endpoint=homepage)])\n\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.json() == {\"mock\": \"example\"}",
      "docstring": "We should be able to use the test client within applications.\n\nThis is useful if we need to mock out other services,\nduring tests or in development.",
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "itertools",
        "sys",
        "asyncio.Task",
        "asyncio.current_task",
        "contextlib.asynccontextmanager",
        "typing.Any",
        "typing.AsyncGenerator",
        "anyio",
        "anyio.lowlevel",
        "pytest",
        "sniffio",
        "trio.lowlevel",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.testclient.ASGIInstance",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'mock': 'example'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_testclient_headers_behavior",
      "module": "test_testclient",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_testclient.py",
      "line_number": 72,
      "end_line_number": 88,
      "source_code": "def test_testclient_headers_behavior() -> None:\n    \"\"\"\n    We should be able to use the test client with user defined headers.\n\n    This is useful if we need to set custom headers for authentication\n    during tests or in development.\n    \"\"\"\n\n    client = TestClient(mock_service)\n    assert client.headers.get(\"user-agent\") == \"testclient\"\n\n    client = TestClient(mock_service, headers={\"user-agent\": \"non-default-agent\"})\n    assert client.headers.get(\"user-agent\") == \"non-default-agent\"\n\n    client = TestClient(mock_service, headers={\"Authentication\": \"Bearer 123\"})\n    assert client.headers.get(\"user-agent\") == \"testclient\"\n    assert client.headers.get(\"Authentication\") == \"Bearer 123\"",
      "docstring": "We should be able to use the test client with user defined headers.\n\nThis is useful if we need to set custom headers for authentication\nduring tests or in development.",
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "itertools",
        "sys",
        "asyncio.Task",
        "asyncio.current_task",
        "contextlib.asynccontextmanager",
        "typing.Any",
        "typing.AsyncGenerator",
        "anyio",
        "anyio.lowlevel",
        "pytest",
        "sniffio",
        "trio.lowlevel",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.testclient.ASGIInstance",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.headers.get('user-agent') == 'testclient'",
        "assert client.headers.get('user-agent') == 'non-default-agent'",
        "assert client.headers.get('user-agent') == 'testclient'",
        "assert client.headers.get('Authentication') == 'Bearer 123'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.headers.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.headers.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.headers.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.headers.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_use_testclient_as_contextmanager",
      "module": "test_testclient",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_testclient.py",
      "line_number": 91,
      "end_line_number": 166,
      "source_code": "def test_use_testclient_as_contextmanager(test_client_factory: TestClientFactory, anyio_backend_name: str) -> None:\n    \"\"\"\n    This test asserts a number of properties that are important for an\n    app level task_group\n    \"\"\"\n    counter = itertools.count()\n    identity_runvar = anyio.lowlevel.RunVar[int](\"identity_runvar\")\n\n    def get_identity() -> int:\n        try:\n            return identity_runvar.get()\n        except LookupError:\n            token = next(counter)\n            identity_runvar.set(token)\n            return token\n\n    startup_task = object()\n    startup_loop = None\n    shutdown_task = object()\n    shutdown_loop = None\n\n    @asynccontextmanager\n    async def lifespan_context(app: Starlette) -> AsyncGenerator[None, None]:\n        nonlocal startup_task, startup_loop, shutdown_task, shutdown_loop\n\n        startup_task = current_task()\n        startup_loop = get_identity()\n        async with anyio.create_task_group():\n            yield\n        shutdown_task = current_task()\n        shutdown_loop = get_identity()\n\n    async def loop_id(request: Request) -> JSONResponse:\n        return JSONResponse(get_identity())\n\n    app = Starlette(\n        lifespan=lifespan_context,\n        routes=[Route(\"/loop_id\", endpoint=loop_id)],\n    )\n\n    client = test_client_factory(app)\n\n    with client:\n        # within a TestClient context every async request runs in the same thread\n        assert client.get(\"/loop_id\").json() == 0\n        assert client.get(\"/loop_id\").json() == 0\n\n    # that thread is also the same as the lifespan thread\n    assert startup_loop == 0\n    assert shutdown_loop == 0\n\n    # lifespan events run in the same task, this is important because a task\n    # group must be entered and exited in the same task.\n    assert startup_task is shutdown_task\n\n    # outside the TestClient context, new requests continue to spawn in new\n    # event loops in new threads\n    assert client.get(\"/loop_id\").json() == 1\n    assert client.get(\"/loop_id\").json() == 2\n\n    first_task = startup_task\n\n    with client:\n        # the TestClient context can be re-used, starting a new lifespan task\n        # in a new thread\n        assert client.get(\"/loop_id\").json() == 3\n        assert client.get(\"/loop_id\").json() == 3\n\n    assert startup_loop == 3\n    assert shutdown_loop == 3\n\n    # lifespan events still run in the same task, with the context but...\n    assert startup_task is shutdown_task\n\n    # ... the second TestClient context creates a new lifespan task.\n    assert first_task is not startup_task",
      "docstring": "This test asserts a number of properties that are important for an\napp level task_group",
      "decorators": [],
      "arguments": [
        "test_client_factory",
        "anyio_backend_name"
      ],
      "imports": [
        "__future__.annotations",
        "itertools",
        "sys",
        "asyncio.Task",
        "asyncio.current_task",
        "contextlib.asynccontextmanager",
        "typing.Any",
        "typing.AsyncGenerator",
        "anyio",
        "anyio.lowlevel",
        "pytest",
        "sniffio",
        "trio.lowlevel",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.testclient.ASGIInstance",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert startup_loop == 0",
        "assert shutdown_loop == 0",
        "assert startup_task is shutdown_task",
        "assert client.get('/loop_id').json() == 1",
        "assert client.get('/loop_id').json() == 2",
        "assert startup_loop == 3",
        "assert shutdown_loop == 3",
        "assert startup_task is shutdown_task",
        "assert first_task is not startup_task",
        "assert client.get('/loop_id').json() == 0",
        "assert client.get('/loop_id').json() == 0",
        "assert client.get('/loop_id').json() == 3",
        "assert client.get('/loop_id').json() == 3"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "current_task",
          "body": "def current_task() -> Task[Any] | trio.lowlevel.Task:\n    asynclib_name = sniffio.current_async_library()\n    if asynclib_name == 'trio':\n        return trio.lowlevel.current_task()\n    if asynclib_name == 'asyncio':\n        task = asyncio_current_task()\n        if task is None:\n            raise RuntimeError('must be called from a running task')\n        return task\n    raise RuntimeError(f'unsupported asynclib={asynclib_name}')"
        },
        {
          "name": "get_identity",
          "body": "def get_identity() -> int:\n    try:\n        return identity_runvar.get()\n    except LookupError:\n        token = next(counter)\n        identity_runvar.set(token)\n        return token"
        },
        {
          "name": "current_task",
          "body": "def current_task() -> Task[Any] | trio.lowlevel.Task:\n    asynclib_name = sniffio.current_async_library()\n    if asynclib_name == 'trio':\n        return trio.lowlevel.current_task()\n    if asynclib_name == 'asyncio':\n        task = asyncio_current_task()\n        if task is None:\n            raise RuntimeError('must be called from a running task')\n        return task\n    raise RuntimeError(f'unsupported asynclib={asynclib_name}')"
        },
        {
          "name": "get_identity",
          "body": "def get_identity() -> int:\n    try:\n        return identity_runvar.get()\n    except LookupError:\n        token = next(counter)\n        identity_runvar.set(token)\n        return token"
        },
        {
          "name": "identity_runvar.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "get_identity",
          "body": "def get_identity() -> int:\n    try:\n        return identity_runvar.get()\n    except LookupError:\n        token = next(counter)\n        identity_runvar.set(token)\n        return token"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_error_on_startup",
      "module": "test_testclient",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_testclient.py",
      "line_number": 169,
      "end_line_number": 175,
      "source_code": "def test_error_on_startup(test_client_factory: TestClientFactory) -> None:\n    with pytest.deprecated_call(match=\"The on_startup and on_shutdown parameters are deprecated\"):\n        startup_error_app = Starlette(on_startup=[startup])\n\n    with pytest.raises(RuntimeError):\n        with test_client_factory(startup_error_app):\n            pass",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "itertools",
        "sys",
        "asyncio.Task",
        "asyncio.current_task",
        "contextlib.asynccontextmanager",
        "typing.Any",
        "typing.AsyncGenerator",
        "anyio",
        "anyio.lowlevel",
        "pytest",
        "sniffio",
        "trio.lowlevel",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.testclient.ASGIInstance",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_exception_in_middleware",
      "module": "test_testclient",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_testclient.py",
      "line_number": 178,
      "end_line_number": 193,
      "source_code": "def test_exception_in_middleware(test_client_factory: TestClientFactory) -> None:\n    class MiddlewareException(Exception):\n        pass\n\n    class BrokenMiddleware:\n        def __init__(self, app: ASGIApp):\n            self.app = app\n\n        async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n            raise MiddlewareException()\n\n    broken_middleware = Starlette(middleware=[Middleware(BrokenMiddleware)])\n\n    with pytest.raises(MiddlewareException):\n        with test_client_factory(broken_middleware):\n            pass",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "itertools",
        "sys",
        "asyncio.Task",
        "asyncio.current_task",
        "contextlib.asynccontextmanager",
        "typing.Any",
        "typing.AsyncGenerator",
        "anyio",
        "anyio.lowlevel",
        "pytest",
        "sniffio",
        "trio.lowlevel",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.testclient.ASGIInstance",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_testclient_asgi2",
      "module": "test_testclient",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_testclient.py",
      "line_number": 196,
      "end_line_number": 212,
      "source_code": "def test_testclient_asgi2(test_client_factory: TestClientFactory) -> None:\n    def app(scope: Scope) -> ASGIInstance:\n        async def inner(receive: Receive, send: Send) -> None:\n            await send(\n                {\n                    \"type\": \"http.response.start\",\n                    \"status\": 200,\n                    \"headers\": [[b\"content-type\", b\"text/plain\"]],\n                }\n            )\n            await send({\"type\": \"http.response.body\", \"body\": b\"Hello, world!\"})\n\n        return inner\n\n    client = test_client_factory(app)  # type: ignore\n    response = client.get(\"/\")\n    assert response.text == \"Hello, world!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "itertools",
        "sys",
        "asyncio.Task",
        "asyncio.current_task",
        "contextlib.asynccontextmanager",
        "typing.Any",
        "typing.AsyncGenerator",
        "anyio",
        "anyio.lowlevel",
        "pytest",
        "sniffio",
        "trio.lowlevel",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.testclient.ASGIInstance",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'Hello, world!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_testclient_asgi3",
      "module": "test_testclient",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_testclient.py",
      "line_number": 215,
      "end_line_number": 228,
      "source_code": "def test_testclient_asgi3(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        await send(\n            {\n                \"type\": \"http.response.start\",\n                \"status\": 200,\n                \"headers\": [[b\"content-type\", b\"text/plain\"]],\n            }\n        )\n        await send({\"type\": \"http.response.body\", \"body\": b\"Hello, world!\"})\n\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.text == \"Hello, world!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "itertools",
        "sys",
        "asyncio.Task",
        "asyncio.current_task",
        "contextlib.asynccontextmanager",
        "typing.Any",
        "typing.AsyncGenerator",
        "anyio",
        "anyio.lowlevel",
        "pytest",
        "sniffio",
        "trio.lowlevel",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.testclient.ASGIInstance",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'Hello, world!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_websocket_blocking_receive",
      "module": "test_testclient",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_testclient.py",
      "line_number": 231,
      "end_line_number": 253,
      "source_code": "def test_websocket_blocking_receive(test_client_factory: TestClientFactory) -> None:\n    def app(scope: Scope) -> ASGIInstance:\n        async def respond(websocket: WebSocket) -> None:\n            await websocket.send_json({\"message\": \"test\"})\n\n        async def asgi(receive: Receive, send: Send) -> None:\n            websocket = WebSocket(scope, receive=receive, send=send)\n            await websocket.accept()\n            async with anyio.create_task_group() as task_group:\n                task_group.start_soon(respond, websocket)\n                try:\n                    # this will block as the client does not send us data\n                    # it should not prevent `respond` from executing though\n                    await websocket.receive_json()\n                except WebSocketDisconnect:\n                    pass\n\n        return asgi\n\n    client = test_client_factory(app)  # type: ignore\n    with client.websocket_connect(\"/\") as websocket:\n        data = websocket.receive_json()\n        assert data == {\"message\": \"test\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "itertools",
        "sys",
        "asyncio.Task",
        "asyncio.current_task",
        "contextlib.asynccontextmanager",
        "typing.Any",
        "typing.AsyncGenerator",
        "anyio",
        "anyio.lowlevel",
        "pytest",
        "sniffio",
        "trio.lowlevel",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.testclient.ASGIInstance",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert data == {'message': 'test'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_websocket_not_block_on_close",
      "module": "test_testclient",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_testclient.py",
      "line_number": 256,
      "end_line_number": 269,
      "source_code": "def test_websocket_not_block_on_close(test_client_factory: TestClientFactory) -> None:\n    def app(scope: Scope) -> ASGIInstance:\n        async def asgi(receive: Receive, send: Send) -> None:\n            websocket = WebSocket(scope, receive=receive, send=send)\n            await websocket.accept()\n            while True:\n                await anyio.sleep(0.1)\n\n        return asgi\n\n    client = test_client_factory(app)  # type: ignore\n    with client.websocket_connect(\"/\") as websocket:\n        ...\n    assert websocket.should_close.is_set()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "itertools",
        "sys",
        "asyncio.Task",
        "asyncio.current_task",
        "contextlib.asynccontextmanager",
        "typing.Any",
        "typing.AsyncGenerator",
        "anyio",
        "anyio.lowlevel",
        "pytest",
        "sniffio",
        "trio.lowlevel",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.testclient.ASGIInstance",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert websocket.should_close.is_set()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_client",
      "module": "test_testclient",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_testclient.py",
      "line_number": 272,
      "end_line_number": 282,
      "source_code": "def test_client(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        client = scope.get(\"client\")\n        assert client is not None\n        host, port = client\n        response = JSONResponse({\"host\": host, \"port\": port})\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.json() == {\"host\": \"testclient\", \"port\": 50000}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "itertools",
        "sys",
        "asyncio.Task",
        "asyncio.current_task",
        "contextlib.asynccontextmanager",
        "typing.Any",
        "typing.AsyncGenerator",
        "anyio",
        "anyio.lowlevel",
        "pytest",
        "sniffio",
        "trio.lowlevel",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.testclient.ASGIInstance",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'host': 'testclient', 'port': 50000}",
        "assert client is not None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "scope.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_query_params",
      "module": "test_testclient",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_testclient.py",
      "line_number": 286,
      "end_line_number": 293,
      "source_code": "def test_query_params(test_client_factory: TestClientFactory, param: str) -> None:\n    def homepage(request: Request) -> Response:\n        return Response(request.query_params[\"param\"])\n\n    app = Starlette(routes=[Route(\"/\", endpoint=homepage)])\n    client = test_client_factory(app)\n    response = client.get(\"/\", params={\"param\": param})\n    assert response.text == param",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('param', ('2020-07-14T00:00:00+00:00', 'Espa\u00f1a', 'voil\u00e0'))"
      ],
      "arguments": [
        "test_client_factory",
        "param"
      ],
      "imports": [
        "__future__.annotations",
        "itertools",
        "sys",
        "asyncio.Task",
        "asyncio.current_task",
        "contextlib.asynccontextmanager",
        "typing.Any",
        "typing.AsyncGenerator",
        "anyio",
        "anyio.lowlevel",
        "pytest",
        "sniffio",
        "trio.lowlevel",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.testclient.ASGIInstance",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == param"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_domain_restricted_cookies",
      "module": "test_testclient",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_testclient.py",
      "line_number": 314,
      "end_line_number": 337,
      "source_code": "def test_domain_restricted_cookies(test_client_factory: TestClientFactory, domain: str, ok: bool) -> None:\n    \"\"\"\n    Test that test client discards domain restricted cookies which do not match the\n    base_url of the testclient (`http://testserver` by default).\n\n    The domain `testserver.local` works because the Python http.cookiejar module derives\n    the \"effective domain\" by appending `.local` to non-dotted request domains\n    in accordance with RFC 2965.\n    \"\"\"\n\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        response = Response(\"Hello, world!\", media_type=\"text/plain\")\n        response.set_cookie(\n            \"mycookie\",\n            \"myvalue\",\n            path=\"/\",\n            domain=domain,\n        )\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    cookie_set = len(response.cookies) == 1\n    assert cookie_set == ok",
      "docstring": "Test that test client discards domain restricted cookies which do not match the\nbase_url of the testclient (`http://testserver` by default).\n\nThe domain `testserver.local` works because the Python http.cookiejar module derives\nthe \"effective domain\" by appending `.local` to non-dotted request domains\nin accordance with RFC 2965.",
      "decorators": [
        "pytest.mark.parametrize('domain, ok', [pytest.param('testserver', True, marks=[pytest.mark.xfail(sys.version_info < (3, 11), reason='Fails due to domain handling in http.cookiejar module (see #2152)')]), ('testserver.local', True), ('localhost', False), ('example.com', False)])"
      ],
      "arguments": [
        "test_client_factory",
        "domain",
        "ok"
      ],
      "imports": [
        "__future__.annotations",
        "itertools",
        "sys",
        "asyncio.Task",
        "asyncio.current_task",
        "contextlib.asynccontextmanager",
        "typing.Any",
        "typing.AsyncGenerator",
        "anyio",
        "anyio.lowlevel",
        "pytest",
        "sniffio",
        "trio.lowlevel",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.testclient.ASGIInstance",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert cookie_set == ok"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_forward_follow_redirects",
      "module": "test_testclient",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_testclient.py",
      "line_number": 340,
      "end_line_number": 350,
      "source_code": "def test_forward_follow_redirects(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        if \"/ok\" in scope[\"path\"]:\n            response = Response(\"ok\")\n        else:\n            response = RedirectResponse(\"/ok\")\n        await response(scope, receive, send)\n\n    client = test_client_factory(app, follow_redirects=True)\n    response = client.get(\"/\")\n    assert response.status_code == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "itertools",
        "sys",
        "asyncio.Task",
        "asyncio.current_task",
        "contextlib.asynccontextmanager",
        "typing.Any",
        "typing.AsyncGenerator",
        "anyio",
        "anyio.lowlevel",
        "pytest",
        "sniffio",
        "trio.lowlevel",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.testclient.ASGIInstance",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_forward_nofollow_redirects",
      "module": "test_testclient",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_testclient.py",
      "line_number": 353,
      "end_line_number": 360,
      "source_code": "def test_forward_nofollow_redirects(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        response = RedirectResponse(\"/ok\")\n        await response(scope, receive, send)\n\n    client = test_client_factory(app, follow_redirects=False)\n    response = client.get(\"/\")\n    assert response.status_code == 307",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "itertools",
        "sys",
        "asyncio.Task",
        "asyncio.current_task",
        "contextlib.asynccontextmanager",
        "typing.Any",
        "typing.AsyncGenerator",
        "anyio",
        "anyio.lowlevel",
        "pytest",
        "sniffio",
        "trio.lowlevel",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.testclient.ASGIInstance",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 307"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_with_duplicate_headers",
      "module": "test_testclient",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_testclient.py",
      "line_number": 363,
      "end_line_number": 370,
      "source_code": "def test_with_duplicate_headers(test_client_factory: TestClientFactory) -> None:\n    def homepage(request: Request) -> JSONResponse:\n        return JSONResponse({\"x-token\": request.headers.getlist(\"x-token\")})\n\n    app = Starlette(routes=[Route(\"/\", endpoint=homepage)])\n    client = test_client_factory(app)\n    response = client.get(\"/\", headers=[(\"x-token\", \"foo\"), (\"x-token\", \"bar\")])\n    assert response.json() == {\"x-token\": [\"foo\", \"bar\"]}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "itertools",
        "sys",
        "asyncio.Task",
        "asyncio.current_task",
        "contextlib.asynccontextmanager",
        "typing.Any",
        "typing.AsyncGenerator",
        "anyio",
        "anyio.lowlevel",
        "pytest",
        "sniffio",
        "trio.lowlevel",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.testclient.ASGIInstance",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'x-token': ['foo', 'bar']}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_merge_url",
      "module": "test_testclient",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_testclient.py",
      "line_number": 373,
      "end_line_number": 380,
      "source_code": "def test_merge_url(test_client_factory: TestClientFactory) -> None:\n    def homepage(request: Request) -> Response:\n        return Response(request.url.path)\n\n    app = Starlette(routes=[Route(\"/api/v1/bar\", endpoint=homepage)])\n    client = test_client_factory(app, base_url=\"http://testserver/api/v1/\")\n    response = client.get(\"/bar\")\n    assert response.text == \"/api/v1/bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "itertools",
        "sys",
        "asyncio.Task",
        "asyncio.current_task",
        "contextlib.asynccontextmanager",
        "typing.Any",
        "typing.AsyncGenerator",
        "anyio",
        "anyio.lowlevel",
        "pytest",
        "sniffio",
        "trio.lowlevel",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.testclient.ASGIInstance",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == '/api/v1/bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_config_types",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_config.py",
      "line_number": 13,
      "end_line_number": 38,
      "source_code": "def test_config_types() -> None:\n    \"\"\"\n    We use `assert_type` to test the types returned by Config via mypy.\n    \"\"\"\n    config = Config(environ={\"STR\": \"some_str_value\", \"STR_CAST\": \"some_str_value\", \"BOOL\": \"true\"})\n\n    assert_type(config(\"STR\"), str)\n    assert_type(config(\"STR_DEFAULT\", default=\"\"), str)\n    assert_type(config(\"STR_CAST\", cast=str), str)\n    assert_type(config(\"STR_NONE\", default=None), Optional[str])\n    assert_type(config(\"STR_CAST_NONE\", cast=str, default=None), Optional[str])\n    assert_type(config(\"STR_CAST_STR\", cast=str, default=\"\"), str)\n\n    assert_type(config(\"BOOL\", cast=bool), bool)\n    assert_type(config(\"BOOL_DEFAULT\", cast=bool, default=False), bool)\n    assert_type(config(\"BOOL_NONE\", cast=bool, default=None), Optional[bool])\n\n    def cast_to_int(v: Any) -> int:\n        return int(v)\n\n    # our type annotations allow these `cast` and `default` configurations, but\n    # the code will error at runtime.\n    with pytest.raises(ValueError):\n        config(\"INT_CAST_DEFAULT_STR\", cast=cast_to_int, default=\"true\")\n    with pytest.raises(ValueError):\n        config(\"INT_DEFAULT_STR\", cast=int, default=\"true\")",
      "docstring": "We use `assert_type` to test the types returned by Config via mypy.",
      "decorators": [],
      "arguments": [],
      "imports": [
        "os",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Optional",
        "pytest",
        "typing_extensions.assert_type",
        "starlette.config.Config",
        "starlette.config.Environ",
        "starlette.config.EnvironError",
        "starlette.datastructures.URL",
        "starlette.datastructures.Secret"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_config",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_config.py",
      "line_number": 41,
      "end_line_number": 103,
      "source_code": "def test_config(tmpdir: Path, monkeypatch: pytest.MonkeyPatch) -> None:\n    path = os.path.join(tmpdir, \".env\")\n    with open(path, \"w\") as file:\n        file.write(\"# Do not commit to source control\\n\")\n        file.write(\"DATABASE_URL=postgres://user:pass@localhost/dbname\\n\")\n        file.write(\"REQUEST_HOSTNAME=example.com\\n\")\n        file.write(\"SECRET_KEY=12345\\n\")\n        file.write(\"BOOL_AS_INT=0\\n\")\n        file.write(\"\\n\")\n        file.write(\"\\n\")\n\n    config = Config(path, environ={\"DEBUG\": \"true\"})\n\n    def cast_to_int(v: typing.Any) -> int:\n        return int(v)\n\n    DEBUG = config(\"DEBUG\", cast=bool)\n    DATABASE_URL = config(\"DATABASE_URL\", cast=URL)\n    REQUEST_TIMEOUT = config(\"REQUEST_TIMEOUT\", cast=int, default=10)\n    REQUEST_HOSTNAME = config(\"REQUEST_HOSTNAME\")\n    MAIL_HOSTNAME = config(\"MAIL_HOSTNAME\", default=None)\n    SECRET_KEY = config(\"SECRET_KEY\", cast=Secret)\n    UNSET_SECRET = config(\"UNSET_SECRET\", cast=Secret, default=None)\n    EMPTY_SECRET = config(\"EMPTY_SECRET\", cast=Secret, default=\"\")\n    assert config(\"BOOL_AS_INT\", cast=bool) is False\n    assert config(\"BOOL_AS_INT\", cast=cast_to_int) == 0\n    assert config(\"DEFAULTED_BOOL\", cast=cast_to_int, default=True) == 1\n\n    assert DEBUG is True\n    assert DATABASE_URL.path == \"/dbname\"\n    assert DATABASE_URL.password == \"pass\"\n    assert DATABASE_URL.username == \"user\"\n    assert REQUEST_TIMEOUT == 10\n    assert REQUEST_HOSTNAME == \"example.com\"\n    assert MAIL_HOSTNAME is None\n    assert repr(SECRET_KEY) == \"Secret('**********')\"\n    assert str(SECRET_KEY) == \"12345\"\n    assert bool(SECRET_KEY)\n    assert not bool(EMPTY_SECRET)\n    assert not bool(UNSET_SECRET)\n\n    with pytest.raises(KeyError):\n        config.get(\"MISSING\")\n\n    with pytest.raises(ValueError):\n        config.get(\"DEBUG\", cast=int)\n\n    with pytest.raises(ValueError):\n        config.get(\"REQUEST_HOSTNAME\", cast=bool)\n\n    config = Config(Path(path))\n    REQUEST_HOSTNAME = config(\"REQUEST_HOSTNAME\")\n    assert REQUEST_HOSTNAME == \"example.com\"\n\n    config = Config()\n    monkeypatch.setenv(\"STARLETTE_EXAMPLE_TEST\", \"123\")\n    monkeypatch.setenv(\"BOOL_AS_INT\", \"1\")\n    assert config.get(\"STARLETTE_EXAMPLE_TEST\", cast=int) == 123\n    assert config.get(\"BOOL_AS_INT\", cast=bool) is True\n\n    monkeypatch.setenv(\"BOOL_AS_INT\", \"2\")\n    with pytest.raises(ValueError):\n        config.get(\"BOOL_AS_INT\", cast=bool)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "monkeypatch"
      ],
      "imports": [
        "os",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Optional",
        "pytest",
        "typing_extensions.assert_type",
        "starlette.config.Config",
        "starlette.config.Environ",
        "starlette.config.EnvironError",
        "starlette.datastructures.URL",
        "starlette.datastructures.Secret"
      ],
      "fixtures": [],
      "assertions": [
        "assert config('BOOL_AS_INT', cast=bool) is False",
        "assert config('BOOL_AS_INT', cast=cast_to_int) == 0",
        "assert config('DEFAULTED_BOOL', cast=cast_to_int, default=True) == 1",
        "assert DEBUG is True",
        "assert DATABASE_URL.path == '/dbname'",
        "assert DATABASE_URL.password == 'pass'",
        "assert DATABASE_URL.username == 'user'",
        "assert REQUEST_TIMEOUT == 10",
        "assert REQUEST_HOSTNAME == 'example.com'",
        "assert MAIL_HOSTNAME is None",
        "assert repr(SECRET_KEY) == \"Secret('**********')\"",
        "assert str(SECRET_KEY) == '12345'",
        "assert bool(SECRET_KEY)",
        "assert not bool(EMPTY_SECRET)",
        "assert not bool(UNSET_SECRET)",
        "assert REQUEST_HOSTNAME == 'example.com'",
        "assert config.get('STARLETTE_EXAMPLE_TEST', cast=int) == 123",
        "assert config.get('BOOL_AS_INT', cast=bool) is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "config.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "config.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "config.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "config.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "config.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "config.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_missing_env_file_raises",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_config.py",
      "line_number": 106,
      "end_line_number": 110,
      "source_code": "def test_missing_env_file_raises(tmpdir: Path) -> None:\n    path = os.path.join(tmpdir, \".env\")\n\n    with pytest.warns(UserWarning, match=f\"Config file '{path}' not found.\"):\n        Config(path)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir"
      ],
      "imports": [
        "os",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Optional",
        "pytest",
        "typing_extensions.assert_type",
        "starlette.config.Config",
        "starlette.config.Environ",
        "starlette.config.EnvironError",
        "starlette.datastructures.URL",
        "starlette.datastructures.Secret"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_environ",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_config.py",
      "line_number": 113,
      "end_line_number": 135,
      "source_code": "def test_environ() -> None:\n    environ = Environ()\n\n    # We can mutate the environ at this point.\n    environ[\"TESTING\"] = \"True\"\n    environ[\"GONE\"] = \"123\"\n    del environ[\"GONE\"]\n\n    # We can read the environ.\n    assert environ[\"TESTING\"] == \"True\"\n    assert \"GONE\" not in environ\n\n    # We cannot mutate these keys now that we've read them.\n    with pytest.raises(EnvironError):\n        environ[\"TESTING\"] = \"False\"\n\n    with pytest.raises(EnvironError):\n        del environ[\"GONE\"]\n\n    # Test coverage of abstract methods for MutableMapping.\n    environ = Environ()\n    assert list(iter(environ)) == list(iter(os.environ))\n    assert len(environ) == len(os.environ)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "os",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Optional",
        "pytest",
        "typing_extensions.assert_type",
        "starlette.config.Config",
        "starlette.config.Environ",
        "starlette.config.EnvironError",
        "starlette.datastructures.URL",
        "starlette.datastructures.Secret"
      ],
      "fixtures": [],
      "assertions": [
        "assert environ['TESTING'] == 'True'",
        "assert 'GONE' not in environ",
        "assert list(iter(environ)) == list(iter(os.environ))",
        "assert len(environ) == len(os.environ)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_config_with_env_prefix",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_config.py",
      "line_number": 138,
      "end_line_number": 143,
      "source_code": "def test_config_with_env_prefix(tmpdir: Path, monkeypatch: pytest.MonkeyPatch) -> None:\n    config = Config(environ={\"APP_DEBUG\": \"value\", \"ENVIRONMENT\": \"dev\"}, env_prefix=\"APP_\")\n    assert config.get(\"DEBUG\") == \"value\"\n\n    with pytest.raises(KeyError):\n        config.get(\"ENVIRONMENT\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "monkeypatch"
      ],
      "imports": [
        "os",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Optional",
        "pytest",
        "typing_extensions.assert_type",
        "starlette.config.Config",
        "starlette.config.Environ",
        "starlette.config.EnvironError",
        "starlette.datastructures.URL",
        "starlette.datastructures.Secret"
      ],
      "fixtures": [],
      "assertions": [
        "assert config.get('DEBUG') == 'value'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "config.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "config.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_multipart_request_data",
      "module": "test_formparsers",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_formparsers.py",
      "line_number": 130,
      "end_line_number": 133,
      "source_code": "def test_multipart_request_data(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    client = test_client_factory(app)\n    response = client.post(\"/\", data={\"some\": \"data\"}, files=FORCE_MULTIPART)\n    assert response.json() == {\"some\": \"data\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "typing",
        "contextlib.nullcontext",
        "pathlib.Path",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.datastructures.UploadFile",
        "starlette.formparsers.MultiPartException",
        "starlette.formparsers._user_safe_decode",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.routing.Mount",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'some': 'data'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_multipart_request_files",
      "module": "test_formparsers",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_formparsers.py",
      "line_number": 136,
      "end_line_number": 151,
      "source_code": "def test_multipart_request_files(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    path = os.path.join(tmpdir, \"test.txt\")\n    with open(path, \"wb\") as file:\n        file.write(b\"<file content>\")\n\n    client = test_client_factory(app)\n    with open(path, \"rb\") as f:\n        response = client.post(\"/\", files={\"test\": f})\n        assert response.json() == {\n            \"test\": {\n                \"filename\": \"test.txt\",\n                \"size\": 14,\n                \"content\": \"<file content>\",\n                \"content_type\": \"text/plain\",\n            }\n        }",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "typing",
        "contextlib.nullcontext",
        "pathlib.Path",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.datastructures.UploadFile",
        "starlette.formparsers.MultiPartException",
        "starlette.formparsers._user_safe_decode",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.routing.Mount",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'test': {'filename': 'test.txt', 'size': 14, 'content': '<file content>', 'content_type': 'text/plain'}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_multipart_request_files_with_content_type",
      "module": "test_formparsers",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_formparsers.py",
      "line_number": 154,
      "end_line_number": 169,
      "source_code": "def test_multipart_request_files_with_content_type(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    path = os.path.join(tmpdir, \"test.txt\")\n    with open(path, \"wb\") as file:\n        file.write(b\"<file content>\")\n\n    client = test_client_factory(app)\n    with open(path, \"rb\") as f:\n        response = client.post(\"/\", files={\"test\": (\"test.txt\", f, \"text/plain\")})\n        assert response.json() == {\n            \"test\": {\n                \"filename\": \"test.txt\",\n                \"size\": 14,\n                \"content\": \"<file content>\",\n                \"content_type\": \"text/plain\",\n            }\n        }",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "typing",
        "contextlib.nullcontext",
        "pathlib.Path",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.datastructures.UploadFile",
        "starlette.formparsers.MultiPartException",
        "starlette.formparsers._user_safe_decode",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.routing.Mount",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'test': {'filename': 'test.txt', 'size': 14, 'content': '<file content>', 'content_type': 'text/plain'}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_multipart_request_multiple_files",
      "module": "test_formparsers",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_formparsers.py",
      "line_number": 172,
      "end_line_number": 197,
      "source_code": "def test_multipart_request_multiple_files(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    path1 = os.path.join(tmpdir, \"test1.txt\")\n    with open(path1, \"wb\") as file:\n        file.write(b\"<file1 content>\")\n\n    path2 = os.path.join(tmpdir, \"test2.txt\")\n    with open(path2, \"wb\") as file:\n        file.write(b\"<file2 content>\")\n\n    client = test_client_factory(app)\n    with open(path1, \"rb\") as f1, open(path2, \"rb\") as f2:\n        response = client.post(\"/\", files={\"test1\": f1, \"test2\": (\"test2.txt\", f2, \"text/plain\")})\n        assert response.json() == {\n            \"test1\": {\n                \"filename\": \"test1.txt\",\n                \"size\": 15,\n                \"content\": \"<file1 content>\",\n                \"content_type\": \"text/plain\",\n            },\n            \"test2\": {\n                \"filename\": \"test2.txt\",\n                \"size\": 15,\n                \"content\": \"<file2 content>\",\n                \"content_type\": \"text/plain\",\n            },\n        }",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "typing",
        "contextlib.nullcontext",
        "pathlib.Path",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.datastructures.UploadFile",
        "starlette.formparsers.MultiPartException",
        "starlette.formparsers._user_safe_decode",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.routing.Mount",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'test1': {'filename': 'test1.txt', 'size': 15, 'content': '<file1 content>', 'content_type': 'text/plain'}, 'test2': {'filename': 'test2.txt', 'size': 15, 'content': '<file2 content>', 'content_type': 'text/plain'}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_multipart_request_multiple_files_with_headers",
      "module": "test_formparsers",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_formparsers.py",
      "line_number": 200,
      "end_line_number": 234,
      "source_code": "def test_multipart_request_multiple_files_with_headers(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    path1 = os.path.join(tmpdir, \"test1.txt\")\n    with open(path1, \"wb\") as file:\n        file.write(b\"<file1 content>\")\n\n    path2 = os.path.join(tmpdir, \"test2.txt\")\n    with open(path2, \"wb\") as file:\n        file.write(b\"<file2 content>\")\n\n    client = test_client_factory(app_with_headers)\n    with open(path1, \"rb\") as f1, open(path2, \"rb\") as f2:\n        response = client.post(\n            \"/\",\n            files=[\n                (\"test1\", (None, f1)),\n                (\"test2\", (\"test2.txt\", f2, \"text/plain\", {\"x-custom\": \"f2\"})),\n            ],\n        )\n        assert response.json() == {\n            \"test1\": \"<file1 content>\",\n            \"test2\": {\n                \"filename\": \"test2.txt\",\n                \"size\": 15,\n                \"content\": \"<file2 content>\",\n                \"content_type\": \"text/plain\",\n                \"headers\": [\n                    [\n                        \"content-disposition\",\n                        'form-data; name=\"test2\"; filename=\"test2.txt\"',\n                    ],\n                    [\"x-custom\", \"f2\"],\n                    [\"content-type\", \"text/plain\"],\n                ],\n            },\n        }",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "typing",
        "contextlib.nullcontext",
        "pathlib.Path",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.datastructures.UploadFile",
        "starlette.formparsers.MultiPartException",
        "starlette.formparsers._user_safe_decode",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.routing.Mount",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'test1': '<file1 content>', 'test2': {'filename': 'test2.txt', 'size': 15, 'content': '<file2 content>', 'content_type': 'text/plain', 'headers': [['content-disposition', 'form-data; name=\"test2\"; filename=\"test2.txt\"'], ['x-custom', 'f2'], ['content-type', 'text/plain']]}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_multi_items",
      "module": "test_formparsers",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_formparsers.py",
      "line_number": 237,
      "end_line_number": 269,
      "source_code": "def test_multi_items(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    path1 = os.path.join(tmpdir, \"test1.txt\")\n    with open(path1, \"wb\") as file:\n        file.write(b\"<file1 content>\")\n\n    path2 = os.path.join(tmpdir, \"test2.txt\")\n    with open(path2, \"wb\") as file:\n        file.write(b\"<file2 content>\")\n\n    client = test_client_factory(multi_items_app)\n    with open(path1, \"rb\") as f1, open(path2, \"rb\") as f2:\n        response = client.post(\n            \"/\",\n            data={\"test1\": \"abc\"},\n            files=[(\"test1\", f1), (\"test1\", (\"test2.txt\", f2, \"text/plain\"))],\n        )\n        assert response.json() == {\n            \"test1\": [\n                \"abc\",\n                {\n                    \"filename\": \"test1.txt\",\n                    \"size\": 15,\n                    \"content\": \"<file1 content>\",\n                    \"content_type\": \"text/plain\",\n                },\n                {\n                    \"filename\": \"test2.txt\",\n                    \"size\": 15,\n                    \"content\": \"<file2 content>\",\n                    \"content_type\": \"text/plain\",\n                },\n            ]\n        }",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "typing",
        "contextlib.nullcontext",
        "pathlib.Path",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.datastructures.UploadFile",
        "starlette.formparsers.MultiPartException",
        "starlette.formparsers._user_safe_decode",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.routing.Mount",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'test1': ['abc', {'filename': 'test1.txt', 'size': 15, 'content': '<file1 content>', 'content_type': 'text/plain'}, {'filename': 'test2.txt', 'size': 15, 'content': '<file2 content>', 'content_type': 'text/plain'}]}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_multipart_request_mixed_files_and_data",
      "module": "test_formparsers",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_formparsers.py",
      "line_number": 272,
      "end_line_number": 303,
      "source_code": "def test_multipart_request_mixed_files_and_data(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    client = test_client_factory(app)\n    response = client.post(\n        \"/\",\n        data=(\n            # data\n            b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c\\r\\n\"  # type: ignore\n            b'Content-Disposition: form-data; name=\"field0\"\\r\\n\\r\\n'\n            b\"value0\\r\\n\"\n            # file\n            b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c\\r\\n\"\n            b'Content-Disposition: form-data; name=\"file\"; filename=\"file.txt\"\\r\\n'\n            b\"Content-Type: text/plain\\r\\n\\r\\n\"\n            b\"<file content>\\r\\n\"\n            # data\n            b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c\\r\\n\"\n            b'Content-Disposition: form-data; name=\"field1\"\\r\\n\\r\\n'\n            b\"value1\\r\\n\"\n            b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c--\\r\\n\"\n        ),\n        headers={\"Content-Type\": (\"multipart/form-data; boundary=a7f7ac8d4e2e437c877bb7b8d7cc549c\")},\n    )\n    assert response.json() == {\n        \"file\": {\n            \"filename\": \"file.txt\",\n            \"size\": 14,\n            \"content\": \"<file content>\",\n            \"content_type\": \"text/plain\",\n        },\n        \"field0\": \"value0\",\n        \"field1\": \"value1\",\n    }",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "typing",
        "contextlib.nullcontext",
        "pathlib.Path",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.datastructures.UploadFile",
        "starlette.formparsers.MultiPartException",
        "starlette.formparsers._user_safe_decode",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.routing.Mount",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'file': {'filename': 'file.txt', 'size': 14, 'content': '<file content>', 'content_type': 'text/plain'}, 'field0': 'value0', 'field1': 'value1'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_multipart_request_with_charset_for_filename",
      "module": "test_formparsers",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_formparsers.py",
      "line_number": 306,
      "end_line_number": 327,
      "source_code": "def test_multipart_request_with_charset_for_filename(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    client = test_client_factory(app)\n    response = client.post(\n        \"/\",\n        data=(\n            # file\n            b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c\\r\\n\"  # type: ignore\n            b'Content-Disposition: form-data; name=\"file\"; filename=\"\\xe6\\x96\\x87\\xe6\\x9b\\xb8.txt\"\\r\\n'\n            b\"Content-Type: text/plain\\r\\n\\r\\n\"\n            b\"<file content>\\r\\n\"\n            b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c--\\r\\n\"\n        ),\n        headers={\"Content-Type\": (\"multipart/form-data; charset=utf-8; boundary=a7f7ac8d4e2e437c877bb7b8d7cc549c\")},\n    )\n    assert response.json() == {\n        \"file\": {\n            \"filename\": \"\u6587\u66f8.txt\",\n            \"size\": 14,\n            \"content\": \"<file content>\",\n            \"content_type\": \"text/plain\",\n        }\n    }",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "typing",
        "contextlib.nullcontext",
        "pathlib.Path",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.datastructures.UploadFile",
        "starlette.formparsers.MultiPartException",
        "starlette.formparsers._user_safe_decode",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.routing.Mount",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'file': {'filename': '\u6587\u66f8.txt', 'size': 14, 'content': '<file content>', 'content_type': 'text/plain'}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_multipart_request_without_charset_for_filename",
      "module": "test_formparsers",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_formparsers.py",
      "line_number": 330,
      "end_line_number": 351,
      "source_code": "def test_multipart_request_without_charset_for_filename(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    client = test_client_factory(app)\n    response = client.post(\n        \"/\",\n        data=(\n            # file\n            b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c\\r\\n\"  # type: ignore\n            b'Content-Disposition: form-data; name=\"file\"; filename=\"\\xe7\\x94\\xbb\\xe5\\x83\\x8f.jpg\"\\r\\n'\n            b\"Content-Type: image/jpeg\\r\\n\\r\\n\"\n            b\"<file content>\\r\\n\"\n            b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c--\\r\\n\"\n        ),\n        headers={\"Content-Type\": (\"multipart/form-data; boundary=a7f7ac8d4e2e437c877bb7b8d7cc549c\")},\n    )\n    assert response.json() == {\n        \"file\": {\n            \"filename\": \"\u753b\u50cf.jpg\",\n            \"size\": 14,\n            \"content\": \"<file content>\",\n            \"content_type\": \"image/jpeg\",\n        }\n    }",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "typing",
        "contextlib.nullcontext",
        "pathlib.Path",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.datastructures.UploadFile",
        "starlette.formparsers.MultiPartException",
        "starlette.formparsers._user_safe_decode",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.routing.Mount",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'file': {'filename': '\u753b\u50cf.jpg', 'size': 14, 'content': '<file content>', 'content_type': 'image/jpeg'}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_multipart_request_with_encoded_value",
      "module": "test_formparsers",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_formparsers.py",
      "line_number": 354,
      "end_line_number": 367,
      "source_code": "def test_multipart_request_with_encoded_value(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    client = test_client_factory(app)\n    response = client.post(\n        \"/\",\n        data=(\n            b\"--20b303e711c4ab8c443184ac833ab00f\\r\\n\"  # type: ignore\n            b\"Content-Disposition: form-data; \"\n            b'name=\"value\"\\r\\n\\r\\n'\n            b\"Transf\\xc3\\xa9rer\\r\\n\"\n            b\"--20b303e711c4ab8c443184ac833ab00f--\\r\\n\"\n        ),\n        headers={\"Content-Type\": (\"multipart/form-data; charset=utf-8; boundary=20b303e711c4ab8c443184ac833ab00f\")},\n    )\n    assert response.json() == {\"value\": \"Transf\u00e9rer\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "typing",
        "contextlib.nullcontext",
        "pathlib.Path",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.datastructures.UploadFile",
        "starlette.formparsers.MultiPartException",
        "starlette.formparsers._user_safe_decode",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.routing.Mount",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'value': 'Transf\u00e9rer'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_urlencoded_request_data",
      "module": "test_formparsers",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_formparsers.py",
      "line_number": 370,
      "end_line_number": 373,
      "source_code": "def test_urlencoded_request_data(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    client = test_client_factory(app)\n    response = client.post(\"/\", data={\"some\": \"data\"})\n    assert response.json() == {\"some\": \"data\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "typing",
        "contextlib.nullcontext",
        "pathlib.Path",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.datastructures.UploadFile",
        "starlette.formparsers.MultiPartException",
        "starlette.formparsers._user_safe_decode",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.routing.Mount",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'some': 'data'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_no_request_data",
      "module": "test_formparsers",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_formparsers.py",
      "line_number": 376,
      "end_line_number": 379,
      "source_code": "def test_no_request_data(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    client = test_client_factory(app)\n    response = client.post(\"/\")\n    assert response.json() == {}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "typing",
        "contextlib.nullcontext",
        "pathlib.Path",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.datastructures.UploadFile",
        "starlette.formparsers.MultiPartException",
        "starlette.formparsers._user_safe_decode",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.routing.Mount",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_urlencoded_percent_encoding",
      "module": "test_formparsers",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_formparsers.py",
      "line_number": 382,
      "end_line_number": 385,
      "source_code": "def test_urlencoded_percent_encoding(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    client = test_client_factory(app)\n    response = client.post(\"/\", data={\"some\": \"da ta\"})\n    assert response.json() == {\"some\": \"da ta\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "typing",
        "contextlib.nullcontext",
        "pathlib.Path",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.datastructures.UploadFile",
        "starlette.formparsers.MultiPartException",
        "starlette.formparsers._user_safe_decode",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.routing.Mount",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'some': 'da ta'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_urlencoded_percent_encoding_keys",
      "module": "test_formparsers",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_formparsers.py",
      "line_number": 388,
      "end_line_number": 391,
      "source_code": "def test_urlencoded_percent_encoding_keys(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    client = test_client_factory(app)\n    response = client.post(\"/\", data={\"so me\": \"data\"})\n    assert response.json() == {\"so me\": \"data\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "typing",
        "contextlib.nullcontext",
        "pathlib.Path",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.datastructures.UploadFile",
        "starlette.formparsers.MultiPartException",
        "starlette.formparsers._user_safe_decode",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.routing.Mount",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'so me': 'data'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_urlencoded_multi_field_app_reads_body",
      "module": "test_formparsers",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_formparsers.py",
      "line_number": 394,
      "end_line_number": 397,
      "source_code": "def test_urlencoded_multi_field_app_reads_body(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    client = test_client_factory(app_read_body)\n    response = client.post(\"/\", data={\"some\": \"data\", \"second\": \"key pair\"})\n    assert response.json() == {\"some\": \"data\", \"second\": \"key pair\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "typing",
        "contextlib.nullcontext",
        "pathlib.Path",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.datastructures.UploadFile",
        "starlette.formparsers.MultiPartException",
        "starlette.formparsers._user_safe_decode",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.routing.Mount",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'some': 'data', 'second': 'key pair'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_multipart_multi_field_app_reads_body",
      "module": "test_formparsers",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_formparsers.py",
      "line_number": 400,
      "end_line_number": 403,
      "source_code": "def test_multipart_multi_field_app_reads_body(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    client = test_client_factory(app_read_body)\n    response = client.post(\"/\", data={\"some\": \"data\", \"second\": \"key pair\"}, files=FORCE_MULTIPART)\n    assert response.json() == {\"some\": \"data\", \"second\": \"key pair\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "typing",
        "contextlib.nullcontext",
        "pathlib.Path",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.datastructures.UploadFile",
        "starlette.formparsers.MultiPartException",
        "starlette.formparsers._user_safe_decode",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.routing.Mount",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'some': 'data', 'second': 'key pair'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_user_safe_decode_helper",
      "module": "test_formparsers",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_formparsers.py",
      "line_number": 406,
      "end_line_number": 408,
      "source_code": "def test_user_safe_decode_helper() -> None:\n    result = _user_safe_decode(b\"\\xc4\\x99\\xc5\\xbc\\xc4\\x87\", \"utf-8\")\n    assert result == \"\u0119\u017c\u0107\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "os",
        "typing",
        "contextlib.nullcontext",
        "pathlib.Path",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.datastructures.UploadFile",
        "starlette.formparsers.MultiPartException",
        "starlette.formparsers._user_safe_decode",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.routing.Mount",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert result == '\u0119\u017c\u0107'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_user_safe_decode_ignores_wrong_charset",
      "module": "test_formparsers",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_formparsers.py",
      "line_number": 411,
      "end_line_number": 413,
      "source_code": "def test_user_safe_decode_ignores_wrong_charset() -> None:\n    result = _user_safe_decode(b\"abc\", \"latin-8\")\n    assert result == \"abc\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "os",
        "typing",
        "contextlib.nullcontext",
        "pathlib.Path",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.datastructures.UploadFile",
        "starlette.formparsers.MultiPartException",
        "starlette.formparsers._user_safe_decode",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.routing.Mount",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert result == 'abc'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_missing_boundary_parameter",
      "module": "test_formparsers",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_formparsers.py",
      "line_number": 423,
      "end_line_number": 441,
      "source_code": "def test_missing_boundary_parameter(\n    app: ASGIApp,\n    expectation: typing.ContextManager[Exception],\n    test_client_factory: TestClientFactory,\n) -> None:\n    client = test_client_factory(app)\n    with expectation:\n        res = client.post(\n            \"/\",\n            data=(\n                # file\n                b'Content-Disposition: form-data; name=\"file\"; filename=\"\\xe6\\x96\\x87\\xe6\\x9b\\xb8.txt\"\\r\\n'  # type: ignore\n                b\"Content-Type: text/plain\\r\\n\\r\\n\"\n                b\"<file content>\\r\\n\"\n            ),\n            headers={\"Content-Type\": \"multipart/form-data; charset=utf-8\"},\n        )\n        assert res.status_code == 400\n        assert res.text == \"Missing boundary in multipart.\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('app,expectation', [(app, pytest.raises(MultiPartException)), (Starlette(routes=[Mount('/', app=app)]), does_not_raise())])"
      ],
      "arguments": [
        "app",
        "expectation",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "typing",
        "contextlib.nullcontext",
        "pathlib.Path",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.datastructures.UploadFile",
        "starlette.formparsers.MultiPartException",
        "starlette.formparsers._user_safe_decode",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.routing.Mount",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert res.status_code == 400",
        "assert res.text == 'Missing boundary in multipart.'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_missing_name_parameter_on_content_disposition",
      "module": "test_formparsers",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_formparsers.py",
      "line_number": 451,
      "end_line_number": 469,
      "source_code": "def test_missing_name_parameter_on_content_disposition(\n    app: ASGIApp,\n    expectation: typing.ContextManager[Exception],\n    test_client_factory: TestClientFactory,\n) -> None:\n    client = test_client_factory(app)\n    with expectation:\n        res = client.post(\n            \"/\",\n            data=(\n                # data\n                b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c\\r\\n\"  # type: ignore\n                b'Content-Disposition: form-data; =\"field0\"\\r\\n\\r\\n'\n                b\"value0\\r\\n\"\n            ),\n            headers={\"Content-Type\": (\"multipart/form-data; boundary=a7f7ac8d4e2e437c877bb7b8d7cc549c\")},\n        )\n        assert res.status_code == 400\n        assert res.text == 'The Content-Disposition header field \"name\" must be provided.'",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('app,expectation', [(app, pytest.raises(MultiPartException)), (Starlette(routes=[Mount('/', app=app)]), does_not_raise())])"
      ],
      "arguments": [
        "app",
        "expectation",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "typing",
        "contextlib.nullcontext",
        "pathlib.Path",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.datastructures.UploadFile",
        "starlette.formparsers.MultiPartException",
        "starlette.formparsers._user_safe_decode",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.routing.Mount",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert res.status_code == 400",
        "assert res.text == 'The Content-Disposition header field \"name\" must be provided.'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_too_many_fields_raise",
      "module": "test_formparsers",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_formparsers.py",
      "line_number": 479,
      "end_line_number": 496,
      "source_code": "def test_too_many_fields_raise(\n    app: ASGIApp,\n    expectation: typing.ContextManager[Exception],\n    test_client_factory: TestClientFactory,\n) -> None:\n    client = test_client_factory(app)\n    fields = []\n    for i in range(1001):\n        fields.append(\"--B\\r\\n\" f'Content-Disposition: form-data; name=\"N{i}\";\\r\\n\\r\\n' \"\\r\\n\")\n    data = \"\".join(fields).encode(\"utf-8\")\n    with expectation:\n        res = client.post(\n            \"/\",\n            data=data,  # type: ignore\n            headers={\"Content-Type\": (\"multipart/form-data; boundary=B\")},\n        )\n        assert res.status_code == 400\n        assert res.text == \"Too many fields. Maximum number of fields is 1000.\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('app,expectation', [(app, pytest.raises(MultiPartException)), (Starlette(routes=[Mount('/', app=app)]), does_not_raise())])"
      ],
      "arguments": [
        "app",
        "expectation",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "typing",
        "contextlib.nullcontext",
        "pathlib.Path",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.datastructures.UploadFile",
        "starlette.formparsers.MultiPartException",
        "starlette.formparsers._user_safe_decode",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.routing.Mount",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert res.status_code == 400",
        "assert res.text == 'Too many fields. Maximum number of fields is 1000.'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_too_many_files_raise",
      "module": "test_formparsers",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_formparsers.py",
      "line_number": 506,
      "end_line_number": 523,
      "source_code": "def test_too_many_files_raise(\n    app: ASGIApp,\n    expectation: typing.ContextManager[Exception],\n    test_client_factory: TestClientFactory,\n) -> None:\n    client = test_client_factory(app)\n    fields = []\n    for i in range(1001):\n        fields.append(\"--B\\r\\n\" f'Content-Disposition: form-data; name=\"N{i}\"; filename=\"F{i}\";\\r\\n\\r\\n' \"\\r\\n\")\n    data = \"\".join(fields).encode(\"utf-8\")\n    with expectation:\n        res = client.post(\n            \"/\",\n            data=data,  # type: ignore\n            headers={\"Content-Type\": (\"multipart/form-data; boundary=B\")},\n        )\n        assert res.status_code == 400\n        assert res.text == \"Too many files. Maximum number of files is 1000.\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('app,expectation', [(app, pytest.raises(MultiPartException)), (Starlette(routes=[Mount('/', app=app)]), does_not_raise())])"
      ],
      "arguments": [
        "app",
        "expectation",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "typing",
        "contextlib.nullcontext",
        "pathlib.Path",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.datastructures.UploadFile",
        "starlette.formparsers.MultiPartException",
        "starlette.formparsers._user_safe_decode",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.routing.Mount",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert res.status_code == 400",
        "assert res.text == 'Too many files. Maximum number of files is 1000.'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_too_many_files_single_field_raise",
      "module": "test_formparsers",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_formparsers.py",
      "line_number": 533,
      "end_line_number": 552,
      "source_code": "def test_too_many_files_single_field_raise(\n    app: ASGIApp,\n    expectation: typing.ContextManager[Exception],\n    test_client_factory: TestClientFactory,\n) -> None:\n    client = test_client_factory(app)\n    fields = []\n    for i in range(1001):\n        # This uses the same field name \"N\" for all files, equivalent to a\n        # multifile upload form field\n        fields.append(\"--B\\r\\n\" f'Content-Disposition: form-data; name=\"N\"; filename=\"F{i}\";\\r\\n\\r\\n' \"\\r\\n\")\n    data = \"\".join(fields).encode(\"utf-8\")\n    with expectation:\n        res = client.post(\n            \"/\",\n            data=data,  # type: ignore\n            headers={\"Content-Type\": (\"multipart/form-data; boundary=B\")},\n        )\n        assert res.status_code == 400\n        assert res.text == \"Too many files. Maximum number of files is 1000.\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('app,expectation', [(app, pytest.raises(MultiPartException)), (Starlette(routes=[Mount('/', app=app)]), does_not_raise())])"
      ],
      "arguments": [
        "app",
        "expectation",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "typing",
        "contextlib.nullcontext",
        "pathlib.Path",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.datastructures.UploadFile",
        "starlette.formparsers.MultiPartException",
        "starlette.formparsers._user_safe_decode",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.routing.Mount",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert res.status_code == 400",
        "assert res.text == 'Too many files. Maximum number of files is 1000.'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_too_many_files_and_fields_raise",
      "module": "test_formparsers",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_formparsers.py",
      "line_number": 562,
      "end_line_number": 580,
      "source_code": "def test_too_many_files_and_fields_raise(\n    app: ASGIApp,\n    expectation: typing.ContextManager[Exception],\n    test_client_factory: TestClientFactory,\n) -> None:\n    client = test_client_factory(app)\n    fields = []\n    for i in range(1001):\n        fields.append(\"--B\\r\\n\" f'Content-Disposition: form-data; name=\"F{i}\"; filename=\"F{i}\";\\r\\n\\r\\n' \"\\r\\n\")\n        fields.append(\"--B\\r\\n\" f'Content-Disposition: form-data; name=\"N{i}\";\\r\\n\\r\\n' \"\\r\\n\")\n    data = \"\".join(fields).encode(\"utf-8\")\n    with expectation:\n        res = client.post(\n            \"/\",\n            data=data,  # type: ignore\n            headers={\"Content-Type\": (\"multipart/form-data; boundary=B\")},\n        )\n        assert res.status_code == 400\n        assert res.text == \"Too many files. Maximum number of files is 1000.\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('app,expectation', [(app, pytest.raises(MultiPartException)), (Starlette(routes=[Mount('/', app=app)]), does_not_raise())])"
      ],
      "arguments": [
        "app",
        "expectation",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "typing",
        "contextlib.nullcontext",
        "pathlib.Path",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.datastructures.UploadFile",
        "starlette.formparsers.MultiPartException",
        "starlette.formparsers._user_safe_decode",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.routing.Mount",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert res.status_code == 400",
        "assert res.text == 'Too many files. Maximum number of files is 1000.'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_max_fields_is_customizable_low_raises",
      "module": "test_formparsers",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_formparsers.py",
      "line_number": 593,
      "end_line_number": 610,
      "source_code": "def test_max_fields_is_customizable_low_raises(\n    app: ASGIApp,\n    expectation: typing.ContextManager[Exception],\n    test_client_factory: TestClientFactory,\n) -> None:\n    client = test_client_factory(app)\n    fields = []\n    for i in range(2):\n        fields.append(\"--B\\r\\n\" f'Content-Disposition: form-data; name=\"N{i}\";\\r\\n\\r\\n' \"\\r\\n\")\n    data = \"\".join(fields).encode(\"utf-8\")\n    with expectation:\n        res = client.post(\n            \"/\",\n            data=data,  # type: ignore\n            headers={\"Content-Type\": (\"multipart/form-data; boundary=B\")},\n        )\n        assert res.status_code == 400\n        assert res.text == \"Too many fields. Maximum number of fields is 1.\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('app,expectation', [(make_app_max_parts(max_fields=1), pytest.raises(MultiPartException)), (Starlette(routes=[Mount('/', app=make_app_max_parts(max_fields=1))]), does_not_raise())])"
      ],
      "arguments": [
        "app",
        "expectation",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "typing",
        "contextlib.nullcontext",
        "pathlib.Path",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.datastructures.UploadFile",
        "starlette.formparsers.MultiPartException",
        "starlette.formparsers._user_safe_decode",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.routing.Mount",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert res.status_code == 400",
        "assert res.text == 'Too many fields. Maximum number of fields is 1.'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        },
        {
          "name": "make_app_max_parts",
          "body": "def make_app_max_parts(max_files: int=1000, max_fields: int=1000) -> ASGIApp:\n\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        request = Request(scope, receive)\n        data = await request.form(max_files=max_files, max_fields=max_fields)\n        output: dict[str, typing.Any] = {}\n        for (key, value) in data.items():\n            if isinstance(value, UploadFile):\n                content = await value.read()\n                output[key] = {'filename': value.filename, 'size': value.size, 'content': content.decode(), 'content_type': value.content_type}\n            else:\n                output[key] = value\n        await request.close()\n        response = JSONResponse(output)\n        await response(scope, receive, send)\n    return app"
        },
        {
          "name": "make_app_max_parts",
          "body": "def make_app_max_parts(max_files: int=1000, max_fields: int=1000) -> ASGIApp:\n\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        request = Request(scope, receive)\n        data = await request.form(max_files=max_files, max_fields=max_fields)\n        output: dict[str, typing.Any] = {}\n        for (key, value) in data.items():\n            if isinstance(value, UploadFile):\n                content = await value.read()\n                output[key] = {'filename': value.filename, 'size': value.size, 'content': content.decode(), 'content_type': value.content_type}\n            else:\n                output[key] = value\n        await request.close()\n        response = JSONResponse(output)\n        await response(scope, receive, send)\n    return app"
        }
      ]
    },
    {
      "name": "test_max_files_is_customizable_low_raises",
      "module": "test_formparsers",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_formparsers.py",
      "line_number": 623,
      "end_line_number": 640,
      "source_code": "def test_max_files_is_customizable_low_raises(\n    app: ASGIApp,\n    expectation: typing.ContextManager[Exception],\n    test_client_factory: TestClientFactory,\n) -> None:\n    client = test_client_factory(app)\n    fields = []\n    for i in range(2):\n        fields.append(\"--B\\r\\n\" f'Content-Disposition: form-data; name=\"F{i}\"; filename=\"F{i}\";\\r\\n\\r\\n' \"\\r\\n\")\n    data = \"\".join(fields).encode(\"utf-8\")\n    with expectation:\n        res = client.post(\n            \"/\",\n            data=data,  # type: ignore\n            headers={\"Content-Type\": (\"multipart/form-data; boundary=B\")},\n        )\n        assert res.status_code == 400\n        assert res.text == \"Too many files. Maximum number of files is 1.\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('app,expectation', [(make_app_max_parts(max_files=1), pytest.raises(MultiPartException)), (Starlette(routes=[Mount('/', app=make_app_max_parts(max_files=1))]), does_not_raise())])"
      ],
      "arguments": [
        "app",
        "expectation",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "typing",
        "contextlib.nullcontext",
        "pathlib.Path",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.datastructures.UploadFile",
        "starlette.formparsers.MultiPartException",
        "starlette.formparsers._user_safe_decode",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.routing.Mount",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert res.status_code == 400",
        "assert res.text == 'Too many files. Maximum number of files is 1.'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        },
        {
          "name": "make_app_max_parts",
          "body": "def make_app_max_parts(max_files: int=1000, max_fields: int=1000) -> ASGIApp:\n\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        request = Request(scope, receive)\n        data = await request.form(max_files=max_files, max_fields=max_fields)\n        output: dict[str, typing.Any] = {}\n        for (key, value) in data.items():\n            if isinstance(value, UploadFile):\n                content = await value.read()\n                output[key] = {'filename': value.filename, 'size': value.size, 'content': content.decode(), 'content_type': value.content_type}\n            else:\n                output[key] = value\n        await request.close()\n        response = JSONResponse(output)\n        await response(scope, receive, send)\n    return app"
        },
        {
          "name": "make_app_max_parts",
          "body": "def make_app_max_parts(max_files: int=1000, max_fields: int=1000) -> ASGIApp:\n\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        request = Request(scope, receive)\n        data = await request.form(max_files=max_files, max_fields=max_fields)\n        output: dict[str, typing.Any] = {}\n        for (key, value) in data.items():\n            if isinstance(value, UploadFile):\n                content = await value.read()\n                output[key] = {'filename': value.filename, 'size': value.size, 'content': content.decode(), 'content_type': value.content_type}\n            else:\n                output[key] = value\n        await request.close()\n        response = JSONResponse(output)\n        await response(scope, receive, send)\n    return app"
        }
      ]
    },
    {
      "name": "test_max_fields_is_customizable_high",
      "module": "test_formparsers",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_formparsers.py",
      "line_number": 643,
      "end_line_number": 664,
      "source_code": "def test_max_fields_is_customizable_high(test_client_factory: TestClientFactory) -> None:\n    client = test_client_factory(make_app_max_parts(max_fields=2000, max_files=2000))\n    fields = []\n    for i in range(2000):\n        fields.append(\"--B\\r\\n\" f'Content-Disposition: form-data; name=\"N{i}\";\\r\\n\\r\\n' \"\\r\\n\")\n        fields.append(\"--B\\r\\n\" f'Content-Disposition: form-data; name=\"F{i}\"; filename=\"F{i}\";\\r\\n\\r\\n' \"\\r\\n\")\n    data = \"\".join(fields).encode(\"utf-8\")\n    data += b\"--B--\\r\\n\"\n    res = client.post(\n        \"/\",\n        data=data,  # type: ignore\n        headers={\"Content-Type\": (\"multipart/form-data; boundary=B\")},\n    )\n    assert res.status_code == 200\n    res_data = res.json()\n    assert res_data[\"N1999\"] == \"\"\n    assert res_data[\"F1999\"] == {\n        \"filename\": \"F1999\",\n        \"size\": 0,\n        \"content\": \"\",\n        \"content_type\": None,\n    }",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "typing",
        "contextlib.nullcontext",
        "pathlib.Path",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.datastructures.UploadFile",
        "starlette.formparsers.MultiPartException",
        "starlette.formparsers._user_safe_decode",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.routing.Mount",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert res.status_code == 200",
        "assert res_data['N1999'] == ''",
        "assert res_data['F1999'] == {'filename': 'F1999', 'size': 0, 'content': '', 'content_type': None}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        },
        {
          "name": "make_app_max_parts",
          "body": "def make_app_max_parts(max_files: int=1000, max_fields: int=1000) -> ASGIApp:\n\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        request = Request(scope, receive)\n        data = await request.form(max_files=max_files, max_fields=max_fields)\n        output: dict[str, typing.Any] = {}\n        for (key, value) in data.items():\n            if isinstance(value, UploadFile):\n                content = await value.read()\n                output[key] = {'filename': value.filename, 'size': value.size, 'content': content.decode(), 'content_type': value.content_type}\n            else:\n                output[key] = value\n        await request.close()\n        response = JSONResponse(output)\n        await response(scope, receive, send)\n    return app"
        }
      ]
    },
    {
      "name": "test_max_part_size_exceeds_limit",
      "module": "test_formparsers",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_formparsers.py",
      "line_number": 674,
      "end_line_number": 701,
      "source_code": "def test_max_part_size_exceeds_limit(\n    app: ASGIApp,\n    expectation: typing.ContextManager[Exception],\n    test_client_factory: TestClientFactory,\n) -> None:\n    client = test_client_factory(app)\n    boundary = \"------------------------4K1ON9fZkj9uCUmqLHRbbR\"\n\n    multipart_data = (\n        f\"--{boundary}\\r\\n\"\n        f'Content-Disposition: form-data; name=\"small\"\\r\\n\\r\\n'\n        \"small content\\r\\n\"\n        f\"--{boundary}\\r\\n\"\n        f'Content-Disposition: form-data; name=\"large\"\\r\\n\\r\\n'\n        + (\"x\" * 1024 * 1024 + \"x\")  # 1MB + 1 byte of data\n        + \"\\r\\n\"\n        f\"--{boundary}--\\r\\n\"\n    ).encode(\"utf-8\")\n\n    headers = {\n        \"Content-Type\": f\"multipart/form-data; boundary={boundary}\",\n        \"Transfer-Encoding\": \"chunked\",\n    }\n\n    with expectation:\n        response = client.post(\"/\", data=multipart_data, headers=headers)  # type: ignore\n        assert response.status_code == 400\n        assert response.text == \"Part exceeded maximum size of 1024KB.\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('app,expectation', [(app, pytest.raises(MultiPartException)), (Starlette(routes=[Mount('/', app=app)]), does_not_raise())])"
      ],
      "arguments": [
        "app",
        "expectation",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "typing",
        "contextlib.nullcontext",
        "pathlib.Path",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.datastructures.UploadFile",
        "starlette.formparsers.MultiPartException",
        "starlette.formparsers._user_safe_decode",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.routing.Mount",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 400",
        "assert response.text == 'Part exceeded maximum size of 1024KB.'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_deprecated_types",
      "module": "test_status",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_status.py",
      "line_number": 19,
      "end_line_number": 23,
      "source_code": "def test_deprecated_types(constant: str, msg: str) -> None:\n    with pytest.warns(DeprecationWarning) as record:\n        getattr(importlib.import_module(\"starlette.status\"), constant)\n        assert len(record) == 1\n        assert msg in str(record.list[0])",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('constant,msg', (('WS_1004_NO_STATUS_RCVD', \"'WS_1004_NO_STATUS_RCVD' is deprecated. Use 'WS_1005_NO_STATUS_RCVD' instead.\"), ('WS_1005_ABNORMAL_CLOSURE', \"'WS_1005_ABNORMAL_CLOSURE' is deprecated. Use 'WS_1006_ABNORMAL_CLOSURE' instead.\")))"
      ],
      "arguments": [
        "constant",
        "msg"
      ],
      "imports": [
        "importlib",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(record) == 1",
        "assert msg in str(record.list[0])"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_websocket_url",
      "module": "test_websockets",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_websockets.py",
      "line_number": 16,
      "end_line_number": 26,
      "source_code": "def test_websocket_url(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        websocket = WebSocket(scope, receive=receive, send=send)\n        await websocket.accept()\n        await websocket.send_json({\"url\": str(websocket.url)})\n        await websocket.close()\n\n    client = test_client_factory(app)\n    with client.websocket_connect(\"/123?a=abc\") as websocket:\n        data = websocket.receive_json()\n        assert data == {\"url\": \"ws://testserver/123?a=abc\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.MutableMapping",
        "anyio",
        "pytest",
        "anyio.abc.ObjectReceiveStream",
        "anyio.abc.ObjectSendStream",
        "starlette.status",
        "starlette.responses.Response",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "starlette.websockets.WebSocketState",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert data == {'url': 'ws://testserver/123?a=abc'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_websocket_binary_json",
      "module": "test_websockets",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_websockets.py",
      "line_number": 29,
      "end_line_number": 41,
      "source_code": "def test_websocket_binary_json(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        websocket = WebSocket(scope, receive=receive, send=send)\n        await websocket.accept()\n        message = await websocket.receive_json(mode=\"binary\")\n        await websocket.send_json(message, mode=\"binary\")\n        await websocket.close()\n\n    client = test_client_factory(app)\n    with client.websocket_connect(\"/123?a=abc\") as websocket:\n        websocket.send_json({\"test\": \"data\"}, mode=\"binary\")\n        data = websocket.receive_json(mode=\"binary\")\n        assert data == {\"test\": \"data\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.MutableMapping",
        "anyio",
        "pytest",
        "anyio.abc.ObjectReceiveStream",
        "anyio.abc.ObjectSendStream",
        "starlette.status",
        "starlette.responses.Response",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "starlette.websockets.WebSocketState",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert data == {'test': 'data'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_websocket_ensure_unicode_on_send_json",
      "module": "test_websockets",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_websockets.py",
      "line_number": 44,
      "end_line_number": 59,
      "source_code": "def test_websocket_ensure_unicode_on_send_json(\n    test_client_factory: TestClientFactory,\n) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        websocket = WebSocket(scope, receive=receive, send=send)\n\n        await websocket.accept()\n        message = await websocket.receive_json(mode=\"text\")\n        await websocket.send_json(message, mode=\"text\")\n        await websocket.close()\n\n    client = test_client_factory(app)\n    with client.websocket_connect(\"/123?a=abc\") as websocket:\n        websocket.send_json({\"test\": \"\u6570\u636e\"}, mode=\"text\")\n        data = websocket.receive_text()\n        assert data == '{\"test\":\"\u6570\u636e\"}'",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.MutableMapping",
        "anyio",
        "pytest",
        "anyio.abc.ObjectReceiveStream",
        "anyio.abc.ObjectSendStream",
        "starlette.status",
        "starlette.responses.Response",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "starlette.websockets.WebSocketState",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert data == '{\"test\":\"\u6570\u636e\"}'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_websocket_query_params",
      "module": "test_websockets",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_websockets.py",
      "line_number": 62,
      "end_line_number": 73,
      "source_code": "def test_websocket_query_params(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        websocket = WebSocket(scope, receive=receive, send=send)\n        query_params = dict(websocket.query_params)\n        await websocket.accept()\n        await websocket.send_json({\"params\": query_params})\n        await websocket.close()\n\n    client = test_client_factory(app)\n    with client.websocket_connect(\"/?a=abc&b=456\") as websocket:\n        data = websocket.receive_json()\n        assert data == {\"params\": {\"a\": \"abc\", \"b\": \"456\"}}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.MutableMapping",
        "anyio",
        "pytest",
        "anyio.abc.ObjectReceiveStream",
        "anyio.abc.ObjectSendStream",
        "starlette.status",
        "starlette.responses.Response",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "starlette.websockets.WebSocketState",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert data == {'params': {'a': 'abc', 'b': '456'}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_websocket_headers",
      "module": "test_websockets",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_websockets.py",
      "line_number": 80,
      "end_line_number": 100,
      "source_code": "def test_websocket_headers(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        websocket = WebSocket(scope, receive=receive, send=send)\n        headers = dict(websocket.headers)\n        await websocket.accept()\n        await websocket.send_json({\"headers\": headers})\n        await websocket.close()\n\n    client = test_client_factory(app)\n    with client.websocket_connect(\"/\") as websocket:\n        expected_headers = {\n            \"accept\": \"*/*\",\n            \"accept-encoding\": \"gzip, deflate\",\n            \"connection\": \"upgrade\",\n            \"host\": \"testserver\",\n            \"user-agent\": \"testclient\",\n            \"sec-websocket-key\": \"testserver==\",\n            \"sec-websocket-version\": \"13\",\n        }\n        data = websocket.receive_json()\n        assert data == {\"headers\": expected_headers}",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(any((module in sys.modules for module in ('brotli', 'brotlicffi'))), reason='urllib3 includes \"br\" to the \"accept-encoding\" headers.')"
      ],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.MutableMapping",
        "anyio",
        "pytest",
        "anyio.abc.ObjectReceiveStream",
        "anyio.abc.ObjectSendStream",
        "starlette.status",
        "starlette.responses.Response",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "starlette.websockets.WebSocketState",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert data == {'headers': expected_headers}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_websocket_port",
      "module": "test_websockets",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_websockets.py",
      "line_number": 103,
      "end_line_number": 113,
      "source_code": "def test_websocket_port(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        websocket = WebSocket(scope, receive=receive, send=send)\n        await websocket.accept()\n        await websocket.send_json({\"port\": websocket.url.port})\n        await websocket.close()\n\n    client = test_client_factory(app)\n    with client.websocket_connect(\"ws://example.com:123/123?a=abc\") as websocket:\n        data = websocket.receive_json()\n        assert data == {\"port\": 123}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.MutableMapping",
        "anyio",
        "pytest",
        "anyio.abc.ObjectReceiveStream",
        "anyio.abc.ObjectSendStream",
        "starlette.status",
        "starlette.responses.Response",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "starlette.websockets.WebSocketState",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert data == {'port': 123}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_websocket_send_and_receive_text",
      "module": "test_websockets",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_websockets.py",
      "line_number": 116,
      "end_line_number": 130,
      "source_code": "def test_websocket_send_and_receive_text(\n    test_client_factory: TestClientFactory,\n) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        websocket = WebSocket(scope, receive=receive, send=send)\n        await websocket.accept()\n        data = await websocket.receive_text()\n        await websocket.send_text(\"Message was: \" + data)\n        await websocket.close()\n\n    client = test_client_factory(app)\n    with client.websocket_connect(\"/\") as websocket:\n        websocket.send_text(\"Hello, world!\")\n        data = websocket.receive_text()\n        assert data == \"Message was: Hello, world!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.MutableMapping",
        "anyio",
        "pytest",
        "anyio.abc.ObjectReceiveStream",
        "anyio.abc.ObjectSendStream",
        "starlette.status",
        "starlette.responses.Response",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "starlette.websockets.WebSocketState",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert data == 'Message was: Hello, world!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_websocket_send_and_receive_bytes",
      "module": "test_websockets",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_websockets.py",
      "line_number": 133,
      "end_line_number": 147,
      "source_code": "def test_websocket_send_and_receive_bytes(\n    test_client_factory: TestClientFactory,\n) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        websocket = WebSocket(scope, receive=receive, send=send)\n        await websocket.accept()\n        data = await websocket.receive_bytes()\n        await websocket.send_bytes(b\"Message was: \" + data)\n        await websocket.close()\n\n    client = test_client_factory(app)\n    with client.websocket_connect(\"/\") as websocket:\n        websocket.send_bytes(b\"Hello, world!\")\n        data = websocket.receive_bytes()\n        assert data == b\"Message was: Hello, world!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.MutableMapping",
        "anyio",
        "pytest",
        "anyio.abc.ObjectReceiveStream",
        "anyio.abc.ObjectSendStream",
        "starlette.status",
        "starlette.responses.Response",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "starlette.websockets.WebSocketState",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert data == b'Message was: Hello, world!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_websocket_send_and_receive_json",
      "module": "test_websockets",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_websockets.py",
      "line_number": 150,
      "end_line_number": 164,
      "source_code": "def test_websocket_send_and_receive_json(\n    test_client_factory: TestClientFactory,\n) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        websocket = WebSocket(scope, receive=receive, send=send)\n        await websocket.accept()\n        data = await websocket.receive_json()\n        await websocket.send_json({\"message\": data})\n        await websocket.close()\n\n    client = test_client_factory(app)\n    with client.websocket_connect(\"/\") as websocket:\n        websocket.send_json({\"hello\": \"world\"})\n        data = websocket.receive_json()\n        assert data == {\"message\": {\"hello\": \"world\"}}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.MutableMapping",
        "anyio",
        "pytest",
        "anyio.abc.ObjectReceiveStream",
        "anyio.abc.ObjectSendStream",
        "starlette.status",
        "starlette.responses.Response",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "starlette.websockets.WebSocketState",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert data == {'message': {'hello': 'world'}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_websocket_iter_text",
      "module": "test_websockets",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_websockets.py",
      "line_number": 167,
      "end_line_number": 178,
      "source_code": "def test_websocket_iter_text(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        websocket = WebSocket(scope, receive=receive, send=send)\n        await websocket.accept()\n        async for data in websocket.iter_text():\n            await websocket.send_text(\"Message was: \" + data)\n\n    client = test_client_factory(app)\n    with client.websocket_connect(\"/\") as websocket:\n        websocket.send_text(\"Hello, world!\")\n        data = websocket.receive_text()\n        assert data == \"Message was: Hello, world!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.MutableMapping",
        "anyio",
        "pytest",
        "anyio.abc.ObjectReceiveStream",
        "anyio.abc.ObjectSendStream",
        "starlette.status",
        "starlette.responses.Response",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "starlette.websockets.WebSocketState",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert data == 'Message was: Hello, world!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_websocket_iter_bytes",
      "module": "test_websockets",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_websockets.py",
      "line_number": 181,
      "end_line_number": 192,
      "source_code": "def test_websocket_iter_bytes(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        websocket = WebSocket(scope, receive=receive, send=send)\n        await websocket.accept()\n        async for data in websocket.iter_bytes():\n            await websocket.send_bytes(b\"Message was: \" + data)\n\n    client = test_client_factory(app)\n    with client.websocket_connect(\"/\") as websocket:\n        websocket.send_bytes(b\"Hello, world!\")\n        data = websocket.receive_bytes()\n        assert data == b\"Message was: Hello, world!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.MutableMapping",
        "anyio",
        "pytest",
        "anyio.abc.ObjectReceiveStream",
        "anyio.abc.ObjectSendStream",
        "starlette.status",
        "starlette.responses.Response",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "starlette.websockets.WebSocketState",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert data == b'Message was: Hello, world!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_websocket_iter_json",
      "module": "test_websockets",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_websockets.py",
      "line_number": 195,
      "end_line_number": 206,
      "source_code": "def test_websocket_iter_json(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        websocket = WebSocket(scope, receive=receive, send=send)\n        await websocket.accept()\n        async for data in websocket.iter_json():\n            await websocket.send_json({\"message\": data})\n\n    client = test_client_factory(app)\n    with client.websocket_connect(\"/\") as websocket:\n        websocket.send_json({\"hello\": \"world\"})\n        data = websocket.receive_json()\n        assert data == {\"message\": {\"hello\": \"world\"}}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.MutableMapping",
        "anyio",
        "pytest",
        "anyio.abc.ObjectReceiveStream",
        "anyio.abc.ObjectSendStream",
        "starlette.status",
        "starlette.responses.Response",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "starlette.websockets.WebSocketState",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert data == {'message': {'hello': 'world'}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_websocket_concurrency_pattern",
      "module": "test_websockets",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_websockets.py",
      "line_number": 209,
      "end_line_number": 236,
      "source_code": "def test_websocket_concurrency_pattern(test_client_factory: TestClientFactory) -> None:\n    stream_send: ObjectSendStream[MutableMapping[str, Any]]\n    stream_receive: ObjectReceiveStream[MutableMapping[str, Any]]\n    stream_send, stream_receive = anyio.create_memory_object_stream()\n\n    async def reader(websocket: WebSocket) -> None:\n        async with stream_send:\n            async for data in websocket.iter_json():\n                await stream_send.send(data)\n\n    async def writer(websocket: WebSocket) -> None:\n        async with stream_receive:\n            async for message in stream_receive:\n                await websocket.send_json(message)\n\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        websocket = WebSocket(scope, receive=receive, send=send)\n        await websocket.accept()\n        async with anyio.create_task_group() as task_group:\n            task_group.start_soon(reader, websocket)\n            await writer(websocket)\n        await websocket.close()\n\n    client = test_client_factory(app)\n    with client.websocket_connect(\"/\") as websocket:\n        websocket.send_json({\"hello\": \"world\"})\n        data = websocket.receive_json()\n        assert data == {\"hello\": \"world\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.MutableMapping",
        "anyio",
        "pytest",
        "anyio.abc.ObjectReceiveStream",
        "anyio.abc.ObjectSendStream",
        "starlette.status",
        "starlette.responses.Response",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "starlette.websockets.WebSocketState",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert data == {'hello': 'world'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_client_close",
      "module": "test_websockets",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_websockets.py",
      "line_number": 239,
      "end_line_number": 257,
      "source_code": "def test_client_close(test_client_factory: TestClientFactory) -> None:\n    close_code = None\n    close_reason = None\n\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        nonlocal close_code, close_reason\n        websocket = WebSocket(scope, receive=receive, send=send)\n        await websocket.accept()\n        try:\n            await websocket.receive_text()\n        except WebSocketDisconnect as exc:\n            close_code = exc.code\n            close_reason = exc.reason\n\n    client = test_client_factory(app)\n    with client.websocket_connect(\"/\") as websocket:\n        websocket.close(code=status.WS_1001_GOING_AWAY, reason=\"Going Away\")\n    assert close_code == status.WS_1001_GOING_AWAY\n    assert close_reason == \"Going Away\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.MutableMapping",
        "anyio",
        "pytest",
        "anyio.abc.ObjectReceiveStream",
        "anyio.abc.ObjectSendStream",
        "starlette.status",
        "starlette.responses.Response",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "starlette.websockets.WebSocketState",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert close_code == status.WS_1001_GOING_AWAY",
        "assert close_reason == 'Going Away'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_application_close",
      "module": "test_websockets",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_websockets.py",
      "line_number": 281,
      "end_line_number": 291,
      "source_code": "def test_application_close(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        websocket = WebSocket(scope, receive=receive, send=send)\n        await websocket.accept()\n        await websocket.close(status.WS_1001_GOING_AWAY)\n\n    client = test_client_factory(app)\n    with client.websocket_connect(\"/\") as websocket:\n        with pytest.raises(WebSocketDisconnect) as exc:\n            websocket.receive_text()\n        assert exc.value.code == status.WS_1001_GOING_AWAY",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.MutableMapping",
        "anyio",
        "pytest",
        "anyio.abc.ObjectReceiveStream",
        "anyio.abc.ObjectSendStream",
        "starlette.status",
        "starlette.responses.Response",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "starlette.websockets.WebSocketState",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert exc.value.code == status.WS_1001_GOING_AWAY"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_rejected_connection",
      "module": "test_websockets",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_websockets.py",
      "line_number": 294,
      "end_line_number": 305,
      "source_code": "def test_rejected_connection(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        websocket = WebSocket(scope, receive=receive, send=send)\n        msg = await websocket.receive()\n        assert msg == {\"type\": \"websocket.connect\"}\n        await websocket.close(status.WS_1001_GOING_AWAY)\n\n    client = test_client_factory(app)\n    with pytest.raises(WebSocketDisconnect) as exc:\n        with client.websocket_connect(\"/\"):\n            pass  # pragma: no cover\n    assert exc.value.code == status.WS_1001_GOING_AWAY",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.MutableMapping",
        "anyio",
        "pytest",
        "anyio.abc.ObjectReceiveStream",
        "anyio.abc.ObjectSendStream",
        "starlette.status",
        "starlette.responses.Response",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "starlette.websockets.WebSocketState",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert exc.value.code == status.WS_1001_GOING_AWAY",
        "assert msg == {'type': 'websocket.connect'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_send_denial_response",
      "module": "test_websockets",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_websockets.py",
      "line_number": 308,
      "end_line_number": 321,
      "source_code": "def test_send_denial_response(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        websocket = WebSocket(scope, receive=receive, send=send)\n        msg = await websocket.receive()\n        assert msg == {\"type\": \"websocket.connect\"}\n        response = Response(status_code=404, content=\"foo\")\n        await websocket.send_denial_response(response)\n\n    client = test_client_factory(app)\n    with pytest.raises(WebSocketDenialResponse) as exc:\n        with client.websocket_connect(\"/\"):\n            pass  # pragma: no cover\n    assert exc.value.status_code == 404\n    assert exc.value.content == b\"foo\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.MutableMapping",
        "anyio",
        "pytest",
        "anyio.abc.ObjectReceiveStream",
        "anyio.abc.ObjectSendStream",
        "starlette.status",
        "starlette.responses.Response",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "starlette.websockets.WebSocketState",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert exc.value.status_code == 404",
        "assert exc.value.content == b'foo'",
        "assert msg == {'type': 'websocket.connect'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_send_response_multi",
      "module": "test_websockets",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_websockets.py",
      "line_number": 324,
      "end_line_number": 345,
      "source_code": "def test_send_response_multi(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        websocket = WebSocket(scope, receive=receive, send=send)\n        msg = await websocket.receive()\n        assert msg == {\"type\": \"websocket.connect\"}\n        await websocket.send(\n            {\n                \"type\": \"websocket.http.response.start\",\n                \"status\": 404,\n                \"headers\": [(b\"content-type\", b\"text/plain\"), (b\"foo\", b\"bar\")],\n            }\n        )\n        await websocket.send({\"type\": \"websocket.http.response.body\", \"body\": b\"hard\", \"more_body\": True})\n        await websocket.send({\"type\": \"websocket.http.response.body\", \"body\": b\"body\"})\n\n    client = test_client_factory(app)\n    with pytest.raises(WebSocketDenialResponse) as exc:\n        with client.websocket_connect(\"/\"):\n            pass  # pragma: no cover\n    assert exc.value.status_code == 404\n    assert exc.value.content == b\"hardbody\"\n    assert exc.value.headers[\"foo\"] == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.MutableMapping",
        "anyio",
        "pytest",
        "anyio.abc.ObjectReceiveStream",
        "anyio.abc.ObjectSendStream",
        "starlette.status",
        "starlette.responses.Response",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "starlette.websockets.WebSocketState",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert exc.value.status_code == 404",
        "assert exc.value.content == b'hardbody'",
        "assert exc.value.headers['foo'] == 'bar'",
        "assert msg == {'type': 'websocket.connect'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_send_response_unsupported",
      "module": "test_websockets",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_websockets.py",
      "line_number": 348,
      "end_line_number": 366,
      "source_code": "def test_send_response_unsupported(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        del scope[\"extensions\"][\"websocket.http.response\"]\n        websocket = WebSocket(scope, receive=receive, send=send)\n        msg = await websocket.receive()\n        assert msg == {\"type\": \"websocket.connect\"}\n        response = Response(status_code=404, content=\"foo\")\n        with pytest.raises(\n            RuntimeError,\n            match=\"The server doesn't support the Websocket Denial Response extension.\",\n        ):\n            await websocket.send_denial_response(response)\n        await websocket.close()\n\n    client = test_client_factory(app)\n    with pytest.raises(WebSocketDisconnect) as exc:\n        with client.websocket_connect(\"/\"):\n            pass  # pragma: no cover\n    assert exc.value.code == status.WS_1000_NORMAL_CLOSURE",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.MutableMapping",
        "anyio",
        "pytest",
        "anyio.abc.ObjectReceiveStream",
        "anyio.abc.ObjectSendStream",
        "starlette.status",
        "starlette.responses.Response",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "starlette.websockets.WebSocketState",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert exc.value.code == status.WS_1000_NORMAL_CLOSURE",
        "assert msg == {'type': 'websocket.connect'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_send_response_duplicate_start",
      "module": "test_websockets",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_websockets.py",
      "line_number": 369,
      "end_line_number": 396,
      "source_code": "def test_send_response_duplicate_start(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        websocket = WebSocket(scope, receive=receive, send=send)\n        msg = await websocket.receive()\n        assert msg == {\"type\": \"websocket.connect\"}\n        response = Response(status_code=404, content=\"foo\")\n        await websocket.send(\n            {\n                \"type\": \"websocket.http.response.start\",\n                \"status\": response.status_code,\n                \"headers\": response.raw_headers,\n            }\n        )\n        await websocket.send(\n            {\n                \"type\": \"websocket.http.response.start\",\n                \"status\": response.status_code,\n                \"headers\": response.raw_headers,\n            }\n        )\n\n    client = test_client_factory(app)\n    with pytest.raises(\n        RuntimeError,\n        match=(\"Expected ASGI message \\\"websocket.http.response.body\\\", but got 'websocket.http.response.start'\"),\n    ):\n        with client.websocket_connect(\"/\"):\n            pass",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.MutableMapping",
        "anyio",
        "pytest",
        "anyio.abc.ObjectReceiveStream",
        "anyio.abc.ObjectSendStream",
        "starlette.status",
        "starlette.responses.Response",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "starlette.websockets.WebSocketState",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg == {'type': 'websocket.connect'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_subprotocol",
      "module": "test_websockets",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_websockets.py",
      "line_number": 399,
      "end_line_number": 408,
      "source_code": "def test_subprotocol(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        websocket = WebSocket(scope, receive=receive, send=send)\n        assert websocket[\"subprotocols\"] == [\"soap\", \"wamp\"]\n        await websocket.accept(subprotocol=\"wamp\")\n        await websocket.close()\n\n    client = test_client_factory(app)\n    with client.websocket_connect(\"/\", subprotocols=[\"soap\", \"wamp\"]) as websocket:\n        assert websocket.accepted_subprotocol == \"wamp\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.MutableMapping",
        "anyio",
        "pytest",
        "anyio.abc.ObjectReceiveStream",
        "anyio.abc.ObjectSendStream",
        "starlette.status",
        "starlette.responses.Response",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "starlette.websockets.WebSocketState",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert websocket['subprotocols'] == ['soap', 'wamp']",
        "assert websocket.accepted_subprotocol == 'wamp'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_additional_headers",
      "module": "test_websockets",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_websockets.py",
      "line_number": 411,
      "end_line_number": 419,
      "source_code": "def test_additional_headers(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        websocket = WebSocket(scope, receive=receive, send=send)\n        await websocket.accept(headers=[(b\"additional\", b\"header\")])\n        await websocket.close()\n\n    client = test_client_factory(app)\n    with client.websocket_connect(\"/\") as websocket:\n        assert websocket.extra_headers == [(b\"additional\", b\"header\")]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.MutableMapping",
        "anyio",
        "pytest",
        "anyio.abc.ObjectReceiveStream",
        "anyio.abc.ObjectSendStream",
        "starlette.status",
        "starlette.responses.Response",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "starlette.websockets.WebSocketState",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert websocket.extra_headers == [(b'additional', b'header')]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_no_additional_headers",
      "module": "test_websockets",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_websockets.py",
      "line_number": 422,
      "end_line_number": 430,
      "source_code": "def test_no_additional_headers(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        websocket = WebSocket(scope, receive=receive, send=send)\n        await websocket.accept()\n        await websocket.close()\n\n    client = test_client_factory(app)\n    with client.websocket_connect(\"/\") as websocket:\n        assert websocket.extra_headers == []",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.MutableMapping",
        "anyio",
        "pytest",
        "anyio.abc.ObjectReceiveStream",
        "anyio.abc.ObjectSendStream",
        "starlette.status",
        "starlette.responses.Response",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "starlette.websockets.WebSocketState",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert websocket.extra_headers == []"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_websocket_exception",
      "module": "test_websockets",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_websockets.py",
      "line_number": 433,
      "end_line_number": 440,
      "source_code": "def test_websocket_exception(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        assert False\n\n    client = test_client_factory(app)\n    with pytest.raises(AssertionError):\n        with client.websocket_connect(\"/123?a=abc\"):\n            pass",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.MutableMapping",
        "anyio",
        "pytest",
        "anyio.abc.ObjectReceiveStream",
        "anyio.abc.ObjectSendStream",
        "starlette.status",
        "starlette.responses.Response",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "starlette.websockets.WebSocketState",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_duplicate_close",
      "module": "test_websockets",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_websockets.py",
      "line_number": 443,
      "end_line_number": 453,
      "source_code": "def test_duplicate_close(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        websocket = WebSocket(scope, receive=receive, send=send)\n        await websocket.accept()\n        await websocket.close()\n        await websocket.close()\n\n    client = test_client_factory(app)\n    with pytest.raises(RuntimeError):\n        with client.websocket_connect(\"/\"):\n            pass",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.MutableMapping",
        "anyio",
        "pytest",
        "anyio.abc.ObjectReceiveStream",
        "anyio.abc.ObjectSendStream",
        "starlette.status",
        "starlette.responses.Response",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "starlette.websockets.WebSocketState",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_duplicate_disconnect",
      "module": "test_websockets",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_websockets.py",
      "line_number": 456,
      "end_line_number": 467,
      "source_code": "def test_duplicate_disconnect(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        websocket = WebSocket(scope, receive=receive, send=send)\n        await websocket.accept()\n        message = await websocket.receive()\n        assert message[\"type\"] == \"websocket.disconnect\"\n        message = await websocket.receive()\n\n    client = test_client_factory(app)\n    with pytest.raises(RuntimeError):\n        with client.websocket_connect(\"/\") as websocket:\n            websocket.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.MutableMapping",
        "anyio",
        "pytest",
        "anyio.abc.ObjectReceiveStream",
        "anyio.abc.ObjectSendStream",
        "starlette.status",
        "starlette.responses.Response",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "starlette.websockets.WebSocketState",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert message['type'] == 'websocket.disconnect'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_websocket_scope_interface",
      "module": "test_websockets",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_websockets.py",
      "line_number": 470,
      "end_line_number": 494,
      "source_code": "def test_websocket_scope_interface() -> None:\n    \"\"\"\n    A WebSocket can be instantiated with a scope, and presents a `Mapping`\n    interface.\n    \"\"\"\n\n    async def mock_receive() -> Message:  # type: ignore\n        ...  # pragma: no cover\n\n    async def mock_send(message: Message) -> None: ...  # pragma: no cover\n\n    websocket = WebSocket({\"type\": \"websocket\", \"path\": \"/abc/\", \"headers\": []}, receive=mock_receive, send=mock_send)\n    assert websocket[\"type\"] == \"websocket\"\n    assert dict(websocket) == {\"type\": \"websocket\", \"path\": \"/abc/\", \"headers\": []}\n    assert len(websocket) == 3\n\n    # check __eq__ and __hash__\n    assert websocket != WebSocket(\n        {\"type\": \"websocket\", \"path\": \"/abc/\", \"headers\": []},\n        receive=mock_receive,\n        send=mock_send,\n    )\n    assert websocket == websocket\n    assert websocket in {websocket}\n    assert {websocket} == {websocket}",
      "docstring": "A WebSocket can be instantiated with a scope, and presents a `Mapping`\ninterface.",
      "decorators": [],
      "arguments": [],
      "imports": [
        "sys",
        "typing.Any",
        "typing.MutableMapping",
        "anyio",
        "pytest",
        "anyio.abc.ObjectReceiveStream",
        "anyio.abc.ObjectSendStream",
        "starlette.status",
        "starlette.responses.Response",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "starlette.websockets.WebSocketState",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert websocket['type'] == 'websocket'",
        "assert dict(websocket) == {'type': 'websocket', 'path': '/abc/', 'headers': []}",
        "assert len(websocket) == 3",
        "assert websocket != WebSocket({'type': 'websocket', 'path': '/abc/', 'headers': []}, receive=mock_receive, send=mock_send)",
        "assert websocket == websocket",
        "assert websocket in {websocket}",
        "assert {websocket} == {websocket}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_websocket_close_reason",
      "module": "test_websockets",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_websockets.py",
      "line_number": 497,
      "end_line_number": 508,
      "source_code": "def test_websocket_close_reason(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        websocket = WebSocket(scope, receive=receive, send=send)\n        await websocket.accept()\n        await websocket.close(code=status.WS_1001_GOING_AWAY, reason=\"Going Away\")\n\n    client = test_client_factory(app)\n    with client.websocket_connect(\"/\") as websocket:\n        with pytest.raises(WebSocketDisconnect) as exc:\n            websocket.receive_text()\n        assert exc.value.code == status.WS_1001_GOING_AWAY\n        assert exc.value.reason == \"Going Away\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.MutableMapping",
        "anyio",
        "pytest",
        "anyio.abc.ObjectReceiveStream",
        "anyio.abc.ObjectSendStream",
        "starlette.status",
        "starlette.responses.Response",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "starlette.websockets.WebSocketState",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert exc.value.code == status.WS_1001_GOING_AWAY",
        "assert exc.value.reason == 'Going Away'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_send_json_invalid_mode",
      "module": "test_websockets",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_websockets.py",
      "line_number": 511,
      "end_line_number": 520,
      "source_code": "def test_send_json_invalid_mode(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        websocket = WebSocket(scope, receive=receive, send=send)\n        await websocket.accept()\n        await websocket.send_json({}, mode=\"invalid\")\n\n    client = test_client_factory(app)\n    with pytest.raises(RuntimeError):\n        with client.websocket_connect(\"/\"):\n            pass",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.MutableMapping",
        "anyio",
        "pytest",
        "anyio.abc.ObjectReceiveStream",
        "anyio.abc.ObjectSendStream",
        "starlette.status",
        "starlette.responses.Response",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "starlette.websockets.WebSocketState",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_receive_json_invalid_mode",
      "module": "test_websockets",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_websockets.py",
      "line_number": 523,
      "end_line_number": 532,
      "source_code": "def test_receive_json_invalid_mode(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        websocket = WebSocket(scope, receive=receive, send=send)\n        await websocket.accept()\n        await websocket.receive_json(mode=\"invalid\")\n\n    client = test_client_factory(app)\n    with pytest.raises(RuntimeError):\n        with client.websocket_connect(\"/\"):\n            pass",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.MutableMapping",
        "anyio",
        "pytest",
        "anyio.abc.ObjectReceiveStream",
        "anyio.abc.ObjectSendStream",
        "starlette.status",
        "starlette.responses.Response",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "starlette.websockets.WebSocketState",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_receive_text_before_accept",
      "module": "test_websockets",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_websockets.py",
      "line_number": 535,
      "end_line_number": 543,
      "source_code": "def test_receive_text_before_accept(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        websocket = WebSocket(scope, receive=receive, send=send)\n        await websocket.receive_text()\n\n    client = test_client_factory(app)\n    with pytest.raises(RuntimeError):\n        with client.websocket_connect(\"/\"):\n            pass",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.MutableMapping",
        "anyio",
        "pytest",
        "anyio.abc.ObjectReceiveStream",
        "anyio.abc.ObjectSendStream",
        "starlette.status",
        "starlette.responses.Response",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "starlette.websockets.WebSocketState",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_receive_bytes_before_accept",
      "module": "test_websockets",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_websockets.py",
      "line_number": 546,
      "end_line_number": 554,
      "source_code": "def test_receive_bytes_before_accept(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        websocket = WebSocket(scope, receive=receive, send=send)\n        await websocket.receive_bytes()\n\n    client = test_client_factory(app)\n    with pytest.raises(RuntimeError):\n        with client.websocket_connect(\"/\"):\n            pass",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.MutableMapping",
        "anyio",
        "pytest",
        "anyio.abc.ObjectReceiveStream",
        "anyio.abc.ObjectSendStream",
        "starlette.status",
        "starlette.responses.Response",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "starlette.websockets.WebSocketState",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_receive_json_before_accept",
      "module": "test_websockets",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_websockets.py",
      "line_number": 557,
      "end_line_number": 565,
      "source_code": "def test_receive_json_before_accept(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        websocket = WebSocket(scope, receive=receive, send=send)\n        await websocket.receive_json()\n\n    client = test_client_factory(app)\n    with pytest.raises(RuntimeError):\n        with client.websocket_connect(\"/\"):\n            pass",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.MutableMapping",
        "anyio",
        "pytest",
        "anyio.abc.ObjectReceiveStream",
        "anyio.abc.ObjectSendStream",
        "starlette.status",
        "starlette.responses.Response",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "starlette.websockets.WebSocketState",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_send_before_accept",
      "module": "test_websockets",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_websockets.py",
      "line_number": 568,
      "end_line_number": 576,
      "source_code": "def test_send_before_accept(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        websocket = WebSocket(scope, receive=receive, send=send)\n        await websocket.send({\"type\": \"websocket.send\"})\n\n    client = test_client_factory(app)\n    with pytest.raises(RuntimeError):\n        with client.websocket_connect(\"/\"):\n            pass",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.MutableMapping",
        "anyio",
        "pytest",
        "anyio.abc.ObjectReceiveStream",
        "anyio.abc.ObjectSendStream",
        "starlette.status",
        "starlette.responses.Response",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "starlette.websockets.WebSocketState",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_send_wrong_message_type",
      "module": "test_websockets",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_websockets.py",
      "line_number": 579,
      "end_line_number": 588,
      "source_code": "def test_send_wrong_message_type(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        websocket = WebSocket(scope, receive=receive, send=send)\n        await websocket.send({\"type\": \"websocket.accept\"})\n        await websocket.send({\"type\": \"websocket.accept\"})\n\n    client = test_client_factory(app)\n    with pytest.raises(RuntimeError):\n        with client.websocket_connect(\"/\"):\n            pass",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.MutableMapping",
        "anyio",
        "pytest",
        "anyio.abc.ObjectReceiveStream",
        "anyio.abc.ObjectSendStream",
        "starlette.status",
        "starlette.responses.Response",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "starlette.websockets.WebSocketState",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_receive_before_accept",
      "module": "test_websockets",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_websockets.py",
      "line_number": 591,
      "end_line_number": 601,
      "source_code": "def test_receive_before_accept(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        websocket = WebSocket(scope, receive=receive, send=send)\n        await websocket.accept()\n        websocket.client_state = WebSocketState.CONNECTING\n        await websocket.receive()\n\n    client = test_client_factory(app)\n    with pytest.raises(RuntimeError):\n        with client.websocket_connect(\"/\") as websocket:\n            websocket.send({\"type\": \"websocket.send\"})",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.MutableMapping",
        "anyio",
        "pytest",
        "anyio.abc.ObjectReceiveStream",
        "anyio.abc.ObjectSendStream",
        "starlette.status",
        "starlette.responses.Response",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "starlette.websockets.WebSocketState",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_receive_wrong_message_type",
      "module": "test_websockets",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_websockets.py",
      "line_number": 604,
      "end_line_number": 613,
      "source_code": "def test_receive_wrong_message_type(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        websocket = WebSocket(scope, receive=receive, send=send)\n        await websocket.accept()\n        await websocket.receive()\n\n    client = test_client_factory(app)\n    with pytest.raises(RuntimeError):\n        with client.websocket_connect(\"/\") as websocket:\n            websocket.send({\"type\": \"websocket.connect\"})",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.MutableMapping",
        "anyio",
        "pytest",
        "anyio.abc.ObjectReceiveStream",
        "anyio.abc.ObjectSendStream",
        "starlette.status",
        "starlette.responses.Response",
        "starlette.testclient.WebSocketDenialResponse",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "starlette.websockets.WebSocketState",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_async_func",
      "module": "test__utils",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test__utils.py",
      "line_number": 10,
      "end_line_number": 16,
      "source_code": "def test_async_func() -> None:\n    async def async_func() -> None: ...  # pragma: no cover\n\n    def func() -> None: ...  # pragma: no cover\n\n    assert is_async_callable(async_func)\n    assert not is_async_callable(func)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "functools",
        "typing.Any",
        "pytest",
        "starlette._utils.get_route_path",
        "starlette._utils.is_async_callable",
        "starlette.types.Scope"
      ],
      "fixtures": [],
      "assertions": [
        "assert is_async_callable(async_func)",
        "assert not is_async_callable(func)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_async_partial",
      "module": "test__utils",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test__utils.py",
      "line_number": 19,
      "end_line_number": 28,
      "source_code": "def test_async_partial() -> None:\n    async def async_func(a: Any, b: Any) -> None: ...  # pragma: no cover\n\n    def func(a: Any, b: Any) -> None: ...  # pragma: no cover\n\n    partial = functools.partial(async_func, 1)\n    assert is_async_callable(partial)\n\n    partial = functools.partial(func, 1)  # type: ignore\n    assert not is_async_callable(partial)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "functools",
        "typing.Any",
        "pytest",
        "starlette._utils.get_route_path",
        "starlette._utils.is_async_callable",
        "starlette.types.Scope"
      ],
      "fixtures": [],
      "assertions": [
        "assert is_async_callable(partial)",
        "assert not is_async_callable(partial)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_async_method",
      "module": "test__utils",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test__utils.py",
      "line_number": 31,
      "end_line_number": 39,
      "source_code": "def test_async_method() -> None:\n    class Async:\n        async def method(self) -> None: ...  # pragma: no cover\n\n    class Sync:\n        def method(self) -> None: ...  # pragma: no cover\n\n    assert is_async_callable(Async().method)\n    assert not is_async_callable(Sync().method)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "functools",
        "typing.Any",
        "pytest",
        "starlette._utils.get_route_path",
        "starlette._utils.is_async_callable",
        "starlette.types.Scope"
      ],
      "fixtures": [],
      "assertions": [
        "assert is_async_callable(Async().method)",
        "assert not is_async_callable(Sync().method)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_async_object_call",
      "module": "test__utils",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test__utils.py",
      "line_number": 42,
      "end_line_number": 50,
      "source_code": "def test_async_object_call() -> None:\n    class Async:\n        async def __call__(self) -> None: ...  # pragma: no cover\n\n    class Sync:\n        def __call__(self) -> None: ...  # pragma: no cover\n\n    assert is_async_callable(Async())\n    assert not is_async_callable(Sync())",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "functools",
        "typing.Any",
        "pytest",
        "starlette._utils.get_route_path",
        "starlette._utils.is_async_callable",
        "starlette.types.Scope"
      ],
      "fixtures": [],
      "assertions": [
        "assert is_async_callable(Async())",
        "assert not is_async_callable(Sync())"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_async_partial_object_call",
      "module": "test__utils",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test__utils.py",
      "line_number": 53,
      "end_line_number": 72,
      "source_code": "def test_async_partial_object_call() -> None:\n    class Async:\n        async def __call__(\n            self,\n            a: Any,\n            b: Any,\n        ) -> None: ...  # pragma: no cover\n\n    class Sync:\n        def __call__(\n            self,\n            a: Any,\n            b: Any,\n        ) -> None: ...  # pragma: no cover\n\n    partial = functools.partial(Async(), 1)\n    assert is_async_callable(partial)\n\n    partial = functools.partial(Sync(), 1)  # type: ignore\n    assert not is_async_callable(partial)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "functools",
        "typing.Any",
        "pytest",
        "starlette._utils.get_route_path",
        "starlette._utils.is_async_callable",
        "starlette.types.Scope"
      ],
      "fixtures": [],
      "assertions": [
        "assert is_async_callable(partial)",
        "assert not is_async_callable(partial)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_async_nested_partial",
      "module": "test__utils",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test__utils.py",
      "line_number": 75,
      "end_line_number": 83,
      "source_code": "def test_async_nested_partial() -> None:\n    async def async_func(\n        a: Any,\n        b: Any,\n    ) -> None: ...  # pragma: no cover\n\n    partial = functools.partial(async_func, b=2)\n    nested_partial = functools.partial(partial, a=1)\n    assert is_async_callable(nested_partial)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "functools",
        "typing.Any",
        "pytest",
        "starlette._utils.get_route_path",
        "starlette._utils.is_async_callable",
        "starlette.types.Scope"
      ],
      "fixtures": [],
      "assertions": [
        "assert is_async_callable(nested_partial)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get_route_path",
      "module": "test__utils",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test__utils.py",
      "line_number": 95,
      "end_line_number": 96,
      "source_code": "def test_get_route_path(scope: Scope, expected_result: str) -> None:\n    assert get_route_path(scope) == expected_result",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('scope, expected_result', [({'path': '/foo-123/bar', 'root_path': '/foo'}, '/foo-123/bar'), ({'path': '/foo/bar', 'root_path': '/foo'}, '/bar'), ({'path': '/foo', 'root_path': '/foo'}, ''), ({'path': '/foo/bar', 'root_path': '/bar'}, '/foo/bar')])"
      ],
      "arguments": [
        "scope",
        "expected_result"
      ],
      "imports": [
        "functools",
        "typing.Any",
        "pytest",
        "starlette._utils.get_route_path",
        "starlette._utils.is_async_callable",
        "starlette.types.Scope"
      ],
      "fixtures": [],
      "assertions": [
        "assert get_route_path(scope) == expected_result"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_text_response",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 22,
      "end_line_number": 29,
      "source_code": "def test_text_response(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        response = Response(\"hello, world\", media_type=\"text/plain\")\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.text == \"hello, world\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'hello, world'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_bytes_response",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 32,
      "end_line_number": 39,
      "source_code": "def test_bytes_response(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        response = Response(b\"xxxxx\", media_type=\"image/png\")\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.content == b\"xxxxx\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.content == b'xxxxx'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_json_none_response",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 42,
      "end_line_number": 50,
      "source_code": "def test_json_none_response(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        response = JSONResponse(None)\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.json() is None\n    assert response.content == b\"null\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() is None",
        "assert response.content == b'null'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_redirect_response",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 53,
      "end_line_number": 64,
      "source_code": "def test_redirect_response(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        if scope[\"path\"] == \"/\":\n            response = Response(\"hello, world\", media_type=\"text/plain\")\n        else:\n            response = RedirectResponse(\"/\")\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n    response = client.get(\"/redirect\")\n    assert response.text == \"hello, world\"\n    assert response.url == \"http://testserver/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'hello, world'",
        "assert response.url == 'http://testserver/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_quoting_redirect_response",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 67,
      "end_line_number": 78,
      "source_code": "def test_quoting_redirect_response(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        if scope[\"path\"] == \"/I \u2665 Starlette/\":\n            response = Response(\"hello, world\", media_type=\"text/plain\")\n        else:\n            response = RedirectResponse(\"/I \u2665 Starlette/\")\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n    response = client.get(\"/redirect\")\n    assert response.text == \"hello, world\"\n    assert response.url == \"http://testserver/I%20%E2%99%A5%20Starlette/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'hello, world'",
        "assert response.url == 'http://testserver/I%20%E2%99%A5%20Starlette/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_redirect_response_content_length_header",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 81,
      "end_line_number": 94,
      "source_code": "def test_redirect_response_content_length_header(\n    test_client_factory: TestClientFactory,\n) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        if scope[\"path\"] == \"/\":\n            response = Response(\"hello\", media_type=\"text/plain\")  # pragma: no cover\n        else:\n            response = RedirectResponse(\"/\")\n        await response(scope, receive, send)\n\n    client: TestClient = test_client_factory(app)\n    response = client.request(\"GET\", \"/redirect\", allow_redirects=False)\n    assert response.url == \"http://testserver/redirect\"\n    assert response.headers[\"content-length\"] == \"0\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.url == 'http://testserver/redirect'",
        "assert response.headers['content-length'] == '0'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_streaming_response",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 97,
      "end_line_number": 122,
      "source_code": "def test_streaming_response(test_client_factory: TestClientFactory) -> None:\n    filled_by_bg_task = \"\"\n\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        async def numbers(minimum: int, maximum: int) -> AsyncIterator[str]:\n            for i in range(minimum, maximum + 1):\n                yield str(i)\n                if i != maximum:\n                    yield \", \"\n                await anyio.sleep(0)\n\n        async def numbers_for_cleanup(start: int = 1, stop: int = 5) -> None:\n            nonlocal filled_by_bg_task\n            async for thing in numbers(start, stop):\n                filled_by_bg_task = filled_by_bg_task + thing\n\n        cleanup_task = BackgroundTask(numbers_for_cleanup, start=6, stop=9)\n        generator = numbers(1, 5)\n        response = StreamingResponse(generator, media_type=\"text/plain\", background=cleanup_task)\n        await response(scope, receive, send)\n\n    assert filled_by_bg_task == \"\"\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.text == \"1, 2, 3, 4, 5\"\n    assert filled_by_bg_task == \"6, 7, 8, 9\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert filled_by_bg_task == ''",
        "assert response.text == '1, 2, 3, 4, 5'",
        "assert filled_by_bg_task == '6, 7, 8, 9'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_streaming_response_custom_iterator",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 125,
      "end_line_number": 147,
      "source_code": "def test_streaming_response_custom_iterator(\n    test_client_factory: TestClientFactory,\n) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        class CustomAsyncIterator:\n            def __init__(self) -> None:\n                self._called = 0\n\n            def __aiter__(self) -> AsyncIterator[str]:\n                return self\n\n            async def __anext__(self) -> str:\n                if self._called == 5:\n                    raise StopAsyncIteration()\n                self._called += 1\n                return str(self._called)\n\n        response = StreamingResponse(CustomAsyncIterator(), media_type=\"text/plain\")\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.text == \"12345\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == '12345'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_streaming_response_custom_iterable",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 150,
      "end_line_number": 164,
      "source_code": "def test_streaming_response_custom_iterable(\n    test_client_factory: TestClientFactory,\n) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        class CustomAsyncIterable:\n            async def __aiter__(self) -> AsyncIterator[str | bytes]:\n                for i in range(5):\n                    yield str(i + 1)\n\n        response = StreamingResponse(CustomAsyncIterable(), media_type=\"text/plain\")\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.text == \"12345\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == '12345'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_sync_streaming_response",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 167,
      "end_line_number": 181,
      "source_code": "def test_sync_streaming_response(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        def numbers(minimum: int, maximum: int) -> Iterator[str]:\n            for i in range(minimum, maximum + 1):\n                yield str(i)\n                if i != maximum:\n                    yield \", \"\n\n        generator = numbers(1, 5)\n        response = StreamingResponse(generator, media_type=\"text/plain\")\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.text == \"1, 2, 3, 4, 5\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == '1, 2, 3, 4, 5'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_response_headers",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 184,
      "end_line_number": 194,
      "source_code": "def test_response_headers(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        headers = {\"x-header-1\": \"123\", \"x-header-2\": \"456\"}\n        response = Response(\"hello, world\", media_type=\"text/plain\", headers=headers)\n        response.headers[\"x-header-2\"] = \"789\"\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.headers[\"x-header-1\"] == \"123\"\n    assert response.headers[\"x-header-2\"] == \"789\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.headers['x-header-1'] == '123'",
        "assert response.headers['x-header-2'] == '789'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_response_phrase",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 197,
      "end_line_number": 206,
      "source_code": "def test_response_phrase(test_client_factory: TestClientFactory) -> None:\n    app = Response(status_code=204)\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.reason_phrase == \"No Content\"\n\n    app = Response(b\"\", status_code=123)\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.reason_phrase == \"\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.reason_phrase == 'No Content'",
        "assert response.reason_phrase == ''"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_file_response",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 209,
      "end_line_number": 245,
      "source_code": "def test_file_response(tmp_path: Path, test_client_factory: TestClientFactory) -> None:\n    path = tmp_path / \"xyz\"\n    content = b\"<file content>\" * 1000\n    path.write_bytes(content)\n\n    filled_by_bg_task = \"\"\n\n    async def numbers(minimum: int, maximum: int) -> AsyncIterator[str]:\n        for i in range(minimum, maximum + 1):\n            yield str(i)\n            if i != maximum:\n                yield \", \"\n            await anyio.sleep(0)\n\n    async def numbers_for_cleanup(start: int = 1, stop: int = 5) -> None:\n        nonlocal filled_by_bg_task\n        async for thing in numbers(start, stop):\n            filled_by_bg_task = filled_by_bg_task + thing\n\n    cleanup_task = BackgroundTask(numbers_for_cleanup, start=6, stop=9)\n\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        response = FileResponse(path=path, filename=\"example.png\", background=cleanup_task)\n        await response(scope, receive, send)\n\n    assert filled_by_bg_task == \"\"\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    expected_disposition = 'attachment; filename=\"example.png\"'\n    assert response.status_code == status.HTTP_200_OK\n    assert response.content == content\n    assert response.headers[\"content-type\"] == \"image/png\"\n    assert response.headers[\"content-disposition\"] == expected_disposition\n    assert \"content-length\" in response.headers\n    assert \"last-modified\" in response.headers\n    assert \"etag\" in response.headers\n    assert filled_by_bg_task == \"6, 7, 8, 9\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmp_path",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert filled_by_bg_task == ''",
        "assert response.status_code == status.HTTP_200_OK",
        "assert response.content == content",
        "assert response.headers['content-type'] == 'image/png'",
        "assert response.headers['content-disposition'] == expected_disposition",
        "assert 'content-length' in response.headers",
        "assert 'last-modified' in response.headers",
        "assert 'etag' in response.headers",
        "assert filled_by_bg_task == '6, 7, 8, 9'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_file_response_set_media_type",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 277,
      "end_line_number": 286,
      "source_code": "def test_file_response_set_media_type(tmp_path: Path, test_client_factory: TestClientFactory) -> None:\n    path = tmp_path / \"xyz\"\n    path.write_bytes(b\"<file content>\")\n\n    # By default, FileResponse will determine the `content-type` based on\n    # the filename or path, unless a specific `media_type` is provided.\n    app = FileResponse(path=path, filename=\"example.png\", media_type=\"image/jpeg\")\n    client: TestClient = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.headers[\"content-type\"] == \"image/jpeg\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmp_path",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.headers['content-type'] == 'image/jpeg'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_file_response_with_directory_raises_error",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 289,
      "end_line_number": 294,
      "source_code": "def test_file_response_with_directory_raises_error(tmp_path: Path, test_client_factory: TestClientFactory) -> None:\n    app = FileResponse(path=tmp_path, filename=\"example.png\")\n    client = test_client_factory(app)\n    with pytest.raises(RuntimeError) as exc_info:\n        client.get(\"/\")\n    assert \"is not a file\" in str(exc_info.value)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmp_path",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'is not a file' in str(exc_info.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_file_response_with_missing_file_raises_error",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 297,
      "end_line_number": 303,
      "source_code": "def test_file_response_with_missing_file_raises_error(tmp_path: Path, test_client_factory: TestClientFactory) -> None:\n    path = tmp_path / \"404.txt\"\n    app = FileResponse(path=path, filename=\"404.txt\")\n    client = test_client_factory(app)\n    with pytest.raises(RuntimeError) as exc_info:\n        client.get(\"/\")\n    assert \"does not exist\" in str(exc_info.value)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmp_path",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'does not exist' in str(exc_info.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_file_response_with_chinese_filename",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 306,
      "end_line_number": 317,
      "source_code": "def test_file_response_with_chinese_filename(tmp_path: Path, test_client_factory: TestClientFactory) -> None:\n    content = b\"file content\"\n    filename = \"\u4f60\u597d.txt\"  # probably \"Hello.txt\" in Chinese\n    path = tmp_path / filename\n    path.write_bytes(content)\n    app = FileResponse(path=path, filename=filename)\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    expected_disposition = \"attachment; filename*=utf-8''%E4%BD%A0%E5%A5%BD.txt\"\n    assert response.status_code == status.HTTP_200_OK\n    assert response.content == content\n    assert response.headers[\"content-disposition\"] == expected_disposition",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmp_path",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == status.HTTP_200_OK",
        "assert response.content == content",
        "assert response.headers['content-disposition'] == expected_disposition"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_file_response_with_inline_disposition",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 320,
      "end_line_number": 331,
      "source_code": "def test_file_response_with_inline_disposition(tmp_path: Path, test_client_factory: TestClientFactory) -> None:\n    content = b\"file content\"\n    filename = \"hello.txt\"\n    path = tmp_path / filename\n    path.write_bytes(content)\n    app = FileResponse(path=path, filename=filename, content_disposition_type=\"inline\")\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    expected_disposition = 'inline; filename=\"hello.txt\"'\n    assert response.status_code == status.HTTP_200_OK\n    assert response.content == content\n    assert response.headers[\"content-disposition\"] == expected_disposition",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmp_path",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == status.HTTP_200_OK",
        "assert response.content == content",
        "assert response.headers['content-disposition'] == expected_disposition"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_file_response_with_method_warns",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 334,
      "end_line_number": 336,
      "source_code": "def test_file_response_with_method_warns(tmp_path: Path) -> None:\n    with pytest.warns(DeprecationWarning):\n        FileResponse(path=tmp_path, filename=\"example.png\", method=\"GET\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmp_path"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_set_cookie",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 339,
      "end_line_number": 365,
      "source_code": "def test_set_cookie(test_client_factory: TestClientFactory, monkeypatch: pytest.MonkeyPatch) -> None:\n    # Mock time used as a reference for `Expires` by stdlib `SimpleCookie`.\n    mocked_now = dt.datetime(2037, 1, 22, 12, 0, 0, tzinfo=dt.timezone.utc)\n    monkeypatch.setattr(time, \"time\", lambda: mocked_now.timestamp())\n\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        response = Response(\"Hello, world!\", media_type=\"text/plain\")\n        response.set_cookie(\n            \"mycookie\",\n            \"myvalue\",\n            max_age=10,\n            expires=10,\n            path=\"/\",\n            domain=\"localhost\",\n            secure=True,\n            httponly=True,\n            samesite=\"none\",\n        )\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.text == \"Hello, world!\"\n    assert (\n        response.headers[\"set-cookie\"] == \"mycookie=myvalue; Domain=localhost; expires=Thu, 22 Jan 2037 12:00:10 GMT; \"\n        \"HttpOnly; Max-Age=10; Path=/; SameSite=none; Secure\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory",
        "monkeypatch"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'Hello, world!'",
        "assert response.headers['set-cookie'] == 'mycookie=myvalue; Domain=localhost; expires=Thu, 22 Jan 2037 12:00:10 GMT; HttpOnly; Max-Age=10; Path=/; SameSite=none; Secure'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_set_cookie_path_none",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 368,
      "end_line_number": 377,
      "source_code": "def test_set_cookie_path_none(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        response = Response(\"Hello, world!\", media_type=\"text/plain\")\n        response.set_cookie(\"mycookie\", \"myvalue\", path=None)\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.text == \"Hello, world!\"\n    assert response.headers[\"set-cookie\"] == \"mycookie=myvalue; SameSite=lax\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'Hello, world!'",
        "assert response.headers['set-cookie'] == 'mycookie=myvalue; SameSite=lax'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_expires_on_set_cookie",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 388,
      "end_line_number": 405,
      "source_code": "def test_expires_on_set_cookie(\n    test_client_factory: TestClientFactory,\n    monkeypatch: pytest.MonkeyPatch,\n    expires: str,\n) -> None:\n    # Mock time used as a reference for `Expires` by stdlib `SimpleCookie`.\n    mocked_now = dt.datetime(2037, 1, 22, 12, 0, 0, tzinfo=dt.timezone.utc)\n    monkeypatch.setattr(time, \"time\", lambda: mocked_now.timestamp())\n\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        response = Response(\"Hello, world!\", media_type=\"text/plain\")\n        response.set_cookie(\"mycookie\", \"myvalue\", expires=expires)\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    cookie = SimpleCookie(response.headers.get(\"set-cookie\"))\n    assert cookie[\"mycookie\"][\"expires\"] == \"Thu, 22 Jan 2037 12:00:10 GMT\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('expires', [pytest.param(dt.datetime(2037, 1, 22, 12, 0, 10, tzinfo=dt.timezone.utc), id='datetime'), pytest.param('Thu, 22 Jan 2037 12:00:10 GMT', id='str'), pytest.param(10, id='int')])"
      ],
      "arguments": [
        "test_client_factory",
        "monkeypatch",
        "expires"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert cookie['mycookie']['expires'] == 'Thu, 22 Jan 2037 12:00:10 GMT'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "response.headers.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_delete_cookie",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 408,
      "end_line_number": 422,
      "source_code": "def test_delete_cookie(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        request = Request(scope, receive)\n        response = Response(\"Hello, world!\", media_type=\"text/plain\")\n        if request.cookies.get(\"mycookie\"):\n            response.delete_cookie(\"mycookie\")\n        else:\n            response.set_cookie(\"mycookie\", \"myvalue\")\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.cookies[\"mycookie\"]\n    response = client.get(\"/\")\n    assert not response.cookies.get(\"mycookie\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.cookies['mycookie']",
        "assert not response.cookies.get('mycookie')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "request.cookies.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "response.cookies.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_populate_headers",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 425,
      "end_line_number": 431,
      "source_code": "def test_populate_headers(test_client_factory: TestClientFactory) -> None:\n    app = Response(content=\"hi\", headers={}, media_type=\"text/html\")\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.text == \"hi\"\n    assert response.headers[\"content-length\"] == \"2\"\n    assert response.headers[\"content-type\"] == \"text/html; charset=utf-8\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'hi'",
        "assert response.headers['content-length'] == '2'",
        "assert response.headers['content-type'] == 'text/html; charset=utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_head_method",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 434,
      "end_line_number": 438,
      "source_code": "def test_head_method(test_client_factory: TestClientFactory) -> None:\n    app = Response(\"hello, world\", media_type=\"text/plain\")\n    client = test_client_factory(app)\n    response = client.head(\"/\")\n    assert response.text == \"\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == ''"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_empty_response",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 441,
      "end_line_number": 447,
      "source_code": "def test_empty_response(test_client_factory: TestClientFactory) -> None:\n    app = Response()\n    client: TestClient = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.content == b\"\"\n    assert response.headers[\"content-length\"] == \"0\"\n    assert \"content-type\" not in response.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.content == b''",
        "assert response.headers['content-length'] == '0'",
        "assert 'content-type' not in response.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_empty_204_response",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 450,
      "end_line_number": 454,
      "source_code": "def test_empty_204_response(test_client_factory: TestClientFactory) -> None:\n    app = Response(status_code=204)\n    client: TestClient = test_client_factory(app)\n    response = client.get(\"/\")\n    assert \"content-length\" not in response.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'content-length' not in response.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_non_empty_response",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 457,
      "end_line_number": 461,
      "source_code": "def test_non_empty_response(test_client_factory: TestClientFactory) -> None:\n    app = Response(content=\"hi\")\n    client: TestClient = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.headers[\"content-length\"] == \"2\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.headers['content-length'] == '2'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_response_do_not_add_redundant_charset",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 464,
      "end_line_number": 470,
      "source_code": "def test_response_do_not_add_redundant_charset(\n    test_client_factory: TestClientFactory,\n) -> None:\n    app = Response(media_type=\"text/plain; charset=utf-8\")\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.headers[\"content-type\"] == \"text/plain; charset=utf-8\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.headers['content-type'] == 'text/plain; charset=utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_file_response_known_size",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 473,
      "end_line_number": 481,
      "source_code": "def test_file_response_known_size(tmp_path: Path, test_client_factory: TestClientFactory) -> None:\n    path = tmp_path / \"xyz\"\n    content = b\"<file content>\" * 1000\n    path.write_bytes(content)\n\n    app = FileResponse(path=path, filename=\"example.png\")\n    client: TestClient = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.headers[\"content-length\"] == str(len(content))",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmp_path",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.headers['content-length'] == str(len(content))"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_streaming_response_unknown_size",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 484,
      "end_line_number": 490,
      "source_code": "def test_streaming_response_unknown_size(\n    test_client_factory: TestClientFactory,\n) -> None:\n    app = StreamingResponse(content=iter([\"hello\", \"world\"]))\n    client: TestClient = test_client_factory(app)\n    response = client.get(\"/\")\n    assert \"content-length\" not in response.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'content-length' not in response.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_streaming_response_known_size",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 493,
      "end_line_number": 497,
      "source_code": "def test_streaming_response_known_size(test_client_factory: TestClientFactory) -> None:\n    app = StreamingResponse(content=iter([\"hello\", \"world\"]), headers={\"content-length\": \"10\"})\n    client: TestClient = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.headers[\"content-length\"] == \"10\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.headers['content-length'] == '10'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_response_memoryview",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 500,
      "end_line_number": 504,
      "source_code": "def test_response_memoryview(test_client_factory: TestClientFactory) -> None:\n    app = Response(content=memoryview(b\"\\xc0\"))\n    client: TestClient = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.content == b\"\\xc0\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.content == b'\\xc0'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_streaming_response_memoryview",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 507,
      "end_line_number": 511,
      "source_code": "def test_streaming_response_memoryview(test_client_factory: TestClientFactory) -> None:\n    app = StreamingResponse(content=iter([memoryview(b\"\\xc0\"), memoryview(b\"\\xf5\")]))\n    client: TestClient = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.content == b\"\\xc0\\xf5\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.content == b'\\xc0\\xf5'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_file_response_without_range",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 568,
      "end_line_number": 572,
      "source_code": "def test_file_response_without_range(file_response_client: TestClient) -> None:\n    response = file_response_client.get(\"/\")\n    assert response.status_code == 200\n    assert response.headers[\"content-length\"] == str(len(README.encode(\"utf8\")))\n    assert response.text == README",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "file_response_client"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.headers['content-length'] == str(len(README.encode('utf8')))",
        "assert response.text == README"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "file_response_client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_file_response_head",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 575,
      "end_line_number": 579,
      "source_code": "def test_file_response_head(file_response_client: TestClient) -> None:\n    response = file_response_client.head(\"/\")\n    assert response.status_code == 200\n    assert response.headers[\"content-length\"] == str(len(README.encode(\"utf8\")))\n    assert response.content == b\"\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "file_response_client"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.headers['content-length'] == str(len(README.encode('utf8')))",
        "assert response.content == b''"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_file_response_range",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 582,
      "end_line_number": 587,
      "source_code": "def test_file_response_range(file_response_client: TestClient) -> None:\n    response = file_response_client.get(\"/\", headers={\"Range\": \"bytes=0-100\"})\n    assert response.status_code == 206\n    assert response.headers[\"content-range\"] == f\"bytes 0-100/{len(README.encode('utf8'))}\"\n    assert response.headers[\"content-length\"] == \"101\"\n    assert response.content == README.encode(\"utf8\")[:101]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "file_response_client"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 206",
        "assert response.headers['content-range'] == f\"bytes 0-100/{len(README.encode('utf8'))}\"",
        "assert response.headers['content-length'] == '101'",
        "assert response.content == README.encode('utf8')[:101]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "file_response_client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_file_response_range_head",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 590,
      "end_line_number": 594,
      "source_code": "def test_file_response_range_head(file_response_client: TestClient) -> None:\n    response = file_response_client.head(\"/\", headers={\"Range\": \"bytes=0-100\"})\n    assert response.status_code == 206\n    assert response.headers[\"content-length\"] == str(101)\n    assert response.content == b\"\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "file_response_client"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 206",
        "assert response.headers['content-length'] == str(101)",
        "assert response.content == b''"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_file_response_range_multi",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 597,
      "end_line_number": 601,
      "source_code": "def test_file_response_range_multi(file_response_client: TestClient) -> None:\n    response = file_response_client.get(\"/\", headers={\"Range\": \"bytes=0-100, 200-300\"})\n    assert response.status_code == 206\n    assert response.headers[\"content-range\"].startswith(\"multipart/byteranges; boundary=\")\n    assert response.headers[\"content-length\"] == \"439\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "file_response_client"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 206",
        "assert response.headers['content-range'].startswith('multipart/byteranges; boundary=')",
        "assert response.headers['content-length'] == '439'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "file_response_client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_file_response_range_multi_head",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 604,
      "end_line_number": 619,
      "source_code": "def test_file_response_range_multi_head(file_response_client: TestClient) -> None:\n    response = file_response_client.head(\"/\", headers={\"Range\": \"bytes=0-100, 200-300\"})\n    assert response.status_code == 206\n    assert response.headers[\"content-length\"] == \"439\"\n    assert response.content == b\"\"\n\n    response = file_response_client.head(\n        \"/\",\n        headers={\"Range\": \"bytes=200-300\", \"if-range\": response.headers[\"etag\"][:-1]},\n    )\n    assert response.status_code == 200\n    response = file_response_client.head(\n        \"/\",\n        headers={\"Range\": \"bytes=200-300\", \"if-range\": response.headers[\"etag\"]},\n    )\n    assert response.status_code == 206",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "file_response_client"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 206",
        "assert response.headers['content-length'] == '439'",
        "assert response.content == b''",
        "assert response.status_code == 200",
        "assert response.status_code == 206"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_file_response_range_invalid",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 622,
      "end_line_number": 624,
      "source_code": "def test_file_response_range_invalid(file_response_client: TestClient) -> None:\n    response = file_response_client.head(\"/\", headers={\"Range\": \"bytes: 0-1000\"})\n    assert response.status_code == 400",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "file_response_client"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 400"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_file_response_range_head_max",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 627,
      "end_line_number": 629,
      "source_code": "def test_file_response_range_head_max(file_response_client: TestClient) -> None:\n    response = file_response_client.head(\"/\", headers={\"Range\": f\"bytes=0-{len(README.encode('utf8'))+1}\"})\n    assert response.status_code == 206",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "file_response_client"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 206"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_file_response_range_416",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 632,
      "end_line_number": 635,
      "source_code": "def test_file_response_range_416(file_response_client: TestClient) -> None:\n    response = file_response_client.head(\"/\", headers={\"Range\": f\"bytes={len(README.encode('utf8'))+1}-\"})\n    assert response.status_code == 416\n    assert response.headers[\"Content-Range\"] == f\"*/{len(README.encode('utf8'))}\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "file_response_client"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 416",
        "assert response.headers['Content-Range'] == f\"*/{len(README.encode('utf8'))}\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_file_response_only_support_bytes_range",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 638,
      "end_line_number": 641,
      "source_code": "def test_file_response_only_support_bytes_range(file_response_client: TestClient) -> None:\n    response = file_response_client.get(\"/\", headers={\"Range\": \"items=0-100\"})\n    assert response.status_code == 400\n    assert response.text == \"Only support bytes range\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "file_response_client"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 400",
        "assert response.text == 'Only support bytes range'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "file_response_client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_file_response_range_must_be_requested",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 644,
      "end_line_number": 647,
      "source_code": "def test_file_response_range_must_be_requested(file_response_client: TestClient) -> None:\n    response = file_response_client.get(\"/\", headers={\"Range\": \"bytes=\"})\n    assert response.status_code == 400\n    assert response.text == \"Range header: range must be requested\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "file_response_client"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 400",
        "assert response.text == 'Range header: range must be requested'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "file_response_client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_file_response_start_must_be_less_than_end",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 650,
      "end_line_number": 653,
      "source_code": "def test_file_response_start_must_be_less_than_end(file_response_client: TestClient) -> None:\n    response = file_response_client.get(\"/\", headers={\"Range\": \"bytes=100-0\"})\n    assert response.status_code == 400\n    assert response.text == \"Range header: start must be less than end\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "file_response_client"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 400",
        "assert response.text == 'Range header: start must be less than end'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "file_response_client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_file_response_merge_ranges",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 656,
      "end_line_number": 660,
      "source_code": "def test_file_response_merge_ranges(file_response_client: TestClient) -> None:\n    response = file_response_client.get(\"/\", headers={\"Range\": \"bytes=0-100, 50-200\"})\n    assert response.status_code == 206\n    assert response.headers[\"content-length\"] == \"201\"\n    assert response.headers[\"content-range\"] == f\"bytes 0-200/{len(README.encode('utf8'))}\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "file_response_client"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 206",
        "assert response.headers['content-length'] == '201'",
        "assert response.headers['content-range'] == f\"bytes 0-200/{len(README.encode('utf8'))}\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "file_response_client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_file_response_insert_ranges",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_responses.py",
      "line_number": 663,
      "end_line_number": 684,
      "source_code": "def test_file_response_insert_ranges(file_response_client: TestClient) -> None:\n    response = file_response_client.get(\"/\", headers={\"Range\": \"bytes=100-200, 0-50\"})\n\n    assert response.status_code == 206\n    assert response.headers[\"content-range\"].startswith(\"multipart/byteranges; boundary=\")\n    boundary = response.headers[\"content-range\"].split(\"boundary=\")[1]\n    assert response.text.splitlines() == [\n        f\"--{boundary}\",\n        \"Content-Type: text/plain; charset=utf-8\",\n        \"Content-Range: bytes 0-50/526\",\n        \"\",\n        \"# B\u00e1iZ\u00e9\",\n        \"\",\n        \"Powerful and exquisite WSGI/ASGI framewo\",\n        f\"--{boundary}\",\n        \"Content-Type: text/plain; charset=utf-8\",\n        \"Content-Range: bytes 100-200/526\",\n        \"\",\n        \"ds required in the Web framework. No redundant implementation means that you can freely customize fun\",\n        \"\",\n        f\"--{boundary}--\",\n    ]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "file_response_client"
      ],
      "imports": [
        "__future__.annotations",
        "datetime",
        "time",
        "http.cookies.SimpleCookie",
        "pathlib.Path",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Iterator",
        "anyio",
        "pytest",
        "starlette.status",
        "starlette.background.BackgroundTask",
        "starlette.datastructures.Headers",
        "starlette.requests.Request",
        "starlette.responses.FileResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.testclient.TestClient",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 206",
        "assert response.headers['content-range'].startswith('multipart/byteranges; boundary=')",
        "assert response.text.splitlines() == [f'--{boundary}', 'Content-Type: text/plain; charset=utf-8', 'Content-Range: bytes 0-50/526', '', '# B\u00e1iZ\u00e9', '', 'Powerful and exquisite WSGI/ASGI framewo', f'--{boundary}', 'Content-Type: text/plain; charset=utf-8', 'Content-Range: bytes 100-200/526', '', 'ds required in the Web framework. No redundant implementation means that you can freely customize fun', '', f'--{boundary}--']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "file_response_client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_http_endpoint_route",
      "module": "test_endpoints",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_endpoints.py",
      "line_number": 31,
      "end_line_number": 34,
      "source_code": "def test_http_endpoint_route(client: TestClient) -> None:\n    response = client.get(\"/\")\n    assert response.status_code == 200\n    assert response.text == \"Hello, world!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "client"
      ],
      "imports": [
        "typing.Iterator",
        "pytest",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.endpoints.WebSocketEndpoint",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.testclient.TestClient",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == 'Hello, world!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_http_endpoint_route_path_params",
      "module": "test_endpoints",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_endpoints.py",
      "line_number": 37,
      "end_line_number": 40,
      "source_code": "def test_http_endpoint_route_path_params(client: TestClient) -> None:\n    response = client.get(\"/tomchristie\")\n    assert response.status_code == 200\n    assert response.text == \"Hello, tomchristie!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "client"
      ],
      "imports": [
        "typing.Iterator",
        "pytest",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.endpoints.WebSocketEndpoint",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.testclient.TestClient",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == 'Hello, tomchristie!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_http_endpoint_route_method",
      "module": "test_endpoints",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_endpoints.py",
      "line_number": 43,
      "end_line_number": 47,
      "source_code": "def test_http_endpoint_route_method(client: TestClient) -> None:\n    response = client.post(\"/\")\n    assert response.status_code == 405\n    assert response.text == \"Method Not Allowed\"\n    assert response.headers[\"allow\"] == \"GET\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "client"
      ],
      "imports": [
        "typing.Iterator",
        "pytest",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.endpoints.WebSocketEndpoint",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.testclient.TestClient",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 405",
        "assert response.text == 'Method Not Allowed'",
        "assert response.headers['allow'] == 'GET'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_websocket_endpoint_on_connect",
      "module": "test_endpoints",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_endpoints.py",
      "line_number": 50,
      "end_line_number": 58,
      "source_code": "def test_websocket_endpoint_on_connect(test_client_factory: TestClientFactory) -> None:\n    class WebSocketApp(WebSocketEndpoint):\n        async def on_connect(self, websocket: WebSocket) -> None:\n            assert websocket[\"subprotocols\"] == [\"soap\", \"wamp\"]\n            await websocket.accept(subprotocol=\"wamp\")\n\n    client = test_client_factory(WebSocketApp)\n    with client.websocket_connect(\"/ws\", subprotocols=[\"soap\", \"wamp\"]) as websocket:\n        assert websocket.accepted_subprotocol == \"wamp\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "typing.Iterator",
        "pytest",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.endpoints.WebSocketEndpoint",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.testclient.TestClient",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert websocket.accepted_subprotocol == 'wamp'",
        "assert websocket['subprotocols'] == ['soap', 'wamp']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_websocket_endpoint_on_receive_bytes",
      "module": "test_endpoints",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_endpoints.py",
      "line_number": 61,
      "end_line_number": 78,
      "source_code": "def test_websocket_endpoint_on_receive_bytes(\n    test_client_factory: TestClientFactory,\n) -> None:\n    class WebSocketApp(WebSocketEndpoint):\n        encoding = \"bytes\"\n\n        async def on_receive(self, websocket: WebSocket, data: bytes) -> None:\n            await websocket.send_bytes(b\"Message bytes was: \" + data)\n\n    client = test_client_factory(WebSocketApp)\n    with client.websocket_connect(\"/ws\") as websocket:\n        websocket.send_bytes(b\"Hello, world!\")\n        _bytes = websocket.receive_bytes()\n        assert _bytes == b\"Message bytes was: Hello, world!\"\n\n    with pytest.raises(RuntimeError):\n        with client.websocket_connect(\"/ws\") as websocket:\n            websocket.send_text(\"Hello world\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "typing.Iterator",
        "pytest",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.endpoints.WebSocketEndpoint",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.testclient.TestClient",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert _bytes == b'Message bytes was: Hello, world!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_websocket_endpoint_on_receive_json",
      "module": "test_endpoints",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_endpoints.py",
      "line_number": 81,
      "end_line_number": 98,
      "source_code": "def test_websocket_endpoint_on_receive_json(\n    test_client_factory: TestClientFactory,\n) -> None:\n    class WebSocketApp(WebSocketEndpoint):\n        encoding = \"json\"\n\n        async def on_receive(self, websocket: WebSocket, data: str) -> None:\n            await websocket.send_json({\"message\": data})\n\n    client = test_client_factory(WebSocketApp)\n    with client.websocket_connect(\"/ws\") as websocket:\n        websocket.send_json({\"hello\": \"world\"})\n        data = websocket.receive_json()\n        assert data == {\"message\": {\"hello\": \"world\"}}\n\n    with pytest.raises(RuntimeError):\n        with client.websocket_connect(\"/ws\") as websocket:\n            websocket.send_text(\"Hello world\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "typing.Iterator",
        "pytest",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.endpoints.WebSocketEndpoint",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.testclient.TestClient",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert data == {'message': {'hello': 'world'}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_websocket_endpoint_on_receive_json_binary",
      "module": "test_endpoints",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_endpoints.py",
      "line_number": 101,
      "end_line_number": 114,
      "source_code": "def test_websocket_endpoint_on_receive_json_binary(\n    test_client_factory: TestClientFactory,\n) -> None:\n    class WebSocketApp(WebSocketEndpoint):\n        encoding = \"json\"\n\n        async def on_receive(self, websocket: WebSocket, data: str) -> None:\n            await websocket.send_json({\"message\": data}, mode=\"binary\")\n\n    client = test_client_factory(WebSocketApp)\n    with client.websocket_connect(\"/ws\") as websocket:\n        websocket.send_json({\"hello\": \"world\"}, mode=\"binary\")\n        data = websocket.receive_json(mode=\"binary\")\n        assert data == {\"message\": {\"hello\": \"world\"}}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "typing.Iterator",
        "pytest",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.endpoints.WebSocketEndpoint",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.testclient.TestClient",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert data == {'message': {'hello': 'world'}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_websocket_endpoint_on_receive_text",
      "module": "test_endpoints",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_endpoints.py",
      "line_number": 117,
      "end_line_number": 134,
      "source_code": "def test_websocket_endpoint_on_receive_text(\n    test_client_factory: TestClientFactory,\n) -> None:\n    class WebSocketApp(WebSocketEndpoint):\n        encoding = \"text\"\n\n        async def on_receive(self, websocket: WebSocket, data: str) -> None:\n            await websocket.send_text(f\"Message text was: {data}\")\n\n    client = test_client_factory(WebSocketApp)\n    with client.websocket_connect(\"/ws\") as websocket:\n        websocket.send_text(\"Hello, world!\")\n        _text = websocket.receive_text()\n        assert _text == \"Message text was: Hello, world!\"\n\n    with pytest.raises(RuntimeError):\n        with client.websocket_connect(\"/ws\") as websocket:\n            websocket.send_bytes(b\"Hello world\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "typing.Iterator",
        "pytest",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.endpoints.WebSocketEndpoint",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.testclient.TestClient",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert _text == 'Message text was: Hello, world!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_websocket_endpoint_on_default",
      "module": "test_endpoints",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_endpoints.py",
      "line_number": 137,
      "end_line_number": 148,
      "source_code": "def test_websocket_endpoint_on_default(test_client_factory: TestClientFactory) -> None:\n    class WebSocketApp(WebSocketEndpoint):\n        encoding = None\n\n        async def on_receive(self, websocket: WebSocket, data: str) -> None:\n            await websocket.send_text(f\"Message text was: {data}\")\n\n    client = test_client_factory(WebSocketApp)\n    with client.websocket_connect(\"/ws\") as websocket:\n        websocket.send_text(\"Hello, world!\")\n        _text = websocket.receive_text()\n        assert _text == \"Message text was: Hello, world!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "typing.Iterator",
        "pytest",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.endpoints.WebSocketEndpoint",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.testclient.TestClient",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert _text == 'Message text was: Hello, world!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_websocket_endpoint_on_disconnect",
      "module": "test_endpoints",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_endpoints.py",
      "line_number": 151,
      "end_line_number": 161,
      "source_code": "def test_websocket_endpoint_on_disconnect(\n    test_client_factory: TestClientFactory,\n) -> None:\n    class WebSocketApp(WebSocketEndpoint):\n        async def on_disconnect(self, websocket: WebSocket, close_code: int) -> None:\n            assert close_code == 1001\n            await websocket.close(code=close_code)\n\n    client = test_client_factory(WebSocketApp)\n    with client.websocket_connect(\"/ws\") as websocket:\n        websocket.close(code=1001)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "typing.Iterator",
        "pytest",
        "starlette.endpoints.HTTPEndpoint",
        "starlette.endpoints.WebSocketEndpoint",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.testclient.TestClient",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert close_code == 1001"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_datetime_convertor",
      "module": "test_convertors",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_convertors.py",
      "line_number": 51,
      "end_line_number": 58,
      "source_code": "def test_datetime_convertor(test_client_factory: TestClientFactory, app: Router) -> None:\n    client = test_client_factory(app)\n    response = client.get(\"/datetime/2020-01-01T00:00:00\")\n    assert response.json() == {\"datetime\": \"2020-01-01T00:00:00\"}\n\n    assert (\n        app.url_path_for(\"datetime-convertor\", param=datetime(1996, 1, 22, 23, 0, 0)) == \"/datetime/1996-01-22T23:00:00\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory",
        "app"
      ],
      "imports": [
        "datetime.datetime",
        "typing.Iterator",
        "pytest",
        "starlette.convertors",
        "starlette.convertors.Convertor",
        "starlette.convertors.register_url_convertor",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'datetime': '2020-01-01T00:00:00'}",
        "assert app.url_path_for('datetime-convertor', param=datetime(1996, 1, 22, 23, 0, 0)) == '/datetime/1996-01-22T23:00:00'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_default_float_convertor",
      "module": "test_convertors",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_convertors.py",
      "line_number": 62,
      "end_line_number": 72,
      "source_code": "def test_default_float_convertor(test_client_factory: TestClientFactory, param: str, status_code: int) -> None:\n    def float_convertor(request: Request) -> JSONResponse:\n        param = request.path_params[\"param\"]\n        assert isinstance(param, float)\n        return JSONResponse({\"float\": param})\n\n    app = Router(routes=[Route(\"/{param:float}\", endpoint=float_convertor)])\n\n    client = test_client_factory(app)\n    response = client.get(f\"/{param}\")\n    assert response.status_code == status_code",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('param, status_code', [('1.0', 200), ('1-0', 404)])"
      ],
      "arguments": [
        "test_client_factory",
        "param",
        "status_code"
      ],
      "imports": [
        "datetime.datetime",
        "typing.Iterator",
        "pytest",
        "starlette.convertors",
        "starlette.convertors.Convertor",
        "starlette.convertors.register_url_convertor",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == status_code",
        "assert isinstance(param, float)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_not_acceptable",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_exceptions.py",
      "line_number": 83,
      "end_line_number": 86,
      "source_code": "def test_not_acceptable(client: TestClient) -> None:\n    response = client.get(\"/not_acceptable\")\n    assert response.status_code == 406\n    assert response.text == \"Not Acceptable\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "client"
      ],
      "imports": [
        "warnings",
        "typing.Generator",
        "pytest",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.exceptions.ExceptionMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.exceptions.ExceptionMiddleware",
        "starlette.exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 406",
        "assert response.text == 'Not Acceptable'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_no_content",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_exceptions.py",
      "line_number": 89,
      "end_line_number": 92,
      "source_code": "def test_no_content(client: TestClient) -> None:\n    response = client.get(\"/no_content\")\n    assert response.status_code == 204\n    assert \"content-length\" not in response.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "client"
      ],
      "imports": [
        "warnings",
        "typing.Generator",
        "pytest",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.exceptions.ExceptionMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.exceptions.ExceptionMiddleware",
        "starlette.exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 204",
        "assert 'content-length' not in response.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_not_modified",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_exceptions.py",
      "line_number": 95,
      "end_line_number": 98,
      "source_code": "def test_not_modified(client: TestClient) -> None:\n    response = client.get(\"/not_modified\")\n    assert response.status_code == 304\n    assert response.text == \"\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "client"
      ],
      "imports": [
        "warnings",
        "typing.Generator",
        "pytest",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.exceptions.ExceptionMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.exceptions.ExceptionMiddleware",
        "starlette.exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 304",
        "assert response.text == ''"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_with_headers",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_exceptions.py",
      "line_number": 101,
      "end_line_number": 104,
      "source_code": "def test_with_headers(client: TestClient) -> None:\n    response = client.get(\"/with_headers\")\n    assert response.status_code == 200\n    assert response.headers[\"x-potato\"] == \"always\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "client"
      ],
      "imports": [
        "warnings",
        "typing.Generator",
        "pytest",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.exceptions.ExceptionMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.exceptions.ExceptionMiddleware",
        "starlette.exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.headers['x-potato'] == 'always'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_websockets_should_raise",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_exceptions.py",
      "line_number": 107,
      "end_line_number": 110,
      "source_code": "def test_websockets_should_raise(client: TestClient) -> None:\n    with pytest.raises(RuntimeError):\n        with client.websocket_connect(\"/runtime_error\"):\n            pass",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "client"
      ],
      "imports": [
        "warnings",
        "typing.Generator",
        "pytest",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.exceptions.ExceptionMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.exceptions.ExceptionMiddleware",
        "starlette.exceptions"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_handled_exc_after_response",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_exceptions.py",
      "line_number": 113,
      "end_line_number": 124,
      "source_code": "def test_handled_exc_after_response(test_client_factory: TestClientFactory, client: TestClient) -> None:\n    # A 406 HttpException is raised *after* the response has already been sent.\n    # The exception middleware should raise a RuntimeError.\n    with pytest.raises(RuntimeError, match=\"Caught handled exception, but response already started.\"):\n        client.get(\"/handled_exc_after_response\")\n\n    # If `raise_server_exceptions=False` then the test client will still allow\n    # us to see the response as it will have been seen by the client.\n    allow_200_client = test_client_factory(app, raise_server_exceptions=False)\n    response = allow_200_client.get(\"/handled_exc_after_response\")\n    assert response.status_code == 200\n    assert response.text == \"OK\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory",
        "client"
      ],
      "imports": [
        "warnings",
        "typing.Generator",
        "pytest",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.exceptions.ExceptionMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.exceptions.ExceptionMiddleware",
        "starlette.exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == 'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "allow_200_client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_force_500_response",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_exceptions.py",
      "line_number": 127,
      "end_line_number": 142,
      "source_code": "def test_force_500_response(test_client_factory: TestClientFactory) -> None:\n    # use a sentinel variable to make sure we actually\n    # make it into the endpoint and don't get a 500\n    # from an incorrect ASGI app signature or something\n    called = False\n\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        nonlocal called\n        called = True\n        raise RuntimeError()\n\n    force_500_client = test_client_factory(app, raise_server_exceptions=False)\n    response = force_500_client.get(\"/\")\n    assert called\n    assert response.status_code == 500\n    assert response.text == \"\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "warnings",
        "typing.Generator",
        "pytest",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.exceptions.ExceptionMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.exceptions.ExceptionMiddleware",
        "starlette.exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert called",
        "assert response.status_code == 500",
        "assert response.text == ''"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "force_500_client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_http_str",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_exceptions.py",
      "line_number": 145,
      "end_line_number": 148,
      "source_code": "def test_http_str() -> None:\n    assert str(HTTPException(status_code=404)) == \"404: Not Found\"\n    assert str(HTTPException(404, \"Not Found: foo\")) == \"404: Not Found: foo\"\n    assert str(HTTPException(404, headers={\"key\": \"value\"})) == \"404: Not Found\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "warnings",
        "typing.Generator",
        "pytest",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.exceptions.ExceptionMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.exceptions.ExceptionMiddleware",
        "starlette.exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(HTTPException(status_code=404)) == '404: Not Found'",
        "assert str(HTTPException(404, 'Not Found: foo')) == '404: Not Found: foo'",
        "assert str(HTTPException(404, headers={'key': 'value'})) == '404: Not Found'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_http_repr",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_exceptions.py",
      "line_number": 151,
      "end_line_number": 162,
      "source_code": "def test_http_repr() -> None:\n    assert repr(HTTPException(404)) == (\"HTTPException(status_code=404, detail='Not Found')\")\n    assert repr(HTTPException(404, detail=\"Not Found: foo\")) == (\n        \"HTTPException(status_code=404, detail='Not Found: foo')\"\n    )\n\n    class CustomHTTPException(HTTPException):\n        pass\n\n    assert repr(CustomHTTPException(500, detail=\"Something custom\")) == (\n        \"CustomHTTPException(status_code=500, detail='Something custom')\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "warnings",
        "typing.Generator",
        "pytest",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.exceptions.ExceptionMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.exceptions.ExceptionMiddleware",
        "starlette.exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(HTTPException(404)) == \"HTTPException(status_code=404, detail='Not Found')\"",
        "assert repr(HTTPException(404, detail='Not Found: foo')) == \"HTTPException(status_code=404, detail='Not Found: foo')\"",
        "assert repr(CustomHTTPException(500, detail='Something custom')) == \"CustomHTTPException(status_code=500, detail='Something custom')\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_websocket_str",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_exceptions.py",
      "line_number": 165,
      "end_line_number": 167,
      "source_code": "def test_websocket_str() -> None:\n    assert str(WebSocketException(1008)) == \"1008: \"\n    assert str(WebSocketException(1008, \"Policy Violation\")) == \"1008: Policy Violation\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "warnings",
        "typing.Generator",
        "pytest",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.exceptions.ExceptionMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.exceptions.ExceptionMiddleware",
        "starlette.exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(WebSocketException(1008)) == '1008: '",
        "assert str(WebSocketException(1008, 'Policy Violation')) == '1008: Policy Violation'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_websocket_repr",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_exceptions.py",
      "line_number": 170,
      "end_line_number": 181,
      "source_code": "def test_websocket_repr() -> None:\n    assert repr(WebSocketException(1008, reason=\"Policy Violation\")) == (\n        \"WebSocketException(code=1008, reason='Policy Violation')\"\n    )\n\n    class CustomWebSocketException(WebSocketException):\n        pass\n\n    assert (\n        repr(CustomWebSocketException(1013, reason=\"Something custom\"))\n        == \"CustomWebSocketException(code=1013, reason='Something custom')\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "warnings",
        "typing.Generator",
        "pytest",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.exceptions.ExceptionMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.exceptions.ExceptionMiddleware",
        "starlette.exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(WebSocketException(1008, reason='Policy Violation')) == \"WebSocketException(code=1008, reason='Policy Violation')\"",
        "assert repr(CustomWebSocketException(1013, reason='Something custom')) == \"CustomWebSocketException(code=1013, reason='Something custom')\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_exception_middleware_deprecation",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_exceptions.py",
      "line_number": 184,
      "end_line_number": 194,
      "source_code": "def test_exception_middleware_deprecation() -> None:\n    # this test should be removed once the deprecation shim is removed\n    with pytest.warns(DeprecationWarning):\n        from starlette.exceptions import ExceptionMiddleware  # noqa: F401\n\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"error\")\n        import starlette.exceptions\n\n    with pytest.warns(DeprecationWarning):\n        starlette.exceptions.ExceptionMiddleware",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "warnings",
        "typing.Generator",
        "pytest",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.exceptions.ExceptionMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.exceptions.ExceptionMiddleware",
        "starlette.exceptions"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_request_in_app_and_handler_is_the_same_object",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_exceptions.py",
      "line_number": 197,
      "end_line_number": 200,
      "source_code": "def test_request_in_app_and_handler_is_the_same_object(client: TestClient) -> None:\n    response = client.post(\"/consume_body_in_endpoint_and_handler\", content=b\"Hello!\")\n    assert response.status_code == 422\n    assert response.json() == {\"body\": \"Hello!\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "client"
      ],
      "imports": [
        "warnings",
        "typing.Generator",
        "pytest",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "starlette.middleware.exceptions.ExceptionMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory",
        "starlette.exceptions.ExceptionMiddleware",
        "starlette.exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 422",
        "assert response.json() == {'body': 'Hello!'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_templates",
      "module": "test_templates",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_templates.py",
      "line_number": 21,
      "end_line_number": 36,
      "source_code": "def test_templates(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    path = os.path.join(tmpdir, \"index.html\")\n    with open(path, \"w\") as file:\n        file.write(\"<html>Hello, <a href='{{ url_for('homepage') }}'>world</a></html>\")\n\n    async def homepage(request: Request) -> Response:\n        return templates.TemplateResponse(request, \"index.html\")\n\n    app = Starlette(debug=True, routes=[Route(\"/\", endpoint=homepage)])\n    templates = Jinja2Templates(directory=str(tmpdir))\n\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.text == \"<html>Hello, <a href='http://testserver/'>world</a></html>\"\n    assert response.template.name == \"index.html\"  # type: ignore\n    assert set(response.context.keys()) == {\"request\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "pathlib.Path",
        "unittest.mock",
        "jinja2",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.background.BackgroundTask",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.templating.Jinja2Templates",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == \"<html>Hello, <a href='http://testserver/'>world</a></html>\"",
        "assert response.template.name == 'index.html'",
        "assert set(response.context.keys()) == {'request'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_calls_context_processors",
      "module": "test_templates",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_templates.py",
      "line_number": 39,
      "end_line_number": 64,
      "source_code": "def test_calls_context_processors(tmp_path: Path, test_client_factory: TestClientFactory) -> None:\n    path = tmp_path / \"index.html\"\n    path.write_text(\"<html>Hello {{ username }}</html>\")\n\n    async def homepage(request: Request) -> Response:\n        return templates.TemplateResponse(request, \"index.html\")\n\n    def hello_world_processor(request: Request) -> dict[str, str]:\n        return {\"username\": \"World\"}\n\n    app = Starlette(\n        debug=True,\n        routes=[Route(\"/\", endpoint=homepage)],\n    )\n    templates = Jinja2Templates(\n        directory=tmp_path,\n        context_processors=[\n            hello_world_processor,\n        ],\n    )\n\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.text == \"<html>Hello World</html>\"\n    assert response.template.name == \"index.html\"  # type: ignore\n    assert set(response.context.keys()) == {\"request\", \"username\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmp_path",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "pathlib.Path",
        "unittest.mock",
        "jinja2",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.background.BackgroundTask",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.templating.Jinja2Templates",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == '<html>Hello World</html>'",
        "assert response.template.name == 'index.html'",
        "assert set(response.context.keys()) == {'request', 'username'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_template_with_middleware",
      "module": "test_templates",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_templates.py",
      "line_number": 67,
      "end_line_number": 90,
      "source_code": "def test_template_with_middleware(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    path = os.path.join(tmpdir, \"index.html\")\n    with open(path, \"w\") as file:\n        file.write(\"<html>Hello, <a href='{{ url_for('homepage') }}'>world</a></html>\")\n\n    async def homepage(request: Request) -> Response:\n        return templates.TemplateResponse(request, \"index.html\")\n\n    class CustomMiddleware(BaseHTTPMiddleware):\n        async def dispatch(self, request: Request, call_next: RequestResponseEndpoint) -> Response:\n            return await call_next(request)\n\n    app = Starlette(\n        debug=True,\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[Middleware(CustomMiddleware)],\n    )\n    templates = Jinja2Templates(directory=str(tmpdir))\n\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.text == \"<html>Hello, <a href='http://testserver/'>world</a></html>\"\n    assert response.template.name == \"index.html\"  # type: ignore\n    assert set(response.context.keys()) == {\"request\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "pathlib.Path",
        "unittest.mock",
        "jinja2",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.background.BackgroundTask",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.templating.Jinja2Templates",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == \"<html>Hello, <a href='http://testserver/'>world</a></html>\"",
        "assert response.template.name == 'index.html'",
        "assert set(response.context.keys()) == {'request'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_templates_with_directories",
      "module": "test_templates",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_templates.py",
      "line_number": 93,
      "end_line_number": 125,
      "source_code": "def test_templates_with_directories(tmp_path: Path, test_client_factory: TestClientFactory) -> None:\n    dir_a = tmp_path.resolve() / \"a\"\n    dir_a.mkdir()\n    template_a = dir_a / \"template_a.html\"\n    template_a.write_text(\"<html><a href='{{ url_for('page_a') }}'></a> a</html>\")\n\n    async def page_a(request: Request) -> Response:\n        return templates.TemplateResponse(request, \"template_a.html\")\n\n    dir_b = tmp_path.resolve() / \"b\"\n    dir_b.mkdir()\n    template_b = dir_b / \"template_b.html\"\n    template_b.write_text(\"<html><a href='{{ url_for('page_b') }}'></a> b</html>\")\n\n    async def page_b(request: Request) -> Response:\n        return templates.TemplateResponse(request, \"template_b.html\")\n\n    app = Starlette(\n        debug=True,\n        routes=[Route(\"/a\", endpoint=page_a), Route(\"/b\", endpoint=page_b)],\n    )\n    templates = Jinja2Templates(directory=[dir_a, dir_b])\n\n    client = test_client_factory(app)\n    response = client.get(\"/a\")\n    assert response.text == \"<html><a href='http://testserver/a'></a> a</html>\"\n    assert response.template.name == \"template_a.html\"  # type: ignore\n    assert set(response.context.keys()) == {\"request\"}  # type: ignore\n\n    response = client.get(\"/b\")\n    assert response.text == \"<html><a href='http://testserver/b'></a> b</html>\"\n    assert response.template.name == \"template_b.html\"  # type: ignore\n    assert set(response.context.keys()) == {\"request\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmp_path",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "pathlib.Path",
        "unittest.mock",
        "jinja2",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.background.BackgroundTask",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.templating.Jinja2Templates",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == \"<html><a href='http://testserver/a'></a> a</html>\"",
        "assert response.template.name == 'template_a.html'",
        "assert set(response.context.keys()) == {'request'}",
        "assert response.text == \"<html><a href='http://testserver/b'></a> b</html>\"",
        "assert response.template.name == 'template_b.html'",
        "assert set(response.context.keys()) == {'request'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_templates_require_directory_or_environment",
      "module": "test_templates",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_templates.py",
      "line_number": 128,
      "end_line_number": 130,
      "source_code": "def test_templates_require_directory_or_environment() -> None:\n    with pytest.raises(AssertionError, match=\"either 'directory' or 'env' arguments must be passed\"):\n        Jinja2Templates()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "os",
        "pathlib.Path",
        "unittest.mock",
        "jinja2",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.background.BackgroundTask",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.templating.Jinja2Templates",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_templates_require_directory_or_enviroment_not_both",
      "module": "test_templates",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_templates.py",
      "line_number": 133,
      "end_line_number": 135,
      "source_code": "def test_templates_require_directory_or_enviroment_not_both() -> None:\n    with pytest.raises(AssertionError, match=\"either 'directory' or 'env' arguments must be passed\"):\n        Jinja2Templates(directory=\"dir\", env=jinja2.Environment())",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "os",
        "pathlib.Path",
        "unittest.mock",
        "jinja2",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.background.BackgroundTask",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.templating.Jinja2Templates",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_templates_with_directory",
      "module": "test_templates",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_templates.py",
      "line_number": 138,
      "end_line_number": 145,
      "source_code": "def test_templates_with_directory(tmpdir: Path) -> None:\n    path = os.path.join(tmpdir, \"index.html\")\n    with open(path, \"w\") as file:\n        file.write(\"Hello\")\n\n    templates = Jinja2Templates(directory=str(tmpdir))\n    template = templates.get_template(\"index.html\")\n    assert template.render({}) == \"Hello\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "pathlib.Path",
        "unittest.mock",
        "jinja2",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.background.BackgroundTask",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.templating.Jinja2Templates",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert template.render({}) == 'Hello'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_templates_with_environment",
      "module": "test_templates",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_templates.py",
      "line_number": 148,
      "end_line_number": 166,
      "source_code": "def test_templates_with_environment(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    path = os.path.join(tmpdir, \"index.html\")\n    with open(path, \"w\") as file:\n        file.write(\"<html>Hello, <a href='{{ url_for('homepage') }}'>world</a></html>\")\n\n    async def homepage(request: Request) -> Response:\n        return templates.TemplateResponse(request, \"index.html\")\n\n    env = jinja2.Environment(loader=jinja2.FileSystemLoader(str(tmpdir)))\n    app = Starlette(\n        debug=True,\n        routes=[Route(\"/\", endpoint=homepage)],\n    )\n    templates = Jinja2Templates(env=env)\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.text == \"<html>Hello, <a href='http://testserver/'>world</a></html>\"\n    assert response.template.name == \"index.html\"  # type: ignore\n    assert set(response.context.keys()) == {\"request\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "pathlib.Path",
        "unittest.mock",
        "jinja2",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.background.BackgroundTask",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.templating.Jinja2Templates",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == \"<html>Hello, <a href='http://testserver/'>world</a></html>\"",
        "assert response.template.name == 'index.html'",
        "assert set(response.context.keys()) == {'request'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_templates_with_environment_options_emit_warning",
      "module": "test_templates",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_templates.py",
      "line_number": 169,
      "end_line_number": 171,
      "source_code": "def test_templates_with_environment_options_emit_warning(tmpdir: Path) -> None:\n    with pytest.warns(DeprecationWarning):\n        Jinja2Templates(str(tmpdir), autoescape=True)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "pathlib.Path",
        "unittest.mock",
        "jinja2",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.background.BackgroundTask",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.templating.Jinja2Templates",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_templates_with_kwargs_only",
      "module": "test_templates",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_templates.py",
      "line_number": 174,
      "end_line_number": 202,
      "source_code": "def test_templates_with_kwargs_only(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    # MAINTAINERS: remove after 1.0\n    path = os.path.join(tmpdir, \"index.html\")\n    with open(path, \"w\") as file:\n        file.write(\"value: {{ a }}\")\n    templates = Jinja2Templates(directory=str(tmpdir))\n\n    spy = mock.MagicMock()\n\n    def page(request: Request) -> Response:\n        return templates.TemplateResponse(\n            request=request,\n            name=\"index.html\",\n            context={\"a\": \"b\"},\n            status_code=201,\n            headers={\"x-key\": \"value\"},\n            media_type=\"text/plain\",\n            background=BackgroundTask(func=spy),\n        )\n\n    app = Starlette(routes=[Route(\"/\", page)])\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n\n    assert response.text == \"value: b\"  # context was rendered\n    assert response.status_code == 201\n    assert response.headers[\"x-key\"] == \"value\"\n    assert response.headers[\"content-type\"] == \"text/plain; charset=utf-8\"\n    spy.assert_called()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "pathlib.Path",
        "unittest.mock",
        "jinja2",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.background.BackgroundTask",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.templating.Jinja2Templates",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'value: b'",
        "assert response.status_code == 201",
        "assert response.headers['x-key'] == 'value'",
        "assert response.headers['content-type'] == 'text/plain; charset=utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.MagicMock()"
      ],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_templates_with_kwargs_only_requires_request_in_context",
      "module": "test_templates",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_templates.py",
      "line_number": 205,
      "end_line_number": 214,
      "source_code": "def test_templates_with_kwargs_only_requires_request_in_context(tmpdir: Path) -> None:\n    # MAINTAINERS: remove after 1.0\n\n    templates = Jinja2Templates(directory=str(tmpdir))\n    with pytest.warns(\n        DeprecationWarning,\n        match=\"requires the `request` argument\",\n    ):\n        with pytest.raises(ValueError):\n            templates.TemplateResponse(name=\"index.html\", context={\"a\": \"b\"})",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "pathlib.Path",
        "unittest.mock",
        "jinja2",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.background.BackgroundTask",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.templating.Jinja2Templates",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_templates_with_kwargs_only_warns_when_no_request_keyword",
      "module": "test_templates",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_templates.py",
      "line_number": 217,
      "end_line_number": 238,
      "source_code": "def test_templates_with_kwargs_only_warns_when_no_request_keyword(\n    tmpdir: Path, test_client_factory: TestClientFactory\n) -> None:\n    # MAINTAINERS: remove after 1.0\n\n    path = os.path.join(tmpdir, \"index.html\")\n    with open(path, \"w\") as file:\n        file.write(\"Hello\")\n\n    templates = Jinja2Templates(directory=str(tmpdir))\n\n    def page(request: Request) -> Response:\n        return templates.TemplateResponse(name=\"index.html\", context={\"request\": request})\n\n    app = Starlette(routes=[Route(\"/\", page)])\n    client = test_client_factory(app)\n\n    with pytest.warns(\n        DeprecationWarning,\n        match=\"requires the `request` argument\",\n    ):\n        client.get(\"/\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "pathlib.Path",
        "unittest.mock",
        "jinja2",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.background.BackgroundTask",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.templating.Jinja2Templates",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_templates_with_requires_request_in_context",
      "module": "test_templates",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_templates.py",
      "line_number": 241,
      "end_line_number": 246,
      "source_code": "def test_templates_with_requires_request_in_context(tmpdir: Path) -> None:\n    # MAINTAINERS: remove after 1.0\n    templates = Jinja2Templates(directory=str(tmpdir))\n    with pytest.warns(DeprecationWarning):\n        with pytest.raises(ValueError):\n            templates.TemplateResponse(\"index.html\", context={})",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "pathlib.Path",
        "unittest.mock",
        "jinja2",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.background.BackgroundTask",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.templating.Jinja2Templates",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_templates_warns_when_first_argument_isnot_request",
      "module": "test_templates",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_templates.py",
      "line_number": 249,
      "end_line_number": 279,
      "source_code": "def test_templates_warns_when_first_argument_isnot_request(\n    tmpdir: Path, test_client_factory: TestClientFactory\n) -> None:\n    # MAINTAINERS: remove after 1.0\n    path = os.path.join(tmpdir, \"index.html\")\n    with open(path, \"w\") as file:\n        file.write(\"value: {{ a }}\")\n    templates = Jinja2Templates(directory=str(tmpdir))\n\n    spy = mock.MagicMock()\n\n    def page(request: Request) -> Response:\n        return templates.TemplateResponse(\n            \"index.html\",\n            {\"a\": \"b\", \"request\": request},\n            status_code=201,\n            headers={\"x-key\": \"value\"},\n            media_type=\"text/plain\",\n            background=BackgroundTask(func=spy),\n        )\n\n    app = Starlette(routes=[Route(\"/\", page)])\n    client = test_client_factory(app)\n    with pytest.warns(DeprecationWarning):\n        response = client.get(\"/\")\n\n    assert response.text == \"value: b\"  # context was rendered\n    assert response.status_code == 201\n    assert response.headers[\"x-key\"] == \"value\"\n    assert response.headers[\"content-type\"] == \"text/plain; charset=utf-8\"\n    spy.assert_called()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "pathlib.Path",
        "unittest.mock",
        "jinja2",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.background.BackgroundTask",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.templating.Jinja2Templates",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'value: b'",
        "assert response.status_code == 201",
        "assert response.headers['x-key'] == 'value'",
        "assert response.headers['content-type'] == 'text/plain; charset=utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.MagicMock()"
      ],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_templates_when_first_argument_is_request",
      "module": "test_templates",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_templates.py",
      "line_number": 282,
      "end_line_number": 310,
      "source_code": "def test_templates_when_first_argument_is_request(tmpdir: Path, test_client_factory: TestClientFactory) -> None:\n    # MAINTAINERS: remove after 1.0\n    path = os.path.join(tmpdir, \"index.html\")\n    with open(path, \"w\") as file:\n        file.write(\"value: {{ a }}\")\n    templates = Jinja2Templates(directory=str(tmpdir))\n\n    spy = mock.MagicMock()\n\n    def page(request: Request) -> Response:\n        return templates.TemplateResponse(\n            request,\n            \"index.html\",\n            {\"a\": \"b\"},\n            status_code=201,\n            headers={\"x-key\": \"value\"},\n            media_type=\"text/plain\",\n            background=BackgroundTask(func=spy),\n        )\n\n    app = Starlette(routes=[Route(\"/\", page)])\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n\n    assert response.text == \"value: b\"  # context was rendered\n    assert response.status_code == 201\n    assert response.headers[\"x-key\"] == \"value\"\n    assert response.headers[\"content-type\"] == \"text/plain; charset=utf-8\"\n    spy.assert_called()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmpdir",
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "os",
        "pathlib.Path",
        "unittest.mock",
        "jinja2",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.background.BackgroundTask",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.templating.Jinja2Templates",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'value: b'",
        "assert response.status_code == 201",
        "assert response.headers['x-key'] == 'value'",
        "assert response.headers['content-type'] == 'text/plain; charset=utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.MagicMock()"
      ],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_async_task",
      "module": "test_background",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_background.py",
      "line_number": 9,
      "end_line_number": 25,
      "source_code": "def test_async_task(test_client_factory: TestClientFactory) -> None:\n    TASK_COMPLETE = False\n\n    async def async_task() -> None:\n        nonlocal TASK_COMPLETE\n        TASK_COMPLETE = True\n\n    task = BackgroundTask(async_task)\n\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        response = Response(\"task initiated\", media_type=\"text/plain\", background=task)\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.text == \"task initiated\"\n    assert TASK_COMPLETE",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "pytest",
        "starlette.background.BackgroundTask",
        "starlette.background.BackgroundTasks",
        "starlette.responses.Response",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'task initiated'",
        "assert TASK_COMPLETE"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_sync_task",
      "module": "test_background",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_background.py",
      "line_number": 28,
      "end_line_number": 44,
      "source_code": "def test_sync_task(test_client_factory: TestClientFactory) -> None:\n    TASK_COMPLETE = False\n\n    def sync_task() -> None:\n        nonlocal TASK_COMPLETE\n        TASK_COMPLETE = True\n\n    task = BackgroundTask(sync_task)\n\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        response = Response(\"task initiated\", media_type=\"text/plain\", background=task)\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.text == \"task initiated\"\n    assert TASK_COMPLETE",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "pytest",
        "starlette.background.BackgroundTask",
        "starlette.background.BackgroundTasks",
        "starlette.responses.Response",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'task initiated'",
        "assert TASK_COMPLETE"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_multiple_tasks",
      "module": "test_background",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_background.py",
      "line_number": 47,
      "end_line_number": 65,
      "source_code": "def test_multiple_tasks(test_client_factory: TestClientFactory) -> None:\n    TASK_COUNTER = 0\n\n    def increment(amount: int) -> None:\n        nonlocal TASK_COUNTER\n        TASK_COUNTER += amount\n\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        tasks = BackgroundTasks()\n        tasks.add_task(increment, amount=1)\n        tasks.add_task(increment, amount=2)\n        tasks.add_task(increment, amount=3)\n        response = Response(\"tasks initiated\", media_type=\"text/plain\", background=tasks)\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.text == \"tasks initiated\"\n    assert TASK_COUNTER == 1 + 2 + 3",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "pytest",
        "starlette.background.BackgroundTask",
        "starlette.background.BackgroundTasks",
        "starlette.responses.Response",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'tasks initiated'",
        "assert TASK_COUNTER == 1 + 2 + 3"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_multi_tasks_failure_avoids_next_execution",
      "module": "test_background",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_background.py",
      "line_number": 68,
      "end_line_number": 89,
      "source_code": "def test_multi_tasks_failure_avoids_next_execution(\n    test_client_factory: TestClientFactory,\n) -> None:\n    TASK_COUNTER = 0\n\n    def increment() -> None:\n        nonlocal TASK_COUNTER\n        TASK_COUNTER += 1\n        if TASK_COUNTER == 1:\n            raise Exception(\"task failed\")\n\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        tasks = BackgroundTasks()\n        tasks.add_task(increment)\n        tasks.add_task(increment)\n        response = Response(\"tasks initiated\", media_type=\"text/plain\", background=tasks)\n        await response(scope, receive, send)\n\n    client = test_client_factory(app)\n    with pytest.raises(Exception):\n        client.get(\"/\")\n    assert TASK_COUNTER == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "pytest",
        "starlette.background.BackgroundTask",
        "starlette.background.BackgroundTasks",
        "starlette.responses.Response",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert TASK_COUNTER == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_url",
      "module": "test_datastructures",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_datastructures.py",
      "line_number": 19,
      "end_line_number": 62,
      "source_code": "def test_url() -> None:\n    u = URL(\"https://example.org:123/path/to/somewhere?abc=123#anchor\")\n    assert u.scheme == \"https\"\n    assert u.hostname == \"example.org\"\n    assert u.port == 123\n    assert u.netloc == \"example.org:123\"\n    assert u.username is None\n    assert u.password is None\n    assert u.path == \"/path/to/somewhere\"\n    assert u.query == \"abc=123\"\n    assert u.fragment == \"anchor\"\n\n    new = u.replace(scheme=\"http\")\n    assert new == \"http://example.org:123/path/to/somewhere?abc=123#anchor\"\n    assert new.scheme == \"http\"\n\n    new = u.replace(port=None)\n    assert new == \"https://example.org/path/to/somewhere?abc=123#anchor\"\n    assert new.port is None\n\n    new = u.replace(hostname=\"example.com\")\n    assert new == \"https://example.com:123/path/to/somewhere?abc=123#anchor\"\n    assert new.hostname == \"example.com\"\n\n    ipv6_url = URL(\"https://[fe::2]:12345\")\n    new = ipv6_url.replace(port=8080)\n    assert new == \"https://[fe::2]:8080\"\n\n    new = ipv6_url.replace(username=\"username\", password=\"password\")\n    assert new == \"https://username:password@[fe::2]:12345\"\n    assert new.netloc == \"username:password@[fe::2]:12345\"\n\n    ipv6_url = URL(\"https://[fe::2]\")\n    new = ipv6_url.replace(port=123)\n    assert new == \"https://[fe::2]:123\"\n\n    url = URL(\"http://u:p@host/\")\n    assert url.replace(hostname=\"bar\") == URL(\"http://u:p@bar/\")\n\n    url = URL(\"http://u:p@host:80\")\n    assert url.replace(port=88) == URL(\"http://u:p@host:88\")\n\n    url = URL(\"http://host:80\")\n    assert url.replace(username=\"u\") == URL(\"http://u@host:80\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "io",
        "tempfile.SpooledTemporaryFile",
        "typing.BinaryIO",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.CommaSeparatedStrings",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.MultiDict",
        "starlette.datastructures.MutableHeaders",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile"
      ],
      "fixtures": [],
      "assertions": [
        "assert u.scheme == 'https'",
        "assert u.hostname == 'example.org'",
        "assert u.port == 123",
        "assert u.netloc == 'example.org:123'",
        "assert u.username is None",
        "assert u.password is None",
        "assert u.path == '/path/to/somewhere'",
        "assert u.query == 'abc=123'",
        "assert u.fragment == 'anchor'",
        "assert new == 'http://example.org:123/path/to/somewhere?abc=123#anchor'",
        "assert new.scheme == 'http'",
        "assert new == 'https://example.org/path/to/somewhere?abc=123#anchor'",
        "assert new.port is None",
        "assert new == 'https://example.com:123/path/to/somewhere?abc=123#anchor'",
        "assert new.hostname == 'example.com'",
        "assert new == 'https://[fe::2]:8080'",
        "assert new == 'https://username:password@[fe::2]:12345'",
        "assert new.netloc == 'username:password@[fe::2]:12345'",
        "assert new == 'https://[fe::2]:123'",
        "assert url.replace(hostname='bar') == URL('http://u:p@bar/')",
        "assert url.replace(port=88) == URL('http://u:p@host:88')",
        "assert url.replace(username='u') == URL('http://u@host:80')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_url_query_params",
      "module": "test_datastructures",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_datastructures.py",
      "line_number": 65,
      "end_line_number": 79,
      "source_code": "def test_url_query_params() -> None:\n    u = URL(\"https://example.org/path/?page=3\")\n    assert u.query == \"page=3\"\n    u = u.include_query_params(page=4)\n    assert str(u) == \"https://example.org/path/?page=4\"\n    u = u.include_query_params(search=\"testing\")\n    assert str(u) == \"https://example.org/path/?page=4&search=testing\"\n    u = u.replace_query_params(order=\"name\")\n    assert str(u) == \"https://example.org/path/?order=name\"\n    u = u.remove_query_params(\"order\")\n    assert str(u) == \"https://example.org/path/\"\n    u = u.include_query_params(page=4, search=\"testing\")\n    assert str(u) == \"https://example.org/path/?page=4&search=testing\"\n    u = u.remove_query_params([\"page\", \"search\"])\n    assert str(u) == \"https://example.org/path/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "io",
        "tempfile.SpooledTemporaryFile",
        "typing.BinaryIO",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.CommaSeparatedStrings",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.MultiDict",
        "starlette.datastructures.MutableHeaders",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile"
      ],
      "fixtures": [],
      "assertions": [
        "assert u.query == 'page=3'",
        "assert str(u) == 'https://example.org/path/?page=4'",
        "assert str(u) == 'https://example.org/path/?page=4&search=testing'",
        "assert str(u) == 'https://example.org/path/?order=name'",
        "assert str(u) == 'https://example.org/path/'",
        "assert str(u) == 'https://example.org/path/?page=4&search=testing'",
        "assert str(u) == 'https://example.org/path/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_hidden_password",
      "module": "test_datastructures",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_datastructures.py",
      "line_number": 82,
      "end_line_number": 90,
      "source_code": "def test_hidden_password() -> None:\n    u = URL(\"https://example.org/path/to/somewhere\")\n    assert repr(u) == \"URL('https://example.org/path/to/somewhere')\"\n\n    u = URL(\"https://username@example.org/path/to/somewhere\")\n    assert repr(u) == \"URL('https://username@example.org/path/to/somewhere')\"\n\n    u = URL(\"https://username:password@example.org/path/to/somewhere\")\n    assert repr(u) == \"URL('https://username:********@example.org/path/to/somewhere')\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "io",
        "tempfile.SpooledTemporaryFile",
        "typing.BinaryIO",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.CommaSeparatedStrings",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.MultiDict",
        "starlette.datastructures.MutableHeaders",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(u) == \"URL('https://example.org/path/to/somewhere')\"",
        "assert repr(u) == \"URL('https://username@example.org/path/to/somewhere')\"",
        "assert repr(u) == \"URL('https://username:********@example.org/path/to/somewhere')\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_csv",
      "module": "test_datastructures",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_datastructures.py",
      "line_number": 93,
      "end_line_number": 114,
      "source_code": "def test_csv() -> None:\n    csv = CommaSeparatedStrings('\"localhost\", \"127.0.0.1\", 0.0.0.0')\n    assert list(csv) == [\"localhost\", \"127.0.0.1\", \"0.0.0.0\"]\n    assert repr(csv) == \"CommaSeparatedStrings(['localhost', '127.0.0.1', '0.0.0.0'])\"\n    assert str(csv) == \"'localhost', '127.0.0.1', '0.0.0.0'\"\n    assert csv[0] == \"localhost\"\n    assert len(csv) == 3\n\n    csv = CommaSeparatedStrings(\"'localhost', '127.0.0.1', 0.0.0.0\")\n    assert list(csv) == [\"localhost\", \"127.0.0.1\", \"0.0.0.0\"]\n    assert repr(csv) == \"CommaSeparatedStrings(['localhost', '127.0.0.1', '0.0.0.0'])\"\n    assert str(csv) == \"'localhost', '127.0.0.1', '0.0.0.0'\"\n\n    csv = CommaSeparatedStrings(\"localhost, 127.0.0.1, 0.0.0.0\")\n    assert list(csv) == [\"localhost\", \"127.0.0.1\", \"0.0.0.0\"]\n    assert repr(csv) == \"CommaSeparatedStrings(['localhost', '127.0.0.1', '0.0.0.0'])\"\n    assert str(csv) == \"'localhost', '127.0.0.1', '0.0.0.0'\"\n\n    csv = CommaSeparatedStrings([\"localhost\", \"127.0.0.1\", \"0.0.0.0\"])\n    assert list(csv) == [\"localhost\", \"127.0.0.1\", \"0.0.0.0\"]\n    assert repr(csv) == \"CommaSeparatedStrings(['localhost', '127.0.0.1', '0.0.0.0'])\"\n    assert str(csv) == \"'localhost', '127.0.0.1', '0.0.0.0'\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "io",
        "tempfile.SpooledTemporaryFile",
        "typing.BinaryIO",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.CommaSeparatedStrings",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.MultiDict",
        "starlette.datastructures.MutableHeaders",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile"
      ],
      "fixtures": [],
      "assertions": [
        "assert list(csv) == ['localhost', '127.0.0.1', '0.0.0.0']",
        "assert repr(csv) == \"CommaSeparatedStrings(['localhost', '127.0.0.1', '0.0.0.0'])\"",
        "assert str(csv) == \"'localhost', '127.0.0.1', '0.0.0.0'\"",
        "assert csv[0] == 'localhost'",
        "assert len(csv) == 3",
        "assert list(csv) == ['localhost', '127.0.0.1', '0.0.0.0']",
        "assert repr(csv) == \"CommaSeparatedStrings(['localhost', '127.0.0.1', '0.0.0.0'])\"",
        "assert str(csv) == \"'localhost', '127.0.0.1', '0.0.0.0'\"",
        "assert list(csv) == ['localhost', '127.0.0.1', '0.0.0.0']",
        "assert repr(csv) == \"CommaSeparatedStrings(['localhost', '127.0.0.1', '0.0.0.0'])\"",
        "assert str(csv) == \"'localhost', '127.0.0.1', '0.0.0.0'\"",
        "assert list(csv) == ['localhost', '127.0.0.1', '0.0.0.0']",
        "assert repr(csv) == \"CommaSeparatedStrings(['localhost', '127.0.0.1', '0.0.0.0'])\"",
        "assert str(csv) == \"'localhost', '127.0.0.1', '0.0.0.0'\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_url_from_scope",
      "module": "test_datastructures",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_datastructures.py",
      "line_number": 117,
      "end_line_number": 159,
      "source_code": "def test_url_from_scope() -> None:\n    u = URL(scope={\"path\": \"/path/to/somewhere\", \"query_string\": b\"abc=123\", \"headers\": []})\n    assert u == \"/path/to/somewhere?abc=123\"\n    assert repr(u) == \"URL('/path/to/somewhere?abc=123')\"\n\n    u = URL(\n        scope={\n            \"scheme\": \"https\",\n            \"server\": (\"example.org\", 123),\n            \"path\": \"/path/to/somewhere\",\n            \"query_string\": b\"abc=123\",\n            \"headers\": [],\n        }\n    )\n    assert u == \"https://example.org:123/path/to/somewhere?abc=123\"\n    assert repr(u) == \"URL('https://example.org:123/path/to/somewhere?abc=123')\"\n\n    u = URL(\n        scope={\n            \"scheme\": \"https\",\n            \"server\": (\"example.org\", 443),\n            \"path\": \"/path/to/somewhere\",\n            \"query_string\": b\"abc=123\",\n            \"headers\": [],\n        }\n    )\n    assert u == \"https://example.org/path/to/somewhere?abc=123\"\n    assert repr(u) == \"URL('https://example.org/path/to/somewhere?abc=123')\"\n\n    u = URL(\n        scope={\n            \"scheme\": \"http\",\n            \"path\": \"/some/path\",\n            \"query_string\": b\"query=string\",\n            \"headers\": [\n                (b\"content-type\", b\"text/html\"),\n                (b\"host\", b\"example.com:8000\"),\n                (b\"accept\", b\"text/html\"),\n            ],\n        }\n    )\n    assert u == \"http://example.com:8000/some/path?query=string\"\n    assert repr(u) == \"URL('http://example.com:8000/some/path?query=string')\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "io",
        "tempfile.SpooledTemporaryFile",
        "typing.BinaryIO",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.CommaSeparatedStrings",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.MultiDict",
        "starlette.datastructures.MutableHeaders",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile"
      ],
      "fixtures": [],
      "assertions": [
        "assert u == '/path/to/somewhere?abc=123'",
        "assert repr(u) == \"URL('/path/to/somewhere?abc=123')\"",
        "assert u == 'https://example.org:123/path/to/somewhere?abc=123'",
        "assert repr(u) == \"URL('https://example.org:123/path/to/somewhere?abc=123')\"",
        "assert u == 'https://example.org/path/to/somewhere?abc=123'",
        "assert repr(u) == \"URL('https://example.org/path/to/somewhere?abc=123')\"",
        "assert u == 'http://example.com:8000/some/path?query=string'",
        "assert repr(u) == \"URL('http://example.com:8000/some/path?query=string')\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_headers",
      "module": "test_datastructures",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_datastructures.py",
      "line_number": 162,
      "end_line_number": 186,
      "source_code": "def test_headers() -> None:\n    h = Headers(raw=[(b\"a\", b\"123\"), (b\"a\", b\"456\"), (b\"b\", b\"789\")])\n    assert \"a\" in h\n    assert \"A\" in h\n    assert \"b\" in h\n    assert \"B\" in h\n    assert \"c\" not in h\n    assert h[\"a\"] == \"123\"\n    assert h.get(\"a\") == \"123\"\n    assert h.get(\"nope\", default=None) is None\n    assert h.getlist(\"a\") == [\"123\", \"456\"]\n    assert h.keys() == [\"a\", \"a\", \"b\"]\n    assert h.values() == [\"123\", \"456\", \"789\"]\n    assert h.items() == [(\"a\", \"123\"), (\"a\", \"456\"), (\"b\", \"789\")]\n    assert list(h) == [\"a\", \"a\", \"b\"]\n    assert dict(h) == {\"a\": \"123\", \"b\": \"789\"}\n    assert repr(h) == \"Headers(raw=[(b'a', b'123'), (b'a', b'456'), (b'b', b'789')])\"\n    assert h == Headers(raw=[(b\"a\", b\"123\"), (b\"b\", b\"789\"), (b\"a\", b\"456\")])\n    assert h != [(b\"a\", b\"123\"), (b\"A\", b\"456\"), (b\"b\", b\"789\")]\n\n    h = Headers({\"a\": \"123\", \"b\": \"789\"})\n    assert h[\"A\"] == \"123\"\n    assert h[\"B\"] == \"789\"\n    assert h.raw == [(b\"a\", b\"123\"), (b\"b\", b\"789\")]\n    assert repr(h) == \"Headers({'a': '123', 'b': '789'})\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "io",
        "tempfile.SpooledTemporaryFile",
        "typing.BinaryIO",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.CommaSeparatedStrings",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.MultiDict",
        "starlette.datastructures.MutableHeaders",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'a' in h",
        "assert 'A' in h",
        "assert 'b' in h",
        "assert 'B' in h",
        "assert 'c' not in h",
        "assert h['a'] == '123'",
        "assert h.get('a') == '123'",
        "assert h.get('nope', default=None) is None",
        "assert h.getlist('a') == ['123', '456']",
        "assert h.keys() == ['a', 'a', 'b']",
        "assert h.values() == ['123', '456', '789']",
        "assert h.items() == [('a', '123'), ('a', '456'), ('b', '789')]",
        "assert list(h) == ['a', 'a', 'b']",
        "assert dict(h) == {'a': '123', 'b': '789'}",
        "assert repr(h) == \"Headers(raw=[(b'a', b'123'), (b'a', b'456'), (b'b', b'789')])\"",
        "assert h == Headers(raw=[(b'a', b'123'), (b'b', b'789'), (b'a', b'456')])",
        "assert h != [(b'a', b'123'), (b'A', b'456'), (b'b', b'789')]",
        "assert h['A'] == '123'",
        "assert h['B'] == '789'",
        "assert h.raw == [(b'a', b'123'), (b'b', b'789')]",
        "assert repr(h) == \"Headers({'a': '123', 'b': '789'})\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "h.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "h.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_mutable_headers",
      "module": "test_datastructures",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_datastructures.py",
      "line_number": 189,
      "end_line_number": 202,
      "source_code": "def test_mutable_headers() -> None:\n    h = MutableHeaders()\n    assert dict(h) == {}\n    h[\"a\"] = \"1\"\n    assert dict(h) == {\"a\": \"1\"}\n    h[\"a\"] = \"2\"\n    assert dict(h) == {\"a\": \"2\"}\n    h.setdefault(\"a\", \"3\")\n    assert dict(h) == {\"a\": \"2\"}\n    h.setdefault(\"b\", \"4\")\n    assert dict(h) == {\"a\": \"2\", \"b\": \"4\"}\n    del h[\"a\"]\n    assert dict(h) == {\"b\": \"4\"}\n    assert h.raw == [(b\"b\", b\"4\")]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "io",
        "tempfile.SpooledTemporaryFile",
        "typing.BinaryIO",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.CommaSeparatedStrings",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.MultiDict",
        "starlette.datastructures.MutableHeaders",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile"
      ],
      "fixtures": [],
      "assertions": [
        "assert dict(h) == {}",
        "assert dict(h) == {'a': '1'}",
        "assert dict(h) == {'a': '2'}",
        "assert dict(h) == {'a': '2'}",
        "assert dict(h) == {'a': '2', 'b': '4'}",
        "assert dict(h) == {'b': '4'}",
        "assert h.raw == [(b'b', b'4')]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_mutable_headers_merge",
      "module": "test_datastructures",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_datastructures.py",
      "line_number": 205,
      "end_line_number": 211,
      "source_code": "def test_mutable_headers_merge() -> None:\n    h = MutableHeaders()\n    h = h | MutableHeaders({\"a\": \"1\"})\n    assert isinstance(h, MutableHeaders)\n    assert dict(h) == {\"a\": \"1\"}\n    assert h.items() == [(\"a\", \"1\")]\n    assert h.raw == [(b\"a\", b\"1\")]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "io",
        "tempfile.SpooledTemporaryFile",
        "typing.BinaryIO",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.CommaSeparatedStrings",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.MultiDict",
        "starlette.datastructures.MutableHeaders",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(h, MutableHeaders)",
        "assert dict(h) == {'a': '1'}",
        "assert h.items() == [('a', '1')]",
        "assert h.raw == [(b'a', b'1')]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_mutable_headers_merge_dict",
      "module": "test_datastructures",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_datastructures.py",
      "line_number": 214,
      "end_line_number": 220,
      "source_code": "def test_mutable_headers_merge_dict() -> None:\n    h = MutableHeaders()\n    h = h | {\"a\": \"1\"}\n    assert isinstance(h, MutableHeaders)\n    assert dict(h) == {\"a\": \"1\"}\n    assert h.items() == [(\"a\", \"1\")]\n    assert h.raw == [(b\"a\", b\"1\")]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "io",
        "tempfile.SpooledTemporaryFile",
        "typing.BinaryIO",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.CommaSeparatedStrings",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.MultiDict",
        "starlette.datastructures.MutableHeaders",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(h, MutableHeaders)",
        "assert dict(h) == {'a': '1'}",
        "assert h.items() == [('a', '1')]",
        "assert h.raw == [(b'a', b'1')]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_mutable_headers_update",
      "module": "test_datastructures",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_datastructures.py",
      "line_number": 223,
      "end_line_number": 229,
      "source_code": "def test_mutable_headers_update() -> None:\n    h = MutableHeaders()\n    h |= MutableHeaders({\"a\": \"1\"})\n    assert isinstance(h, MutableHeaders)\n    assert dict(h) == {\"a\": \"1\"}\n    assert h.items() == [(\"a\", \"1\")]\n    assert h.raw == [(b\"a\", b\"1\")]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "io",
        "tempfile.SpooledTemporaryFile",
        "typing.BinaryIO",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.CommaSeparatedStrings",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.MultiDict",
        "starlette.datastructures.MutableHeaders",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(h, MutableHeaders)",
        "assert dict(h) == {'a': '1'}",
        "assert h.items() == [('a', '1')]",
        "assert h.raw == [(b'a', b'1')]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_mutable_headers_update_dict",
      "module": "test_datastructures",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_datastructures.py",
      "line_number": 232,
      "end_line_number": 238,
      "source_code": "def test_mutable_headers_update_dict() -> None:\n    h = MutableHeaders()\n    h |= {\"a\": \"1\"}\n    assert isinstance(h, MutableHeaders)\n    assert dict(h) == {\"a\": \"1\"}\n    assert h.items() == [(\"a\", \"1\")]\n    assert h.raw == [(b\"a\", b\"1\")]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "io",
        "tempfile.SpooledTemporaryFile",
        "typing.BinaryIO",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.CommaSeparatedStrings",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.MultiDict",
        "starlette.datastructures.MutableHeaders",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(h, MutableHeaders)",
        "assert dict(h) == {'a': '1'}",
        "assert h.items() == [('a', '1')]",
        "assert h.raw == [(b'a', b'1')]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_mutable_headers_merge_not_mapping",
      "module": "test_datastructures",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_datastructures.py",
      "line_number": 241,
      "end_line_number": 246,
      "source_code": "def test_mutable_headers_merge_not_mapping() -> None:\n    h = MutableHeaders()\n    with pytest.raises(TypeError):\n        h |= {\"not_mapping\"}  # type: ignore[arg-type]\n    with pytest.raises(TypeError):\n        h | {\"not_mapping\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "io",
        "tempfile.SpooledTemporaryFile",
        "typing.BinaryIO",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.CommaSeparatedStrings",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.MultiDict",
        "starlette.datastructures.MutableHeaders",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_headers_mutablecopy",
      "module": "test_datastructures",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_datastructures.py",
      "line_number": 249,
      "end_line_number": 254,
      "source_code": "def test_headers_mutablecopy() -> None:\n    h = Headers(raw=[(b\"a\", b\"123\"), (b\"a\", b\"456\"), (b\"b\", b\"789\")])\n    c = h.mutablecopy()\n    assert c.items() == [(\"a\", \"123\"), (\"a\", \"456\"), (\"b\", \"789\")]\n    c[\"a\"] = \"abc\"\n    assert c.items() == [(\"a\", \"abc\"), (\"b\", \"789\")]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "io",
        "tempfile.SpooledTemporaryFile",
        "typing.BinaryIO",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.CommaSeparatedStrings",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.MultiDict",
        "starlette.datastructures.MutableHeaders",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile"
      ],
      "fixtures": [],
      "assertions": [
        "assert c.items() == [('a', '123'), ('a', '456'), ('b', '789')]",
        "assert c.items() == [('a', 'abc'), ('b', '789')]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_mutable_headers_from_scope",
      "module": "test_datastructures",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_datastructures.py",
      "line_number": 257,
      "end_line_number": 264,
      "source_code": "def test_mutable_headers_from_scope() -> None:\n    # \"headers\" in scope must not necessarily be a list\n    h = MutableHeaders(scope={\"headers\": ((b\"a\", b\"1\"),)})\n    assert dict(h) == {\"a\": \"1\"}\n    h.update({\"b\": \"2\"})\n    assert dict(h) == {\"a\": \"1\", \"b\": \"2\"}\n    assert list(h.items()) == [(\"a\", \"1\"), (\"b\", \"2\")]\n    assert list(h.raw) == [(b\"a\", b\"1\"), (b\"b\", b\"2\")]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "io",
        "tempfile.SpooledTemporaryFile",
        "typing.BinaryIO",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.CommaSeparatedStrings",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.MultiDict",
        "starlette.datastructures.MutableHeaders",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile"
      ],
      "fixtures": [],
      "assertions": [
        "assert dict(h) == {'a': '1'}",
        "assert dict(h) == {'a': '1', 'b': '2'}",
        "assert list(h.items()) == [('a', '1'), ('b', '2')]",
        "assert list(h.raw) == [(b'a', b'1'), (b'b', b'2')]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_url_blank_params",
      "module": "test_datastructures",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_datastructures.py",
      "line_number": 267,
      "end_line_number": 277,
      "source_code": "def test_url_blank_params() -> None:\n    q = QueryParams(\"a=123&abc&def&b=456\")\n    assert \"a\" in q\n    assert \"abc\" in q\n    assert \"def\" in q\n    assert \"b\" in q\n    val = q.get(\"abc\")\n    assert val is not None\n    assert len(val) == 0\n    assert len(q[\"a\"]) == 3\n    assert list(q.keys()) == [\"a\", \"abc\", \"def\", \"b\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "io",
        "tempfile.SpooledTemporaryFile",
        "typing.BinaryIO",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.CommaSeparatedStrings",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.MultiDict",
        "starlette.datastructures.MutableHeaders",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'a' in q",
        "assert 'abc' in q",
        "assert 'def' in q",
        "assert 'b' in q",
        "assert val is not None",
        "assert len(val) == 0",
        "assert len(q['a']) == 3",
        "assert list(q.keys()) == ['a', 'abc', 'def', 'b']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "q.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_queryparams",
      "module": "test_datastructures",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_datastructures.py",
      "line_number": 280,
      "end_line_number": 305,
      "source_code": "def test_queryparams() -> None:\n    q = QueryParams(\"a=123&a=456&b=789\")\n    assert \"a\" in q\n    assert \"A\" not in q\n    assert \"c\" not in q\n    assert q[\"a\"] == \"456\"\n    assert q.get(\"a\") == \"456\"\n    assert q.get(\"nope\", default=None) is None\n    assert q.getlist(\"a\") == [\"123\", \"456\"]\n    assert list(q.keys()) == [\"a\", \"b\"]\n    assert list(q.values()) == [\"456\", \"789\"]\n    assert list(q.items()) == [(\"a\", \"456\"), (\"b\", \"789\")]\n    assert len(q) == 2\n    assert list(q) == [\"a\", \"b\"]\n    assert dict(q) == {\"a\": \"456\", \"b\": \"789\"}\n    assert str(q) == \"a=123&a=456&b=789\"\n    assert repr(q) == \"QueryParams('a=123&a=456&b=789')\"\n    assert QueryParams({\"a\": \"123\", \"b\": \"456\"}) == QueryParams([(\"a\", \"123\"), (\"b\", \"456\")])\n    assert QueryParams({\"a\": \"123\", \"b\": \"456\"}) == QueryParams(\"a=123&b=456\")\n    assert QueryParams({\"a\": \"123\", \"b\": \"456\"}) == QueryParams({\"b\": \"456\", \"a\": \"123\"})\n    assert QueryParams() == QueryParams({})\n    assert QueryParams([(\"a\", \"123\"), (\"a\", \"456\")]) == QueryParams(\"a=123&a=456\")\n    assert QueryParams({\"a\": \"123\", \"b\": \"456\"}) != \"invalid\"\n\n    q = QueryParams([(\"a\", \"123\"), (\"a\", \"456\")])\n    assert QueryParams(q) == q",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "io",
        "tempfile.SpooledTemporaryFile",
        "typing.BinaryIO",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.CommaSeparatedStrings",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.MultiDict",
        "starlette.datastructures.MutableHeaders",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'a' in q",
        "assert 'A' not in q",
        "assert 'c' not in q",
        "assert q['a'] == '456'",
        "assert q.get('a') == '456'",
        "assert q.get('nope', default=None) is None",
        "assert q.getlist('a') == ['123', '456']",
        "assert list(q.keys()) == ['a', 'b']",
        "assert list(q.values()) == ['456', '789']",
        "assert list(q.items()) == [('a', '456'), ('b', '789')]",
        "assert len(q) == 2",
        "assert list(q) == ['a', 'b']",
        "assert dict(q) == {'a': '456', 'b': '789'}",
        "assert str(q) == 'a=123&a=456&b=789'",
        "assert repr(q) == \"QueryParams('a=123&a=456&b=789')\"",
        "assert QueryParams({'a': '123', 'b': '456'}) == QueryParams([('a', '123'), ('b', '456')])",
        "assert QueryParams({'a': '123', 'b': '456'}) == QueryParams('a=123&b=456')",
        "assert QueryParams({'a': '123', 'b': '456'}) == QueryParams({'b': '456', 'a': '123'})",
        "assert QueryParams() == QueryParams({})",
        "assert QueryParams([('a', '123'), ('a', '456')]) == QueryParams('a=123&a=456')",
        "assert QueryParams({'a': '123', 'b': '456'}) != 'invalid'",
        "assert QueryParams(q) == q"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "q.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "q.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_formdata",
      "module": "test_datastructures",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_datastructures.py",
      "line_number": 362,
      "end_line_number": 382,
      "source_code": "def test_formdata() -> None:\n    stream = io.BytesIO(b\"data\")\n    upload = UploadFile(filename=\"file\", file=stream, size=4)\n    form = FormData([(\"a\", \"123\"), (\"a\", \"456\"), (\"b\", upload)])\n    assert \"a\" in form\n    assert \"A\" not in form\n    assert \"c\" not in form\n    assert form[\"a\"] == \"456\"\n    assert form.get(\"a\") == \"456\"\n    assert form.get(\"nope\", default=None) is None\n    assert form.getlist(\"a\") == [\"123\", \"456\"]\n    assert list(form.keys()) == [\"a\", \"b\"]\n    assert list(form.values()) == [\"456\", upload]\n    assert list(form.items()) == [(\"a\", \"456\"), (\"b\", upload)]\n    assert len(form) == 2\n    assert list(form) == [\"a\", \"b\"]\n    assert dict(form) == {\"a\": \"456\", \"b\": upload}\n    assert repr(form) == \"FormData([('a', '123'), ('a', '456'), ('b', \" + repr(upload) + \")])\"\n    assert FormData(form) == form\n    assert FormData({\"a\": \"123\", \"b\": \"789\"}) == FormData([(\"a\", \"123\"), (\"b\", \"789\")])\n    assert FormData({\"a\": \"123\", \"b\": \"789\"}) != {\"a\": \"123\", \"b\": \"789\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "io",
        "tempfile.SpooledTemporaryFile",
        "typing.BinaryIO",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.CommaSeparatedStrings",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.MultiDict",
        "starlette.datastructures.MutableHeaders",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'a' in form",
        "assert 'A' not in form",
        "assert 'c' not in form",
        "assert form['a'] == '456'",
        "assert form.get('a') == '456'",
        "assert form.get('nope', default=None) is None",
        "assert form.getlist('a') == ['123', '456']",
        "assert list(form.keys()) == ['a', 'b']",
        "assert list(form.values()) == ['456', upload]",
        "assert list(form.items()) == [('a', '456'), ('b', upload)]",
        "assert len(form) == 2",
        "assert list(form) == ['a', 'b']",
        "assert dict(form) == {'a': '456', 'b': upload}",
        "assert repr(form) == \"FormData([('a', '123'), ('a', '456'), ('b', \" + repr(upload) + ')])'",
        "assert FormData(form) == form",
        "assert FormData({'a': '123', 'b': '789'}) == FormData([('a', '123'), ('b', '789')])",
        "assert FormData({'a': '123', 'b': '789'}) != {'a': '123', 'b': '789'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "form.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "form.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_multidict",
      "module": "test_datastructures",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_datastructures.py",
      "line_number": 399,
      "end_line_number": 485,
      "source_code": "def test_multidict() -> None:\n    q = MultiDict([(\"a\", \"123\"), (\"a\", \"456\"), (\"b\", \"789\")])\n    assert \"a\" in q\n    assert \"A\" not in q\n    assert \"c\" not in q\n    assert q[\"a\"] == \"456\"\n    assert q.get(\"a\") == \"456\"\n    assert q.get(\"nope\", default=None) is None\n    assert q.getlist(\"a\") == [\"123\", \"456\"]\n    assert list(q.keys()) == [\"a\", \"b\"]\n    assert list(q.values()) == [\"456\", \"789\"]\n    assert list(q.items()) == [(\"a\", \"456\"), (\"b\", \"789\")]\n    assert len(q) == 2\n    assert list(q) == [\"a\", \"b\"]\n    assert dict(q) == {\"a\": \"456\", \"b\": \"789\"}\n    assert str(q) == \"MultiDict([('a', '123'), ('a', '456'), ('b', '789')])\"\n    assert repr(q) == \"MultiDict([('a', '123'), ('a', '456'), ('b', '789')])\"\n    assert MultiDict({\"a\": \"123\", \"b\": \"456\"}) == MultiDict([(\"a\", \"123\"), (\"b\", \"456\")])\n    assert MultiDict({\"a\": \"123\", \"b\": \"456\"}) == MultiDict({\"b\": \"456\", \"a\": \"123\"})\n    assert MultiDict() == MultiDict({})\n    assert MultiDict({\"a\": \"123\", \"b\": \"456\"}) != \"invalid\"\n\n    q = MultiDict([(\"a\", \"123\"), (\"a\", \"456\")])\n    assert MultiDict(q) == q\n\n    q = MultiDict([(\"a\", \"123\"), (\"a\", \"456\")])\n    q[\"a\"] = \"789\"\n    assert q[\"a\"] == \"789\"\n    assert q.get(\"a\") == \"789\"\n    assert q.getlist(\"a\") == [\"789\"]\n\n    q = MultiDict([(\"a\", \"123\"), (\"a\", \"456\")])\n    del q[\"a\"]\n    assert q.get(\"a\") is None\n    assert repr(q) == \"MultiDict([])\"\n\n    q = MultiDict([(\"a\", \"123\"), (\"a\", \"456\"), (\"b\", \"789\")])\n    assert q.pop(\"a\") == \"456\"\n    assert q.get(\"a\", None) is None\n    assert repr(q) == \"MultiDict([('b', '789')])\"\n\n    q = MultiDict([(\"a\", \"123\"), (\"a\", \"456\"), (\"b\", \"789\")])\n    item = q.popitem()\n    assert q.get(item[0]) is None\n\n    q = MultiDict([(\"a\", \"123\"), (\"a\", \"456\"), (\"b\", \"789\")])\n    assert q.poplist(\"a\") == [\"123\", \"456\"]\n    assert q.get(\"a\") is None\n    assert repr(q) == \"MultiDict([('b', '789')])\"\n\n    q = MultiDict([(\"a\", \"123\"), (\"a\", \"456\"), (\"b\", \"789\")])\n    q.clear()\n    assert q.get(\"a\") is None\n    assert repr(q) == \"MultiDict([])\"\n\n    q = MultiDict([(\"a\", \"123\")])\n    q.setlist(\"a\", [\"456\", \"789\"])\n    assert q.getlist(\"a\") == [\"456\", \"789\"]\n    q.setlist(\"b\", [])\n    assert \"b\" not in q\n\n    q = MultiDict([(\"a\", \"123\")])\n    assert q.setdefault(\"a\", \"456\") == \"123\"\n    assert q.getlist(\"a\") == [\"123\"]\n    assert q.setdefault(\"b\", \"456\") == \"456\"\n    assert q.getlist(\"b\") == [\"456\"]\n    assert repr(q) == \"MultiDict([('a', '123'), ('b', '456')])\"\n\n    q = MultiDict([(\"a\", \"123\")])\n    q.append(\"a\", \"456\")\n    assert q.getlist(\"a\") == [\"123\", \"456\"]\n    assert repr(q) == \"MultiDict([('a', '123'), ('a', '456')])\"\n\n    q = MultiDict([(\"a\", \"123\"), (\"b\", \"456\")])\n    q.update({\"a\": \"789\"})\n    assert q.getlist(\"a\") == [\"789\"]\n    assert q == MultiDict([(\"a\", \"789\"), (\"b\", \"456\")])\n\n    q = MultiDict([(\"a\", \"123\"), (\"b\", \"456\")])\n    q.update(q)\n    assert repr(q) == \"MultiDict([('a', '123'), ('b', '456')])\"\n\n    q = MultiDict([(\"a\", \"123\"), (\"a\", \"456\")])\n    q.update([(\"a\", \"123\")])\n    assert q.getlist(\"a\") == [\"123\"]\n    q.update([(\"a\", \"456\")], a=\"789\", b=\"123\")\n    assert q == MultiDict([(\"a\", \"456\"), (\"a\", \"789\"), (\"b\", \"123\")])",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "io",
        "tempfile.SpooledTemporaryFile",
        "typing.BinaryIO",
        "pytest",
        "starlette.datastructures.URL",
        "starlette.datastructures.CommaSeparatedStrings",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.MultiDict",
        "starlette.datastructures.MutableHeaders",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'a' in q",
        "assert 'A' not in q",
        "assert 'c' not in q",
        "assert q['a'] == '456'",
        "assert q.get('a') == '456'",
        "assert q.get('nope', default=None) is None",
        "assert q.getlist('a') == ['123', '456']",
        "assert list(q.keys()) == ['a', 'b']",
        "assert list(q.values()) == ['456', '789']",
        "assert list(q.items()) == [('a', '456'), ('b', '789')]",
        "assert len(q) == 2",
        "assert list(q) == ['a', 'b']",
        "assert dict(q) == {'a': '456', 'b': '789'}",
        "assert str(q) == \"MultiDict([('a', '123'), ('a', '456'), ('b', '789')])\"",
        "assert repr(q) == \"MultiDict([('a', '123'), ('a', '456'), ('b', '789')])\"",
        "assert MultiDict({'a': '123', 'b': '456'}) == MultiDict([('a', '123'), ('b', '456')])",
        "assert MultiDict({'a': '123', 'b': '456'}) == MultiDict({'b': '456', 'a': '123'})",
        "assert MultiDict() == MultiDict({})",
        "assert MultiDict({'a': '123', 'b': '456'}) != 'invalid'",
        "assert MultiDict(q) == q",
        "assert q['a'] == '789'",
        "assert q.get('a') == '789'",
        "assert q.getlist('a') == ['789']",
        "assert q.get('a') is None",
        "assert repr(q) == 'MultiDict([])'",
        "assert q.pop('a') == '456'",
        "assert q.get('a', None) is None",
        "assert repr(q) == \"MultiDict([('b', '789')])\"",
        "assert q.get(item[0]) is None",
        "assert q.poplist('a') == ['123', '456']",
        "assert q.get('a') is None",
        "assert repr(q) == \"MultiDict([('b', '789')])\"",
        "assert q.get('a') is None",
        "assert repr(q) == 'MultiDict([])'",
        "assert q.getlist('a') == ['456', '789']",
        "assert 'b' not in q",
        "assert q.setdefault('a', '456') == '123'",
        "assert q.getlist('a') == ['123']",
        "assert q.setdefault('b', '456') == '456'",
        "assert q.getlist('b') == ['456']",
        "assert repr(q) == \"MultiDict([('a', '123'), ('b', '456')])\"",
        "assert q.getlist('a') == ['123', '456']",
        "assert repr(q) == \"MultiDict([('a', '123'), ('a', '456')])\"",
        "assert q.getlist('a') == ['789']",
        "assert q == MultiDict([('a', '789'), ('b', '456')])",
        "assert repr(q) == \"MultiDict([('a', '123'), ('b', '456')])\"",
        "assert q.getlist('a') == ['123']",
        "assert q == MultiDict([('a', '456'), ('a', '789'), ('b', '123')])"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "q.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "q.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "q.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "q.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "q.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "q.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "q.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "q.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_router",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 179,
      "end_line_number": 221,
      "source_code": "def test_router(client: TestClient) -> None:\n    response = client.get(\"/\")\n    assert response.status_code == 200\n    assert response.text == \"Hello, world\"\n\n    response = client.post(\"/\")\n    assert response.status_code == 405\n    assert response.text == \"Method Not Allowed\"\n    assert set(response.headers[\"allow\"].split(\", \")) == {\"HEAD\", \"GET\"}\n\n    response = client.get(\"/foo\")\n    assert response.status_code == 404\n    assert response.text == \"Not Found\"\n\n    response = client.get(\"/users\")\n    assert response.status_code == 200\n    assert response.text == \"All users\"\n\n    response = client.get(\"/users/tomchristie\")\n    assert response.status_code == 200\n    assert response.text == \"User tomchristie\"\n\n    response = client.get(\"/users/me\")\n    assert response.status_code == 200\n    assert response.text == \"User fixed me\"\n\n    response = client.get(\"/users/tomchristie/\")\n    assert response.status_code == 200\n    assert response.url == \"http://testserver/users/tomchristie\"\n    assert response.text == \"User tomchristie\"\n\n    response = client.put(\"/users/tomchristie:disable\")\n    assert response.status_code == 200\n    assert response.url == \"http://testserver/users/tomchristie:disable\"\n    assert response.text == \"User tomchristie disabled\"\n\n    response = client.get(\"/users/nomatch\")\n    assert response.status_code == 200\n    assert response.text == \"User nomatch\"\n\n    response = client.get(\"/static/123\")\n    assert response.status_code == 200\n    assert response.text == \"xxxxx\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.filterwarnings('ignore:Trying to detect encoding from a tiny portion of \\\\(5\\\\) byte\\\\(s\\\\)\\\\.:UserWarning:charset_normalizer.api')"
      ],
      "arguments": [
        "client"
      ],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == 'Hello, world'",
        "assert response.status_code == 405",
        "assert response.text == 'Method Not Allowed'",
        "assert set(response.headers['allow'].split(', ')) == {'HEAD', 'GET'}",
        "assert response.status_code == 404",
        "assert response.text == 'Not Found'",
        "assert response.status_code == 200",
        "assert response.text == 'All users'",
        "assert response.status_code == 200",
        "assert response.text == 'User tomchristie'",
        "assert response.status_code == 200",
        "assert response.text == 'User fixed me'",
        "assert response.status_code == 200",
        "assert response.url == 'http://testserver/users/tomchristie'",
        "assert response.text == 'User tomchristie'",
        "assert response.status_code == 200",
        "assert response.url == 'http://testserver/users/tomchristie:disable'",
        "assert response.text == 'User tomchristie disabled'",
        "assert response.status_code == 200",
        "assert response.text == 'User nomatch'",
        "assert response.status_code == 200",
        "assert response.text == 'xxxxx'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_route_converters",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 224,
      "end_line_number": 256,
      "source_code": "def test_route_converters(client: TestClient) -> None:\n    # Test integer conversion\n    response = client.get(\"/int/5\")\n    assert response.status_code == 200\n    assert response.json() == {\"int\": 5}\n    assert app.url_path_for(\"int-convertor\", param=5) == \"/int/5\"\n\n    # Test path with parentheses\n    response = client.get(\"/path-with-parentheses(7)\")\n    assert response.status_code == 200\n    assert response.json() == {\"int\": 7}\n    assert app.url_path_for(\"path-with-parentheses\", param=7) == \"/path-with-parentheses(7)\"\n\n    # Test float conversion\n    response = client.get(\"/float/25.5\")\n    assert response.status_code == 200\n    assert response.json() == {\"float\": 25.5}\n    assert app.url_path_for(\"float-convertor\", param=25.5) == \"/float/25.5\"\n\n    # Test path conversion\n    response = client.get(\"/path/some/example\")\n    assert response.status_code == 200\n    assert response.json() == {\"path\": \"some/example\"}\n    assert app.url_path_for(\"path-convertor\", param=\"some/example\") == \"/path/some/example\"\n\n    # Test UUID conversion\n    response = client.get(\"/uuid/ec38df32-ceda-4cfa-9b4a-1aeb94ad551a\")\n    assert response.status_code == 200\n    assert response.json() == {\"uuid\": \"ec38df32-ceda-4cfa-9b4a-1aeb94ad551a\"}\n    assert (\n        app.url_path_for(\"uuid-convertor\", param=uuid.UUID(\"ec38df32-ceda-4cfa-9b4a-1aeb94ad551a\"))\n        == \"/uuid/ec38df32-ceda-4cfa-9b4a-1aeb94ad551a\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "client"
      ],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.json() == {'int': 5}",
        "assert app.url_path_for('int-convertor', param=5) == '/int/5'",
        "assert response.status_code == 200",
        "assert response.json() == {'int': 7}",
        "assert app.url_path_for('path-with-parentheses', param=7) == '/path-with-parentheses(7)'",
        "assert response.status_code == 200",
        "assert response.json() == {'float': 25.5}",
        "assert app.url_path_for('float-convertor', param=25.5) == '/float/25.5'",
        "assert response.status_code == 200",
        "assert response.json() == {'path': 'some/example'}",
        "assert app.url_path_for('path-convertor', param='some/example') == '/path/some/example'",
        "assert response.status_code == 200",
        "assert response.json() == {'uuid': 'ec38df32-ceda-4cfa-9b4a-1aeb94ad551a'}",
        "assert app.url_path_for('uuid-convertor', param=uuid.UUID('ec38df32-ceda-4cfa-9b4a-1aeb94ad551a')) == '/uuid/ec38df32-ceda-4cfa-9b4a-1aeb94ad551a'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_url_path_for",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 259,
      "end_line_number": 270,
      "source_code": "def test_url_path_for() -> None:\n    assert app.url_path_for(\"homepage\") == \"/\"\n    assert app.url_path_for(\"user\", username=\"tomchristie\") == \"/users/tomchristie\"\n    assert app.url_path_for(\"websocket_endpoint\") == \"/ws\"\n    with pytest.raises(NoMatchFound, match='No route exists for name \"broken\" and params \"\".'):\n        assert app.url_path_for(\"broken\")\n    with pytest.raises(NoMatchFound, match='No route exists for name \"broken\" and params \"key, key2\".'):\n        assert app.url_path_for(\"broken\", key=\"value\", key2=\"value2\")\n    with pytest.raises(AssertionError):\n        app.url_path_for(\"user\", username=\"tom/christie\")\n    with pytest.raises(AssertionError):\n        app.url_path_for(\"user\", username=\"\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.url_path_for('homepage') == '/'",
        "assert app.url_path_for('user', username='tomchristie') == '/users/tomchristie'",
        "assert app.url_path_for('websocket_endpoint') == '/ws'",
        "assert app.url_path_for('broken')",
        "assert app.url_path_for('broken', key='value', key2='value2')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_url_for",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 273,
      "end_line_number": 290,
      "source_code": "def test_url_for() -> None:\n    assert app.url_path_for(\"homepage\").make_absolute_url(base_url=\"https://example.org\") == \"https://example.org/\"\n    assert (\n        app.url_path_for(\"homepage\").make_absolute_url(base_url=\"https://example.org/root_path/\")\n        == \"https://example.org/root_path/\"\n    )\n    assert (\n        app.url_path_for(\"user\", username=\"tomchristie\").make_absolute_url(base_url=\"https://example.org\")\n        == \"https://example.org/users/tomchristie\"\n    )\n    assert (\n        app.url_path_for(\"user\", username=\"tomchristie\").make_absolute_url(base_url=\"https://example.org/root_path/\")\n        == \"https://example.org/root_path/users/tomchristie\"\n    )\n    assert (\n        app.url_path_for(\"websocket_endpoint\").make_absolute_url(base_url=\"https://example.org\")\n        == \"wss://example.org/ws\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.url_path_for('homepage').make_absolute_url(base_url='https://example.org') == 'https://example.org/'",
        "assert app.url_path_for('homepage').make_absolute_url(base_url='https://example.org/root_path/') == 'https://example.org/root_path/'",
        "assert app.url_path_for('user', username='tomchristie').make_absolute_url(base_url='https://example.org') == 'https://example.org/users/tomchristie'",
        "assert app.url_path_for('user', username='tomchristie').make_absolute_url(base_url='https://example.org/root_path/') == 'https://example.org/root_path/users/tomchristie'",
        "assert app.url_path_for('websocket_endpoint').make_absolute_url(base_url='https://example.org') == 'wss://example.org/ws'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_router_add_route",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 293,
      "end_line_number": 296,
      "source_code": "def test_router_add_route(client: TestClient) -> None:\n    response = client.get(\"/func\")\n    assert response.status_code == 200\n    assert response.text == \"Hello, world!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "client"
      ],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == 'Hello, world!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_router_duplicate_path",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 299,
      "end_line_number": 302,
      "source_code": "def test_router_duplicate_path(client: TestClient) -> None:\n    response = client.post(\"/func\")\n    assert response.status_code == 200\n    assert response.text == \"Hello, POST!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "client"
      ],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == 'Hello, POST!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_router_add_websocket_route",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 305,
      "end_line_number": 312,
      "source_code": "def test_router_add_websocket_route(client: TestClient) -> None:\n    with client.websocket_connect(\"/ws\") as session:\n        text = session.receive_text()\n        assert text == \"Hello, world!\"\n\n    with client.websocket_connect(\"/ws/test\") as session:\n        text = session.receive_text()\n        assert text == \"Hello, test!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "client"
      ],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert text == 'Hello, world!'",
        "assert text == 'Hello, test!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_router_middleware",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 315,
      "end_line_number": 332,
      "source_code": "def test_router_middleware(test_client_factory: TestClientFactory) -> None:\n    class CustomMiddleware:\n        def __init__(self, app: ASGIApp) -> None:\n            self.app = app\n\n        async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n            response = PlainTextResponse(\"OK\")\n            await response(scope, receive, send)\n\n    app = Router(\n        routes=[Route(\"/\", homepage)],\n        middleware=[Middleware(CustomMiddleware)],\n    )\n\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.status_code == 200\n    assert response.text == \"OK\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == 'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_protocol_switch",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 356,
      "end_line_number": 368,
      "source_code": "def test_protocol_switch(test_client_factory: TestClientFactory) -> None:\n    client = test_client_factory(mixed_protocol_app)\n\n    response = client.get(\"/\")\n    assert response.status_code == 200\n    assert response.text == \"URL: http://testserver/\"\n\n    with client.websocket_connect(\"/\") as session:\n        assert session.receive_json() == {\"URL\": \"ws://testserver/\"}\n\n    with pytest.raises(WebSocketDisconnect):\n        with client.websocket_connect(\"/404\"):\n            pass",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == 'URL: http://testserver/'",
        "assert session.receive_json() == {'URL': 'ws://testserver/'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_mount_urls",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 374,
      "end_line_number": 381,
      "source_code": "def test_mount_urls(test_client_factory: TestClientFactory) -> None:\n    mounted = Router([Mount(\"/users\", ok, name=\"users\")])\n    client = test_client_factory(mounted)\n    assert client.get(\"/users\").status_code == 200\n    assert client.get(\"/users\").url == \"http://testserver/users/\"\n    assert client.get(\"/users/\").status_code == 200\n    assert client.get(\"/users/a\").status_code == 200\n    assert client.get(\"/usersa\").status_code == 404",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/users').status_code == 200",
        "assert client.get('/users').url == 'http://testserver/users/'",
        "assert client.get('/users/').status_code == 200",
        "assert client.get('/users/a').status_code == 200",
        "assert client.get('/usersa').status_code == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_reverse_mount_urls",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 384,
      "end_line_number": 391,
      "source_code": "def test_reverse_mount_urls() -> None:\n    mounted = Router([Mount(\"/users\", ok, name=\"users\")])\n    assert mounted.url_path_for(\"users\", path=\"/a\") == \"/users/a\"\n\n    users = Router([Route(\"/{username}\", ok, name=\"user\")])\n    mounted = Router([Mount(\"/{subpath}/users\", users, name=\"users\")])\n    assert mounted.url_path_for(\"users:user\", subpath=\"test\", username=\"tom\") == \"/test/users/tom\"\n    assert mounted.url_path_for(\"users\", subpath=\"test\", path=\"/tom\") == \"/test/users/tom\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert mounted.url_path_for('users', path='/a') == '/users/a'",
        "assert mounted.url_path_for('users:user', subpath='test', username='tom') == '/test/users/tom'",
        "assert mounted.url_path_for('users', subpath='test', path='/tom') == '/test/users/tom'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_mount_at_root",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 394,
      "end_line_number": 397,
      "source_code": "def test_mount_at_root(test_client_factory: TestClientFactory) -> None:\n    mounted = Router([Mount(\"/\", ok, name=\"users\")])\n    client = test_client_factory(mounted)\n    assert client.get(\"/\").status_code == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/').status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_host_routing",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 429,
      "end_line_number": 466,
      "source_code": "def test_host_routing(test_client_factory: TestClientFactory) -> None:\n    client = test_client_factory(mixed_hosts_app, base_url=\"https://api.example.org/\")\n\n    response = client.get(\"/users\")\n    assert response.status_code == 200\n    assert response.json() == {\"users\": [{\"username\": \"tom\"}]}\n\n    response = client.get(\"/\")\n    assert response.status_code == 404\n\n    client = test_client_factory(mixed_hosts_app, base_url=\"https://www.example.org/\")\n\n    response = client.get(\"/users\")\n    assert response.status_code == 200\n    assert response.text == \"All users\"\n\n    response = client.get(\"/\")\n    assert response.status_code == 200\n\n    client = test_client_factory(mixed_hosts_app, base_url=\"https://port.example.org:3600/\")\n\n    response = client.get(\"/users\")\n    assert response.status_code == 404\n\n    response = client.get(\"/\")\n    assert response.status_code == 200\n\n    # Port in requested Host is irrelevant.\n\n    client = test_client_factory(mixed_hosts_app, base_url=\"https://port.example.org/\")\n\n    response = client.get(\"/\")\n    assert response.status_code == 200\n\n    client = test_client_factory(mixed_hosts_app, base_url=\"https://port.example.org:5600/\")\n\n    response = client.get(\"/\")\n    assert response.status_code == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.json() == {'users': [{'username': 'tom'}]}",
        "assert response.status_code == 404",
        "assert response.status_code == 200",
        "assert response.text == 'All users'",
        "assert response.status_code == 200",
        "assert response.status_code == 404",
        "assert response.status_code == 200",
        "assert response.status_code == 200",
        "assert response.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_host_reverse_urls",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 469,
      "end_line_number": 481,
      "source_code": "def test_host_reverse_urls() -> None:\n    assert mixed_hosts_app.url_path_for(\"homepage\").make_absolute_url(\"https://whatever\") == \"https://www.example.org/\"\n    assert (\n        mixed_hosts_app.url_path_for(\"users\").make_absolute_url(\"https://whatever\") == \"https://www.example.org/users\"\n    )\n    assert (\n        mixed_hosts_app.url_path_for(\"api:users\").make_absolute_url(\"https://whatever\")\n        == \"https://api.example.org/users\"\n    )\n    assert (\n        mixed_hosts_app.url_path_for(\"port:homepage\").make_absolute_url(\"https://whatever\")\n        == \"https://port.example.org:3600/\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert mixed_hosts_app.url_path_for('homepage').make_absolute_url('https://whatever') == 'https://www.example.org/'",
        "assert mixed_hosts_app.url_path_for('users').make_absolute_url('https://whatever') == 'https://www.example.org/users'",
        "assert mixed_hosts_app.url_path_for('api:users').make_absolute_url('https://whatever') == 'https://api.example.org/users'",
        "assert mixed_hosts_app.url_path_for('port:homepage').make_absolute_url('https://whatever') == 'https://port.example.org:3600/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_subdomain_routing",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 492,
      "end_line_number": 497,
      "source_code": "def test_subdomain_routing(test_client_factory: TestClientFactory) -> None:\n    client = test_client_factory(subdomain_router, base_url=\"https://foo.example.org/\")\n\n    response = client.get(\"/\")\n    assert response.status_code == 200\n    assert response.json() == {\"subdomain\": \"foo\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.json() == {'subdomain': 'foo'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_subdomain_reverse_urls",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 500,
      "end_line_number": 506,
      "source_code": "def test_subdomain_reverse_urls() -> None:\n    assert (\n        subdomain_router.url_path_for(\"subdomains\", subdomain=\"foo\", path=\"/homepage\").make_absolute_url(\n            \"https://whatever\"\n        )\n        == \"https://foo.example.org/homepage\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert subdomain_router.url_path_for('subdomains', subdomain='foo', path='/homepage').make_absolute_url('https://whatever') == 'https://foo.example.org/homepage'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_url_for_with_root_path",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 528,
      "end_line_number": 540,
      "source_code": "def test_url_for_with_root_path(test_client_factory: TestClientFactory) -> None:\n    app = Starlette(routes=echo_url_routes)\n    client = test_client_factory(app, base_url=\"https://www.example.org/\", root_path=\"/sub_path\")\n    response = client.get(\"/sub_path/\")\n    assert response.json() == {\n        \"index\": \"https://www.example.org/sub_path/\",\n        \"submount\": \"https://www.example.org/sub_path/submount/\",\n    }\n    response = client.get(\"/sub_path/submount/\")\n    assert response.json() == {\n        \"index\": \"https://www.example.org/sub_path/\",\n        \"submount\": \"https://www.example.org/sub_path/submount/\",\n    }",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'index': 'https://www.example.org/sub_path/', 'submount': 'https://www.example.org/sub_path/submount/'}",
        "assert response.json() == {'index': 'https://www.example.org/sub_path/', 'submount': 'https://www.example.org/sub_path/submount/'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_url_for_with_double_mount",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 552,
      "end_line_number": 555,
      "source_code": "def test_url_for_with_double_mount() -> None:\n    app = Starlette(routes=double_mount_routes)\n    url = app.url_path_for(\"mount:static\", path=\"123\")\n    assert url == \"/mount/static/123\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert url == '/mount/static/123'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_standalone_route_matches",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 558,
      "end_line_number": 565,
      "source_code": "def test_standalone_route_matches(\n    test_client_factory: TestClientFactory,\n) -> None:\n    app = Route(\"/\", PlainTextResponse(\"Hello, World!\"))\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.status_code == 200\n    assert response.text == \"Hello, World!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == 'Hello, World!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_standalone_route_does_not_match",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 568,
      "end_line_number": 575,
      "source_code": "def test_standalone_route_does_not_match(\n    test_client_factory: typing.Callable[..., TestClient],\n) -> None:\n    app = Route(\"/\", PlainTextResponse(\"Hello, World!\"))\n    client = test_client_factory(app)\n    response = client.get(\"/invalid\")\n    assert response.status_code == 404\n    assert response.text == \"Not Found\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 404",
        "assert response.text == 'Not Found'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_standalone_ws_route_matches",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 584,
      "end_line_number": 591,
      "source_code": "def test_standalone_ws_route_matches(\n    test_client_factory: TestClientFactory,\n) -> None:\n    app = WebSocketRoute(\"/\", ws_helloworld)\n    client = test_client_factory(app)\n    with client.websocket_connect(\"/\") as websocket:\n        text = websocket.receive_text()\n        assert text == \"Hello, world!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert text == 'Hello, world!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_standalone_ws_route_does_not_match",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 594,
      "end_line_number": 601,
      "source_code": "def test_standalone_ws_route_does_not_match(\n    test_client_factory: TestClientFactory,\n) -> None:\n    app = WebSocketRoute(\"/\", ws_helloworld)\n    client = test_client_factory(app)\n    with pytest.raises(WebSocketDisconnect):\n        with client.websocket_connect(\"/invalid\"):\n            pass",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_lifespan_async",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 604,
      "end_line_number": 633,
      "source_code": "def test_lifespan_async(test_client_factory: TestClientFactory) -> None:\n    startup_complete = False\n    shutdown_complete = False\n\n    async def hello_world(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"hello, world\")\n\n    async def run_startup() -> None:\n        nonlocal startup_complete\n        startup_complete = True\n\n    async def run_shutdown() -> None:\n        nonlocal shutdown_complete\n        shutdown_complete = True\n\n    with pytest.deprecated_call(match=\"The on_startup and on_shutdown parameters are deprecated\"):\n        app = Router(\n            on_startup=[run_startup],\n            on_shutdown=[run_shutdown],\n            routes=[Route(\"/\", hello_world)],\n        )\n\n    assert not startup_complete\n    assert not shutdown_complete\n    with test_client_factory(app) as client:\n        assert startup_complete\n        assert not shutdown_complete\n        client.get(\"/\")\n    assert startup_complete\n    assert shutdown_complete",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert not startup_complete",
        "assert not shutdown_complete",
        "assert startup_complete",
        "assert shutdown_complete",
        "assert startup_complete",
        "assert not shutdown_complete"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_lifespan_with_on_events",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 636,
      "end_line_number": 673,
      "source_code": "def test_lifespan_with_on_events(test_client_factory: TestClientFactory) -> None:\n    lifespan_called = False\n    startup_called = False\n    shutdown_called = False\n\n    @contextlib.asynccontextmanager\n    async def lifespan(app: Starlette) -> typing.AsyncGenerator[None, None]:\n        nonlocal lifespan_called\n        lifespan_called = True\n        yield\n\n    # We do not expected, neither of run_startup nor run_shutdown to be called\n    # we thus mark them as #pragma: no cover, to fulfill test coverage\n    def run_startup() -> None:  # pragma: no cover\n        nonlocal startup_called\n        startup_called = True\n\n    def run_shutdown() -> None:  # pragma: no cover\n        nonlocal shutdown_called\n        shutdown_called = True\n\n    with pytest.deprecated_call(match=\"The on_startup and on_shutdown parameters are deprecated\"):\n        with pytest.warns(\n            UserWarning, match=\"The `lifespan` parameter cannot be used with `on_startup` or `on_shutdown`.\"\n        ):\n            app = Router(on_startup=[run_startup], on_shutdown=[run_shutdown], lifespan=lifespan)\n\n            assert not lifespan_called\n            assert not startup_called\n            assert not shutdown_called\n\n            # Triggers the lifespan events\n            with test_client_factory(app):\n                ...\n\n            assert lifespan_called\n            assert not startup_called\n            assert not shutdown_called",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert not lifespan_called",
        "assert not startup_called",
        "assert not shutdown_called",
        "assert lifespan_called",
        "assert not startup_called",
        "assert not shutdown_called"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_lifespan_sync",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 676,
      "end_line_number": 705,
      "source_code": "def test_lifespan_sync(test_client_factory: TestClientFactory) -> None:\n    startup_complete = False\n    shutdown_complete = False\n\n    def hello_world(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"hello, world\")\n\n    def run_startup() -> None:\n        nonlocal startup_complete\n        startup_complete = True\n\n    def run_shutdown() -> None:\n        nonlocal shutdown_complete\n        shutdown_complete = True\n\n    with pytest.deprecated_call(match=\"The on_startup and on_shutdown parameters are deprecated\"):\n        app = Router(\n            on_startup=[run_startup],\n            on_shutdown=[run_shutdown],\n            routes=[Route(\"/\", hello_world)],\n        )\n\n    assert not startup_complete\n    assert not shutdown_complete\n    with test_client_factory(app) as client:\n        assert startup_complete\n        assert not shutdown_complete\n        client.get(\"/\")\n    assert startup_complete\n    assert shutdown_complete",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert not startup_complete",
        "assert not shutdown_complete",
        "assert startup_complete",
        "assert shutdown_complete",
        "assert startup_complete",
        "assert not shutdown_complete"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_lifespan_state_unsupported",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 708,
      "end_line_number": 728,
      "source_code": "def test_lifespan_state_unsupported(\n    test_client_factory: TestClientFactory,\n) -> None:\n    @contextlib.asynccontextmanager\n    async def lifespan(\n        app: ASGIApp,\n    ) -> typing.AsyncGenerator[dict[str, str], None]:\n        yield {\"foo\": \"bar\"}\n\n    app = Router(\n        lifespan=lifespan,\n        routes=[Mount(\"/\", PlainTextResponse(\"hello, world\"))],\n    )\n\n    async def no_state_wrapper(scope: Scope, receive: Receive, send: Send) -> None:\n        del scope[\"state\"]\n        await app(scope, receive, send)\n\n    with pytest.raises(RuntimeError, match='The server does not support \"state\" in the lifespan scope'):\n        with test_client_factory(no_state_wrapper):\n            raise AssertionError(\"Should not be called\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app",
          "body": "def app(request: Request) -> Response:\n    return endpoint(request=request, **kwargs)"
        },
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_lifespan_state_async_cm",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 731,
      "end_line_number": 776,
      "source_code": "def test_lifespan_state_async_cm(test_client_factory: TestClientFactory) -> None:\n    startup_complete = False\n    shutdown_complete = False\n\n    class State(typing.TypedDict):\n        count: int\n        items: list[int]\n\n    async def hello_world(request: Request) -> Response:\n        # modifications to the state should not leak across requests\n        assert request.state.count == 0\n        # modify the state, this should not leak to the lifespan or other requests\n        request.state.count += 1\n        # since state.items is a mutable object this modification _will_ leak across\n        # requests and to the lifespan\n        request.state.items.append(1)\n        return PlainTextResponse(\"hello, world\")\n\n    @contextlib.asynccontextmanager\n    async def lifespan(app: Starlette) -> typing.AsyncIterator[State]:\n        nonlocal startup_complete, shutdown_complete\n        startup_complete = True\n        state = State(count=0, items=[])\n        yield state\n        shutdown_complete = True\n        # modifications made to the state from a request do not leak to the lifespan\n        assert state[\"count\"] == 0\n        # unless of course the request mutates a mutable object that is referenced\n        # via state\n        assert state[\"items\"] == [1, 1]\n\n    app = Router(\n        lifespan=lifespan,\n        routes=[Route(\"/\", hello_world)],\n    )\n\n    assert not startup_complete\n    assert not shutdown_complete\n    with test_client_factory(app) as client:\n        assert startup_complete\n        assert not shutdown_complete\n        client.get(\"/\")\n        # Calling it a second time to ensure that the state is preserved.\n        client.get(\"/\")\n    assert startup_complete\n    assert shutdown_complete",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert not startup_complete",
        "assert not shutdown_complete",
        "assert startup_complete",
        "assert shutdown_complete",
        "assert request.state.count == 0",
        "assert state['count'] == 0",
        "assert state['items'] == [1, 1]",
        "assert startup_complete",
        "assert not shutdown_complete"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_raise_on_startup",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 779,
      "end_line_number": 799,
      "source_code": "def test_raise_on_startup(test_client_factory: TestClientFactory) -> None:\n    def run_startup() -> None:\n        raise RuntimeError()\n\n    with pytest.deprecated_call(match=\"The on_startup and on_shutdown parameters are deprecated\"):\n        router = Router(on_startup=[run_startup])\n    startup_failed = False\n\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        async def _send(message: Message) -> None:\n            nonlocal startup_failed\n            if message[\"type\"] == \"lifespan.startup.failed\":\n                startup_failed = True\n            return await send(message)\n\n        await router(scope, receive, _send)\n\n    with pytest.raises(RuntimeError):\n        with test_client_factory(app):\n            pass  # pragma: no cover\n    assert startup_failed",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert startup_failed"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_raise_on_shutdown",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 802,
      "end_line_number": 811,
      "source_code": "def test_raise_on_shutdown(test_client_factory: TestClientFactory) -> None:\n    def run_shutdown() -> None:\n        raise RuntimeError()\n\n    with pytest.deprecated_call(match=\"The on_startup and on_shutdown parameters are deprecated\"):\n        app = Router(on_shutdown=[run_shutdown])\n\n    with pytest.raises(RuntimeError):\n        with test_client_factory(app):\n            pass",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_partial_async_endpoint",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 814,
      "end_line_number": 822,
      "source_code": "def test_partial_async_endpoint(test_client_factory: TestClientFactory) -> None:\n    test_client = test_client_factory(app)\n    response = test_client.get(\"/partial\")\n    assert response.status_code == 200\n    assert response.json() == {\"arg\": \"foo\"}\n\n    cls_method_response = test_client.get(\"/partial/cls\")\n    assert cls_method_response.status_code == 200\n    assert cls_method_response.json() == {\"arg\": \"foo\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.json() == {'arg': 'foo'}",
        "assert cls_method_response.status_code == 200",
        "assert cls_method_response.json() == {'arg': 'foo'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "test_client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "test_client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_partial_async_ws_endpoint",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 825,
      "end_line_number": 835,
      "source_code": "def test_partial_async_ws_endpoint(\n    test_client_factory: TestClientFactory,\n) -> None:\n    test_client = test_client_factory(app)\n    with test_client.websocket_connect(\"/partial/ws\") as websocket:\n        data = websocket.receive_json()\n        assert data == {\"url\": \"ws://testserver/partial/ws\"}\n\n    with test_client.websocket_connect(\"/partial/ws/cls\") as websocket:\n        data = websocket.receive_json()\n        assert data == {\"url\": \"ws://testserver/partial/ws/cls\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert data == {'url': 'ws://testserver/partial/ws'}",
        "assert data == {'url': 'ws://testserver/partial/ws/cls'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_duplicated_param_names",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 838,
      "end_line_number": 849,
      "source_code": "def test_duplicated_param_names() -> None:\n    with pytest.raises(\n        ValueError,\n        match=\"Duplicated param name id at path /{id}/{id}\",\n    ):\n        Route(\"/{id}/{id}\", user)\n\n    with pytest.raises(\n        ValueError,\n        match=\"Duplicated param names id, name at path /{id}/{name}/{id}/{name}\",\n    ):\n        Route(\"/{id}/{name}/{id}/{name}\", user)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_route_name",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 879,
      "end_line_number": 880,
      "source_code": "def test_route_name(endpoint: typing.Callable[..., Response], expected_name: str) -> None:\n    assert Route(path=\"/\", endpoint=endpoint).name == expected_name",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('endpoint, expected_name', [pytest.param(func_homepage, 'func_homepage', id='function'), pytest.param(Endpoint().my_method, 'my_method', id='method'), pytest.param(Endpoint.my_classmethod, 'my_classmethod', id='classmethod'), pytest.param(Endpoint.my_staticmethod, 'my_staticmethod', id='staticmethod'), pytest.param(Endpoint(), 'Endpoint', id='object'), pytest.param(lambda request: ..., '<lambda>', id='lambda')])"
      ],
      "arguments": [
        "endpoint",
        "expected_name"
      ],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert Route(path='/', endpoint=endpoint).name == expected_name"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_base_route_middleware",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 959,
      "end_line_number": 971,
      "source_code": "def test_base_route_middleware(\n    test_client_factory: TestClientFactory,\n    app: Starlette,\n) -> None:\n    test_client = test_client_factory(app)\n\n    response = test_client.get(\"/home\")\n    assert response.status_code == 200\n    assert \"X-Test\" not in response.headers\n\n    response = test_client.get(\"/http\")\n    assert response.status_code == 200\n    assert response.headers[\"X-Test\"] == \"Set by middleware\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('app', [mounted_routes_with_middleware, mounted_app_with_middleware, route_with_middleware])"
      ],
      "arguments": [
        "test_client_factory",
        "app"
      ],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert 'X-Test' not in response.headers",
        "assert response.status_code == 200",
        "assert response.headers['X-Test'] == 'Set by middleware'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "test_client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "test_client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_mount_routes_with_middleware_url_path_for",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 974,
      "end_line_number": 976,
      "source_code": "def test_mount_routes_with_middleware_url_path_for() -> None:\n    \"\"\"Checks that url_path_for still works with mounted routes with Middleware\"\"\"\n    assert mounted_routes_with_middleware.url_path_for(\"route\") == \"/http/\"",
      "docstring": "Checks that url_path_for still works with mounted routes with Middleware",
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert mounted_routes_with_middleware.url_path_for('route') == '/http/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_mount_asgi_app_with_middleware_url_path_for",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 979,
      "end_line_number": 984,
      "source_code": "def test_mount_asgi_app_with_middleware_url_path_for() -> None:\n    \"\"\"Mounted ASGI apps do not work with url path for,\n    middleware does not change this\n    \"\"\"\n    with pytest.raises(NoMatchFound):\n        mounted_app_with_middleware.url_path_for(\"route\")",
      "docstring": "Mounted ASGI apps do not work with url path for,\nmiddleware does not change this",
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_add_route_to_app_after_mount",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 987,
      "end_line_number": 1002,
      "source_code": "def test_add_route_to_app_after_mount(\n    test_client_factory: typing.Callable[..., TestClient],\n) -> None:\n    \"\"\"Checks that Mount will pick up routes\n    added to the underlying app after it is mounted\n    \"\"\"\n    inner_app = Router()\n    app = Mount(\"/http\", app=inner_app)\n    inner_app.add_route(\n        \"/inner\",\n        endpoint=homepage,\n        methods=[\"GET\"],\n    )\n    client = test_client_factory(app)\n    response = client.get(\"/http/inner\")\n    assert response.status_code == 200",
      "docstring": "Checks that Mount will pick up routes\nadded to the underlying app after it is mounted",
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_exception_on_mounted_apps",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 1005,
      "end_line_number": 1017,
      "source_code": "def test_exception_on_mounted_apps(\n    test_client_factory: TestClientFactory,\n) -> None:\n    def exc(request: Request) -> None:\n        raise Exception(\"Exc\")\n\n    sub_app = Starlette(routes=[Route(\"/\", exc)])\n    app = Starlette(routes=[Mount(\"/sub\", app=sub_app)])\n\n    client = test_client_factory(app)\n    with pytest.raises(Exception) as ctx:\n        client.get(\"/sub/\")\n    assert str(ctx.value) == \"Exc\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(ctx.value) == 'Exc'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_mounted_middleware_does_not_catch_exception",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 1020,
      "end_line_number": 1072,
      "source_code": "def test_mounted_middleware_does_not_catch_exception(\n    test_client_factory: typing.Callable[..., TestClient],\n) -> None:\n    # https://github.com/encode/starlette/pull/1649#discussion_r960236107\n    def exc(request: Request) -> Response:\n        raise HTTPException(status_code=403, detail=\"auth\")\n\n    class NamedMiddleware:\n        def __init__(self, app: ASGIApp, name: str) -> None:\n            self.app = app\n            self.name = name\n\n        async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n            async def modified_send(msg: Message) -> None:\n                if msg[\"type\"] == \"http.response.start\":\n                    msg[\"headers\"].append((f\"X-{self.name}\".encode(), b\"true\"))\n                await send(msg)\n\n            await self.app(scope, receive, modified_send)\n\n    app = Starlette(\n        routes=[\n            Mount(\n                \"/mount\",\n                routes=[\n                    Route(\"/err\", exc),\n                    Route(\"/home\", homepage),\n                ],\n                middleware=[Middleware(NamedMiddleware, name=\"Mounted\")],\n            ),\n            Route(\"/err\", exc),\n            Route(\"/home\", homepage),\n        ],\n        middleware=[Middleware(NamedMiddleware, name=\"Outer\")],\n    )\n\n    client = test_client_factory(app)\n\n    resp = client.get(\"/home\")\n    assert resp.status_code == 200, resp.content\n    assert \"X-Outer\" in resp.headers\n\n    resp = client.get(\"/err\")\n    assert resp.status_code == 403, resp.content\n    assert \"X-Outer\" in resp.headers\n\n    resp = client.get(\"/mount/home\")\n    assert resp.status_code == 200, resp.content\n    assert \"X-Mounted\" in resp.headers\n\n    resp = client.get(\"/mount/err\")\n    assert resp.status_code == 403, resp.content\n    assert \"X-Mounted\" in resp.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 200, resp.content",
        "assert 'X-Outer' in resp.headers",
        "assert resp.status_code == 403, resp.content",
        "assert 'X-Outer' in resp.headers",
        "assert resp.status_code == 200, resp.content",
        "assert 'X-Mounted' in resp.headers",
        "assert resp.status_code == 403, resp.content",
        "assert 'X-Mounted' in resp.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "self.app",
          "body": "def app(request: Request) -> Response:\n    return endpoint(request=request, **kwargs)"
        }
      ]
    },
    {
      "name": "test_websocket_route_middleware",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 1075,
      "end_line_number": 1110,
      "source_code": "def test_websocket_route_middleware(\n    test_client_factory: TestClientFactory,\n) -> None:\n    async def websocket_endpoint(session: WebSocket) -> None:\n        await session.accept()\n        await session.send_text(\"Hello, world!\")\n        await session.close()\n\n    class WebsocketMiddleware:\n        def __init__(self, app: ASGIApp) -> None:\n            self.app = app\n\n        async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n            async def modified_send(msg: Message) -> None:\n                if msg[\"type\"] == \"websocket.accept\":\n                    msg[\"headers\"].append((b\"X-Test\", b\"Set by middleware\"))\n                await send(msg)\n\n            await self.app(scope, receive, modified_send)\n\n    app = Starlette(\n        routes=[\n            WebSocketRoute(\n                \"/ws\",\n                endpoint=websocket_endpoint,\n                middleware=[Middleware(WebsocketMiddleware)],\n            )\n        ]\n    )\n\n    client = test_client_factory(app)\n\n    with client.websocket_connect(\"/ws\") as websocket:\n        text = websocket.receive_text()\n        assert text == \"Hello, world!\"\n        assert websocket.extra_headers == [(b\"X-Test\", b\"Set by middleware\")]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert text == 'Hello, world!'",
        "assert websocket.extra_headers == [(b'X-Test', b'Set by middleware')]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "self.app",
          "body": "def app(request: Request) -> Response:\n    return endpoint(request=request, **kwargs)"
        }
      ]
    },
    {
      "name": "test_route_repr",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 1113,
      "end_line_number": 1115,
      "source_code": "def test_route_repr() -> None:\n    route = Route(\"/welcome\", endpoint=homepage)\n    assert repr(route) == \"Route(path='/welcome', name='homepage', methods=['GET', 'HEAD'])\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(route) == \"Route(path='/welcome', name='homepage', methods=['GET', 'HEAD'])\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_route_repr_without_methods",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 1118,
      "end_line_number": 1120,
      "source_code": "def test_route_repr_without_methods() -> None:\n    route = Route(\"/welcome\", endpoint=Endpoint, methods=None)\n    assert repr(route) == \"Route(path='/welcome', name='Endpoint', methods=[])\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(route) == \"Route(path='/welcome', name='Endpoint', methods=[])\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_websocket_route_repr",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 1123,
      "end_line_number": 1125,
      "source_code": "def test_websocket_route_repr() -> None:\n    route = WebSocketRoute(\"/ws\", endpoint=websocket_endpoint)\n    assert repr(route) == \"WebSocketRoute(path='/ws', name='websocket_endpoint')\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(route) == \"WebSocketRoute(path='/ws', name='websocket_endpoint')\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_mount_repr",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 1128,
      "end_line_number": 1136,
      "source_code": "def test_mount_repr() -> None:\n    route = Mount(\n        \"/app\",\n        routes=[\n            Route(\"/\", endpoint=homepage),\n        ],\n    )\n    # test for substring because repr(Router) returns unique object ID\n    assert repr(route).startswith(\"Mount(path='/app', name='', app=\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(route).startswith(\"Mount(path='/app', name='', app=\")"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_mount_named_repr",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 1139,
      "end_line_number": 1148,
      "source_code": "def test_mount_named_repr() -> None:\n    route = Mount(\n        \"/app\",\n        name=\"app\",\n        routes=[\n            Route(\"/\", endpoint=homepage),\n        ],\n    )\n    # test for substring because repr(Router) returns unique object ID\n    assert repr(route).startswith(\"Mount(path='/app', name='app', app=\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(route).startswith(\"Mount(path='/app', name='app', app=\")"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_host_repr",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 1151,
      "end_line_number": 1161,
      "source_code": "def test_host_repr() -> None:\n    route = Host(\n        \"example.com\",\n        app=Router(\n            [\n                Route(\"/\", endpoint=homepage),\n            ]\n        ),\n    )\n    # test for substring because repr(Router) returns unique object ID\n    assert repr(route).startswith(\"Host(host='example.com', name='', app=\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(route).startswith(\"Host(host='example.com', name='', app=\")"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_host_named_repr",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 1164,
      "end_line_number": 1175,
      "source_code": "def test_host_named_repr() -> None:\n    route = Host(\n        \"example.com\",\n        name=\"app\",\n        app=Router(\n            [\n                Route(\"/\", endpoint=homepage),\n            ]\n        ),\n    )\n    # test for substring because repr(Router) returns unique object ID\n    assert repr(route).startswith(\"Host(host='example.com', name='app', app=\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(route).startswith(\"Host(host='example.com', name='app', app=\")"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_decorator_deprecations",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 1178,
      "end_line_number": 1191,
      "source_code": "def test_decorator_deprecations() -> None:\n    router = Router()\n\n    with pytest.deprecated_call():\n        router.route(\"/\")(homepage)\n\n    with pytest.deprecated_call():\n        router.websocket_route(\"/ws\")(websocket_endpoint)\n\n    with pytest.deprecated_call():\n\n        async def startup() -> None: ...  # pragma: no cover\n\n        router.on_event(\"startup\")(startup)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_paths_with_root_path",
      "module": "test_routing",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/test_routing.py",
      "line_number": 1246,
      "end_line_number": 1282,
      "source_code": "def test_paths_with_root_path(test_client_factory: TestClientFactory) -> None:\n    app = Starlette(routes=echo_paths_routes)\n    client = test_client_factory(app, base_url=\"https://www.example.org/\", root_path=\"/root\")\n    response = client.get(\"/root/path\")\n    assert response.status_code == 200\n    assert response.json() == {\n        \"name\": \"path\",\n        \"path\": \"/root/path\",\n        \"root_path\": \"/root\",\n    }\n    response = client.get(\"/root/asgipath/\")\n    assert response.status_code == 200\n    assert response.json() == {\n        \"name\": \"asgipath\",\n        \"path\": \"/root/asgipath/\",\n        # Things that mount other ASGI apps, like WSGIMiddleware, would not be aware\n        # of the prefixed path, and would have their own notion of their own paths,\n        # so they need to be able to rely on the root_path to know the location they\n        # are mounted on\n        \"root_path\": \"/root/asgipath\",\n    }\n\n    response = client.get(\"/root/sub/path\")\n    assert response.status_code == 200\n    assert response.json() == {\n        \"name\": \"subpath\",\n        \"path\": \"/root/sub/path\",\n        \"root_path\": \"/root/sub\",\n    }\n\n    response = client.post(\"/root/root-queue/path\")\n    assert response.status_code == 200\n    assert response.json() == {\n        \"name\": \"queue_path\",\n        \"path\": \"/root/root-queue/path\",\n        \"root_path\": \"/root\",\n    }",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextlib",
        "functools",
        "json",
        "typing",
        "uuid",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.routing.Host",
        "starlette.routing.Mount",
        "starlette.routing.NoMatchFound",
        "starlette.routing.Route",
        "starlette.routing.Router",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "starlette.websockets.WebSocketDisconnect",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.json() == {'name': 'path', 'path': '/root/path', 'root_path': '/root'}",
        "assert response.status_code == 200",
        "assert response.json() == {'name': 'asgipath', 'path': '/root/asgipath/', 'root_path': '/root/asgipath'}",
        "assert response.status_code == 200",
        "assert response.json() == {'name': 'subpath', 'path': '/root/sub/path', 'root_path': '/root/sub'}",
        "assert response.status_code == 200",
        "assert response.json() == {'name': 'queue_path', 'path': '/root/root-queue/path', 'root_path': '/root'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_https_redirect_middleware",
      "module": "test_https_redirect",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_https_redirect.py",
      "line_number": 10,
      "end_line_number": 41,
      "source_code": "def test_https_redirect_middleware(test_client_factory: TestClientFactory) -> None:\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"OK\", status_code=200)\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[Middleware(HTTPSRedirectMiddleware)],\n    )\n\n    client = test_client_factory(app, base_url=\"https://testserver\")\n    response = client.get(\"/\")\n    assert response.status_code == 200\n\n    client = test_client_factory(app)\n    response = client.get(\"/\", allow_redirects=False)\n    assert response.status_code == 307\n    assert response.headers[\"location\"] == \"https://testserver/\"\n\n    client = test_client_factory(app, base_url=\"http://testserver:80\")\n    response = client.get(\"/\", allow_redirects=False)\n    assert response.status_code == 307\n    assert response.headers[\"location\"] == \"https://testserver/\"\n\n    client = test_client_factory(app, base_url=\"http://testserver:443\")\n    response = client.get(\"/\", allow_redirects=False)\n    assert response.status_code == 307\n    assert response.headers[\"location\"] == \"https://testserver/\"\n\n    client = test_client_factory(app, base_url=\"http://testserver:123\")\n    response = client.get(\"/\", allow_redirects=False)\n    assert response.status_code == 307\n    assert response.headers[\"location\"] == \"https://testserver:123/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.middleware.httpsredirect.HTTPSRedirectMiddleware",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.status_code == 307",
        "assert response.headers['location'] == 'https://testserver/'",
        "assert response.status_code == 307",
        "assert response.headers['location'] == 'https://testserver/'",
        "assert response.status_code == 307",
        "assert response.headers['location'] == 'https://testserver/'",
        "assert response.status_code == 307",
        "assert response.headers['location'] == 'https://testserver:123/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_handler",
      "module": "test_errors",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_errors.py",
      "line_number": 15,
      "end_line_number": 28,
      "source_code": "def test_handler(\n    test_client_factory: TestClientFactory,\n) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        raise RuntimeError(\"Something went wrong\")\n\n    def error_500(request: Request, exc: Exception) -> JSONResponse:\n        return JSONResponse({\"detail\": \"Server Error\"}, status_code=500)\n\n    app = ServerErrorMiddleware(app, handler=error_500)\n    client = test_client_factory(app, raise_server_exceptions=False)\n    response = client.get(\"/\")\n    assert response.status_code == 500\n    assert response.json() == {\"detail\": \"Server Error\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "typing.Any",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.background.BackgroundTask",
        "starlette.middleware.errors.ServerErrorMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 500",
        "assert response.json() == {'detail': 'Server Error'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_debug_text",
      "module": "test_errors",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_errors.py",
      "line_number": 31,
      "end_line_number": 40,
      "source_code": "def test_debug_text(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        raise RuntimeError(\"Something went wrong\")\n\n    app = ServerErrorMiddleware(app, debug=True)\n    client = test_client_factory(app, raise_server_exceptions=False)\n    response = client.get(\"/\")\n    assert response.status_code == 500\n    assert response.headers[\"content-type\"].startswith(\"text/plain\")\n    assert \"RuntimeError: Something went wrong\" in response.text",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "typing.Any",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.background.BackgroundTask",
        "starlette.middleware.errors.ServerErrorMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 500",
        "assert response.headers['content-type'].startswith('text/plain')",
        "assert 'RuntimeError: Something went wrong' in response.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_debug_html",
      "module": "test_errors",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_errors.py",
      "line_number": 43,
      "end_line_number": 52,
      "source_code": "def test_debug_html(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        raise RuntimeError(\"Something went wrong\")\n\n    app = ServerErrorMiddleware(app, debug=True)\n    client = test_client_factory(app, raise_server_exceptions=False)\n    response = client.get(\"/\", headers={\"Accept\": \"text/html, */*\"})\n    assert response.status_code == 500\n    assert response.headers[\"content-type\"].startswith(\"text/html\")\n    assert \"RuntimeError\" in response.text",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "typing.Any",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.background.BackgroundTask",
        "starlette.middleware.errors.ServerErrorMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 500",
        "assert response.headers['content-type'].startswith('text/html')",
        "assert 'RuntimeError' in response.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_debug_after_response_sent",
      "module": "test_errors",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_errors.py",
      "line_number": 55,
      "end_line_number": 64,
      "source_code": "def test_debug_after_response_sent(test_client_factory: TestClientFactory) -> None:\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        response = Response(b\"\", status_code=204)\n        await response(scope, receive, send)\n        raise RuntimeError(\"Something went wrong\")\n\n    app = ServerErrorMiddleware(app, debug=True)\n    client = test_client_factory(app)\n    with pytest.raises(RuntimeError):\n        client.get(\"/\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "typing.Any",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.background.BackgroundTask",
        "starlette.middleware.errors.ServerErrorMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_debug_not_http",
      "module": "test_errors",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_errors.py",
      "line_number": 67,
      "end_line_number": 80,
      "source_code": "def test_debug_not_http(test_client_factory: TestClientFactory) -> None:\n    \"\"\"\n    DebugMiddleware should just pass through any non-http messages as-is.\n    \"\"\"\n\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        raise RuntimeError(\"Something went wrong\")\n\n    app = ServerErrorMiddleware(app)\n\n    with pytest.raises(RuntimeError):\n        client = test_client_factory(app)\n        with client.websocket_connect(\"/\"):\n            pass",
      "docstring": "DebugMiddleware should just pass through any non-http messages as-is.",
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "typing.Any",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.background.BackgroundTask",
        "starlette.middleware.errors.ServerErrorMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_background_task",
      "module": "test_errors",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_errors.py",
      "line_number": 83,
      "end_line_number": 105,
      "source_code": "def test_background_task(test_client_factory: TestClientFactory) -> None:\n    accessed_error_handler = False\n\n    def error_handler(request: Request, exc: Exception) -> Any:\n        nonlocal accessed_error_handler\n        accessed_error_handler = True\n\n    def raise_exception() -> None:\n        raise Exception(\"Something went wrong\")\n\n    async def endpoint(request: Request) -> Response:\n        task = BackgroundTask(raise_exception)\n        return Response(status_code=204, background=task)\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=endpoint)],\n        exception_handlers={Exception: error_handler},\n    )\n\n    client = test_client_factory(app, raise_server_exceptions=False)\n    response = client.get(\"/\")\n    assert response.status_code == 204\n    assert accessed_error_handler",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "typing.Any",
        "pytest",
        "starlette.applications.Starlette",
        "starlette.background.BackgroundTask",
        "starlette.middleware.errors.ServerErrorMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.Route",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 204",
        "assert accessed_error_handler"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_middleware_repr",
      "module": "test_middleware",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_middleware.py",
      "line_number": 15,
      "end_line_number": 17,
      "source_code": "def test_middleware_repr() -> None:\n    middleware = Middleware(CustomMiddleware, \"foo\", bar=123)\n    assert repr(middleware) == \"Middleware(CustomMiddleware, 'foo', bar=123)\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "starlette.middleware.Middleware",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(middleware) == \"Middleware(CustomMiddleware, 'foo', bar=123)\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_middleware_iter",
      "module": "test_middleware",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_middleware.py",
      "line_number": 20,
      "end_line_number": 22,
      "source_code": "def test_middleware_iter() -> None:\n    cls, args, kwargs = Middleware(CustomMiddleware, \"foo\", bar=123)\n    assert (cls, args, kwargs) == (CustomMiddleware, (\"foo\",), {\"bar\": 123})",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "starlette.middleware.Middleware",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send"
      ],
      "fixtures": [],
      "assertions": [
        "assert (cls, args, kwargs) == (CustomMiddleware, ('foo',), {'bar': 123})"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_custom_middleware",
      "module": "test_base",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_base.py",
      "line_number": 86,
      "end_line_number": 104,
      "source_code": "def test_custom_middleware(test_client_factory: TestClientFactory) -> None:\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.headers[\"Custom-Header\"] == \"Example\"\n\n    with pytest.raises(Exception) as ctx:\n        response = client.get(\"/exc\")\n    assert str(ctx.value) == \"Exc\"\n\n    with pytest.raises(Exception) as ctx:\n        response = client.get(\"/exc-stream\")\n    assert str(ctx.value) == \"Faulty Stream\"\n\n    with pytest.raises(RuntimeError):\n        response = client.get(\"/no-response\")\n\n    with client.websocket_connect(\"/ws\") as session:\n        text = session.receive_text()\n        assert text == \"Hello, world!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextvars",
        "contextlib.AsyncExitStack",
        "typing.Any",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio",
        "pytest",
        "anyio.abc.TaskStatus",
        "starlette.applications.Starlette",
        "starlette.background.BackgroundTask",
        "starlette.middleware.Middleware",
        "starlette.middleware._MiddlewareClass",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.routing.Route",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.headers['Custom-Header'] == 'Example'",
        "assert str(ctx.value) == 'Exc'",
        "assert str(ctx.value) == 'Faulty Stream'",
        "assert text == 'Hello, world!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_state_data_across_multiple_middlewares",
      "module": "test_base",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_base.py",
      "line_number": 107,
      "end_line_number": 160,
      "source_code": "def test_state_data_across_multiple_middlewares(\n    test_client_factory: TestClientFactory,\n) -> None:\n    expected_value1 = \"foo\"\n    expected_value2 = \"bar\"\n\n    class aMiddleware(BaseHTTPMiddleware):\n        async def dispatch(\n            self,\n            request: Request,\n            call_next: RequestResponseEndpoint,\n        ) -> Response:\n            request.state.foo = expected_value1\n            response = await call_next(request)\n            return response\n\n    class bMiddleware(BaseHTTPMiddleware):\n        async def dispatch(\n            self,\n            request: Request,\n            call_next: RequestResponseEndpoint,\n        ) -> Response:\n            request.state.bar = expected_value2\n            response = await call_next(request)\n            response.headers[\"X-State-Foo\"] = request.state.foo\n            return response\n\n    class cMiddleware(BaseHTTPMiddleware):\n        async def dispatch(\n            self,\n            request: Request,\n            call_next: RequestResponseEndpoint,\n        ) -> Response:\n            response = await call_next(request)\n            response.headers[\"X-State-Bar\"] = request.state.bar\n            return response\n\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"OK\")\n\n    app = Starlette(\n        routes=[Route(\"/\", homepage)],\n        middleware=[\n            Middleware(aMiddleware),\n            Middleware(bMiddleware),\n            Middleware(cMiddleware),\n        ],\n    )\n\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.text == \"OK\"\n    assert response.headers[\"X-State-Foo\"] == expected_value1\n    assert response.headers[\"X-State-Bar\"] == expected_value2",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextvars",
        "contextlib.AsyncExitStack",
        "typing.Any",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio",
        "pytest",
        "anyio.abc.TaskStatus",
        "starlette.applications.Starlette",
        "starlette.background.BackgroundTask",
        "starlette.middleware.Middleware",
        "starlette.middleware._MiddlewareClass",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.routing.Route",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert response.headers['X-State-Foo'] == expected_value1",
        "assert response.headers['X-State-Bar'] == expected_value2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_app_middleware_argument",
      "module": "test_base",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_base.py",
      "line_number": 163,
      "end_line_number": 171,
      "source_code": "def test_app_middleware_argument(test_client_factory: TestClientFactory) -> None:\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"Homepage\")\n\n    app = Starlette(routes=[Route(\"/\", homepage)], middleware=[Middleware(CustomMiddleware)])\n\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.headers[\"Custom-Header\"] == \"Example\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextvars",
        "contextlib.AsyncExitStack",
        "typing.Any",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio",
        "pytest",
        "anyio.abc.TaskStatus",
        "starlette.applications.Starlette",
        "starlette.background.BackgroundTask",
        "starlette.middleware.Middleware",
        "starlette.middleware._MiddlewareClass",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.routing.Route",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.headers['Custom-Header'] == 'Example'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_fully_evaluated_response",
      "module": "test_base",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_base.py",
      "line_number": 174,
      "end_line_number": 189,
      "source_code": "def test_fully_evaluated_response(test_client_factory: TestClientFactory) -> None:\n    # Test for https://github.com/encode/starlette/issues/1022\n    class CustomMiddleware(BaseHTTPMiddleware):\n        async def dispatch(\n            self,\n            request: Request,\n            call_next: RequestResponseEndpoint,\n        ) -> PlainTextResponse:\n            await call_next(request)\n            return PlainTextResponse(\"Custom\")\n\n    app = Starlette(middleware=[Middleware(CustomMiddleware)])\n\n    client = test_client_factory(app)\n    response = client.get(\"/does_not_exist\")\n    assert response.text == \"Custom\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextvars",
        "contextlib.AsyncExitStack",
        "typing.Any",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio",
        "pytest",
        "anyio.abc.TaskStatus",
        "starlette.applications.Starlette",
        "starlette.background.BackgroundTask",
        "starlette.middleware.Middleware",
        "starlette.middleware._MiddlewareClass",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.routing.Route",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'Custom'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_contextvars",
      "module": "test_base",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_base.py",
      "line_number": 233,
      "end_line_number": 249,
      "source_code": "def test_contextvars(\n    test_client_factory: TestClientFactory,\n    middleware_cls: type[_MiddlewareClass[Any]],\n) -> None:\n    # this has to be an async endpoint because Starlette calls run_in_threadpool\n    # on sync endpoints which has it's own set of peculiarities w.r.t propagating\n    # contextvars (it propagates them forwards but not backwards)\n    async def homepage(request: Request) -> PlainTextResponse:\n        assert ctxvar.get() == \"set by middleware\"\n        ctxvar.set(\"set by endpoint\")\n        return PlainTextResponse(\"Homepage\")\n\n    app = Starlette(middleware=[Middleware(middleware_cls)], routes=[Route(\"/\", homepage)])\n\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.status_code == 200, response.content",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('middleware_cls', [CustomMiddlewareWithoutBaseHTTPMiddleware, pytest.param(CustomMiddlewareUsingBaseHTTPMiddleware, marks=pytest.mark.xfail(reason='BaseHTTPMiddleware creates a TaskGroup which copies the contextand erases any changes to it made within the TaskGroup', raises=AssertionError))])"
      ],
      "arguments": [
        "test_client_factory",
        "middleware_cls"
      ],
      "imports": [
        "__future__.annotations",
        "contextvars",
        "contextlib.AsyncExitStack",
        "typing.Any",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio",
        "pytest",
        "anyio.abc.TaskStatus",
        "starlette.applications.Starlette",
        "starlette.background.BackgroundTask",
        "starlette.middleware.Middleware",
        "starlette.middleware._MiddlewareClass",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.routing.Route",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200, response.content",
        "assert ctxvar.get() == 'set by middleware'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "ctxvar.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_app_receives_http_disconnect_while_sending_if_discarded",
      "module": "test_base",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_base.py",
      "line_number": 413,
      "end_line_number": 486,
      "source_code": "def test_app_receives_http_disconnect_while_sending_if_discarded(\n    test_client_factory: TestClientFactory,\n) -> None:\n    class DiscardingMiddleware(BaseHTTPMiddleware):\n        async def dispatch(\n            self,\n            request: Request,\n            call_next: Any,\n        ) -> PlainTextResponse:\n            # As a matter of ordering, this test targets the case where the downstream\n            # app response is discarded while it is sending a response body.\n            # We need to wait for the downstream app to begin sending a response body\n            # before sending the middleware response that will overwrite the downstream\n            # response.\n            downstream_app_response = await call_next(request)\n            body_generator = downstream_app_response.body_iterator\n            try:\n                await body_generator.__anext__()\n            finally:\n                await body_generator.aclose()\n\n            return PlainTextResponse(\"Custom\")\n\n    async def downstream_app(\n        scope: Scope,\n        receive: Receive,\n        send: Send,\n    ) -> None:\n        await send(\n            {\n                \"type\": \"http.response.start\",\n                \"status\": 200,\n                \"headers\": [\n                    (b\"content-type\", b\"text/plain\"),\n                ],\n            }\n        )\n        async with anyio.create_task_group() as task_group:\n\n            async def cancel_on_disconnect(\n                *,\n                task_status: TaskStatus[None] = anyio.TASK_STATUS_IGNORED,\n            ) -> None:\n                task_status.started()\n                while True:\n                    message = await receive()\n                    if message[\"type\"] == \"http.disconnect\":\n                        task_group.cancel_scope.cancel()\n                        break\n\n            # Using start instead of start_soon to ensure that\n            # cancel_on_disconnect is scheduled by the event loop\n            # before we start returning the body\n            await task_group.start(cancel_on_disconnect)\n\n            # A timeout is set for 0.1 second in order to ensure that\n            # we never deadlock the test run in an infinite loop\n            with anyio.move_on_after(0.1):\n                while True:\n                    await send(\n                        {\n                            \"type\": \"http.response.body\",\n                            \"body\": b\"chunk \",\n                            \"more_body\": True,\n                        }\n                    )\n\n            pytest.fail(\"http.disconnect should have been received and canceled the scope\")  # pragma: no cover\n\n    app = DiscardingMiddleware(downstream_app)\n\n    client = test_client_factory(app)\n    response = client.get(\"/does_not_exist\")\n    assert response.text == \"Custom\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextvars",
        "contextlib.AsyncExitStack",
        "typing.Any",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio",
        "pytest",
        "anyio.abc.TaskStatus",
        "starlette.applications.Starlette",
        "starlette.background.BackgroundTask",
        "starlette.middleware.Middleware",
        "starlette.middleware._MiddlewareClass",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.routing.Route",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'Custom'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_app_receives_http_disconnect_after_sending_if_discarded",
      "module": "test_base",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_base.py",
      "line_number": 489,
      "end_line_number": 536,
      "source_code": "def test_app_receives_http_disconnect_after_sending_if_discarded(\n    test_client_factory: TestClientFactory,\n) -> None:\n    class DiscardingMiddleware(BaseHTTPMiddleware):\n        async def dispatch(\n            self,\n            request: Request,\n            call_next: RequestResponseEndpoint,\n        ) -> PlainTextResponse:\n            await call_next(request)\n            return PlainTextResponse(\"Custom\")\n\n    async def downstream_app(\n        scope: Scope,\n        receive: Receive,\n        send: Send,\n    ) -> None:\n        await send(\n            {\n                \"type\": \"http.response.start\",\n                \"status\": 200,\n                \"headers\": [\n                    (b\"content-type\", b\"text/plain\"),\n                ],\n            }\n        )\n        await send(\n            {\n                \"type\": \"http.response.body\",\n                \"body\": b\"first chunk, \",\n                \"more_body\": True,\n            }\n        )\n        await send(\n            {\n                \"type\": \"http.response.body\",\n                \"body\": b\"second chunk\",\n                \"more_body\": True,\n            }\n        )\n        message = await receive()\n        assert message[\"type\"] == \"http.disconnect\"\n\n    app = DiscardingMiddleware(downstream_app)\n\n    client = test_client_factory(app)\n    response = client.get(\"/does_not_exist\")\n    assert response.text == \"Custom\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextvars",
        "contextlib.AsyncExitStack",
        "typing.Any",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio",
        "pytest",
        "anyio.abc.TaskStatus",
        "starlette.applications.Starlette",
        "starlette.background.BackgroundTask",
        "starlette.middleware.Middleware",
        "starlette.middleware._MiddlewareClass",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.routing.Route",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'Custom'",
        "assert message['type'] == 'http.disconnect'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_read_request_stream_in_app_after_middleware_calls_stream",
      "module": "test_base",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_base.py",
      "line_number": 539,
      "end_line_number": 568,
      "source_code": "def test_read_request_stream_in_app_after_middleware_calls_stream(\n    test_client_factory: TestClientFactory,\n) -> None:\n    async def homepage(request: Request) -> PlainTextResponse:\n        expected = [b\"\"]\n        async for chunk in request.stream():\n            assert chunk == expected.pop(0)\n        assert expected == []\n        return PlainTextResponse(\"Homepage\")\n\n    class ConsumingMiddleware(BaseHTTPMiddleware):\n        async def dispatch(\n            self,\n            request: Request,\n            call_next: RequestResponseEndpoint,\n        ) -> Response:\n            expected = [b\"a\", b\"\"]\n            async for chunk in request.stream():\n                assert chunk == expected.pop(0)\n            assert expected == []\n            return await call_next(request)\n\n    app = Starlette(\n        routes=[Route(\"/\", homepage, methods=[\"POST\"])],\n        middleware=[Middleware(ConsumingMiddleware)],\n    )\n\n    client: TestClient = test_client_factory(app)\n    response = client.post(\"/\", content=b\"a\")\n    assert response.status_code == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextvars",
        "contextlib.AsyncExitStack",
        "typing.Any",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio",
        "pytest",
        "anyio.abc.TaskStatus",
        "starlette.applications.Starlette",
        "starlette.background.BackgroundTask",
        "starlette.middleware.Middleware",
        "starlette.middleware._MiddlewareClass",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.routing.Route",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert expected == []",
        "assert chunk == expected.pop(0)",
        "assert expected == []",
        "assert chunk == expected.pop(0)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_read_request_stream_in_app_after_middleware_calls_body",
      "module": "test_base",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_base.py",
      "line_number": 571,
      "end_line_number": 597,
      "source_code": "def test_read_request_stream_in_app_after_middleware_calls_body(\n    test_client_factory: TestClientFactory,\n) -> None:\n    async def homepage(request: Request) -> PlainTextResponse:\n        expected = [b\"a\", b\"\"]\n        async for chunk in request.stream():\n            assert chunk == expected.pop(0)\n        assert expected == []\n        return PlainTextResponse(\"Homepage\")\n\n    class ConsumingMiddleware(BaseHTTPMiddleware):\n        async def dispatch(\n            self,\n            request: Request,\n            call_next: RequestResponseEndpoint,\n        ) -> Response:\n            assert await request.body() == b\"a\"\n            return await call_next(request)\n\n    app = Starlette(\n        routes=[Route(\"/\", homepage, methods=[\"POST\"])],\n        middleware=[Middleware(ConsumingMiddleware)],\n    )\n\n    client: TestClient = test_client_factory(app)\n    response = client.post(\"/\", content=b\"a\")\n    assert response.status_code == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextvars",
        "contextlib.AsyncExitStack",
        "typing.Any",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio",
        "pytest",
        "anyio.abc.TaskStatus",
        "starlette.applications.Starlette",
        "starlette.background.BackgroundTask",
        "starlette.middleware.Middleware",
        "starlette.middleware._MiddlewareClass",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.routing.Route",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert expected == []",
        "assert chunk == expected.pop(0)",
        "assert await request.body() == b'a'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_read_request_body_in_app_after_middleware_calls_stream",
      "module": "test_base",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_base.py",
      "line_number": 600,
      "end_line_number": 626,
      "source_code": "def test_read_request_body_in_app_after_middleware_calls_stream(\n    test_client_factory: TestClientFactory,\n) -> None:\n    async def homepage(request: Request) -> PlainTextResponse:\n        assert await request.body() == b\"\"\n        return PlainTextResponse(\"Homepage\")\n\n    class ConsumingMiddleware(BaseHTTPMiddleware):\n        async def dispatch(\n            self,\n            request: Request,\n            call_next: RequestResponseEndpoint,\n        ) -> Response:\n            expected = [b\"a\", b\"\"]\n            async for chunk in request.stream():\n                assert chunk == expected.pop(0)\n            assert expected == []\n            return await call_next(request)\n\n    app = Starlette(\n        routes=[Route(\"/\", homepage, methods=[\"POST\"])],\n        middleware=[Middleware(ConsumingMiddleware)],\n    )\n\n    client: TestClient = test_client_factory(app)\n    response = client.post(\"/\", content=b\"a\")\n    assert response.status_code == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextvars",
        "contextlib.AsyncExitStack",
        "typing.Any",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio",
        "pytest",
        "anyio.abc.TaskStatus",
        "starlette.applications.Starlette",
        "starlette.background.BackgroundTask",
        "starlette.middleware.Middleware",
        "starlette.middleware._MiddlewareClass",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.routing.Route",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert await request.body() == b''",
        "assert expected == []",
        "assert chunk == expected.pop(0)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_read_request_body_in_app_after_middleware_calls_body",
      "module": "test_base",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_base.py",
      "line_number": 629,
      "end_line_number": 652,
      "source_code": "def test_read_request_body_in_app_after_middleware_calls_body(\n    test_client_factory: TestClientFactory,\n) -> None:\n    async def homepage(request: Request) -> PlainTextResponse:\n        assert await request.body() == b\"a\"\n        return PlainTextResponse(\"Homepage\")\n\n    class ConsumingMiddleware(BaseHTTPMiddleware):\n        async def dispatch(\n            self,\n            request: Request,\n            call_next: RequestResponseEndpoint,\n        ) -> Response:\n            assert await request.body() == b\"a\"\n            return await call_next(request)\n\n    app = Starlette(\n        routes=[Route(\"/\", homepage, methods=[\"POST\"])],\n        middleware=[Middleware(ConsumingMiddleware)],\n    )\n\n    client: TestClient = test_client_factory(app)\n    response = client.post(\"/\", content=b\"a\")\n    assert response.status_code == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextvars",
        "contextlib.AsyncExitStack",
        "typing.Any",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio",
        "pytest",
        "anyio.abc.TaskStatus",
        "starlette.applications.Starlette",
        "starlette.background.BackgroundTask",
        "starlette.middleware.Middleware",
        "starlette.middleware._MiddlewareClass",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.routing.Route",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert await request.body() == b'a'",
        "assert await request.body() == b'a'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_read_request_stream_in_dispatch_after_app_calls_stream",
      "module": "test_base",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_base.py",
      "line_number": 655,
      "end_line_number": 684,
      "source_code": "def test_read_request_stream_in_dispatch_after_app_calls_stream(\n    test_client_factory: TestClientFactory,\n) -> None:\n    async def homepage(request: Request) -> PlainTextResponse:\n        expected = [b\"a\", b\"\"]\n        async for chunk in request.stream():\n            assert chunk == expected.pop(0)\n        assert expected == []\n        return PlainTextResponse(\"Homepage\")\n\n    class ConsumingMiddleware(BaseHTTPMiddleware):\n        async def dispatch(\n            self,\n            request: Request,\n            call_next: RequestResponseEndpoint,\n        ) -> Response:\n            resp = await call_next(request)\n            with pytest.raises(RuntimeError, match=\"Stream consumed\"):\n                async for _ in request.stream():\n                    raise AssertionError(\"should not be called\")  # pragma: no cover\n            return resp\n\n    app = Starlette(\n        routes=[Route(\"/\", homepage, methods=[\"POST\"])],\n        middleware=[Middleware(ConsumingMiddleware)],\n    )\n\n    client: TestClient = test_client_factory(app)\n    response = client.post(\"/\", content=b\"a\")\n    assert response.status_code == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextvars",
        "contextlib.AsyncExitStack",
        "typing.Any",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio",
        "pytest",
        "anyio.abc.TaskStatus",
        "starlette.applications.Starlette",
        "starlette.background.BackgroundTask",
        "starlette.middleware.Middleware",
        "starlette.middleware._MiddlewareClass",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.routing.Route",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert expected == []",
        "assert chunk == expected.pop(0)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_read_request_stream_in_dispatch_after_app_calls_body",
      "module": "test_base",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_base.py",
      "line_number": 687,
      "end_line_number": 713,
      "source_code": "def test_read_request_stream_in_dispatch_after_app_calls_body(\n    test_client_factory: TestClientFactory,\n) -> None:\n    async def homepage(request: Request) -> PlainTextResponse:\n        assert await request.body() == b\"a\"\n        return PlainTextResponse(\"Homepage\")\n\n    class ConsumingMiddleware(BaseHTTPMiddleware):\n        async def dispatch(\n            self,\n            request: Request,\n            call_next: RequestResponseEndpoint,\n        ) -> Response:\n            resp = await call_next(request)\n            with pytest.raises(RuntimeError, match=\"Stream consumed\"):\n                async for _ in request.stream():\n                    raise AssertionError(\"should not be called\")  # pragma: no cover\n            return resp\n\n    app = Starlette(\n        routes=[Route(\"/\", homepage, methods=[\"POST\"])],\n        middleware=[Middleware(ConsumingMiddleware)],\n    )\n\n    client: TestClient = test_client_factory(app)\n    response = client.post(\"/\", content=b\"a\")\n    assert response.status_code == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextvars",
        "contextlib.AsyncExitStack",
        "typing.Any",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio",
        "pytest",
        "anyio.abc.TaskStatus",
        "starlette.applications.Starlette",
        "starlette.background.BackgroundTask",
        "starlette.middleware.Middleware",
        "starlette.middleware._MiddlewareClass",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.routing.Route",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert await request.body() == b'a'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_read_request_stream_in_dispatch_after_app_calls_body_with_middleware_calling_body_before_call_next",
      "module": "test_base",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_base.py",
      "line_number": 775,
      "end_line_number": 802,
      "source_code": "def test_read_request_stream_in_dispatch_after_app_calls_body_with_middleware_calling_body_before_call_next(\n    test_client_factory: TestClientFactory,\n) -> None:\n    async def homepage(request: Request) -> PlainTextResponse:\n        assert await request.body() == b\"a\"\n        return PlainTextResponse(\"Homepage\")\n\n    class ConsumingMiddleware(BaseHTTPMiddleware):\n        async def dispatch(\n            self,\n            request: Request,\n            call_next: RequestResponseEndpoint,\n        ) -> Response:\n            assert await request.body() == b\"a\"  # this buffers the request body in memory\n            resp = await call_next(request)\n            async for chunk in request.stream():\n                if chunk:\n                    assert chunk == b\"a\"\n            return resp\n\n    app = Starlette(\n        routes=[Route(\"/\", homepage, methods=[\"POST\"])],\n        middleware=[Middleware(ConsumingMiddleware)],\n    )\n\n    client: TestClient = test_client_factory(app)\n    response = client.post(\"/\", content=b\"a\")\n    assert response.status_code == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextvars",
        "contextlib.AsyncExitStack",
        "typing.Any",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio",
        "pytest",
        "anyio.abc.TaskStatus",
        "starlette.applications.Starlette",
        "starlette.background.BackgroundTask",
        "starlette.middleware.Middleware",
        "starlette.middleware._MiddlewareClass",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.routing.Route",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert await request.body() == b'a'",
        "assert await request.body() == b'a'",
        "assert chunk == b'a'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_read_request_body_in_dispatch_after_app_calls_body_with_middleware_calling_body_before_call_next",
      "module": "test_base",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_base.py",
      "line_number": 805,
      "end_line_number": 830,
      "source_code": "def test_read_request_body_in_dispatch_after_app_calls_body_with_middleware_calling_body_before_call_next(\n    test_client_factory: TestClientFactory,\n) -> None:\n    async def homepage(request: Request) -> PlainTextResponse:\n        assert await request.body() == b\"a\"\n        return PlainTextResponse(\"Homepage\")\n\n    class ConsumingMiddleware(BaseHTTPMiddleware):\n        async def dispatch(\n            self,\n            request: Request,\n            call_next: RequestResponseEndpoint,\n        ) -> Response:\n            assert await request.body() == b\"a\"  # this buffers the request body in memory\n            resp = await call_next(request)\n            assert await request.body() == b\"a\"  # no problem here\n            return resp\n\n    app = Starlette(\n        routes=[Route(\"/\", homepage, methods=[\"POST\"])],\n        middleware=[Middleware(ConsumingMiddleware)],\n    )\n\n    client: TestClient = test_client_factory(app)\n    response = client.post(\"/\", content=b\"a\")\n    assert response.status_code == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextvars",
        "contextlib.AsyncExitStack",
        "typing.Any",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio",
        "pytest",
        "anyio.abc.TaskStatus",
        "starlette.applications.Starlette",
        "starlette.background.BackgroundTask",
        "starlette.middleware.Middleware",
        "starlette.middleware._MiddlewareClass",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.routing.Route",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert await request.body() == b'a'",
        "assert await request.body() == b'a'",
        "assert await request.body() == b'a'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_downstream_middleware_modifies_receive",
      "module": "test_base",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_base.py",
      "line_number": 919,
      "end_line_number": 957,
      "source_code": "def test_downstream_middleware_modifies_receive(\n    test_client_factory: TestClientFactory,\n) -> None:\n    \"\"\"If a downstream middleware modifies receive() the final ASGI app\n    should see the modified version.\n    \"\"\"\n\n    async def endpoint(scope: Scope, receive: Receive, send: Send) -> None:\n        request = Request(scope, receive)\n        body = await request.body()\n        assert body == b\"foo foo \"\n        await Response()(scope, receive, send)\n\n    class ConsumingMiddleware(BaseHTTPMiddleware):\n        async def dispatch(\n            self,\n            request: Request,\n            call_next: RequestResponseEndpoint,\n        ) -> Response:\n            body = await request.body()\n            assert body == b\"foo \"\n            return await call_next(request)\n\n    def modifying_middleware(app: ASGIApp) -> ASGIApp:\n        async def wrapped_app(scope: Scope, receive: Receive, send: Send) -> None:\n            async def wrapped_receive() -> Message:\n                msg = await receive()\n                if msg[\"type\"] == \"http.request\":\n                    msg[\"body\"] = msg[\"body\"] * 2\n                return msg\n\n            await app(scope, wrapped_receive, send)\n\n        return wrapped_app\n\n    client = test_client_factory(ConsumingMiddleware(modifying_middleware(endpoint)))\n\n    resp = client.post(\"/\", content=b\"foo \")\n    assert resp.status_code == 200",
      "docstring": "If a downstream middleware modifies receive() the final ASGI app\nshould see the modified version.",
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "__future__.annotations",
        "contextvars",
        "contextlib.AsyncExitStack",
        "typing.Any",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio",
        "pytest",
        "anyio.abc.TaskStatus",
        "starlette.applications.Starlette",
        "starlette.background.BackgroundTask",
        "starlette.middleware.Middleware",
        "starlette.middleware._MiddlewareClass",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.routing.Route",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 200",
        "assert body == b'foo foo '",
        "assert body == b'foo '"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        },
        {
          "name": "modifying_middleware",
          "body": "def modifying_middleware(app: ASGIApp) -> ASGIApp:\n\n    async def wrapped_app(scope: Scope, receive: Receive, send: Send) -> None:\n\n        async def wrapped_receive() -> Message:\n            msg = await receive()\n            if msg['type'] == 'http.request':\n                msg['body'] = msg['body'] * 2\n            return msg\n        await app(scope, wrapped_receive, send)\n    return wrapped_app"
        },
        {
          "name": "app",
          "body": "def app(request: Request) -> Response:\n    return endpoint(request=request, **kwargs)"
        }
      ]
    },
    {
      "name": "test_pr_1519_comment_1236166180_example",
      "module": "test_base",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_base.py",
      "line_number": 960,
      "end_line_number": 999,
      "source_code": "def test_pr_1519_comment_1236166180_example() -> None:\n    \"\"\"\n    https://github.com/encode/starlette/pull/1519#issuecomment-1236166180\n    \"\"\"\n    bodies: list[bytes] = []\n\n    class LogRequestBodySize(BaseHTTPMiddleware):\n        async def dispatch(\n            self,\n            request: Request,\n            call_next: RequestResponseEndpoint,\n        ) -> Response:\n            print(len(await request.body()))\n            return await call_next(request)\n\n    def replace_body_middleware(app: ASGIApp) -> ASGIApp:\n        async def wrapped_app(scope: Scope, receive: Receive, send: Send) -> None:\n            async def wrapped_rcv() -> Message:\n                msg = await receive()\n                msg[\"body\"] += b\"-foo\"\n                return msg\n\n            await app(scope, wrapped_rcv, send)\n\n        return wrapped_app\n\n    async def endpoint(request: Request) -> Response:\n        body = await request.body()\n        bodies.append(body)\n        return Response()\n\n    app: ASGIApp = Starlette(routes=[Route(\"/\", endpoint, methods=[\"POST\"])])\n    app = replace_body_middleware(app)\n    app = LogRequestBodySize(app)\n\n    client = TestClient(app)\n    resp = client.post(\"/\", content=b\"Hello, World!\")\n    resp.raise_for_status()\n\n    assert bodies == [b\"Hello, World!-foo\"]",
      "docstring": "https://github.com/encode/starlette/pull/1519#issuecomment-1236166180",
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "contextvars",
        "contextlib.AsyncExitStack",
        "typing.Any",
        "typing.AsyncGenerator",
        "typing.AsyncIterator",
        "typing.Generator",
        "anyio",
        "pytest",
        "anyio.abc.TaskStatus",
        "starlette.applications.Starlette",
        "starlette.background.BackgroundTask",
        "starlette.middleware.Middleware",
        "starlette.middleware._MiddlewareClass",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.RequestResponseEndpoint",
        "starlette.requests.ClientDisconnect",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "starlette.routing.Route",
        "starlette.routing.WebSocketRoute",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Message",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "starlette.websockets.WebSocket",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert bodies == [b'Hello, World!-foo']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "replace_body_middleware",
          "body": "def replace_body_middleware(app: ASGIApp) -> ASGIApp:\n\n    async def wrapped_app(scope: Scope, receive: Receive, send: Send) -> None:\n\n        async def wrapped_rcv() -> Message:\n            msg = await receive()\n            msg['body'] += b'-foo'\n            return msg\n        await app(scope, wrapped_rcv, send)\n    return wrapped_app"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        },
        {
          "name": "app",
          "body": "def app(request: Request) -> Response:\n    return endpoint(request=request, **kwargs)"
        }
      ]
    },
    {
      "name": "test_session",
      "module": "test_session",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_session.py",
      "line_number": 28,
      "end_line_number": 58,
      "source_code": "def test_session(test_client_factory: TestClientFactory) -> None:\n    app = Starlette(\n        routes=[\n            Route(\"/view_session\", endpoint=view_session),\n            Route(\"/update_session\", endpoint=update_session, methods=[\"POST\"]),\n            Route(\"/clear_session\", endpoint=clear_session, methods=[\"POST\"]),\n        ],\n        middleware=[Middleware(SessionMiddleware, secret_key=\"example\")],\n    )\n    client = test_client_factory(app)\n\n    response = client.get(\"/view_session\")\n    assert response.json() == {\"session\": {}}\n\n    response = client.post(\"/update_session\", json={\"some\": \"data\"})\n    assert response.json() == {\"session\": {\"some\": \"data\"}}\n\n    # check cookie max-age\n    set_cookie = response.headers[\"set-cookie\"]\n    max_age_matches = re.search(r\"; Max-Age=([0-9]+);\", set_cookie)\n    assert max_age_matches is not None\n    assert int(max_age_matches[1]) == 14 * 24 * 3600\n\n    response = client.get(\"/view_session\")\n    assert response.json() == {\"session\": {\"some\": \"data\"}}\n\n    response = client.post(\"/clear_session\")\n    assert response.json() == {\"session\": {}}\n\n    response = client.get(\"/view_session\")\n    assert response.json() == {\"session\": {}}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "re",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.middleware.sessions.SessionMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.routing.Mount",
        "starlette.routing.Route",
        "starlette.testclient.TestClient",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'session': {}}",
        "assert response.json() == {'session': {'some': 'data'}}",
        "assert max_age_matches is not None",
        "assert int(max_age_matches[1]) == 14 * 24 * 3600",
        "assert response.json() == {'session': {'some': 'data'}}",
        "assert response.json() == {'session': {}}",
        "assert response.json() == {'session': {}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_session_expires",
      "module": "test_session",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_session.py",
      "line_number": 61,
      "end_line_number": 82,
      "source_code": "def test_session_expires(test_client_factory: TestClientFactory) -> None:\n    app = Starlette(\n        routes=[\n            Route(\"/view_session\", endpoint=view_session),\n            Route(\"/update_session\", endpoint=update_session, methods=[\"POST\"]),\n        ],\n        middleware=[Middleware(SessionMiddleware, secret_key=\"example\", max_age=-1)],\n    )\n    client = test_client_factory(app)\n\n    response = client.post(\"/update_session\", json={\"some\": \"data\"})\n    assert response.json() == {\"session\": {\"some\": \"data\"}}\n\n    # requests removes expired cookies from response.cookies, we need to\n    # fetch session id from the headers and pass it explicitly\n    expired_cookie_header = response.headers[\"set-cookie\"]\n    expired_session_match = re.search(r\"session=([^;]*);\", expired_cookie_header)\n    assert expired_session_match is not None\n    expired_session_value = expired_session_match[1]\n    client = test_client_factory(app, cookies={\"session\": expired_session_value})\n    response = client.get(\"/view_session\")\n    assert response.json() == {\"session\": {}}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "re",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.middleware.sessions.SessionMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.routing.Mount",
        "starlette.routing.Route",
        "starlette.testclient.TestClient",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'session': {'some': 'data'}}",
        "assert expired_session_match is not None",
        "assert response.json() == {'session': {}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        },
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_secure_session",
      "module": "test_session",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_session.py",
      "line_number": 85,
      "end_line_number": 119,
      "source_code": "def test_secure_session(test_client_factory: TestClientFactory) -> None:\n    app = Starlette(\n        routes=[\n            Route(\"/view_session\", endpoint=view_session),\n            Route(\"/update_session\", endpoint=update_session, methods=[\"POST\"]),\n            Route(\"/clear_session\", endpoint=clear_session, methods=[\"POST\"]),\n        ],\n        middleware=[Middleware(SessionMiddleware, secret_key=\"example\", https_only=True)],\n    )\n    secure_client = test_client_factory(app, base_url=\"https://testserver\")\n    unsecure_client = test_client_factory(app, base_url=\"http://testserver\")\n\n    response = unsecure_client.get(\"/view_session\")\n    assert response.json() == {\"session\": {}}\n\n    response = unsecure_client.post(\"/update_session\", json={\"some\": \"data\"})\n    assert response.json() == {\"session\": {\"some\": \"data\"}}\n\n    response = unsecure_client.get(\"/view_session\")\n    assert response.json() == {\"session\": {}}\n\n    response = secure_client.get(\"/view_session\")\n    assert response.json() == {\"session\": {}}\n\n    response = secure_client.post(\"/update_session\", json={\"some\": \"data\"})\n    assert response.json() == {\"session\": {\"some\": \"data\"}}\n\n    response = secure_client.get(\"/view_session\")\n    assert response.json() == {\"session\": {\"some\": \"data\"}}\n\n    response = secure_client.post(\"/clear_session\")\n    assert response.json() == {\"session\": {}}\n\n    response = secure_client.get(\"/view_session\")\n    assert response.json() == {\"session\": {}}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "re",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.middleware.sessions.SessionMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.routing.Mount",
        "starlette.routing.Route",
        "starlette.testclient.TestClient",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'session': {}}",
        "assert response.json() == {'session': {'some': 'data'}}",
        "assert response.json() == {'session': {}}",
        "assert response.json() == {'session': {}}",
        "assert response.json() == {'session': {'some': 'data'}}",
        "assert response.json() == {'session': {'some': 'data'}}",
        "assert response.json() == {'session': {}}",
        "assert response.json() == {'session': {}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "unsecure_client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "unsecure_client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        },
        {
          "name": "unsecure_client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "secure_client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "secure_client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        },
        {
          "name": "secure_client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "secure_client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        },
        {
          "name": "secure_client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_session_cookie_subpath",
      "module": "test_session",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_session.py",
      "line_number": 122,
      "end_line_number": 137,
      "source_code": "def test_session_cookie_subpath(test_client_factory: TestClientFactory) -> None:\n    second_app = Starlette(\n        routes=[\n            Route(\"/update_session\", endpoint=update_session, methods=[\"POST\"]),\n        ],\n        middleware=[Middleware(SessionMiddleware, secret_key=\"example\", path=\"/second_app\")],\n    )\n    app = Starlette(routes=[Mount(\"/second_app\", app=second_app)])\n    client = test_client_factory(app, base_url=\"http://testserver/second_app\")\n    response = client.post(\"/update_session\", json={\"some\": \"data\"})\n    assert response.status_code == 200\n    cookie = response.headers[\"set-cookie\"]\n    cookie_path_match = re.search(r\"; path=(\\S+);\", cookie)\n    assert cookie_path_match is not None\n    cookie_path = cookie_path_match.groups()[0]\n    assert cookie_path == \"/second_app\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "re",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.middleware.sessions.SessionMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.routing.Mount",
        "starlette.routing.Route",
        "starlette.testclient.TestClient",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert cookie_path_match is not None",
        "assert cookie_path == '/second_app'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_invalid_session_cookie",
      "module": "test_session",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_session.py",
      "line_number": 140,
      "end_line_number": 156,
      "source_code": "def test_invalid_session_cookie(test_client_factory: TestClientFactory) -> None:\n    app = Starlette(\n        routes=[\n            Route(\"/view_session\", endpoint=view_session),\n            Route(\"/update_session\", endpoint=update_session, methods=[\"POST\"]),\n        ],\n        middleware=[Middleware(SessionMiddleware, secret_key=\"example\")],\n    )\n    client = test_client_factory(app)\n\n    response = client.post(\"/update_session\", json={\"some\": \"data\"})\n    assert response.json() == {\"session\": {\"some\": \"data\"}}\n\n    # we expect it to not raise an exception if we provide a bogus session cookie\n    client = test_client_factory(app, cookies={\"session\": \"invalid\"})\n    response = client.get(\"/view_session\")\n    assert response.json() == {\"session\": {}}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "re",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.middleware.sessions.SessionMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.routing.Mount",
        "starlette.routing.Route",
        "starlette.testclient.TestClient",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'session': {'some': 'data'}}",
        "assert response.json() == {'session': {}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        },
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_session_cookie",
      "module": "test_session",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_session.py",
      "line_number": 159,
      "end_line_number": 178,
      "source_code": "def test_session_cookie(test_client_factory: TestClientFactory) -> None:\n    app = Starlette(\n        routes=[\n            Route(\"/view_session\", endpoint=view_session),\n            Route(\"/update_session\", endpoint=update_session, methods=[\"POST\"]),\n        ],\n        middleware=[Middleware(SessionMiddleware, secret_key=\"example\", max_age=None)],\n    )\n    client: TestClient = test_client_factory(app)\n\n    response = client.post(\"/update_session\", json={\"some\": \"data\"})\n    assert response.json() == {\"session\": {\"some\": \"data\"}}\n\n    # check cookie max-age\n    set_cookie = response.headers[\"set-cookie\"]\n    assert \"Max-Age\" not in set_cookie\n\n    client.cookies.delete(\"session\")\n    response = client.get(\"/view_session\")\n    assert response.json() == {\"session\": {}}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "re",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.middleware.sessions.SessionMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.routing.Mount",
        "starlette.routing.Route",
        "starlette.testclient.TestClient",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'session': {'some': 'data'}}",
        "assert 'Max-Age' not in set_cookie",
        "assert response.json() == {'session': {}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_domain_cookie",
      "module": "test_session",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_session.py",
      "line_number": 181,
      "end_line_number": 200,
      "source_code": "def test_domain_cookie(test_client_factory: TestClientFactory) -> None:\n    app = Starlette(\n        routes=[\n            Route(\"/view_session\", endpoint=view_session),\n            Route(\"/update_session\", endpoint=update_session, methods=[\"POST\"]),\n        ],\n        middleware=[Middleware(SessionMiddleware, secret_key=\"example\", domain=\".example.com\")],\n    )\n    client: TestClient = test_client_factory(app)\n\n    response = client.post(\"/update_session\", json={\"some\": \"data\"})\n    assert response.json() == {\"session\": {\"some\": \"data\"}}\n\n    # check cookie max-age\n    set_cookie = response.headers[\"set-cookie\"]\n    assert \"domain=.example.com\" in set_cookie\n\n    client.cookies.delete(\"session\")\n    response = client.get(\"/view_session\")\n    assert response.json() == {\"session\": {}}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "re",
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.middleware.sessions.SessionMiddleware",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.routing.Mount",
        "starlette.routing.Route",
        "starlette.testclient.TestClient",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json() == {'session': {'some': 'data'}}",
        "assert 'domain=.example.com' in set_cookie",
        "assert response.json() == {'session': {}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_trusted_host_middleware",
      "module": "test_trusted_host",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_trusted_host.py",
      "line_number": 10,
      "end_line_number": 29,
      "source_code": "def test_trusted_host_middleware(test_client_factory: TestClientFactory) -> None:\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"OK\", status_code=200)\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[Middleware(TrustedHostMiddleware, allowed_hosts=[\"testserver\", \"*.testserver\"])],\n    )\n\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.status_code == 200\n\n    client = test_client_factory(app, base_url=\"http://subdomain.testserver\")\n    response = client.get(\"/\")\n    assert response.status_code == 200\n\n    client = test_client_factory(app, base_url=\"http://invalidhost\")\n    response = client.get(\"/\")\n    assert response.status_code == 400",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.middleware.trustedhost.TrustedHostMiddleware",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.status_code == 200",
        "assert response.status_code == 400"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_default_allowed_hosts",
      "module": "test_trusted_host",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_trusted_host.py",
      "line_number": 32,
      "end_line_number": 35,
      "source_code": "def test_default_allowed_hosts() -> None:\n    app = Starlette()\n    middleware = TrustedHostMiddleware(app)\n    assert middleware.allowed_hosts == [\"*\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.middleware.trustedhost.TrustedHostMiddleware",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert middleware.allowed_hosts == ['*']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_www_redirect",
      "module": "test_trusted_host",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_trusted_host.py",
      "line_number": 38,
      "end_line_number": 50,
      "source_code": "def test_www_redirect(test_client_factory: TestClientFactory) -> None:\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"OK\", status_code=200)\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[Middleware(TrustedHostMiddleware, allowed_hosts=[\"www.example.com\"])],\n    )\n\n    client = test_client_factory(app, base_url=\"https://example.com\")\n    response = client.get(\"/\")\n    assert response.status_code == 200\n    assert response.url == \"https://www.example.com/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.middleware.trustedhost.TrustedHostMiddleware",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.url == 'https://www.example.com/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_cors_allow_all",
      "module": "test_cors",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_cors.py",
      "line_number": 10,
      "end_line_number": 68,
      "source_code": "def test_cors_allow_all(\n    test_client_factory: TestClientFactory,\n) -> None:\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"Homepage\", status_code=200)\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[\n            Middleware(\n                CORSMiddleware,\n                allow_origins=[\"*\"],\n                allow_headers=[\"*\"],\n                allow_methods=[\"*\"],\n                expose_headers=[\"X-Status\"],\n                allow_credentials=True,\n            )\n        ],\n    )\n\n    client = test_client_factory(app)\n\n    # Test pre-flight response\n    headers = {\n        \"Origin\": \"https://example.org\",\n        \"Access-Control-Request-Method\": \"GET\",\n        \"Access-Control-Request-Headers\": \"X-Example\",\n    }\n    response = client.options(\"/\", headers=headers)\n    assert response.status_code == 200\n    assert response.text == \"OK\"\n    assert response.headers[\"access-control-allow-origin\"] == \"https://example.org\"\n    assert response.headers[\"access-control-allow-headers\"] == \"X-Example\"\n    assert response.headers[\"access-control-allow-credentials\"] == \"true\"\n    assert response.headers[\"vary\"] == \"Origin\"\n\n    # Test standard response\n    headers = {\"Origin\": \"https://example.org\"}\n    response = client.get(\"/\", headers=headers)\n    assert response.status_code == 200\n    assert response.text == \"Homepage\"\n    assert response.headers[\"access-control-allow-origin\"] == \"*\"\n    assert response.headers[\"access-control-expose-headers\"] == \"X-Status\"\n    assert response.headers[\"access-control-allow-credentials\"] == \"true\"\n\n    # Test standard credentialed response\n    headers = {\"Origin\": \"https://example.org\", \"Cookie\": \"star_cookie=sugar\"}\n    response = client.get(\"/\", headers=headers)\n    assert response.status_code == 200\n    assert response.text == \"Homepage\"\n    assert response.headers[\"access-control-allow-origin\"] == \"https://example.org\"\n    assert response.headers[\"access-control-expose-headers\"] == \"X-Status\"\n    assert response.headers[\"access-control-allow-credentials\"] == \"true\"\n\n    # Test non-CORS response\n    response = client.get(\"/\")\n    assert response.status_code == 200\n    assert response.text == \"Homepage\"\n    assert \"access-control-allow-origin\" not in response.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.middleware.cors.CORSMiddleware",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == 'OK'",
        "assert response.headers['access-control-allow-origin'] == 'https://example.org'",
        "assert response.headers['access-control-allow-headers'] == 'X-Example'",
        "assert response.headers['access-control-allow-credentials'] == 'true'",
        "assert response.headers['vary'] == 'Origin'",
        "assert response.status_code == 200",
        "assert response.text == 'Homepage'",
        "assert response.headers['access-control-allow-origin'] == '*'",
        "assert response.headers['access-control-expose-headers'] == 'X-Status'",
        "assert response.headers['access-control-allow-credentials'] == 'true'",
        "assert response.status_code == 200",
        "assert response.text == 'Homepage'",
        "assert response.headers['access-control-allow-origin'] == 'https://example.org'",
        "assert response.headers['access-control-expose-headers'] == 'X-Status'",
        "assert response.headers['access-control-allow-credentials'] == 'true'",
        "assert response.status_code == 200",
        "assert response.text == 'Homepage'",
        "assert 'access-control-allow-origin' not in response.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_cors_allow_all_except_credentials",
      "module": "test_cors",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_cors.py",
      "line_number": 71,
      "end_line_number": 119,
      "source_code": "def test_cors_allow_all_except_credentials(\n    test_client_factory: TestClientFactory,\n) -> None:\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"Homepage\", status_code=200)\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[\n            Middleware(\n                CORSMiddleware,\n                allow_origins=[\"*\"],\n                allow_headers=[\"*\"],\n                allow_methods=[\"*\"],\n                expose_headers=[\"X-Status\"],\n            )\n        ],\n    )\n\n    client = test_client_factory(app)\n\n    # Test pre-flight response\n    headers = {\n        \"Origin\": \"https://example.org\",\n        \"Access-Control-Request-Method\": \"GET\",\n        \"Access-Control-Request-Headers\": \"X-Example\",\n    }\n    response = client.options(\"/\", headers=headers)\n    assert response.status_code == 200\n    assert response.text == \"OK\"\n    assert response.headers[\"access-control-allow-origin\"] == \"*\"\n    assert response.headers[\"access-control-allow-headers\"] == \"X-Example\"\n    assert \"access-control-allow-credentials\" not in response.headers\n    assert \"vary\" not in response.headers\n\n    # Test standard response\n    headers = {\"Origin\": \"https://example.org\"}\n    response = client.get(\"/\", headers=headers)\n    assert response.status_code == 200\n    assert response.text == \"Homepage\"\n    assert response.headers[\"access-control-allow-origin\"] == \"*\"\n    assert response.headers[\"access-control-expose-headers\"] == \"X-Status\"\n    assert \"access-control-allow-credentials\" not in response.headers\n\n    # Test non-CORS response\n    response = client.get(\"/\")\n    assert response.status_code == 200\n    assert response.text == \"Homepage\"\n    assert \"access-control-allow-origin\" not in response.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.middleware.cors.CORSMiddleware",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == 'OK'",
        "assert response.headers['access-control-allow-origin'] == '*'",
        "assert response.headers['access-control-allow-headers'] == 'X-Example'",
        "assert 'access-control-allow-credentials' not in response.headers",
        "assert 'vary' not in response.headers",
        "assert response.status_code == 200",
        "assert response.text == 'Homepage'",
        "assert response.headers['access-control-allow-origin'] == '*'",
        "assert response.headers['access-control-expose-headers'] == 'X-Status'",
        "assert 'access-control-allow-credentials' not in response.headers",
        "assert response.status_code == 200",
        "assert response.text == 'Homepage'",
        "assert 'access-control-allow-origin' not in response.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_cors_allow_specific_origin",
      "module": "test_cors",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_cors.py",
      "line_number": 122,
      "end_line_number": 168,
      "source_code": "def test_cors_allow_specific_origin(\n    test_client_factory: TestClientFactory,\n) -> None:\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"Homepage\", status_code=200)\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[\n            Middleware(\n                CORSMiddleware,\n                allow_origins=[\"https://example.org\"],\n                allow_headers=[\"X-Example\", \"Content-Type\"],\n            )\n        ],\n    )\n\n    client = test_client_factory(app)\n\n    # Test pre-flight response\n    headers = {\n        \"Origin\": \"https://example.org\",\n        \"Access-Control-Request-Method\": \"GET\",\n        \"Access-Control-Request-Headers\": \"X-Example, Content-Type\",\n    }\n    response = client.options(\"/\", headers=headers)\n    assert response.status_code == 200\n    assert response.text == \"OK\"\n    assert response.headers[\"access-control-allow-origin\"] == \"https://example.org\"\n    assert response.headers[\"access-control-allow-headers\"] == (\n        \"Accept, Accept-Language, Content-Language, Content-Type, X-Example\"\n    )\n    assert \"access-control-allow-credentials\" not in response.headers\n\n    # Test standard response\n    headers = {\"Origin\": \"https://example.org\"}\n    response = client.get(\"/\", headers=headers)\n    assert response.status_code == 200\n    assert response.text == \"Homepage\"\n    assert response.headers[\"access-control-allow-origin\"] == \"https://example.org\"\n    assert \"access-control-allow-credentials\" not in response.headers\n\n    # Test non-CORS response\n    response = client.get(\"/\")\n    assert response.status_code == 200\n    assert response.text == \"Homepage\"\n    assert \"access-control-allow-origin\" not in response.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.middleware.cors.CORSMiddleware",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == 'OK'",
        "assert response.headers['access-control-allow-origin'] == 'https://example.org'",
        "assert response.headers['access-control-allow-headers'] == 'Accept, Accept-Language, Content-Language, Content-Type, X-Example'",
        "assert 'access-control-allow-credentials' not in response.headers",
        "assert response.status_code == 200",
        "assert response.text == 'Homepage'",
        "assert response.headers['access-control-allow-origin'] == 'https://example.org'",
        "assert 'access-control-allow-credentials' not in response.headers",
        "assert response.status_code == 200",
        "assert response.text == 'Homepage'",
        "assert 'access-control-allow-origin' not in response.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_cors_disallowed_preflight",
      "module": "test_cors",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_cors.py",
      "line_number": 171,
      "end_line_number": 209,
      "source_code": "def test_cors_disallowed_preflight(\n    test_client_factory: TestClientFactory,\n) -> None:\n    def homepage(request: Request) -> None:\n        pass  # pragma: no cover\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[\n            Middleware(\n                CORSMiddleware,\n                allow_origins=[\"https://example.org\"],\n                allow_headers=[\"X-Example\"],\n            )\n        ],\n    )\n\n    client = test_client_factory(app)\n\n    # Test pre-flight response\n    headers = {\n        \"Origin\": \"https://another.org\",\n        \"Access-Control-Request-Method\": \"POST\",\n        \"Access-Control-Request-Headers\": \"X-Nope\",\n    }\n    response = client.options(\"/\", headers=headers)\n    assert response.status_code == 400\n    assert response.text == \"Disallowed CORS origin, method, headers\"\n    assert \"access-control-allow-origin\" not in response.headers\n\n    # Bug specific test, https://github.com/encode/starlette/pull/1199\n    # Test preflight response text with multiple disallowed headers\n    headers = {\n        \"Origin\": \"https://example.org\",\n        \"Access-Control-Request-Method\": \"GET\",\n        \"Access-Control-Request-Headers\": \"X-Nope-1, X-Nope-2\",\n    }\n    response = client.options(\"/\", headers=headers)\n    assert response.text == \"Disallowed CORS headers\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.middleware.cors.CORSMiddleware",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 400",
        "assert response.text == 'Disallowed CORS origin, method, headers'",
        "assert 'access-control-allow-origin' not in response.headers",
        "assert response.text == 'Disallowed CORS headers'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_preflight_allows_request_origin_if_origins_wildcard_and_credentials_allowed",
      "module": "test_cors",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_cors.py",
      "line_number": 212,
      "end_line_number": 244,
      "source_code": "def test_preflight_allows_request_origin_if_origins_wildcard_and_credentials_allowed(\n    test_client_factory: TestClientFactory,\n) -> None:\n    def homepage(request: Request) -> None:\n        return  # pragma: no cover\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[\n            Middleware(\n                CORSMiddleware,\n                allow_origins=[\"*\"],\n                allow_methods=[\"POST\"],\n                allow_credentials=True,\n            )\n        ],\n    )\n\n    client = test_client_factory(app)\n\n    # Test pre-flight response\n    headers = {\n        \"Origin\": \"https://example.org\",\n        \"Access-Control-Request-Method\": \"POST\",\n    }\n    response = client.options(\n        \"/\",\n        headers=headers,\n    )\n    assert response.status_code == 200\n    assert response.headers[\"access-control-allow-origin\"] == \"https://example.org\"\n    assert response.headers[\"access-control-allow-credentials\"] == \"true\"\n    assert response.headers[\"vary\"] == \"Origin\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.middleware.cors.CORSMiddleware",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.headers['access-control-allow-origin'] == 'https://example.org'",
        "assert response.headers['access-control-allow-credentials'] == 'true'",
        "assert response.headers['vary'] == 'Origin'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_cors_preflight_allow_all_methods",
      "module": "test_cors",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_cors.py",
      "line_number": 247,
      "end_line_number": 268,
      "source_code": "def test_cors_preflight_allow_all_methods(\n    test_client_factory: TestClientFactory,\n) -> None:\n    def homepage(request: Request) -> None:\n        pass  # pragma: no cover\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[Middleware(CORSMiddleware, allow_origins=[\"*\"], allow_methods=[\"*\"])],\n    )\n\n    client = test_client_factory(app)\n\n    headers = {\n        \"Origin\": \"https://example.org\",\n        \"Access-Control-Request-Method\": \"POST\",\n    }\n\n    for method in (\"DELETE\", \"GET\", \"HEAD\", \"OPTIONS\", \"PATCH\", \"POST\", \"PUT\"):\n        response = client.options(\"/\", headers=headers)\n        assert response.status_code == 200\n        assert method in response.headers[\"access-control-allow-methods\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.middleware.cors.CORSMiddleware",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert method in response.headers['access-control-allow-methods']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_cors_allow_all_methods",
      "module": "test_cors",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_cors.py",
      "line_number": 271,
      "end_line_number": 297,
      "source_code": "def test_cors_allow_all_methods(\n    test_client_factory: TestClientFactory,\n) -> None:\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"Homepage\", status_code=200)\n\n    app = Starlette(\n        routes=[\n            Route(\n                \"/\",\n                endpoint=homepage,\n                methods=[\"delete\", \"get\", \"head\", \"options\", \"patch\", \"post\", \"put\"],\n            )\n        ],\n        middleware=[Middleware(CORSMiddleware, allow_origins=[\"*\"], allow_methods=[\"*\"])],\n    )\n\n    client = test_client_factory(app)\n\n    headers = {\"Origin\": \"https://example.org\"}\n\n    for method in (\"patch\", \"post\", \"put\"):\n        response = getattr(client, method)(\"/\", headers=headers, json={})\n        assert response.status_code == 200\n    for method in (\"delete\", \"get\", \"head\", \"options\"):\n        response = getattr(client, method)(\"/\", headers=headers)\n        assert response.status_code == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.middleware.cors.CORSMiddleware",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        }
      ]
    },
    {
      "name": "test_cors_allow_origin_regex",
      "module": "test_cors",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_cors.py",
      "line_number": 300,
      "end_line_number": 369,
      "source_code": "def test_cors_allow_origin_regex(\n    test_client_factory: TestClientFactory,\n) -> None:\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"Homepage\", status_code=200)\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[\n            Middleware(\n                CORSMiddleware,\n                allow_headers=[\"X-Example\", \"Content-Type\"],\n                allow_origin_regex=\"https://.*\",\n                allow_credentials=True,\n            )\n        ],\n    )\n\n    client = test_client_factory(app)\n\n    # Test standard response\n    headers = {\"Origin\": \"https://example.org\"}\n    response = client.get(\"/\", headers=headers)\n    assert response.status_code == 200\n    assert response.text == \"Homepage\"\n    assert response.headers[\"access-control-allow-origin\"] == \"https://example.org\"\n    assert response.headers[\"access-control-allow-credentials\"] == \"true\"\n\n    # Test standard credentialed response\n    headers = {\"Origin\": \"https://example.org\", \"Cookie\": \"star_cookie=sugar\"}\n    response = client.get(\"/\", headers=headers)\n    assert response.status_code == 200\n    assert response.text == \"Homepage\"\n    assert response.headers[\"access-control-allow-origin\"] == \"https://example.org\"\n    assert response.headers[\"access-control-allow-credentials\"] == \"true\"\n\n    # Test disallowed standard response\n    # Note that enforcement is a browser concern. The disallowed-ness is reflected\n    # in the lack of an \"access-control-allow-origin\" header in the response.\n    headers = {\"Origin\": \"http://example.org\"}\n    response = client.get(\"/\", headers=headers)\n    assert response.status_code == 200\n    assert response.text == \"Homepage\"\n    assert \"access-control-allow-origin\" not in response.headers\n\n    # Test pre-flight response\n    headers = {\n        \"Origin\": \"https://another.com\",\n        \"Access-Control-Request-Method\": \"GET\",\n        \"Access-Control-Request-Headers\": \"X-Example, content-type\",\n    }\n    response = client.options(\"/\", headers=headers)\n    assert response.status_code == 200\n    assert response.text == \"OK\"\n    assert response.headers[\"access-control-allow-origin\"] == \"https://another.com\"\n    assert response.headers[\"access-control-allow-headers\"] == (\n        \"Accept, Accept-Language, Content-Language, Content-Type, X-Example\"\n    )\n    assert response.headers[\"access-control-allow-credentials\"] == \"true\"\n\n    # Test disallowed pre-flight response\n    headers = {\n        \"Origin\": \"http://another.com\",\n        \"Access-Control-Request-Method\": \"GET\",\n        \"Access-Control-Request-Headers\": \"X-Example\",\n    }\n    response = client.options(\"/\", headers=headers)\n    assert response.status_code == 400\n    assert response.text == \"Disallowed CORS origin\"\n    assert \"access-control-allow-origin\" not in response.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.middleware.cors.CORSMiddleware",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == 'Homepage'",
        "assert response.headers['access-control-allow-origin'] == 'https://example.org'",
        "assert response.headers['access-control-allow-credentials'] == 'true'",
        "assert response.status_code == 200",
        "assert response.text == 'Homepage'",
        "assert response.headers['access-control-allow-origin'] == 'https://example.org'",
        "assert response.headers['access-control-allow-credentials'] == 'true'",
        "assert response.status_code == 200",
        "assert response.text == 'Homepage'",
        "assert 'access-control-allow-origin' not in response.headers",
        "assert response.status_code == 200",
        "assert response.text == 'OK'",
        "assert response.headers['access-control-allow-origin'] == 'https://another.com'",
        "assert response.headers['access-control-allow-headers'] == 'Accept, Accept-Language, Content-Language, Content-Type, X-Example'",
        "assert response.headers['access-control-allow-credentials'] == 'true'",
        "assert response.status_code == 400",
        "assert response.text == 'Disallowed CORS origin'",
        "assert 'access-control-allow-origin' not in response.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_cors_allow_origin_regex_fullmatch",
      "module": "test_cors",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_cors.py",
      "line_number": 372,
      "end_line_number": 404,
      "source_code": "def test_cors_allow_origin_regex_fullmatch(\n    test_client_factory: TestClientFactory,\n) -> None:\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"Homepage\", status_code=200)\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[\n            Middleware(\n                CORSMiddleware,\n                allow_headers=[\"X-Example\", \"Content-Type\"],\n                allow_origin_regex=r\"https://.*\\.example.org\",\n            )\n        ],\n    )\n\n    client = test_client_factory(app)\n\n    # Test standard response\n    headers = {\"Origin\": \"https://subdomain.example.org\"}\n    response = client.get(\"/\", headers=headers)\n    assert response.status_code == 200\n    assert response.text == \"Homepage\"\n    assert response.headers[\"access-control-allow-origin\"] == \"https://subdomain.example.org\"\n    assert \"access-control-allow-credentials\" not in response.headers\n\n    # Test diallowed standard response\n    headers = {\"Origin\": \"https://subdomain.example.org.hacker.com\"}\n    response = client.get(\"/\", headers=headers)\n    assert response.status_code == 200\n    assert response.text == \"Homepage\"\n    assert \"access-control-allow-origin\" not in response.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.middleware.cors.CORSMiddleware",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == 'Homepage'",
        "assert response.headers['access-control-allow-origin'] == 'https://subdomain.example.org'",
        "assert 'access-control-allow-credentials' not in response.headers",
        "assert response.status_code == 200",
        "assert response.text == 'Homepage'",
        "assert 'access-control-allow-origin' not in response.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_cors_credentialed_requests_return_specific_origin",
      "module": "test_cors",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_cors.py",
      "line_number": 407,
      "end_line_number": 425,
      "source_code": "def test_cors_credentialed_requests_return_specific_origin(\n    test_client_factory: TestClientFactory,\n) -> None:\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"Homepage\", status_code=200)\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[Middleware(CORSMiddleware, allow_origins=[\"*\"])],\n    )\n    client = test_client_factory(app)\n\n    # Test credentialed request\n    headers = {\"Origin\": \"https://example.org\", \"Cookie\": \"star_cookie=sugar\"}\n    response = client.get(\"/\", headers=headers)\n    assert response.status_code == 200\n    assert response.text == \"Homepage\"\n    assert response.headers[\"access-control-allow-origin\"] == \"https://example.org\"\n    assert \"access-control-allow-credentials\" not in response.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.middleware.cors.CORSMiddleware",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == 'Homepage'",
        "assert response.headers['access-control-allow-origin'] == 'https://example.org'",
        "assert 'access-control-allow-credentials' not in response.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_cors_vary_header_defaults_to_origin",
      "module": "test_cors",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_cors.py",
      "line_number": 428,
      "end_line_number": 445,
      "source_code": "def test_cors_vary_header_defaults_to_origin(\n    test_client_factory: TestClientFactory,\n) -> None:\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"Homepage\", status_code=200)\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[Middleware(CORSMiddleware, allow_origins=[\"https://example.org\"])],\n    )\n\n    headers = {\"Origin\": \"https://example.org\"}\n\n    client = test_client_factory(app)\n\n    response = client.get(\"/\", headers=headers)\n    assert response.status_code == 200\n    assert response.headers[\"vary\"] == \"Origin\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.middleware.cors.CORSMiddleware",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.headers['vary'] == 'Origin'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_cors_vary_header_is_not_set_for_non_credentialed_request",
      "module": "test_cors",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_cors.py",
      "line_number": 448,
      "end_line_number": 462,
      "source_code": "def test_cors_vary_header_is_not_set_for_non_credentialed_request(\n    test_client_factory: TestClientFactory,\n) -> None:\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"Homepage\", status_code=200, headers={\"Vary\": \"Accept-Encoding\"})\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[Middleware(CORSMiddleware, allow_origins=[\"*\"])],\n    )\n    client = test_client_factory(app)\n\n    response = client.get(\"/\", headers={\"Origin\": \"https://someplace.org\"})\n    assert response.status_code == 200\n    assert response.headers[\"vary\"] == \"Accept-Encoding\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.middleware.cors.CORSMiddleware",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.headers['vary'] == 'Accept-Encoding'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_cors_vary_header_is_properly_set_for_credentialed_request",
      "module": "test_cors",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_cors.py",
      "line_number": 465,
      "end_line_number": 479,
      "source_code": "def test_cors_vary_header_is_properly_set_for_credentialed_request(\n    test_client_factory: TestClientFactory,\n) -> None:\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"Homepage\", status_code=200, headers={\"Vary\": \"Accept-Encoding\"})\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[Middleware(CORSMiddleware, allow_origins=[\"*\"])],\n    )\n    client = test_client_factory(app)\n\n    response = client.get(\"/\", headers={\"Cookie\": \"foo=bar\", \"Origin\": \"https://someplace.org\"})\n    assert response.status_code == 200\n    assert response.headers[\"vary\"] == \"Accept-Encoding, Origin\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.middleware.cors.CORSMiddleware",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.headers['vary'] == 'Accept-Encoding, Origin'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_cors_vary_header_is_properly_set_when_allow_origins_is_not_wildcard",
      "module": "test_cors",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_cors.py",
      "line_number": 482,
      "end_line_number": 498,
      "source_code": "def test_cors_vary_header_is_properly_set_when_allow_origins_is_not_wildcard(\n    test_client_factory: TestClientFactory,\n) -> None:\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"Homepage\", status_code=200, headers={\"Vary\": \"Accept-Encoding\"})\n\n    app = Starlette(\n        routes=[\n            Route(\"/\", endpoint=homepage),\n        ],\n        middleware=[Middleware(CORSMiddleware, allow_origins=[\"https://example.org\"])],\n    )\n    client = test_client_factory(app)\n\n    response = client.get(\"/\", headers={\"Origin\": \"https://example.org\"})\n    assert response.status_code == 200\n    assert response.headers[\"vary\"] == \"Accept-Encoding, Origin\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.middleware.cors.CORSMiddleware",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.headers['vary'] == 'Accept-Encoding, Origin'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_cors_allowed_origin_does_not_leak_between_credentialed_requests",
      "module": "test_cors",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_cors.py",
      "line_number": 501,
      "end_line_number": 532,
      "source_code": "def test_cors_allowed_origin_does_not_leak_between_credentialed_requests(\n    test_client_factory: TestClientFactory,\n) -> None:\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"Homepage\", status_code=200)\n\n    app = Starlette(\n        routes=[\n            Route(\"/\", endpoint=homepage),\n        ],\n        middleware=[\n            Middleware(\n                CORSMiddleware,\n                allow_origins=[\"*\"],\n                allow_headers=[\"*\"],\n                allow_methods=[\"*\"],\n            )\n        ],\n    )\n\n    client = test_client_factory(app)\n    response = client.get(\"/\", headers={\"Origin\": \"https://someplace.org\"})\n    assert response.headers[\"access-control-allow-origin\"] == \"*\"\n    assert \"access-control-allow-credentials\" not in response.headers\n\n    response = client.get(\"/\", headers={\"Cookie\": \"foo=bar\", \"Origin\": \"https://someplace.org\"})\n    assert response.headers[\"access-control-allow-origin\"] == \"https://someplace.org\"\n    assert \"access-control-allow-credentials\" not in response.headers\n\n    response = client.get(\"/\", headers={\"Origin\": \"https://someplace.org\"})\n    assert response.headers[\"access-control-allow-origin\"] == \"*\"\n    assert \"access-control-allow-credentials\" not in response.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.middleware.cors.CORSMiddleware",
        "starlette.requests.Request",
        "starlette.responses.PlainTextResponse",
        "starlette.routing.Route",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.headers['access-control-allow-origin'] == '*'",
        "assert 'access-control-allow-credentials' not in response.headers",
        "assert response.headers['access-control-allow-origin'] == 'https://someplace.org'",
        "assert 'access-control-allow-credentials' not in response.headers",
        "assert response.headers['access-control-allow-origin'] == '*'",
        "assert 'access-control-allow-credentials' not in response.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_gzip_responses",
      "module": "test_gzip",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_gzip.py",
      "line_number": 10,
      "end_line_number": 24,
      "source_code": "def test_gzip_responses(test_client_factory: TestClientFactory) -> None:\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"x\" * 4000, status_code=200)\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[Middleware(GZipMiddleware)],\n    )\n\n    client = test_client_factory(app)\n    response = client.get(\"/\", headers={\"accept-encoding\": \"gzip\"})\n    assert response.status_code == 200\n    assert response.text == \"x\" * 4000\n    assert response.headers[\"Content-Encoding\"] == \"gzip\"\n    assert int(response.headers[\"Content-Length\"]) < 4000",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.middleware.gzip.GZipMiddleware",
        "starlette.requests.Request",
        "starlette.responses.ContentStream",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.StreamingResponse",
        "starlette.routing.Route",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == 'x' * 4000",
        "assert response.headers['Content-Encoding'] == 'gzip'",
        "assert int(response.headers['Content-Length']) < 4000"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_gzip_not_in_accept_encoding",
      "module": "test_gzip",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_gzip.py",
      "line_number": 27,
      "end_line_number": 41,
      "source_code": "def test_gzip_not_in_accept_encoding(test_client_factory: TestClientFactory) -> None:\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"x\" * 4000, status_code=200)\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[Middleware(GZipMiddleware)],\n    )\n\n    client = test_client_factory(app)\n    response = client.get(\"/\", headers={\"accept-encoding\": \"identity\"})\n    assert response.status_code == 200\n    assert response.text == \"x\" * 4000\n    assert \"Content-Encoding\" not in response.headers\n    assert int(response.headers[\"Content-Length\"]) == 4000",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.middleware.gzip.GZipMiddleware",
        "starlette.requests.Request",
        "starlette.responses.ContentStream",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.StreamingResponse",
        "starlette.routing.Route",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == 'x' * 4000",
        "assert 'Content-Encoding' not in response.headers",
        "assert int(response.headers['Content-Length']) == 4000"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_gzip_ignored_for_small_responses",
      "module": "test_gzip",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_gzip.py",
      "line_number": 44,
      "end_line_number": 60,
      "source_code": "def test_gzip_ignored_for_small_responses(\n    test_client_factory: TestClientFactory,\n) -> None:\n    def homepage(request: Request) -> PlainTextResponse:\n        return PlainTextResponse(\"OK\", status_code=200)\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[Middleware(GZipMiddleware)],\n    )\n\n    client = test_client_factory(app)\n    response = client.get(\"/\", headers={\"accept-encoding\": \"gzip\"})\n    assert response.status_code == 200\n    assert response.text == \"OK\"\n    assert \"Content-Encoding\" not in response.headers\n    assert int(response.headers[\"Content-Length\"]) == 2",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.middleware.gzip.GZipMiddleware",
        "starlette.requests.Request",
        "starlette.responses.ContentStream",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.StreamingResponse",
        "starlette.routing.Route",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == 'OK'",
        "assert 'Content-Encoding' not in response.headers",
        "assert int(response.headers['Content-Length']) == 2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_gzip_streaming_response",
      "module": "test_gzip",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_gzip.py",
      "line_number": 63,
      "end_line_number": 82,
      "source_code": "def test_gzip_streaming_response(test_client_factory: TestClientFactory) -> None:\n    def homepage(request: Request) -> StreamingResponse:\n        async def generator(bytes: bytes, count: int) -> ContentStream:\n            for index in range(count):\n                yield bytes\n\n        streaming = generator(bytes=b\"x\" * 400, count=10)\n        return StreamingResponse(streaming, status_code=200)\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[Middleware(GZipMiddleware)],\n    )\n\n    client = test_client_factory(app)\n    response = client.get(\"/\", headers={\"accept-encoding\": \"gzip\"})\n    assert response.status_code == 200\n    assert response.text == \"x\" * 4000\n    assert response.headers[\"Content-Encoding\"] == \"gzip\"\n    assert \"Content-Length\" not in response.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.middleware.gzip.GZipMiddleware",
        "starlette.requests.Request",
        "starlette.responses.ContentStream",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.StreamingResponse",
        "starlette.routing.Route",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == 'x' * 4000",
        "assert response.headers['Content-Encoding'] == 'gzip'",
        "assert 'Content-Length' not in response.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_gzip_ignored_for_responses_with_encoding_set",
      "module": "test_gzip",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_gzip.py",
      "line_number": 85,
      "end_line_number": 106,
      "source_code": "def test_gzip_ignored_for_responses_with_encoding_set(\n    test_client_factory: TestClientFactory,\n) -> None:\n    def homepage(request: Request) -> StreamingResponse:\n        async def generator(bytes: bytes, count: int) -> ContentStream:\n            for index in range(count):\n                yield bytes\n\n        streaming = generator(bytes=b\"x\" * 400, count=10)\n        return StreamingResponse(streaming, status_code=200, headers={\"Content-Encoding\": \"text\"})\n\n    app = Starlette(\n        routes=[Route(\"/\", endpoint=homepage)],\n        middleware=[Middleware(GZipMiddleware)],\n    )\n\n    client = test_client_factory(app)\n    response = client.get(\"/\", headers={\"accept-encoding\": \"gzip, text\"})\n    assert response.status_code == 200\n    assert response.text == \"x\" * 4000\n    assert response.headers[\"Content-Encoding\"] == \"text\"\n    assert \"Content-Length\" not in response.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "starlette.applications.Starlette",
        "starlette.middleware.Middleware",
        "starlette.middleware.gzip.GZipMiddleware",
        "starlette.requests.Request",
        "starlette.responses.ContentStream",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.StreamingResponse",
        "starlette.routing.Route",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == 'x' * 4000",
        "assert response.headers['Content-Encoding'] == 'text'",
        "assert 'Content-Length' not in response.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_wsgi_get",
      "module": "test_wsgi",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_wsgi.py",
      "line_number": 67,
      "end_line_number": 72,
      "source_code": "def test_wsgi_get(test_client_factory: TestClientFactory) -> None:\n    app = WSGIMiddleware(hello_world)\n    client = test_client_factory(app)\n    response = client.get(\"/\")\n    assert response.status_code == 200\n    assert response.text == \"Hello World!\\n\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterable",
        "pytest",
        "starlette._utils.collapse_excgroups",
        "starlette.middleware.wsgi.WSGIMiddleware",
        "starlette.middleware.wsgi.build_environ",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == 'Hello World!\\n'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_wsgi_post",
      "module": "test_wsgi",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_wsgi.py",
      "line_number": 75,
      "end_line_number": 80,
      "source_code": "def test_wsgi_post(test_client_factory: TestClientFactory) -> None:\n    app = WSGIMiddleware(echo_body)\n    client = test_client_factory(app)\n    response = client.post(\"/\", json={\"example\": 123})\n    assert response.status_code == 200\n    assert response.text == '{\"example\": 123}'",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterable",
        "pytest",
        "starlette._utils.collapse_excgroups",
        "starlette.middleware.wsgi.WSGIMiddleware",
        "starlette.middleware.wsgi.build_environ",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == '{\"example\": 123}'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.post",
          "body": "def post(self, request: Request) -> None:\n    \"\"\"\n        responses:\n          200:\n            description: An organisation.\n            examples:\n              {\"name\": \"Foo Corp.\"}\n        \"\"\"\n    pass"
        }
      ]
    },
    {
      "name": "test_wsgi_exception",
      "module": "test_wsgi",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_wsgi.py",
      "line_number": 83,
      "end_line_number": 89,
      "source_code": "def test_wsgi_exception(test_client_factory: TestClientFactory) -> None:\n    # Note that we're testing the WSGI app directly here.\n    # The HTTP protocol implementations would catch this error and return 500.\n    app = WSGIMiddleware(raise_exception)\n    client = test_client_factory(app)\n    with pytest.raises(RuntimeError), collapse_excgroups():\n        client.get(\"/\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterable",
        "pytest",
        "starlette._utils.collapse_excgroups",
        "starlette.middleware.wsgi.WSGIMiddleware",
        "starlette.middleware.wsgi.build_environ",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_wsgi_exc_info",
      "module": "test_wsgi",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_wsgi.py",
      "line_number": 92,
      "end_line_number": 104,
      "source_code": "def test_wsgi_exc_info(test_client_factory: TestClientFactory) -> None:\n    # Note that we're testing the WSGI app directly here.\n    # The HTTP protocol implementations would catch this error and return 500.\n    app = WSGIMiddleware(return_exc_info)\n    client = test_client_factory(app)\n    with pytest.raises(RuntimeError):\n        response = client.get(\"/\")\n\n    app = WSGIMiddleware(return_exc_info)\n    client = test_client_factory(app, raise_server_exceptions=False)\n    response = client.get(\"/\")\n    assert response.status_code == 500\n    assert response.text == \"Internal Server Error\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_client_factory"
      ],
      "imports": [
        "sys",
        "typing.Any",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterable",
        "pytest",
        "starlette._utils.collapse_excgroups",
        "starlette.middleware.wsgi.WSGIMiddleware",
        "starlette.middleware.wsgi.build_environ",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 500",
        "assert response.text == 'Internal Server Error'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "test_client_factory",
          "body": "@pytest.fixture\ndef test_client_factory(anyio_backend_name: Literal['asyncio', 'trio'], anyio_backend_options: dict[str, Any]) -> TestClientFactory:\n    return functools.partial(TestClient, backend=anyio_backend_name, backend_options=anyio_backend_options)"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request: Request) -> PlainTextResponse:\n    return PlainTextResponse('Hello, world!')"
        }
      ]
    },
    {
      "name": "test_build_environ",
      "module": "test_wsgi",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_wsgi.py",
      "line_number": 107,
      "end_line_number": 149,
      "source_code": "def test_build_environ() -> None:\n    scope = {\n        \"type\": \"http\",\n        \"http_version\": \"1.1\",\n        \"method\": \"GET\",\n        \"scheme\": \"https\",\n        \"path\": \"/sub/\",\n        \"root_path\": \"/sub\",\n        \"query_string\": b\"a=123&b=456\",\n        \"headers\": [\n            (b\"host\", b\"www.example.org\"),\n            (b\"content-type\", b\"application/json\"),\n            (b\"content-length\", b\"18\"),\n            (b\"accept\", b\"application/json\"),\n            (b\"accept\", b\"text/plain\"),\n        ],\n        \"client\": (\"134.56.78.4\", 1453),\n        \"server\": (\"www.example.org\", 443),\n    }\n    body = b'{\"example\":\"body\"}'\n    environ = build_environ(scope, body)\n    stream = environ.pop(\"wsgi.input\")\n    assert stream.read() == b'{\"example\":\"body\"}'\n    assert environ == {\n        \"CONTENT_LENGTH\": \"18\",\n        \"CONTENT_TYPE\": \"application/json\",\n        \"HTTP_ACCEPT\": \"application/json,text/plain\",\n        \"HTTP_HOST\": \"www.example.org\",\n        \"PATH_INFO\": \"/\",\n        \"QUERY_STRING\": \"a=123&b=456\",\n        \"REMOTE_ADDR\": \"134.56.78.4\",\n        \"REQUEST_METHOD\": \"GET\",\n        \"SCRIPT_NAME\": \"/sub\",\n        \"SERVER_NAME\": \"www.example.org\",\n        \"SERVER_PORT\": 443,\n        \"SERVER_PROTOCOL\": \"HTTP/1.1\",\n        \"wsgi.errors\": sys.stdout,\n        \"wsgi.multiprocess\": True,\n        \"wsgi.multithread\": True,\n        \"wsgi.run_once\": False,\n        \"wsgi.url_scheme\": \"https\",\n        \"wsgi.version\": (1, 0),\n    }",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "sys",
        "typing.Any",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterable",
        "pytest",
        "starlette._utils.collapse_excgroups",
        "starlette.middleware.wsgi.WSGIMiddleware",
        "starlette.middleware.wsgi.build_environ",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert stream.read() == b'{\"example\":\"body\"}'",
        "assert environ == {'CONTENT_LENGTH': '18', 'CONTENT_TYPE': 'application/json', 'HTTP_ACCEPT': 'application/json,text/plain', 'HTTP_HOST': 'www.example.org', 'PATH_INFO': '/', 'QUERY_STRING': 'a=123&b=456', 'REMOTE_ADDR': '134.56.78.4', 'REQUEST_METHOD': 'GET', 'SCRIPT_NAME': '/sub', 'SERVER_NAME': 'www.example.org', 'SERVER_PORT': 443, 'SERVER_PROTOCOL': 'HTTP/1.1', 'wsgi.errors': sys.stdout, 'wsgi.multiprocess': True, 'wsgi.multithread': True, 'wsgi.run_once': False, 'wsgi.url_scheme': 'https', 'wsgi.version': (1, 0)}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_build_environ_encoding",
      "module": "test_wsgi",
      "class_name": null,
      "file_path": "__internal__/data/starlette/tests/middleware/test_wsgi.py",
      "line_number": 152,
      "end_line_number": 164,
      "source_code": "def test_build_environ_encoding() -> None:\n    scope = {\n        \"type\": \"http\",\n        \"http_version\": \"1.1\",\n        \"method\": \"GET\",\n        \"path\": \"/\u5c0f\u661f\",\n        \"root_path\": \"/\u4e2d\u56fd\",\n        \"query_string\": b\"a=123&b=456\",\n        \"headers\": [],\n    }\n    environ = build_environ(scope, b\"\")\n    assert environ[\"SCRIPT_NAME\"] == \"/\u4e2d\u56fd\".encode().decode(\"latin-1\")\n    assert environ[\"PATH_INFO\"] == \"/\u5c0f\u661f\".encode().decode(\"latin-1\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "sys",
        "typing.Any",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterable",
        "pytest",
        "starlette._utils.collapse_excgroups",
        "starlette.middleware.wsgi.WSGIMiddleware",
        "starlette.middleware.wsgi.build_environ",
        "tests.types.TestClientFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert environ['SCRIPT_NAME'] == '/\u4e2d\u56fd'.encode().decode('latin-1')",
        "assert environ['PATH_INFO'] == '/\u5c0f\u661f'.encode().decode('latin-1')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    }
  ]
}