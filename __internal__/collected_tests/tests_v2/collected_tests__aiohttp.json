{
  "tests": [
    {
      "name": "test_repr_for_application",
      "module": "test_web_functional",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_functional.py",
      "line_number": 537,
      "end_line_number": 539,
      "source_code": "def test_repr_for_application() -> None:\n    app = web.Application()\n    assert f\"<Application 0x{id(app):x}>\" == repr(app)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "socket",
        "sys",
        "zlib",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.FormData",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.TraceConfig",
        "aiohttp.multipart",
        "aiohttp.web",
        "aiohttp.abc.AbstractResolver",
        "aiohttp.abc.ResolveResult",
        "aiohttp.hdrs.CONTENT_LENGTH",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.hdrs.TRANSFER_ENCODING",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.Handler",
        "aiohttp.typedefs.Middleware",
        "aiohttp.web_protocol.RequestHandler",
        "brotlicffi",
        "ssl",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert f'<Application 0x{id(app):x}>' == repr(app)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_at_eof",
      "module": "test_multipart",
      "class_name": "TestMultipartResponseWrapper",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 104,
      "end_line_number": 109,
      "source_code": "def test_at_eof(self) -> None:\n        m_resp = mock.create_autospec(aiohttp.ClientResponse, spec_set=True)\n        m_stream = mock.create_autospec(MultipartReader, spec_set=True)\n        wrapper = MultipartResponseWrapper(m_resp, m_stream)\n        wrapper.at_eof()\n        assert m_resp.content.at_eof.called",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert m_resp.content.at_eof.called"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "wrapper.at_eof",
          "body": "def at_eof(self) -> bool:\n    return self.content.tell() == len(self.content.getbuffer())"
        }
      ]
    },
    {
      "name": "test_from_response",
      "module": "test_multipart",
      "class_name": "TestMultipartReader",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 597,
      "end_line_number": 605,
      "source_code": "def test_from_response(self) -> None:\n        h = CIMultiDictProxy(\n            CIMultiDict({CONTENT_TYPE: 'multipart/related;boundary=\":\"'})\n        )\n        with Stream(b\"--:\\r\\n\\r\\nhello\\r\\n--:--\") as stream:\n            resp = Response(h, stream)\n            res = aiohttp.MultipartReader.from_response(resp)  # type: ignore[arg-type]\n        assert isinstance(res, MultipartResponseWrapper)\n        assert isinstance(res.stream, aiohttp.MultipartReader)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(res, MultipartResponseWrapper)",
        "assert isinstance(res.stream, aiohttp.MultipartReader)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_bad_boundary",
      "module": "test_multipart",
      "class_name": "TestMultipartReader",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 607,
      "end_line_number": 614,
      "source_code": "def test_bad_boundary(self) -> None:\n        h = CIMultiDictProxy(\n            CIMultiDict({CONTENT_TYPE: \"multipart/related;boundary=\" + \"a\" * 80})\n        )\n        with Stream(b\"\") as stream:\n            resp = Response(h, stream)\n            with pytest.raises(ValueError):\n                aiohttp.MultipartReader.from_response(resp)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_dispatch",
      "module": "test_multipart",
      "class_name": "TestMultipartReader",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 616,
      "end_line_number": 624,
      "source_code": "def test_dispatch(self) -> None:\n        h = CIMultiDictProxy(CIMultiDict({CONTENT_TYPE: \"text/plain\"}))\n        with Stream(b\"--:\\r\\n\\r\\necho\\r\\n--:--\") as stream:\n            reader = aiohttp.MultipartReader(\n                {CONTENT_TYPE: 'multipart/related;boundary=\":\"'},\n                stream,\n            )\n            res = reader._get_part_reader(h)\n        assert isinstance(res, reader.part_reader_cls)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(res, reader.part_reader_cls)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_dispatch_bodypart",
      "module": "test_multipart",
      "class_name": "TestMultipartReader",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 626,
      "end_line_number": 634,
      "source_code": "def test_dispatch_bodypart(self) -> None:\n        h = CIMultiDictProxy(CIMultiDict({CONTENT_TYPE: \"text/plain\"}))\n        with Stream(b\"--:\\r\\n\\r\\necho\\r\\n--:--\") as stream:\n            reader = aiohttp.MultipartReader(\n                {CONTENT_TYPE: 'multipart/related;boundary=\":\"'},\n                stream,\n            )\n            res = reader._get_part_reader(h)\n        assert isinstance(res, reader.part_reader_cls)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(res, reader.part_reader_cls)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_dispatch_multipart",
      "module": "test_multipart",
      "class_name": "TestMultipartReader",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 636,
      "end_line_number": 655,
      "source_code": "def test_dispatch_multipart(self) -> None:\n        h = CIMultiDictProxy(\n            CIMultiDict({CONTENT_TYPE: \"multipart/related;boundary=--:--\"})\n        )\n        with Stream(\n            b\"----:--\\r\\n\"\n            b\"\\r\\n\"\n            b\"test\\r\\n\"\n            b\"----:--\\r\\n\"\n            b\"\\r\\n\"\n            b\"passed\\r\\n\"\n            b\"----:----\\r\\n\"\n            b\"--:--\"\n        ) as stream:\n            reader = aiohttp.MultipartReader(\n                {CONTENT_TYPE: 'multipart/related;boundary=\":\"'},\n                stream,\n            )\n            res = reader._get_part_reader(h)\n        assert isinstance(res, reader.__class__)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(res, reader.__class__)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_dispatch_custom_multipart_reader",
      "module": "test_multipart",
      "class_name": "TestMultipartReader",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 657,
      "end_line_number": 680,
      "source_code": "def test_dispatch_custom_multipart_reader(self) -> None:\n        class CustomReader(aiohttp.MultipartReader):\n            pass\n\n        h = CIMultiDictProxy(\n            CIMultiDict({CONTENT_TYPE: \"multipart/related;boundary=--:--\"})\n        )\n        with Stream(\n            b\"----:--\\r\\n\"\n            b\"\\r\\n\"\n            b\"test\\r\\n\"\n            b\"----:--\\r\\n\"\n            b\"\\r\\n\"\n            b\"passed\\r\\n\"\n            b\"----:----\\r\\n\"\n            b\"--:--\"\n        ) as stream:\n            reader = aiohttp.MultipartReader(\n                {CONTENT_TYPE: 'multipart/related;boundary=\":\"'},\n                stream,\n            )\n            reader.multipart_reader_cls = CustomReader\n            res = reader._get_part_reader(h)\n        assert isinstance(res, CustomReader)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(res, CustomReader)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_writer_serialize_with_content_encoding_unknown",
      "module": "test_multipart",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1158,
      "end_line_number": 1162,
      "source_code": "def test_writer_serialize_with_content_encoding_unknown(\n    buf: bytearray, stream: Stream, writer: aiohttp.MultipartWriter\n) -> None:\n    with pytest.raises(RuntimeError):\n        writer.append(\"Time to Relax!\", {CONTENT_ENCODING: \"snappy\"})",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "buf",
        "stream",
        "writer"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_writer_content_transfer_encoding_unknown",
      "module": "test_multipart",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1198,
      "end_line_number": 1202,
      "source_code": "def test_writer_content_transfer_encoding_unknown(\n    buf: bytearray, stream: Stream, writer: aiohttp.MultipartWriter\n) -> None:\n    with pytest.raises(RuntimeError):\n        writer.append(\"Time to Relax!\", {CONTENT_TRANSFER_ENCODING: \"unknown\"})",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "buf",
        "stream",
        "writer"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_default_subtype",
      "module": "test_multipart",
      "class_name": "TestMultipartWriter",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1206,
      "end_line_number": 1210,
      "source_code": "def test_default_subtype(self, writer: aiohttp.MultipartWriter) -> None:\n        mimetype = parse_mimetype(writer.headers.get(CONTENT_TYPE))\n\n        assert \"multipart\" == mimetype.type\n        assert \"mixed\" == mimetype.subtype",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "writer"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'multipart' == mimetype.type",
        "assert 'mixed' == mimetype.subtype"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_unquoted_boundary",
      "module": "test_multipart",
      "class_name": "TestMultipartWriter",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1212,
      "end_line_number": 1215,
      "source_code": "def test_unquoted_boundary(self) -> None:\n        writer = aiohttp.MultipartWriter(boundary=\"abc123\")\n        expected = {CONTENT_TYPE: \"multipart/mixed; boundary=abc123\"}\n        assert expected == writer.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert expected == writer.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_quoted_boundary",
      "module": "test_multipart",
      "class_name": "TestMultipartWriter",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1217,
      "end_line_number": 1220,
      "source_code": "def test_quoted_boundary(self) -> None:\n        writer = aiohttp.MultipartWriter(boundary=R\"\\\"\")\n        expected = {CONTENT_TYPE: R'multipart/mixed; boundary=\"\\\\\\\"\"'}\n        assert expected == writer.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert expected == writer.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_bad_boundary",
      "module": "test_multipart",
      "class_name": "TestMultipartWriter",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1222,
      "end_line_number": 1228,
      "source_code": "def test_bad_boundary(self) -> None:\n        with pytest.raises(ValueError):\n            aiohttp.MultipartWriter(boundary=\"\u0442\u0435\u0441\u0442\")\n        with pytest.raises(ValueError):\n            aiohttp.MultipartWriter(boundary=\"test\\n\")\n        with pytest.raises(ValueError):\n            aiohttp.MultipartWriter(boundary=\"X\" * 71)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_default_headers",
      "module": "test_multipart",
      "class_name": "TestMultipartWriter",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1230,
      "end_line_number": 1232,
      "source_code": "def test_default_headers(self, writer: aiohttp.MultipartWriter) -> None:\n        expected = {CONTENT_TYPE: 'multipart/mixed; boundary=\":\"'}\n        assert expected == writer.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "writer"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert expected == writer.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_iter_parts",
      "module": "test_multipart",
      "class_name": "TestMultipartWriter",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1234,
      "end_line_number": 1238,
      "source_code": "def test_iter_parts(self, writer: aiohttp.MultipartWriter) -> None:\n        writer.append(\"foo\")\n        writer.append(\"bar\")\n        writer.append(\"baz\")\n        assert 3 == len(list(writer))",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "writer"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert 3 == len(list(writer))"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_append",
      "module": "test_multipart",
      "class_name": "TestMultipartWriter",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1240,
      "end_line_number": 1244,
      "source_code": "def test_append(self, writer: aiohttp.MultipartWriter) -> None:\n        assert 0 == len(writer)\n        writer.append(\"hello, world!\")\n        assert 1 == len(writer)\n        assert isinstance(writer._parts[0][0], payload.Payload)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "writer"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert 0 == len(writer)",
        "assert 1 == len(writer)",
        "assert isinstance(writer._parts[0][0], payload.Payload)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_append_with_headers",
      "module": "test_multipart",
      "class_name": "TestMultipartWriter",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1246,
      "end_line_number": 1250,
      "source_code": "def test_append_with_headers(self, writer: aiohttp.MultipartWriter) -> None:\n        writer.append(\"hello, world!\", {\"x-foo\": \"bar\"})\n        assert 1 == len(writer)\n        assert \"x-foo\" in writer._parts[0][0].headers\n        assert writer._parts[0][0].headers[\"x-foo\"] == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "writer"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert 1 == len(writer)",
        "assert 'x-foo' in writer._parts[0][0].headers",
        "assert writer._parts[0][0].headers['x-foo'] == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_append_json",
      "module": "test_multipart",
      "class_name": "TestMultipartWriter",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1252,
      "end_line_number": 1256,
      "source_code": "def test_append_json(self, writer: aiohttp.MultipartWriter) -> None:\n        writer.append_json({\"foo\": \"bar\"})\n        assert 1 == len(writer)\n        part = writer._parts[0][0]\n        assert part.headers[CONTENT_TYPE] == \"application/json\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "writer"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert 1 == len(writer)",
        "assert part.headers[CONTENT_TYPE] == 'application/json'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_append_part",
      "module": "test_multipart",
      "class_name": "TestMultipartWriter",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1258,
      "end_line_number": 1263,
      "source_code": "def test_append_part(self, writer: aiohttp.MultipartWriter) -> None:\n        part = payload.get_payload(\"test\", headers={CONTENT_TYPE: \"text/plain\"})\n        writer.append(part, {CONTENT_TYPE: \"test/passed\"})\n        assert 1 == len(writer)\n        part = writer._parts[0][0]\n        assert part.headers[CONTENT_TYPE] == \"test/passed\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "writer"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert 1 == len(writer)",
        "assert part.headers[CONTENT_TYPE] == 'test/passed'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_append_json_overrides_content_type",
      "module": "test_multipart",
      "class_name": "TestMultipartWriter",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1265,
      "end_line_number": 1271,
      "source_code": "def test_append_json_overrides_content_type(\n        self, writer: aiohttp.MultipartWriter\n    ) -> None:\n        writer.append_json({\"foo\": \"bar\"}, {CONTENT_TYPE: \"test/passed\"})\n        assert 1 == len(writer)\n        part = writer._parts[0][0]\n        assert part.headers[CONTENT_TYPE] == \"test/passed\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "writer"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert 1 == len(writer)",
        "assert part.headers[CONTENT_TYPE] == 'test/passed'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_append_form",
      "module": "test_multipart",
      "class_name": "TestMultipartWriter",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1273,
      "end_line_number": 1277,
      "source_code": "def test_append_form(self, writer: aiohttp.MultipartWriter) -> None:\n        writer.append_form({\"foo\": \"bar\"}, {CONTENT_TYPE: \"test/passed\"})\n        assert 1 == len(writer)\n        part = writer._parts[0][0]\n        assert part.headers[CONTENT_TYPE] == \"test/passed\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "writer"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert 1 == len(writer)",
        "assert part.headers[CONTENT_TYPE] == 'test/passed'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_append_multipart",
      "module": "test_multipart",
      "class_name": "TestMultipartWriter",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1279,
      "end_line_number": 1285,
      "source_code": "def test_append_multipart(self, writer: aiohttp.MultipartWriter) -> None:\n        subwriter = aiohttp.MultipartWriter(boundary=\":\")\n        subwriter.append_json({\"foo\": \"bar\"})\n        writer.append(subwriter, {CONTENT_TYPE: \"test/passed\"})\n        assert 1 == len(writer)\n        part = writer._parts[0][0]\n        assert part.headers[CONTENT_TYPE] == \"test/passed\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "writer"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert 1 == len(writer)",
        "assert part.headers[CONTENT_TYPE] == 'test/passed'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_set_content_disposition_after_append",
      "module": "test_multipart",
      "class_name": "TestMultipartWriter",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1287,
      "end_line_number": 1291,
      "source_code": "def test_set_content_disposition_after_append(self) -> None:\n        writer = aiohttp.MultipartWriter(\"form-data\")\n        part = writer.append(\"some-data\")\n        part.set_content_disposition(\"form-data\", name=\"method\")\n        assert 'name=\"method\"' in part.headers[CONTENT_DISPOSITION]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'name=\"method\"' in part.headers[CONTENT_DISPOSITION]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_automatic_content_disposition",
      "module": "test_multipart",
      "class_name": "TestMultipartWriter",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1293,
      "end_line_number": 1304,
      "source_code": "def test_automatic_content_disposition(self) -> None:\n        writer = aiohttp.MultipartWriter(\"form-data\")\n        writer.append_json(())\n        part = payload.StringPayload(\"foo\")\n        part.set_content_disposition(\"form-data\", name=\"second\")\n        writer.append_payload(part)\n        writer.append(\"foo\")\n\n        disps = tuple(p[0].headers[CONTENT_DISPOSITION] for p in writer._parts)\n        assert 'name=\"section-0\"' in disps[0]\n        assert 'name=\"second\"' in disps[1]\n        assert 'name=\"section-2\"' in disps[2]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'name=\"section-0\"' in disps[0]",
        "assert 'name=\"second\"' in disps[1]",
        "assert 'name=\"section-2\"' in disps[2]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_with",
      "module": "test_multipart",
      "class_name": "TestMultipartWriter",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1306,
      "end_line_number": 1311,
      "source_code": "def test_with(self) -> None:\n        with aiohttp.MultipartWriter(boundary=\":\") as writer:\n            writer.append(\"foo\")\n            writer.append(b\"bar\")\n            writer.append_json({\"baz\": True})\n        assert 3 == len(writer)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert 3 == len(writer)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_append_int_not_allowed",
      "module": "test_multipart",
      "class_name": "TestMultipartWriter",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1313,
      "end_line_number": 1316,
      "source_code": "def test_append_int_not_allowed(self) -> None:\n        with pytest.raises(TypeError):\n            with aiohttp.MultipartWriter(boundary=\":\") as writer:\n                writer.append(1)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_append_float_not_allowed",
      "module": "test_multipart",
      "class_name": "TestMultipartWriter",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1318,
      "end_line_number": 1321,
      "source_code": "def test_append_float_not_allowed(self) -> None:\n        with pytest.raises(TypeError):\n            with aiohttp.MultipartWriter(boundary=\":\") as writer:\n                writer.append(1.1)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_append_none_not_allowed",
      "module": "test_multipart",
      "class_name": "TestMultipartWriter",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1323,
      "end_line_number": 1326,
      "source_code": "def test_append_none_not_allowed(self) -> None:\n        with pytest.raises(TypeError):\n            with aiohttp.MultipartWriter(boundary=\":\") as writer:\n                writer.append(None)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_at_eof",
      "module": "test_multipart",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 104,
      "end_line_number": 109,
      "source_code": "def test_at_eof(self) -> None:\n        m_resp = mock.create_autospec(aiohttp.ClientResponse, spec_set=True)\n        m_stream = mock.create_autospec(MultipartReader, spec_set=True)\n        wrapper = MultipartResponseWrapper(m_resp, m_stream)\n        wrapper.at_eof()\n        assert m_resp.content.at_eof.called",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert m_resp.content.at_eof.called"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "wrapper.at_eof",
          "body": "def at_eof(self) -> bool:\n    return self.content.tell() == len(self.content.getbuffer())"
        }
      ]
    },
    {
      "name": "test_from_response",
      "module": "test_multipart",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 597,
      "end_line_number": 605,
      "source_code": "def test_from_response(self) -> None:\n        h = CIMultiDictProxy(\n            CIMultiDict({CONTENT_TYPE: 'multipart/related;boundary=\":\"'})\n        )\n        with Stream(b\"--:\\r\\n\\r\\nhello\\r\\n--:--\") as stream:\n            resp = Response(h, stream)\n            res = aiohttp.MultipartReader.from_response(resp)  # type: ignore[arg-type]\n        assert isinstance(res, MultipartResponseWrapper)\n        assert isinstance(res.stream, aiohttp.MultipartReader)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(res, MultipartResponseWrapper)",
        "assert isinstance(res.stream, aiohttp.MultipartReader)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_bad_boundary",
      "module": "test_multipart",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 607,
      "end_line_number": 614,
      "source_code": "def test_bad_boundary(self) -> None:\n        h = CIMultiDictProxy(\n            CIMultiDict({CONTENT_TYPE: \"multipart/related;boundary=\" + \"a\" * 80})\n        )\n        with Stream(b\"\") as stream:\n            resp = Response(h, stream)\n            with pytest.raises(ValueError):\n                aiohttp.MultipartReader.from_response(resp)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_dispatch",
      "module": "test_multipart",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 616,
      "end_line_number": 624,
      "source_code": "def test_dispatch(self) -> None:\n        h = CIMultiDictProxy(CIMultiDict({CONTENT_TYPE: \"text/plain\"}))\n        with Stream(b\"--:\\r\\n\\r\\necho\\r\\n--:--\") as stream:\n            reader = aiohttp.MultipartReader(\n                {CONTENT_TYPE: 'multipart/related;boundary=\":\"'},\n                stream,\n            )\n            res = reader._get_part_reader(h)\n        assert isinstance(res, reader.part_reader_cls)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(res, reader.part_reader_cls)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_dispatch_bodypart",
      "module": "test_multipart",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 626,
      "end_line_number": 634,
      "source_code": "def test_dispatch_bodypart(self) -> None:\n        h = CIMultiDictProxy(CIMultiDict({CONTENT_TYPE: \"text/plain\"}))\n        with Stream(b\"--:\\r\\n\\r\\necho\\r\\n--:--\") as stream:\n            reader = aiohttp.MultipartReader(\n                {CONTENT_TYPE: 'multipart/related;boundary=\":\"'},\n                stream,\n            )\n            res = reader._get_part_reader(h)\n        assert isinstance(res, reader.part_reader_cls)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(res, reader.part_reader_cls)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_dispatch_multipart",
      "module": "test_multipart",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 636,
      "end_line_number": 655,
      "source_code": "def test_dispatch_multipart(self) -> None:\n        h = CIMultiDictProxy(\n            CIMultiDict({CONTENT_TYPE: \"multipart/related;boundary=--:--\"})\n        )\n        with Stream(\n            b\"----:--\\r\\n\"\n            b\"\\r\\n\"\n            b\"test\\r\\n\"\n            b\"----:--\\r\\n\"\n            b\"\\r\\n\"\n            b\"passed\\r\\n\"\n            b\"----:----\\r\\n\"\n            b\"--:--\"\n        ) as stream:\n            reader = aiohttp.MultipartReader(\n                {CONTENT_TYPE: 'multipart/related;boundary=\":\"'},\n                stream,\n            )\n            res = reader._get_part_reader(h)\n        assert isinstance(res, reader.__class__)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(res, reader.__class__)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_dispatch_custom_multipart_reader",
      "module": "test_multipart",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 657,
      "end_line_number": 680,
      "source_code": "def test_dispatch_custom_multipart_reader(self) -> None:\n        class CustomReader(aiohttp.MultipartReader):\n            pass\n\n        h = CIMultiDictProxy(\n            CIMultiDict({CONTENT_TYPE: \"multipart/related;boundary=--:--\"})\n        )\n        with Stream(\n            b\"----:--\\r\\n\"\n            b\"\\r\\n\"\n            b\"test\\r\\n\"\n            b\"----:--\\r\\n\"\n            b\"\\r\\n\"\n            b\"passed\\r\\n\"\n            b\"----:----\\r\\n\"\n            b\"--:--\"\n        ) as stream:\n            reader = aiohttp.MultipartReader(\n                {CONTENT_TYPE: 'multipart/related;boundary=\":\"'},\n                stream,\n            )\n            reader.multipart_reader_cls = CustomReader\n            res = reader._get_part_reader(h)\n        assert isinstance(res, CustomReader)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(res, CustomReader)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_default_subtype",
      "module": "test_multipart",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1206,
      "end_line_number": 1210,
      "source_code": "def test_default_subtype(self, writer: aiohttp.MultipartWriter) -> None:\n        mimetype = parse_mimetype(writer.headers.get(CONTENT_TYPE))\n\n        assert \"multipart\" == mimetype.type\n        assert \"mixed\" == mimetype.subtype",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "writer"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'multipart' == mimetype.type",
        "assert 'mixed' == mimetype.subtype"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_unquoted_boundary",
      "module": "test_multipart",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1212,
      "end_line_number": 1215,
      "source_code": "def test_unquoted_boundary(self) -> None:\n        writer = aiohttp.MultipartWriter(boundary=\"abc123\")\n        expected = {CONTENT_TYPE: \"multipart/mixed; boundary=abc123\"}\n        assert expected == writer.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert expected == writer.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_quoted_boundary",
      "module": "test_multipart",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1217,
      "end_line_number": 1220,
      "source_code": "def test_quoted_boundary(self) -> None:\n        writer = aiohttp.MultipartWriter(boundary=R\"\\\"\")\n        expected = {CONTENT_TYPE: R'multipart/mixed; boundary=\"\\\\\\\"\"'}\n        assert expected == writer.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert expected == writer.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_bad_boundary",
      "module": "test_multipart",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1222,
      "end_line_number": 1228,
      "source_code": "def test_bad_boundary(self) -> None:\n        with pytest.raises(ValueError):\n            aiohttp.MultipartWriter(boundary=\"\u0442\u0435\u0441\u0442\")\n        with pytest.raises(ValueError):\n            aiohttp.MultipartWriter(boundary=\"test\\n\")\n        with pytest.raises(ValueError):\n            aiohttp.MultipartWriter(boundary=\"X\" * 71)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_default_headers",
      "module": "test_multipart",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1230,
      "end_line_number": 1232,
      "source_code": "def test_default_headers(self, writer: aiohttp.MultipartWriter) -> None:\n        expected = {CONTENT_TYPE: 'multipart/mixed; boundary=\":\"'}\n        assert expected == writer.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "writer"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert expected == writer.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_iter_parts",
      "module": "test_multipart",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1234,
      "end_line_number": 1238,
      "source_code": "def test_iter_parts(self, writer: aiohttp.MultipartWriter) -> None:\n        writer.append(\"foo\")\n        writer.append(\"bar\")\n        writer.append(\"baz\")\n        assert 3 == len(list(writer))",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "writer"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert 3 == len(list(writer))"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_append",
      "module": "test_multipart",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1240,
      "end_line_number": 1244,
      "source_code": "def test_append(self, writer: aiohttp.MultipartWriter) -> None:\n        assert 0 == len(writer)\n        writer.append(\"hello, world!\")\n        assert 1 == len(writer)\n        assert isinstance(writer._parts[0][0], payload.Payload)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "writer"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert 0 == len(writer)",
        "assert 1 == len(writer)",
        "assert isinstance(writer._parts[0][0], payload.Payload)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_append_with_headers",
      "module": "test_multipart",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1246,
      "end_line_number": 1250,
      "source_code": "def test_append_with_headers(self, writer: aiohttp.MultipartWriter) -> None:\n        writer.append(\"hello, world!\", {\"x-foo\": \"bar\"})\n        assert 1 == len(writer)\n        assert \"x-foo\" in writer._parts[0][0].headers\n        assert writer._parts[0][0].headers[\"x-foo\"] == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "writer"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert 1 == len(writer)",
        "assert 'x-foo' in writer._parts[0][0].headers",
        "assert writer._parts[0][0].headers['x-foo'] == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_append_json",
      "module": "test_multipart",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1252,
      "end_line_number": 1256,
      "source_code": "def test_append_json(self, writer: aiohttp.MultipartWriter) -> None:\n        writer.append_json({\"foo\": \"bar\"})\n        assert 1 == len(writer)\n        part = writer._parts[0][0]\n        assert part.headers[CONTENT_TYPE] == \"application/json\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "writer"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert 1 == len(writer)",
        "assert part.headers[CONTENT_TYPE] == 'application/json'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_append_part",
      "module": "test_multipart",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1258,
      "end_line_number": 1263,
      "source_code": "def test_append_part(self, writer: aiohttp.MultipartWriter) -> None:\n        part = payload.get_payload(\"test\", headers={CONTENT_TYPE: \"text/plain\"})\n        writer.append(part, {CONTENT_TYPE: \"test/passed\"})\n        assert 1 == len(writer)\n        part = writer._parts[0][0]\n        assert part.headers[CONTENT_TYPE] == \"test/passed\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "writer"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert 1 == len(writer)",
        "assert part.headers[CONTENT_TYPE] == 'test/passed'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_append_json_overrides_content_type",
      "module": "test_multipart",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1265,
      "end_line_number": 1271,
      "source_code": "def test_append_json_overrides_content_type(\n        self, writer: aiohttp.MultipartWriter\n    ) -> None:\n        writer.append_json({\"foo\": \"bar\"}, {CONTENT_TYPE: \"test/passed\"})\n        assert 1 == len(writer)\n        part = writer._parts[0][0]\n        assert part.headers[CONTENT_TYPE] == \"test/passed\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "writer"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert 1 == len(writer)",
        "assert part.headers[CONTENT_TYPE] == 'test/passed'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_append_form",
      "module": "test_multipart",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1273,
      "end_line_number": 1277,
      "source_code": "def test_append_form(self, writer: aiohttp.MultipartWriter) -> None:\n        writer.append_form({\"foo\": \"bar\"}, {CONTENT_TYPE: \"test/passed\"})\n        assert 1 == len(writer)\n        part = writer._parts[0][0]\n        assert part.headers[CONTENT_TYPE] == \"test/passed\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "writer"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert 1 == len(writer)",
        "assert part.headers[CONTENT_TYPE] == 'test/passed'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_append_multipart",
      "module": "test_multipart",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1279,
      "end_line_number": 1285,
      "source_code": "def test_append_multipart(self, writer: aiohttp.MultipartWriter) -> None:\n        subwriter = aiohttp.MultipartWriter(boundary=\":\")\n        subwriter.append_json({\"foo\": \"bar\"})\n        writer.append(subwriter, {CONTENT_TYPE: \"test/passed\"})\n        assert 1 == len(writer)\n        part = writer._parts[0][0]\n        assert part.headers[CONTENT_TYPE] == \"test/passed\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "writer"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert 1 == len(writer)",
        "assert part.headers[CONTENT_TYPE] == 'test/passed'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_set_content_disposition_after_append",
      "module": "test_multipart",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1287,
      "end_line_number": 1291,
      "source_code": "def test_set_content_disposition_after_append(self) -> None:\n        writer = aiohttp.MultipartWriter(\"form-data\")\n        part = writer.append(\"some-data\")\n        part.set_content_disposition(\"form-data\", name=\"method\")\n        assert 'name=\"method\"' in part.headers[CONTENT_DISPOSITION]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'name=\"method\"' in part.headers[CONTENT_DISPOSITION]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_automatic_content_disposition",
      "module": "test_multipart",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1293,
      "end_line_number": 1304,
      "source_code": "def test_automatic_content_disposition(self) -> None:\n        writer = aiohttp.MultipartWriter(\"form-data\")\n        writer.append_json(())\n        part = payload.StringPayload(\"foo\")\n        part.set_content_disposition(\"form-data\", name=\"second\")\n        writer.append_payload(part)\n        writer.append(\"foo\")\n\n        disps = tuple(p[0].headers[CONTENT_DISPOSITION] for p in writer._parts)\n        assert 'name=\"section-0\"' in disps[0]\n        assert 'name=\"second\"' in disps[1]\n        assert 'name=\"section-2\"' in disps[2]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'name=\"section-0\"' in disps[0]",
        "assert 'name=\"second\"' in disps[1]",
        "assert 'name=\"section-2\"' in disps[2]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_with",
      "module": "test_multipart",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1306,
      "end_line_number": 1311,
      "source_code": "def test_with(self) -> None:\n        with aiohttp.MultipartWriter(boundary=\":\") as writer:\n            writer.append(\"foo\")\n            writer.append(b\"bar\")\n            writer.append_json({\"baz\": True})\n        assert 3 == len(writer)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert 3 == len(writer)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_append_int_not_allowed",
      "module": "test_multipart",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1313,
      "end_line_number": 1316,
      "source_code": "def test_append_int_not_allowed(self) -> None:\n        with pytest.raises(TypeError):\n            with aiohttp.MultipartWriter(boundary=\":\") as writer:\n                writer.append(1)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_append_float_not_allowed",
      "module": "test_multipart",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1318,
      "end_line_number": 1321,
      "source_code": "def test_append_float_not_allowed(self) -> None:\n        with pytest.raises(TypeError):\n            with aiohttp.MultipartWriter(boundary=\":\") as writer:\n                writer.append(1.1)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_append_none_not_allowed",
      "module": "test_multipart",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart.py",
      "line_number": 1323,
      "end_line_number": 1326,
      "source_code": "def test_append_none_not_allowed(self) -> None:\n        with pytest.raises(TypeError):\n            with aiohttp.MultipartWriter(boundary=\":\") as writer:\n                writer.append(None)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "io",
        "json",
        "pathlib",
        "sys",
        "zlib",
        "types.TracebackType",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp",
        "aiohttp.payload",
        "aiohttp.hdrs.CONTENT_DISPOSITION",
        "aiohttp.hdrs.CONTENT_ENCODING",
        "aiohttp.hdrs.CONTENT_TRANSFER_ENCODING",
        "aiohttp.hdrs.CONTENT_TYPE",
        "aiohttp.helpers.parse_mimetype",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartReader",
        "aiohttp.multipart.MultipartResponseWrapper",
        "aiohttp.streams.StreamReader",
        "typing.Self",
        "typing.TypeVar"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get",
      "module": "test_route_def",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_route_def.py",
      "line_number": 16,
      "end_line_number": 30,
      "source_code": "def test_get(router: UrlDispatcher) -> None:\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    router.add_routes([web.get(\"/\", handler)])\n    assert len(router.routes()) == 2  # GET and HEAD\n\n    route = list(router.routes())[1]\n    assert route.handler is handler\n    assert route.method == \"GET\"\n    assert str(route.url_for()) == \"/\"\n\n    route2 = list(router.routes())[0]\n    assert route2.handler is handler\n    assert route2.method == \"HEAD\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "pathlib",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.web_urldispatcher.UrlDispatcher"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(router.routes()) == 2",
        "assert route.handler is handler",
        "assert route.method == 'GET'",
        "assert str(route.url_for()) == '/'",
        "assert route2.handler is handler",
        "assert route2.method == 'HEAD'",
        "assert False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_head",
      "module": "test_route_def",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_route_def.py",
      "line_number": 33,
      "end_line_number": 43,
      "source_code": "def test_head(router: UrlDispatcher) -> None:\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    router.add_routes([web.head(\"/\", handler)])\n    assert len(router.routes()) == 1\n\n    route = list(router.routes())[0]\n    assert route.handler is handler\n    assert route.method == \"HEAD\"\n    assert str(route.url_for()) == \"/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "pathlib",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.web_urldispatcher.UrlDispatcher"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(router.routes()) == 1",
        "assert route.handler is handler",
        "assert route.method == 'HEAD'",
        "assert str(route.url_for()) == '/'",
        "assert False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_options",
      "module": "test_route_def",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_route_def.py",
      "line_number": 46,
      "end_line_number": 56,
      "source_code": "def test_options(router: UrlDispatcher) -> None:\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    router.add_routes([web.options(\"/\", handler)])\n    assert len(router.routes()) == 1\n\n    route = list(router.routes())[0]\n    assert route.handler is handler\n    assert route.method == \"OPTIONS\"\n    assert str(route.url_for()) == \"/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "pathlib",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.web_urldispatcher.UrlDispatcher"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(router.routes()) == 1",
        "assert route.handler is handler",
        "assert route.method == 'OPTIONS'",
        "assert str(route.url_for()) == '/'",
        "assert False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_post",
      "module": "test_route_def",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_route_def.py",
      "line_number": 59,
      "end_line_number": 68,
      "source_code": "def test_post(router: UrlDispatcher) -> None:\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    router.add_routes([web.post(\"/\", handler)])\n\n    route = list(router.routes())[0]\n    assert route.handler is handler\n    assert route.method == \"POST\"\n    assert str(route.url_for()) == \"/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "pathlib",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.web_urldispatcher.UrlDispatcher"
      ],
      "fixtures": [],
      "assertions": [
        "assert route.handler is handler",
        "assert route.method == 'POST'",
        "assert str(route.url_for()) == '/'",
        "assert False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_put",
      "module": "test_route_def",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_route_def.py",
      "line_number": 71,
      "end_line_number": 81,
      "source_code": "def test_put(router: UrlDispatcher) -> None:\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    router.add_routes([web.put(\"/\", handler)])\n    assert len(router.routes()) == 1\n\n    route = list(router.routes())[0]\n    assert route.handler is handler\n    assert route.method == \"PUT\"\n    assert str(route.url_for()) == \"/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "pathlib",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.web_urldispatcher.UrlDispatcher"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(router.routes()) == 1",
        "assert route.handler is handler",
        "assert route.method == 'PUT'",
        "assert str(route.url_for()) == '/'",
        "assert False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_patch",
      "module": "test_route_def",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_route_def.py",
      "line_number": 84,
      "end_line_number": 94,
      "source_code": "def test_patch(router: UrlDispatcher) -> None:\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    router.add_routes([web.patch(\"/\", handler)])\n    assert len(router.routes()) == 1\n\n    route = list(router.routes())[0]\n    assert route.handler is handler\n    assert route.method == \"PATCH\"\n    assert str(route.url_for()) == \"/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "pathlib",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.web_urldispatcher.UrlDispatcher"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(router.routes()) == 1",
        "assert route.handler is handler",
        "assert route.method == 'PATCH'",
        "assert str(route.url_for()) == '/'",
        "assert False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "web.patch('/', handler)"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_delete",
      "module": "test_route_def",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_route_def.py",
      "line_number": 97,
      "end_line_number": 107,
      "source_code": "def test_delete(router: UrlDispatcher) -> None:\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    router.add_routes([web.delete(\"/\", handler)])\n    assert len(router.routes()) == 1\n\n    route = list(router.routes())[0]\n    assert route.handler is handler\n    assert route.method == \"DELETE\"\n    assert str(route.url_for()) == \"/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "pathlib",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.web_urldispatcher.UrlDispatcher"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(router.routes()) == 1",
        "assert route.handler is handler",
        "assert route.method == 'DELETE'",
        "assert str(route.url_for()) == '/'",
        "assert False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_route",
      "module": "test_route_def",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_route_def.py",
      "line_number": 110,
      "end_line_number": 120,
      "source_code": "def test_route(router: UrlDispatcher) -> None:\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    router.add_routes([web.route(\"OTHER\", \"/\", handler)])\n    assert len(router.routes()) == 1\n\n    route = list(router.routes())[0]\n    assert route.handler is handler\n    assert route.method == \"OTHER\"\n    assert str(route.url_for()) == \"/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "pathlib",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.web_urldispatcher.UrlDispatcher"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(router.routes()) == 1",
        "assert route.handler is handler",
        "assert route.method == 'OTHER'",
        "assert str(route.url_for()) == '/'",
        "assert False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_static",
      "module": "test_route_def",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_route_def.py",
      "line_number": 123,
      "end_line_number": 133,
      "source_code": "def test_static(router: UrlDispatcher) -> None:\n    folder = pathlib.Path(__file__).parent\n    router.add_routes([web.static(\"/prefix\", folder)])\n    assert len(router.resources()) == 1  # 2 routes: for HEAD and GET\n\n    resource = list(router.resources())[0]\n    info = resource.get_info()\n    assert info[\"prefix\"] == \"/prefix\"\n    assert info[\"directory\"] == folder\n    url = resource.url_for(filename=\"aiohttp.png\")\n    assert url == URL(\"/prefix/aiohttp.png\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "pathlib",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.web_urldispatcher.UrlDispatcher"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(router.resources()) == 1",
        "assert info['prefix'] == '/prefix'",
        "assert info['directory'] == folder",
        "assert url == URL('/prefix/aiohttp.png')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_head_deco",
      "module": "test_route_def",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_route_def.py",
      "line_number": 136,
      "end_line_number": 149,
      "source_code": "def test_head_deco(router: UrlDispatcher) -> None:\n    routes = web.RouteTableDef()\n\n    @routes.head(\"/path\")\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    router.add_routes(routes)\n\n    assert len(router.routes()) == 1\n\n    route = list(router.routes())[0]\n    assert route.method == \"HEAD\"\n    assert str(route.url_for()) == \"/path\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "pathlib",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.web_urldispatcher.UrlDispatcher"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(router.routes()) == 1",
        "assert route.method == 'HEAD'",
        "assert str(route.url_for()) == '/path'",
        "assert False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get_deco",
      "module": "test_route_def",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_route_def.py",
      "line_number": 152,
      "end_line_number": 169,
      "source_code": "def test_get_deco(router: UrlDispatcher) -> None:\n    routes = web.RouteTableDef()\n\n    @routes.get(\"/path\")\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    router.add_routes(routes)\n\n    assert len(router.routes()) == 2\n\n    route1 = list(router.routes())[0]\n    assert route1.method == \"HEAD\"\n    assert str(route1.url_for()) == \"/path\"\n\n    route2 = list(router.routes())[1]\n    assert route2.method == \"GET\"\n    assert str(route2.url_for()) == \"/path\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "pathlib",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.web_urldispatcher.UrlDispatcher"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(router.routes()) == 2",
        "assert route1.method == 'HEAD'",
        "assert str(route1.url_for()) == '/path'",
        "assert route2.method == 'GET'",
        "assert str(route2.url_for()) == '/path'",
        "assert False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_post_deco",
      "module": "test_route_def",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_route_def.py",
      "line_number": 172,
      "end_line_number": 185,
      "source_code": "def test_post_deco(router: UrlDispatcher) -> None:\n    routes = web.RouteTableDef()\n\n    @routes.post(\"/path\")\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    router.add_routes(routes)\n\n    assert len(router.routes()) == 1\n\n    route = list(router.routes())[0]\n    assert route.method == \"POST\"\n    assert str(route.url_for()) == \"/path\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "pathlib",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.web_urldispatcher.UrlDispatcher"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(router.routes()) == 1",
        "assert route.method == 'POST'",
        "assert str(route.url_for()) == '/path'",
        "assert False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_put_deco",
      "module": "test_route_def",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_route_def.py",
      "line_number": 188,
      "end_line_number": 201,
      "source_code": "def test_put_deco(router: UrlDispatcher) -> None:\n    routes = web.RouteTableDef()\n\n    @routes.put(\"/path\")\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    router.add_routes(routes)\n\n    assert len(router.routes()) == 1\n\n    route = list(router.routes())[0]\n    assert route.method == \"PUT\"\n    assert str(route.url_for()) == \"/path\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "pathlib",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.web_urldispatcher.UrlDispatcher"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(router.routes()) == 1",
        "assert route.method == 'PUT'",
        "assert str(route.url_for()) == '/path'",
        "assert False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_patch_deco",
      "module": "test_route_def",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_route_def.py",
      "line_number": 204,
      "end_line_number": 217,
      "source_code": "def test_patch_deco(router: UrlDispatcher) -> None:\n    routes = web.RouteTableDef()\n\n    @routes.patch(\"/path\")\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    router.add_routes(routes)\n\n    assert len(router.routes()) == 1\n\n    route = list(router.routes())[0]\n    assert route.method == \"PATCH\"\n    assert str(route.url_for()) == \"/path\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "pathlib",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.web_urldispatcher.UrlDispatcher"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(router.routes()) == 1",
        "assert route.method == 'PATCH'",
        "assert str(route.url_for()) == '/path'",
        "assert False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "routes.patch('/path')"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_delete_deco",
      "module": "test_route_def",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_route_def.py",
      "line_number": 220,
      "end_line_number": 233,
      "source_code": "def test_delete_deco(router: UrlDispatcher) -> None:\n    routes = web.RouteTableDef()\n\n    @routes.delete(\"/path\")\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    router.add_routes(routes)\n\n    assert len(router.routes()) == 1\n\n    route = list(router.routes())[0]\n    assert route.method == \"DELETE\"\n    assert str(route.url_for()) == \"/path\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "pathlib",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.web_urldispatcher.UrlDispatcher"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(router.routes()) == 1",
        "assert route.method == 'DELETE'",
        "assert str(route.url_for()) == '/path'",
        "assert False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_options_deco",
      "module": "test_route_def",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_route_def.py",
      "line_number": 236,
      "end_line_number": 249,
      "source_code": "def test_options_deco(router: UrlDispatcher) -> None:\n    routes = web.RouteTableDef()\n\n    @routes.options(\"/path\")\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    router.add_routes(routes)\n\n    assert len(router.routes()) == 1\n\n    route = list(router.routes())[0]\n    assert route.method == \"OPTIONS\"\n    assert str(route.url_for()) == \"/path\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "pathlib",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.web_urldispatcher.UrlDispatcher"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(router.routes()) == 1",
        "assert route.method == 'OPTIONS'",
        "assert str(route.url_for()) == '/path'",
        "assert False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_route_deco",
      "module": "test_route_def",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_route_def.py",
      "line_number": 252,
      "end_line_number": 265,
      "source_code": "def test_route_deco(router: UrlDispatcher) -> None:\n    routes = web.RouteTableDef()\n\n    @routes.route(\"OTHER\", \"/path\")\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    router.add_routes(routes)\n\n    assert len(router.routes()) == 1\n\n    route = list(router.routes())[0]\n    assert route.method == \"OTHER\"\n    assert str(route.url_for()) == \"/path\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "pathlib",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.web_urldispatcher.UrlDispatcher"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(router.routes()) == 1",
        "assert route.method == 'OTHER'",
        "assert str(route.url_for()) == '/path'",
        "assert False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_routedef_sequence_protocol",
      "module": "test_route_def",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_route_def.py",
      "line_number": 268,
      "end_line_number": 280,
      "source_code": "def test_routedef_sequence_protocol() -> None:\n    routes = web.RouteTableDef()\n\n    @routes.delete(\"/path\")\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    assert len(routes) == 1\n\n    info = routes[0]\n    assert isinstance(info, web.RouteDef)\n    assert info in routes\n    assert list(routes)[0] is info",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pathlib",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.web_urldispatcher.UrlDispatcher"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(routes) == 1",
        "assert isinstance(info, web.RouteDef)",
        "assert info in routes",
        "assert list(routes)[0] is info",
        "assert False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_repr_route_def",
      "module": "test_route_def",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_route_def.py",
      "line_number": 283,
      "end_line_number": 291,
      "source_code": "def test_repr_route_def() -> None:\n    routes = web.RouteTableDef()\n\n    @routes.get(\"/path\")\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    rd = routes[0]\n    assert repr(rd) == \"<RouteDef GET /path -> 'handler'>\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pathlib",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.web_urldispatcher.UrlDispatcher"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(rd) == \"<RouteDef GET /path -> 'handler'>\"",
        "assert False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_repr_route_def_with_extra_info",
      "module": "test_route_def",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_route_def.py",
      "line_number": 294,
      "end_line_number": 302,
      "source_code": "def test_repr_route_def_with_extra_info() -> None:\n    routes = web.RouteTableDef()\n\n    @routes.get(\"/path\", extra=\"info\")\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    rd = routes[0]\n    assert repr(rd) == \"<RouteDef GET /path -> 'handler', extra='info'>\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pathlib",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.web_urldispatcher.UrlDispatcher"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(rd) == \"<RouteDef GET /path -> 'handler', extra='info'>\"",
        "assert False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_repr_static_def",
      "module": "test_route_def",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_route_def.py",
      "line_number": 305,
      "end_line_number": 311,
      "source_code": "def test_repr_static_def() -> None:\n    routes = web.RouteTableDef()\n\n    routes.static(\"/prefix\", \"/path\", name=\"name\")\n\n    rd = routes[0]\n    assert repr(rd) == \"<StaticDef /prefix -> /path, name='name'>\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pathlib",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.web_urldispatcher.UrlDispatcher"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(rd) == \"<StaticDef /prefix -> /path, name='name'>\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_repr_route_table_def",
      "module": "test_route_def",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_route_def.py",
      "line_number": 314,
      "end_line_number": 321,
      "source_code": "def test_repr_route_table_def() -> None:\n    routes = web.RouteTableDef()\n\n    @routes.get(\"/path\")\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    assert repr(routes) == \"<RouteTableDef count=1>\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pathlib",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.web_urldispatcher.UrlDispatcher"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(routes) == '<RouteTableDef count=1>'",
        "assert False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test___all__",
      "module": "test_imports",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_imports.py",
      "line_number": 9,
      "end_line_number": 18,
      "source_code": "def test___all__(pytester: pytest.Pytester) -> None:\n    \"\"\"See https://github.com/aio-libs/aiohttp/issues/6197\"\"\"\n    pytester.makepyfile(\n        test_a=\"\"\"\n            from aiohttp import *\n            assert 'GunicornWebWorker' in globals()\n        \"\"\"\n    )\n    result = pytester.runpytest(\"-vv\")\n    result.assert_outcomes(passed=0, errors=0)",
      "docstring": "See https://github.com/aio-libs/aiohttp/issues/6197",
      "decorators": [],
      "arguments": [
        "pytester"
      ],
      "imports": [
        "os",
        "platform",
        "sys",
        "pathlib.Path",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_web___all__",
      "module": "test_imports",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_imports.py",
      "line_number": 21,
      "end_line_number": 28,
      "source_code": "def test_web___all__(pytester: pytest.Pytester) -> None:\n    pytester.makepyfile(\n        test_b=\"\"\"\n            from aiohttp.web import *\n        \"\"\"\n    )\n    result = pytester.runpytest(\"-vv\")\n    result.assert_outcomes(passed=0, errors=0)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "pytester"
      ],
      "imports": [
        "os",
        "platform",
        "sys",
        "pathlib.Path",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_import_time",
      "module": "test_imports",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_imports.py",
      "line_number": 41,
      "end_line_number": 71,
      "source_code": "def test_import_time(pytester: pytest.Pytester) -> None:\n    \"\"\"Check that importing aiohttp doesn't take too long.\n\n    Obviously, the time may vary on different machines and may need to be adjusted\n    from time to time, but this should provide an early warning if something is\n    added that significantly increases import time.\n    \"\"\"\n    root = Path(__file__).parent.parent\n    old_path = os.environ.get(\"PYTHONPATH\")\n    os.environ[\"PYTHONPATH\"] = os.pathsep.join([str(root)] + sys.path)\n\n    best_time_ms = 1000\n    cmd = \"import timeit; print(int(timeit.timeit('import aiohttp', number=1) * 1000))\"\n    try:\n        for _ in range(3):\n            r = pytester.run(sys.executable, \"-We\", \"-c\", cmd)\n\n            assert not r.stderr.str()\n            runtime_ms = int(r.stdout.str())\n            if runtime_ms < best_time_ms:\n                best_time_ms = runtime_ms\n    finally:\n        if old_path is None:\n            os.environ.pop(\"PYTHONPATH\")\n        else:\n            os.environ[\"PYTHONPATH\"] = old_path\n\n    expected_time = _TARGET_TIMINGS_BY_PYTHON_VERSION.get(\n        f\"{sys.version_info.major}.{sys.version_info.minor}\", 200\n    )\n    assert best_time_ms < expected_time",
      "docstring": "Check that importing aiohttp doesn't take too long.\n\nObviously, the time may vary on different machines and may need to be adjusted\nfrom time to time, but this should provide an early warning if something is\nadded that significantly increases import time.",
      "decorators": [
        "pytest.mark.internal",
        "pytest.mark.skipif(not sys.platform.startswith('linux') or platform.python_implementation() == 'PyPy', reason='Timing is more reliable on Linux')"
      ],
      "arguments": [
        "pytester"
      ],
      "imports": [
        "os",
        "platform",
        "sys",
        "pathlib.Path",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert best_time_ms < expected_time",
        "assert not r.stderr.str()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "pytester.run",
          "body": "def run(conn: Connection) -> None:\n    response = ClientResponse('get', URL('http://def-cl-resp.org'), request_info=mock.Mock(), writer=WriterMock(), continue100=None, timer=TimerNoop(), traces=[], loop=loop, session=session)\n    response._closed = False\n    response._connection = conn"
        }
      ]
    },
    {
      "name": "test_date_parsing",
      "module": "test_cookiejar",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 99,
      "end_line_number": 148,
      "source_code": "def test_date_parsing() -> None:\n    parse_func = CookieJar._parse_date\n    utc = datetime.timezone.utc\n\n    assert parse_func(\"\") is None\n\n    # 70 -> 1970\n    assert (\n        parse_func(\"Tue, 1 Jan 70 00:00:00 GMT\")\n        == datetime.datetime(1970, 1, 1, tzinfo=utc).timestamp()\n    )\n\n    # 10 -> 2010\n    assert (\n        parse_func(\"Tue, 1 Jan 10 00:00:00 GMT\")\n        == datetime.datetime(2010, 1, 1, tzinfo=utc).timestamp()\n    )\n\n    # No day of week string\n    assert (\n        parse_func(\"1 Jan 1970 00:00:00 GMT\")\n        == datetime.datetime(1970, 1, 1, tzinfo=utc).timestamp()\n    )\n\n    # No timezone string\n    assert (\n        parse_func(\"Tue, 1 Jan 1970 00:00:00\")\n        == datetime.datetime(1970, 1, 1, tzinfo=utc).timestamp()\n    )\n\n    # No year\n    assert parse_func(\"Tue, 1 Jan 00:00:00 GMT\") is None\n\n    # No month\n    assert parse_func(\"Tue, 1 1970 00:00:00 GMT\") is None\n\n    # No day of month\n    assert parse_func(\"Tue, Jan 1970 00:00:00 GMT\") is None\n\n    # No time\n    assert parse_func(\"Tue, 1 Jan 1970 GMT\") is None\n\n    # Invalid day of month\n    assert parse_func(\"Tue, 0 Jan 1970 00:00:00 GMT\") is None\n\n    # Invalid year\n    assert parse_func(\"Tue, 1 Jan 1500 00:00:00 GMT\") is None\n\n    # Invalid time\n    assert parse_func(\"Tue, 1 Jan 1970 77:88:99 GMT\") is None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert parse_func('') is None",
        "assert parse_func('Tue, 1 Jan 70 00:00:00 GMT') == datetime.datetime(1970, 1, 1, tzinfo=utc).timestamp()",
        "assert parse_func('Tue, 1 Jan 10 00:00:00 GMT') == datetime.datetime(2010, 1, 1, tzinfo=utc).timestamp()",
        "assert parse_func('1 Jan 1970 00:00:00 GMT') == datetime.datetime(1970, 1, 1, tzinfo=utc).timestamp()",
        "assert parse_func('Tue, 1 Jan 1970 00:00:00') == datetime.datetime(1970, 1, 1, tzinfo=utc).timestamp()",
        "assert parse_func('Tue, 1 Jan 00:00:00 GMT') is None",
        "assert parse_func('Tue, 1 1970 00:00:00 GMT') is None",
        "assert parse_func('Tue, Jan 1970 00:00:00 GMT') is None",
        "assert parse_func('Tue, 1 Jan 1970 GMT') is None",
        "assert parse_func('Tue, 0 Jan 1970 00:00:00 GMT') is None",
        "assert parse_func('Tue, 1 Jan 1500 00:00:00 GMT') is None",
        "assert parse_func('Tue, 1 Jan 1970 77:88:99 GMT') is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_domain_matching",
      "module": "test_cookiejar",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 151,
      "end_line_number": 161,
      "source_code": "def test_domain_matching() -> None:\n    test_func = CookieJar._is_domain_match\n\n    assert test_func(\"test.com\", \"test.com\")\n    assert test_func(\"test.com\", \"sub.test.com\")\n\n    assert not test_func(\"test.com\", \"\")\n    assert not test_func(\"test.com\", \"test.org\")\n    assert not test_func(\"diff-test.com\", \"test.com\")\n    assert not test_func(\"test.com\", \"diff-test.com\")\n    assert not test_func(\"test.com\", \"127.0.0.1\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert test_func('test.com', 'test.com')",
        "assert test_func('test.com', 'sub.test.com')",
        "assert not test_func('test.com', '')",
        "assert not test_func('test.com', 'test.org')",
        "assert not test_func('diff-test.com', 'test.com')",
        "assert not test_func('test.com', 'diff-test.com')",
        "assert not test_func('test.com', '127.0.0.1')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_domain_filter_same_host",
      "module": "test_cookiejar",
      "class_name": "TestCookieJarSafe",
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 524,
      "end_line_number": 537,
      "source_code": "def test_domain_filter_same_host(self) -> None:\n        cookies_sent, cookies_received = self.request_reply_with_same_url(\n            \"http://example.com/\"\n        )\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\"shared-cookie\", \"domain-cookie\", \"dotted-domain-cookie\"},\n        )\n\n        self.assertEqual(\n            set(cookies_received.keys()),\n            {\"unconstrained-cookie\", \"domain-cookie\", \"dotted-domain-cookie\"},\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.request_reply_with_same_url",
          "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)"
        }
      ]
    },
    {
      "name": "test_domain_filter_same_host_and_subdomain",
      "module": "test_cookiejar",
      "class_name": "TestCookieJarSafe",
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 539,
      "end_line_number": 562,
      "source_code": "def test_domain_filter_same_host_and_subdomain(self) -> None:\n        cookies_sent, cookies_received = self.request_reply_with_same_url(\n            \"http://test1.example.com/\"\n        )\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\n                \"shared-cookie\",\n                \"domain-cookie\",\n                \"subdomain1-cookie\",\n                \"dotted-domain-cookie\",\n            },\n        )\n\n        self.assertEqual(\n            set(cookies_received.keys()),\n            {\n                \"unconstrained-cookie\",\n                \"domain-cookie\",\n                \"subdomain1-cookie\",\n                \"dotted-domain-cookie\",\n            },\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.request_reply_with_same_url",
          "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)"
        }
      ]
    },
    {
      "name": "test_domain_filter_same_host_diff_subdomain",
      "module": "test_cookiejar",
      "class_name": "TestCookieJarSafe",
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 564,
      "end_line_number": 577,
      "source_code": "def test_domain_filter_same_host_diff_subdomain(self) -> None:\n        cookies_sent, cookies_received = self.request_reply_with_same_url(\n            \"http://different.example.com/\"\n        )\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\"shared-cookie\", \"domain-cookie\", \"dotted-domain-cookie\"},\n        )\n\n        self.assertEqual(\n            set(cookies_received.keys()),\n            {\"unconstrained-cookie\", \"domain-cookie\", \"dotted-domain-cookie\"},\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.request_reply_with_same_url",
          "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)"
        }
      ]
    },
    {
      "name": "test_domain_filter_diff_host",
      "module": "test_cookiejar",
      "class_name": "TestCookieJarSafe",
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 579,
      "end_line_number": 591,
      "source_code": "def test_domain_filter_diff_host(self) -> None:\n        cookies_sent, cookies_received = self.request_reply_with_same_url(\n            \"http://different.org/\"\n        )\n\n        self.assertEqual(\n            set(cookies_sent.keys()), {\"shared-cookie\", \"different-domain-cookie\"}\n        )\n\n        self.assertEqual(\n            set(cookies_received.keys()),\n            {\"unconstrained-cookie\", \"different-domain-cookie\"},\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.request_reply_with_same_url",
          "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)"
        }
      ]
    },
    {
      "name": "test_domain_filter_host_only",
      "module": "test_cookiejar",
      "class_name": "TestCookieJarSafe",
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 593,
      "end_line_number": 600,
      "source_code": "def test_domain_filter_host_only(self) -> None:\n        self.jar.update_cookies(self.cookies_to_receive, URL(\"http://example.com/\"))\n        sub_cookie = SimpleCookie(\"subdomain=spam; Path=/;\")\n        self.jar.update_cookies(sub_cookie, URL(\"http://foo.example.com/\"))\n\n        cookies_sent = self.jar.filter_cookies(URL(\"http://foo.example.com/\"))\n        self.assertIn(\"subdomain\", set(cookies_sent.keys()))\n        self.assertNotIn(\"unconstrained-cookie\", set(cookies_sent.keys()))",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_secure_filter",
      "module": "test_cookiejar",
      "class_name": "TestCookieJarSafe",
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 602,
      "end_line_number": 609,
      "source_code": "def test_secure_filter(self) -> None:\n        cookies_sent, _ = self.request_reply_with_same_url(\"http://secure.com/\")\n\n        self.assertEqual(set(cookies_sent.keys()), {\"shared-cookie\"})\n\n        cookies_sent, _ = self.request_reply_with_same_url(\"https://secure.com/\")\n\n        self.assertEqual(set(cookies_sent.keys()), {\"shared-cookie\", \"secure-cookie\"})",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.request_reply_with_same_url",
          "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)"
        },
        {
          "name": "self.request_reply_with_same_url",
          "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)"
        }
      ]
    },
    {
      "name": "test_path_filter_root",
      "module": "test_cookiejar",
      "class_name": "TestCookieJarSafe",
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 611,
      "end_line_number": 617,
      "source_code": "def test_path_filter_root(self) -> None:\n        cookies_sent, _ = self.request_reply_with_same_url(\"http://pathtest.com/\")\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\"shared-cookie\", \"no-path-cookie\", \"path1-cookie\"},\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.request_reply_with_same_url",
          "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)"
        }
      ]
    },
    {
      "name": "test_path_filter_folder",
      "module": "test_cookiejar",
      "class_name": "TestCookieJarSafe",
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 619,
      "end_line_number": 625,
      "source_code": "def test_path_filter_folder(self) -> None:\n        cookies_sent, _ = self.request_reply_with_same_url(\"http://pathtest.com/one/\")\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\"shared-cookie\", \"no-path-cookie\", \"path1-cookie\", \"path2-cookie\"},\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.request_reply_with_same_url",
          "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)"
        }
      ]
    },
    {
      "name": "test_path_filter_file",
      "module": "test_cookiejar",
      "class_name": "TestCookieJarSafe",
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 627,
      "end_line_number": 641,
      "source_code": "def test_path_filter_file(self) -> None:\n        cookies_sent, _ = self.request_reply_with_same_url(\n            \"http://pathtest.com/one/two\"\n        )\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\n                \"shared-cookie\",\n                \"no-path-cookie\",\n                \"path1-cookie\",\n                \"path2-cookie\",\n                \"path3-cookie\",\n            },\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.request_reply_with_same_url",
          "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)"
        }
      ]
    },
    {
      "name": "test_path_filter_subfolder",
      "module": "test_cookiejar",
      "class_name": "TestCookieJarSafe",
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 643,
      "end_line_number": 658,
      "source_code": "def test_path_filter_subfolder(self) -> None:\n        cookies_sent, _ = self.request_reply_with_same_url(\n            \"http://pathtest.com/one/two/\"\n        )\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\n                \"shared-cookie\",\n                \"no-path-cookie\",\n                \"path1-cookie\",\n                \"path2-cookie\",\n                \"path3-cookie\",\n                \"path4-cookie\",\n            },\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.request_reply_with_same_url",
          "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)"
        }
      ]
    },
    {
      "name": "test_path_filter_subsubfolder",
      "module": "test_cookiejar",
      "class_name": "TestCookieJarSafe",
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 660,
      "end_line_number": 675,
      "source_code": "def test_path_filter_subsubfolder(self) -> None:\n        cookies_sent, _ = self.request_reply_with_same_url(\n            \"http://pathtest.com/one/two/three/\"\n        )\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\n                \"shared-cookie\",\n                \"no-path-cookie\",\n                \"path1-cookie\",\n                \"path2-cookie\",\n                \"path3-cookie\",\n                \"path4-cookie\",\n            },\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.request_reply_with_same_url",
          "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)"
        }
      ]
    },
    {
      "name": "test_path_filter_different_folder",
      "module": "test_cookiejar",
      "class_name": "TestCookieJarSafe",
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 677,
      "end_line_number": 685,
      "source_code": "def test_path_filter_different_folder(self) -> None:\n        cookies_sent, _ = self.request_reply_with_same_url(\n            \"http://pathtest.com/hundred/\"\n        )\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\"shared-cookie\", \"no-path-cookie\", \"path1-cookie\"},\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.request_reply_with_same_url",
          "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)"
        }
      ]
    },
    {
      "name": "test_path_value",
      "module": "test_cookiejar",
      "class_name": "TestCookieJarSafe",
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 687,
      "end_line_number": 702,
      "source_code": "def test_path_value(self) -> None:\n        _, cookies_received = self.request_reply_with_same_url(\"http://pathtest.com/\")\n\n        self.assertEqual(\n            set(cookies_received.keys()),\n            {\n                \"unconstrained-cookie\",\n                \"no-path-cookie\",\n                \"path-cookie\",\n                \"wrong-path-cookie\",\n            },\n        )\n\n        self.assertEqual(cookies_received[\"no-path-cookie\"][\"path\"], \"/\")\n        self.assertEqual(cookies_received[\"path-cookie\"][\"path\"], \"/somepath\")\n        self.assertEqual(cookies_received[\"wrong-path-cookie\"][\"path\"], \"/\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.request_reply_with_same_url",
          "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)"
        }
      ]
    },
    {
      "name": "test_expires",
      "module": "test_cookiejar",
      "class_name": "TestCookieJarSafe",
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 704,
      "end_line_number": 723,
      "source_code": "def test_expires(self) -> None:\n        ts_before = datetime.datetime(\n            1975, 1, 1, tzinfo=datetime.timezone.utc\n        ).timestamp()\n\n        ts_after = datetime.datetime(\n            2030, 1, 1, tzinfo=datetime.timezone.utc\n        ).timestamp()\n\n        cookies_sent = self.timed_request(\n            \"http://expirestest.com/\", ts_before, ts_before\n        )\n\n        self.assertEqual(set(cookies_sent.keys()), {\"shared-cookie\", \"expires-cookie\"})\n\n        cookies_sent = self.timed_request(\n            \"http://expirestest.com/\", ts_before, ts_after\n        )\n\n        self.assertEqual(set(cookies_sent.keys()), {\"shared-cookie\"})",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.timed_request",
          "body": "def timed_request(self, url: str, update_time: float, send_time: float) -> 'BaseCookie[str]':\n    freeze_update_time: Union[datetime.datetime, datetime.timedelta]\n    freeze_send_time: Union[datetime.datetime, datetime.timedelta]\n    if isinstance(update_time, int):\n        freeze_update_time = datetime.timedelta(seconds=update_time)\n    else:\n        freeze_update_time = datetime.datetime.fromtimestamp(update_time)\n    if isinstance(send_time, int):\n        freeze_send_time = datetime.timedelta(seconds=send_time)\n    else:\n        freeze_send_time = datetime.datetime.fromtimestamp(send_time)\n    with freeze_time(freeze_update_time):\n        self.jar.update_cookies(self.cookies_to_send)\n    with freeze_time(freeze_send_time):\n        cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    return cookies_sent"
        },
        {
          "name": "self.timed_request",
          "body": "def timed_request(self, url: str, update_time: float, send_time: float) -> 'BaseCookie[str]':\n    freeze_update_time: Union[datetime.datetime, datetime.timedelta]\n    freeze_send_time: Union[datetime.datetime, datetime.timedelta]\n    if isinstance(update_time, int):\n        freeze_update_time = datetime.timedelta(seconds=update_time)\n    else:\n        freeze_update_time = datetime.datetime.fromtimestamp(update_time)\n    if isinstance(send_time, int):\n        freeze_send_time = datetime.timedelta(seconds=send_time)\n    else:\n        freeze_send_time = datetime.datetime.fromtimestamp(send_time)\n    with freeze_time(freeze_update_time):\n        self.jar.update_cookies(self.cookies_to_send)\n    with freeze_time(freeze_send_time):\n        cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    return cookies_sent"
        }
      ]
    },
    {
      "name": "test_max_age",
      "module": "test_cookiejar",
      "class_name": "TestCookieJarSafe",
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 725,
      "end_line_number": 732,
      "source_code": "def test_max_age(self) -> None:\n        cookies_sent = self.timed_request(\"http://maxagetest.com/\", 1000, 1000)\n\n        self.assertEqual(set(cookies_sent.keys()), {\"shared-cookie\", \"max-age-cookie\"})\n\n        cookies_sent = self.timed_request(\"http://maxagetest.com/\", 1000, 2000)\n\n        self.assertEqual(set(cookies_sent.keys()), {\"shared-cookie\"})",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.timed_request",
          "body": "def timed_request(self, url: str, update_time: float, send_time: float) -> 'BaseCookie[str]':\n    freeze_update_time: Union[datetime.datetime, datetime.timedelta]\n    freeze_send_time: Union[datetime.datetime, datetime.timedelta]\n    if isinstance(update_time, int):\n        freeze_update_time = datetime.timedelta(seconds=update_time)\n    else:\n        freeze_update_time = datetime.datetime.fromtimestamp(update_time)\n    if isinstance(send_time, int):\n        freeze_send_time = datetime.timedelta(seconds=send_time)\n    else:\n        freeze_send_time = datetime.datetime.fromtimestamp(send_time)\n    with freeze_time(freeze_update_time):\n        self.jar.update_cookies(self.cookies_to_send)\n    with freeze_time(freeze_send_time):\n        cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    return cookies_sent"
        },
        {
          "name": "self.timed_request",
          "body": "def timed_request(self, url: str, update_time: float, send_time: float) -> 'BaseCookie[str]':\n    freeze_update_time: Union[datetime.datetime, datetime.timedelta]\n    freeze_send_time: Union[datetime.datetime, datetime.timedelta]\n    if isinstance(update_time, int):\n        freeze_update_time = datetime.timedelta(seconds=update_time)\n    else:\n        freeze_update_time = datetime.datetime.fromtimestamp(update_time)\n    if isinstance(send_time, int):\n        freeze_send_time = datetime.timedelta(seconds=send_time)\n    else:\n        freeze_send_time = datetime.datetime.fromtimestamp(send_time)\n    with freeze_time(freeze_update_time):\n        self.jar.update_cookies(self.cookies_to_send)\n    with freeze_time(freeze_send_time):\n        cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    return cookies_sent"
        }
      ]
    },
    {
      "name": "test_invalid_values",
      "module": "test_cookiejar",
      "class_name": "TestCookieJarSafe",
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 734,
      "end_line_number": 748,
      "source_code": "def test_invalid_values(self) -> None:\n        cookies_sent, cookies_received = self.request_reply_with_same_url(\n            \"http://invalid-values.com/\"\n        )\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\"shared-cookie\", \"invalid-max-age-cookie\", \"invalid-expires-cookie\"},\n        )\n\n        cookie = cookies_sent[\"invalid-max-age-cookie\"]\n        self.assertEqual(cookie[\"max-age\"], \"\")\n\n        cookie = cookies_sent[\"invalid-expires-cookie\"]\n        self.assertEqual(cookie[\"expires\"], \"\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.request_reply_with_same_url",
          "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)"
        }
      ]
    },
    {
      "name": "test_cookie_not_expired_when_added_after_removal",
      "module": "test_cookiejar",
      "class_name": "TestCookieJarSafe",
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 750,
      "end_line_number": 776,
      "source_code": "def test_cookie_not_expired_when_added_after_removal(self) -> None:\n        # Test case for https://github.com/aio-libs/aiohttp/issues/2084\n        timestamps = [\n            533588.993,\n            533588.993,\n            533588.993,\n            533588.993,\n            533589.093,\n            533589.093,\n        ]\n\n        loop = mock.Mock()\n        loop.time.side_effect = itertools.chain(\n            timestamps, itertools.cycle([timestamps[-1]])\n        )\n\n        async def make_jar() -> CookieJar:\n            return CookieJar(unsafe=True)\n\n        jar = self.loop.run_until_complete(make_jar())\n        # Remove `foo` cookie.\n        jar.update_cookies(SimpleCookie('foo=\"\"; Max-Age=0'))\n        # Set `foo` cookie to `bar`.\n        jar.update_cookies(SimpleCookie('foo=\"bar\"'))\n\n        # Assert that there is a cookie.\n        assert len(jar) == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(jar) == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_path_filter_diff_folder_same_name",
      "module": "test_cookiejar",
      "class_name": "TestCookieJarSafe",
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 778,
      "end_line_number": 798,
      "source_code": "def test_path_filter_diff_folder_same_name(self) -> None:\n        async def make_jar() -> CookieJar:\n            return CookieJar(unsafe=True)\n\n        jar = self.loop.run_until_complete(make_jar())\n\n        jar.update_cookies(\n            SimpleCookie(\"path-cookie=zero; Domain=pathtest.com; Path=/; \")\n        )\n        jar.update_cookies(\n            SimpleCookie(\"path-cookie=one; Domain=pathtest.com; Path=/one; \")\n        )\n        self.assertEqual(len(jar), 2)\n\n        jar_filtered = jar.filter_cookies(URL(\"http://pathtest.com/\"))\n        self.assertEqual(len(jar_filtered), 1)\n        self.assertEqual(jar_filtered[\"path-cookie\"].value, \"zero\")\n\n        jar_filtered = jar.filter_cookies(URL(\"http://pathtest.com/one\"))\n        self.assertEqual(len(jar_filtered), 1)\n        self.assertEqual(jar_filtered[\"path-cookie\"].value, \"one\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_path_filter_diff_folder_same_name_return_best_match_independent_from_put_order",
      "module": "test_cookiejar",
      "class_name": "TestCookieJarSafe",
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 800,
      "end_line_number": 828,
      "source_code": "def test_path_filter_diff_folder_same_name_return_best_match_independent_from_put_order(\n        self,\n    ) -> None:\n        async def make_jar() -> CookieJar:\n            return CookieJar(unsafe=True)\n\n        jar = self.loop.run_until_complete(make_jar())\n        jar.update_cookies(\n            SimpleCookie(\"path-cookie=one; Domain=pathtest.com; Path=/one; \")\n        )\n        jar.update_cookies(\n            SimpleCookie(\"path-cookie=zero; Domain=pathtest.com; Path=/; \")\n        )\n        jar.update_cookies(\n            SimpleCookie(\"path-cookie=two; Domain=pathtest.com; Path=/second; \")\n        )\n        self.assertEqual(len(jar), 3)\n\n        jar_filtered = jar.filter_cookies(URL(\"http://pathtest.com/\"))\n        self.assertEqual(len(jar_filtered), 1)\n        self.assertEqual(jar_filtered[\"path-cookie\"].value, \"zero\")\n\n        jar_filtered = jar.filter_cookies(URL(\"http://pathtest.com/second\"))\n        self.assertEqual(len(jar_filtered), 1)\n        self.assertEqual(jar_filtered[\"path-cookie\"].value, \"two\")\n\n        jar_filtered = jar.filter_cookies(URL(\"http://pathtest.com/one\"))\n        self.assertEqual(len(jar_filtered), 1)\n        self.assertEqual(jar_filtered[\"path-cookie\"].value, \"one\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_pickle_format",
      "module": "test_cookiejar",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 1090,
      "end_line_number": 1118,
      "source_code": "def test_pickle_format(cookies_to_send: SimpleCookie) -> None:\n    \"\"\"Test if cookiejar pickle format breaks.\n\n    If this test fails, it may indicate that saved cookiejars will stop working.\n    If that happens then:\n        1. Avoid releasing the change in a bugfix release.\n        2. Try to include a migration script in the release notes (example below).\n        3. Use dump_cookiejar() at the top of this file to update `pickled`.\n\n    Depending on the changes made, a migration script might look like:\n        import pickle\n        with file_path.open(\"rb\") as f:\n            cookies = pickle.load(f)\n\n        morsels = [(name, m) for c in cookies.values() for name, m in c.items()]\n        cookies.clear()\n        for name, m in morsels:\n            cookies[(m[\"domain\"], m[\"path\"])][name] = m\n\n        with file_path.open(\"wb\") as f:\n            pickle.dump(cookies, f, pickle.HIGHEST_PROTOCOL)\n    \"\"\"\n    pickled = b\"\\x80\\x04\\x95\\xc8\\x0b\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x0bcollections\\x94\\x8c\\x0bdefaultdict\\x94\\x93\\x94\\x8c\\x0chttp.cookies\\x94\\x8c\\x0cSimpleCookie\\x94\\x93\\x94\\x85\\x94R\\x94(\\x8c\\x00\\x94h\\x08\\x86\\x94h\\x05)\\x81\\x94\\x8c\\rshared-cookie\\x94h\\x03\\x8c\\x06Morsel\\x94\\x93\\x94)\\x81\\x94(\\x8c\\x07expires\\x94h\\x08\\x8c\\x04path\\x94\\x8c\\x01/\\x94\\x8c\\x07comment\\x94h\\x08\\x8c\\x06domain\\x94h\\x08\\x8c\\x07max-age\\x94h\\x08\\x8c\\x06secure\\x94h\\x08\\x8c\\x08httponly\\x94h\\x08\\x8c\\x07version\\x94h\\x08\\x8c\\x08samesite\\x94h\\x08u}\\x94(\\x8c\\x03key\\x94h\\x0b\\x8c\\x05value\\x94\\x8c\\x05first\\x94\\x8c\\x0bcoded_value\\x94h\\x1cubs\\x8c\\x0bexample.com\\x94h\\x08\\x86\\x94h\\x05)\\x81\\x94(\\x8c\\rdomain-cookie\\x94h\\r)\\x81\\x94(\\x8c\\x07expires\\x94h\\x08\\x8c\\x04path\\x94h\\x11\\x8c\\x07comment\\x94h\\x08\\x8c\\x06domain\\x94h\\x1e\\x8c\\x07max-age\\x94h\\x08\\x8c\\x06secure\\x94h\\x08\\x8c\\x08httponly\\x94h\\x08\\x8c\\x07version\\x94h\\x08\\x8c\\x08samesite\\x94h\\x08u}\\x94(h\\x1ah!h\\x1b\\x8c\\x06second\\x94h\\x1dh-ub\\x8c\\x14dotted-domain-cookie\\x94h\\r)\\x81\\x94(\\x8c\\x07expires\\x94h\\x08\\x8c\\x04path\\x94h\\x11\\x8c\\x07comment\\x94h\\x08\\x8c\\x06domain\\x94\\x8c\\x0bexample.com\\x94\\x8c\\x07max-age\\x94h\\x08\\x8c\\x06secure\\x94h\\x08\\x8c\\x08httponly\\x94h\\x08\\x8c\\x07version\\x94h\\x08\\x8c\\x08samesite\\x94h\\x08u}\\x94(h\\x1ah.h\\x1b\\x8c\\x05fifth\\x94h\\x1dh;ubu\\x8c\\x11test1.example.com\\x94h\\x08\\x86\\x94h\\x05)\\x81\\x94\\x8c\\x11subdomain1-cookie\\x94h\\r)\\x81\\x94(\\x8c\\x07expires\\x94h\\x08\\x8c\\x04path\\x94h\\x11\\x8c\\x07comment\\x94h\\x08\\x8c\\x06domain\\x94h<\\x8c\\x07max-age\\x94h\\x08\\x8c\\x06secure\\x94h\\x08\\x8c\\x08httponly\\x94h\\x08\\x8c\\x07version\\x94h\\x08\\x8c\\x08samesite\\x94h\\x08u}\\x94(h\\x1ah?h\\x1b\\x8c\\x05third\\x94h\\x1dhKubs\\x8c\\x11test2.example.com\\x94h\\x08\\x86\\x94h\\x05)\\x81\\x94\\x8c\\x11subdomain2-cookie\\x94h\\r)\\x81\\x94(\\x8c\\x07expires\\x94h\\x08\\x8c\\x04path\\x94h\\x11\\x8c\\x07comment\\x94h\\x08\\x8c\\x06domain\\x94hL\\x8c\\x07max-age\\x94h\\x08\\x8c\\x06secure\\x94h\\x08\\x8c\\x08httponly\\x94h\\x08\\x8c\\x07version\\x94h\\x08\\x8c\\x08samesite\\x94h\\x08u}\\x94(h\\x1ahOh\\x1b\\x8c\\x06fourth\\x94h\\x1dh[ubs\\x8c\\rdifferent.org\\x94h\\x08\\x86\\x94h\\x05)\\x81\\x94\\x8c\\x17different-domain-cookie\\x94h\\r)\\x81\\x94(\\x8c\\x07expires\\x94h\\x08\\x8c\\x04path\\x94h\\x11\\x8c\\x07comment\\x94h\\x08\\x8c\\x06domain\\x94h\\\\\\x8c\\x07max-age\\x94h\\x08\\x8c\\x06secure\\x94h\\x08\\x8c\\x08httponly\\x94h\\x08\\x8c\\x07version\\x94h\\x08\\x8c\\x08samesite\\x94h\\x08u}\\x94(h\\x1ah_h\\x1b\\x8c\\x05sixth\\x94h\\x1dhkubs\\x8c\\nsecure.com\\x94h\\x08\\x86\\x94h\\x05)\\x81\\x94\\x8c\\rsecure-cookie\\x94h\\r)\\x81\\x94(\\x8c\\x07expires\\x94h\\x08\\x8c\\x04path\\x94h\\x11\\x8c\\x07comment\\x94h\\x08\\x8c\\x06domain\\x94hl\\x8c\\x07max-age\\x94h\\x08\\x8c\\x06secure\\x94\\x88\\x8c\\x08httponly\\x94h\\x08\\x8c\\x07version\\x94h\\x08\\x8c\\x08samesite\\x94h\\x08u}\\x94(h\\x1ahoh\\x1b\\x8c\\x07seventh\\x94h\\x1dh{ubs\\x8c\\x0cpathtest.com\\x94h\\x08\\x86\\x94h\\x05)\\x81\\x94(\\x8c\\x0eno-path-cookie\\x94h\\r)\\x81\\x94(\\x8c\\x07expires\\x94h\\x08\\x8c\\x04path\\x94h\\x11\\x8c\\x07comment\\x94h\\x08\\x8c\\x06domain\\x94h|\\x8c\\x07max-age\\x94h\\x08\\x8c\\x06secure\\x94h\\x08\\x8c\\x08httponly\\x94h\\x08\\x8c\\x07version\\x94h\\x08\\x8c\\x08samesite\\x94h\\x08u}\\x94(h\\x1ah\\x7fh\\x1b\\x8c\\x06eighth\\x94h\\x1dh\\x8bub\\x8c\\x0cpath1-cookie\\x94h\\r)\\x81\\x94(\\x8c\\x07expires\\x94h\\x08\\x8c\\x04path\\x94h\\x11\\x8c\\x07comment\\x94h\\x08\\x8c\\x06domain\\x94\\x8c\\x0cpathtest.com\\x94\\x8c\\x07max-age\\x94h\\x08\\x8c\\x06secure\\x94h\\x08\\x8c\\x08httponly\\x94h\\x08\\x8c\\x07version\\x94h\\x08\\x8c\\x08samesite\\x94h\\x08u}\\x94(h\\x1ah\\x8ch\\x1b\\x8c\\x05ninth\\x94h\\x1dh\\x99ubu\\x8c\\x0cpathtest.com\\x94\\x8c\\x04/one\\x94\\x86\\x94h\\x05)\\x81\\x94\\x8c\\x0cpath2-cookie\\x94h\\r)\\x81\\x94(\\x8c\\x07expires\\x94h\\x08\\x8c\\x04path\\x94h\\x9b\\x8c\\x07comment\\x94h\\x08\\x8c\\x06domain\\x94h\\x9a\\x8c\\x07max-age\\x94h\\x08\\x8c\\x06secure\\x94h\\x08\\x8c\\x08httponly\\x94h\\x08\\x8c\\x07version\\x94h\\x08\\x8c\\x08samesite\\x94h\\x08u}\\x94(h\\x1ah\\x9eh\\x1b\\x8c\\x05tenth\\x94h\\x1dh\\xaaubs\\x8c\\x0cpathtest.com\\x94\\x8c\\x08/one/two\\x94\\x86\\x94h\\x05)\\x81\\x94(\\x8c\\x0cpath3-cookie\\x94h\\r)\\x81\\x94(\\x8c\\x07expires\\x94h\\x08\\x8c\\x04path\\x94h\\xac\\x8c\\x07comment\\x94h\\x08\\x8c\\x06domain\\x94h\\xab\\x8c\\x07max-age\\x94h\\x08\\x8c\\x06secure\\x94h\\x08\\x8c\\x08httponly\\x94h\\x08\\x8c\\x07version\\x94h\\x08\\x8c\\x08samesite\\x94h\\x08u}\\x94(h\\x1ah\\xafh\\x1b\\x8c\\x08eleventh\\x94h\\x1dh\\xbbub\\x8c\\x0cpath4-cookie\\x94h\\r)\\x81\\x94(\\x8c\\x07expires\\x94h\\x08\\x8c\\x04path\\x94\\x8c\\t/one/two/\\x94\\x8c\\x07comment\\x94h\\x08\\x8c\\x06domain\\x94\\x8c\\x0cpathtest.com\\x94\\x8c\\x07max-age\\x94h\\x08\\x8c\\x06secure\\x94h\\x08\\x8c\\x08httponly\\x94h\\x08\\x8c\\x07version\\x94h\\x08\\x8c\\x08samesite\\x94h\\x08u}\\x94(h\\x1ah\\xbch\\x1b\\x8c\\x07twelfth\\x94h\\x1dh\\xcaubu\\x8c\\x0fexpirestest.com\\x94h\\x08\\x86\\x94h\\x05)\\x81\\x94\\x8c\\x0eexpires-cookie\\x94h\\r)\\x81\\x94(\\x8c\\x07expires\\x94\\x8c\\x1cTue, 1 Jan 2999 12:00:00 GMT\\x94\\x8c\\x04path\\x94h\\x11\\x8c\\x07comment\\x94h\\x08\\x8c\\x06domain\\x94h\\xcb\\x8c\\x07max-age\\x94h\\x08\\x8c\\x06secure\\x94h\\x08\\x8c\\x08httponly\\x94h\\x08\\x8c\\x07version\\x94h\\x08\\x8c\\x08samesite\\x94h\\x08u}\\x94(h\\x1ah\\xceh\\x1b\\x8c\\nthirteenth\\x94h\\x1dh\\xdbubs\\x8c\\x0emaxagetest.com\\x94h\\x08\\x86\\x94h\\x05)\\x81\\x94\\x8c\\x0emax-age-cookie\\x94h\\r)\\x81\\x94(\\x8c\\x07expires\\x94h\\x08\\x8c\\x04path\\x94h\\x11\\x8c\\x07comment\\x94h\\x08\\x8c\\x06domain\\x94h\\xdc\\x8c\\x07max-age\\x94\\x8c\\x0260\\x94\\x8c\\x06secure\\x94h\\x08\\x8c\\x08httponly\\x94h\\x08\\x8c\\x07version\\x94h\\x08\\x8c\\x08samesite\\x94h\\x08u}\\x94(h\\x1ah\\xdfh\\x1b\\x8c\\nfourteenth\\x94h\\x1dh\\xecubs\\x8c\\x12invalid-values.com\\x94h\\x08\\x86\\x94h\\x05)\\x81\\x94(\\x8c\\x16invalid-max-age-cookie\\x94h\\r)\\x81\\x94(\\x8c\\x07expires\\x94h\\x08\\x8c\\x04path\\x94h\\x11\\x8c\\x07comment\\x94h\\x08\\x8c\\x06domain\\x94h\\xed\\x8c\\x07max-age\\x94h\\x08\\x8c\\x06secure\\x94h\\x08\\x8c\\x08httponly\\x94h\\x08\\x8c\\x07version\\x94h\\x08\\x8c\\x08samesite\\x94h\\x08u}\\x94(h\\x1ah\\xf0h\\x1b\\x8c\\tfifteenth\\x94h\\x1dh\\xfcub\\x8c\\x16invalid-expires-cookie\\x94h\\r)\\x81\\x94(\\x8c\\x07expires\\x94h\\x08\\x8c\\x04path\\x94h\\x11\\x8c\\x07comment\\x94h\\x08\\x8c\\x06domain\\x94\\x8c\\x12invalid-values.com\\x94\\x8c\\x07max-age\\x94h\\x08\\x8c\\x06secure\\x94h\\x08\\x8c\\x08httponly\\x94h\\x08\\x8c\\x07version\\x94h\\x08\\x8c\\x08samesite\\x94h\\x08u}\\x94(h\\x1ah\\xfdh\\x1b\\x8c\\tsixteenth\\x94h\\x1dj\\n\\x01\\x00\\x00ubuu.\"\n    cookies = pickle.loads(pickled)\n\n    cj = CookieJar()\n    cj.update_cookies(cookies_to_send)\n\n    assert cookies == cj._cookies",
      "docstring": "Test if cookiejar pickle format breaks.\n\nIf this test fails, it may indicate that saved cookiejars will stop working.\nIf that happens then:\n    1. Avoid releasing the change in a bugfix release.\n    2. Try to include a migration script in the release notes (example below).\n    3. Use dump_cookiejar() at the top of this file to update `pickled`.\n\nDepending on the changes made, a migration script might look like:\n    import pickle\n    with file_path.open(\"rb\") as f:\n        cookies = pickle.load(f)\n\n    morsels = [(name, m) for c in cookies.values() for name, m in c.items()]\n    cookies.clear()\n    for name, m in morsels:\n        cookies[(m[\"domain\"], m[\"path\"])][name] = m\n\n    with file_path.open(\"wb\") as f:\n        pickle.dump(cookies, f, pickle.HIGHEST_PROTOCOL)",
      "decorators": [],
      "arguments": [
        "cookies_to_send"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert cookies == cj._cookies"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_domain_filter_same_host",
      "module": "test_cookiejar",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 524,
      "end_line_number": 537,
      "source_code": "def test_domain_filter_same_host(self) -> None:\n        cookies_sent, cookies_received = self.request_reply_with_same_url(\n            \"http://example.com/\"\n        )\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\"shared-cookie\", \"domain-cookie\", \"dotted-domain-cookie\"},\n        )\n\n        self.assertEqual(\n            set(cookies_received.keys()),\n            {\"unconstrained-cookie\", \"domain-cookie\", \"dotted-domain-cookie\"},\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.request_reply_with_same_url",
          "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)"
        }
      ]
    },
    {
      "name": "test_domain_filter_same_host_and_subdomain",
      "module": "test_cookiejar",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 539,
      "end_line_number": 562,
      "source_code": "def test_domain_filter_same_host_and_subdomain(self) -> None:\n        cookies_sent, cookies_received = self.request_reply_with_same_url(\n            \"http://test1.example.com/\"\n        )\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\n                \"shared-cookie\",\n                \"domain-cookie\",\n                \"subdomain1-cookie\",\n                \"dotted-domain-cookie\",\n            },\n        )\n\n        self.assertEqual(\n            set(cookies_received.keys()),\n            {\n                \"unconstrained-cookie\",\n                \"domain-cookie\",\n                \"subdomain1-cookie\",\n                \"dotted-domain-cookie\",\n            },\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.request_reply_with_same_url",
          "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)"
        }
      ]
    },
    {
      "name": "test_domain_filter_same_host_diff_subdomain",
      "module": "test_cookiejar",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 564,
      "end_line_number": 577,
      "source_code": "def test_domain_filter_same_host_diff_subdomain(self) -> None:\n        cookies_sent, cookies_received = self.request_reply_with_same_url(\n            \"http://different.example.com/\"\n        )\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\"shared-cookie\", \"domain-cookie\", \"dotted-domain-cookie\"},\n        )\n\n        self.assertEqual(\n            set(cookies_received.keys()),\n            {\"unconstrained-cookie\", \"domain-cookie\", \"dotted-domain-cookie\"},\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.request_reply_with_same_url",
          "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)"
        }
      ]
    },
    {
      "name": "test_domain_filter_diff_host",
      "module": "test_cookiejar",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 579,
      "end_line_number": 591,
      "source_code": "def test_domain_filter_diff_host(self) -> None:\n        cookies_sent, cookies_received = self.request_reply_with_same_url(\n            \"http://different.org/\"\n        )\n\n        self.assertEqual(\n            set(cookies_sent.keys()), {\"shared-cookie\", \"different-domain-cookie\"}\n        )\n\n        self.assertEqual(\n            set(cookies_received.keys()),\n            {\"unconstrained-cookie\", \"different-domain-cookie\"},\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.request_reply_with_same_url",
          "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)"
        }
      ]
    },
    {
      "name": "test_domain_filter_host_only",
      "module": "test_cookiejar",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 593,
      "end_line_number": 600,
      "source_code": "def test_domain_filter_host_only(self) -> None:\n        self.jar.update_cookies(self.cookies_to_receive, URL(\"http://example.com/\"))\n        sub_cookie = SimpleCookie(\"subdomain=spam; Path=/;\")\n        self.jar.update_cookies(sub_cookie, URL(\"http://foo.example.com/\"))\n\n        cookies_sent = self.jar.filter_cookies(URL(\"http://foo.example.com/\"))\n        self.assertIn(\"subdomain\", set(cookies_sent.keys()))\n        self.assertNotIn(\"unconstrained-cookie\", set(cookies_sent.keys()))",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_secure_filter",
      "module": "test_cookiejar",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 602,
      "end_line_number": 609,
      "source_code": "def test_secure_filter(self) -> None:\n        cookies_sent, _ = self.request_reply_with_same_url(\"http://secure.com/\")\n\n        self.assertEqual(set(cookies_sent.keys()), {\"shared-cookie\"})\n\n        cookies_sent, _ = self.request_reply_with_same_url(\"https://secure.com/\")\n\n        self.assertEqual(set(cookies_sent.keys()), {\"shared-cookie\", \"secure-cookie\"})",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.request_reply_with_same_url",
          "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)"
        },
        {
          "name": "self.request_reply_with_same_url",
          "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)"
        }
      ]
    },
    {
      "name": "test_path_filter_root",
      "module": "test_cookiejar",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 611,
      "end_line_number": 617,
      "source_code": "def test_path_filter_root(self) -> None:\n        cookies_sent, _ = self.request_reply_with_same_url(\"http://pathtest.com/\")\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\"shared-cookie\", \"no-path-cookie\", \"path1-cookie\"},\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.request_reply_with_same_url",
          "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)"
        }
      ]
    },
    {
      "name": "test_path_filter_folder",
      "module": "test_cookiejar",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 619,
      "end_line_number": 625,
      "source_code": "def test_path_filter_folder(self) -> None:\n        cookies_sent, _ = self.request_reply_with_same_url(\"http://pathtest.com/one/\")\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\"shared-cookie\", \"no-path-cookie\", \"path1-cookie\", \"path2-cookie\"},\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.request_reply_with_same_url",
          "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)"
        }
      ]
    },
    {
      "name": "test_path_filter_file",
      "module": "test_cookiejar",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 627,
      "end_line_number": 641,
      "source_code": "def test_path_filter_file(self) -> None:\n        cookies_sent, _ = self.request_reply_with_same_url(\n            \"http://pathtest.com/one/two\"\n        )\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\n                \"shared-cookie\",\n                \"no-path-cookie\",\n                \"path1-cookie\",\n                \"path2-cookie\",\n                \"path3-cookie\",\n            },\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.request_reply_with_same_url",
          "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)"
        }
      ]
    },
    {
      "name": "test_path_filter_subfolder",
      "module": "test_cookiejar",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 643,
      "end_line_number": 658,
      "source_code": "def test_path_filter_subfolder(self) -> None:\n        cookies_sent, _ = self.request_reply_with_same_url(\n            \"http://pathtest.com/one/two/\"\n        )\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\n                \"shared-cookie\",\n                \"no-path-cookie\",\n                \"path1-cookie\",\n                \"path2-cookie\",\n                \"path3-cookie\",\n                \"path4-cookie\",\n            },\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.request_reply_with_same_url",
          "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)"
        }
      ]
    },
    {
      "name": "test_path_filter_subsubfolder",
      "module": "test_cookiejar",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 660,
      "end_line_number": 675,
      "source_code": "def test_path_filter_subsubfolder(self) -> None:\n        cookies_sent, _ = self.request_reply_with_same_url(\n            \"http://pathtest.com/one/two/three/\"\n        )\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\n                \"shared-cookie\",\n                \"no-path-cookie\",\n                \"path1-cookie\",\n                \"path2-cookie\",\n                \"path3-cookie\",\n                \"path4-cookie\",\n            },\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.request_reply_with_same_url",
          "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)"
        }
      ]
    },
    {
      "name": "test_path_filter_different_folder",
      "module": "test_cookiejar",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 677,
      "end_line_number": 685,
      "source_code": "def test_path_filter_different_folder(self) -> None:\n        cookies_sent, _ = self.request_reply_with_same_url(\n            \"http://pathtest.com/hundred/\"\n        )\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\"shared-cookie\", \"no-path-cookie\", \"path1-cookie\"},\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.request_reply_with_same_url",
          "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)"
        }
      ]
    },
    {
      "name": "test_path_value",
      "module": "test_cookiejar",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 687,
      "end_line_number": 702,
      "source_code": "def test_path_value(self) -> None:\n        _, cookies_received = self.request_reply_with_same_url(\"http://pathtest.com/\")\n\n        self.assertEqual(\n            set(cookies_received.keys()),\n            {\n                \"unconstrained-cookie\",\n                \"no-path-cookie\",\n                \"path-cookie\",\n                \"wrong-path-cookie\",\n            },\n        )\n\n        self.assertEqual(cookies_received[\"no-path-cookie\"][\"path\"], \"/\")\n        self.assertEqual(cookies_received[\"path-cookie\"][\"path\"], \"/somepath\")\n        self.assertEqual(cookies_received[\"wrong-path-cookie\"][\"path\"], \"/\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.request_reply_with_same_url",
          "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)"
        }
      ]
    },
    {
      "name": "test_expires",
      "module": "test_cookiejar",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 704,
      "end_line_number": 723,
      "source_code": "def test_expires(self) -> None:\n        ts_before = datetime.datetime(\n            1975, 1, 1, tzinfo=datetime.timezone.utc\n        ).timestamp()\n\n        ts_after = datetime.datetime(\n            2030, 1, 1, tzinfo=datetime.timezone.utc\n        ).timestamp()\n\n        cookies_sent = self.timed_request(\n            \"http://expirestest.com/\", ts_before, ts_before\n        )\n\n        self.assertEqual(set(cookies_sent.keys()), {\"shared-cookie\", \"expires-cookie\"})\n\n        cookies_sent = self.timed_request(\n            \"http://expirestest.com/\", ts_before, ts_after\n        )\n\n        self.assertEqual(set(cookies_sent.keys()), {\"shared-cookie\"})",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.timed_request",
          "body": "def timed_request(self, url: str, update_time: float, send_time: float) -> 'BaseCookie[str]':\n    freeze_update_time: Union[datetime.datetime, datetime.timedelta]\n    freeze_send_time: Union[datetime.datetime, datetime.timedelta]\n    if isinstance(update_time, int):\n        freeze_update_time = datetime.timedelta(seconds=update_time)\n    else:\n        freeze_update_time = datetime.datetime.fromtimestamp(update_time)\n    if isinstance(send_time, int):\n        freeze_send_time = datetime.timedelta(seconds=send_time)\n    else:\n        freeze_send_time = datetime.datetime.fromtimestamp(send_time)\n    with freeze_time(freeze_update_time):\n        self.jar.update_cookies(self.cookies_to_send)\n    with freeze_time(freeze_send_time):\n        cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    return cookies_sent"
        },
        {
          "name": "self.timed_request",
          "body": "def timed_request(self, url: str, update_time: float, send_time: float) -> 'BaseCookie[str]':\n    freeze_update_time: Union[datetime.datetime, datetime.timedelta]\n    freeze_send_time: Union[datetime.datetime, datetime.timedelta]\n    if isinstance(update_time, int):\n        freeze_update_time = datetime.timedelta(seconds=update_time)\n    else:\n        freeze_update_time = datetime.datetime.fromtimestamp(update_time)\n    if isinstance(send_time, int):\n        freeze_send_time = datetime.timedelta(seconds=send_time)\n    else:\n        freeze_send_time = datetime.datetime.fromtimestamp(send_time)\n    with freeze_time(freeze_update_time):\n        self.jar.update_cookies(self.cookies_to_send)\n    with freeze_time(freeze_send_time):\n        cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    return cookies_sent"
        }
      ]
    },
    {
      "name": "test_max_age",
      "module": "test_cookiejar",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 725,
      "end_line_number": 732,
      "source_code": "def test_max_age(self) -> None:\n        cookies_sent = self.timed_request(\"http://maxagetest.com/\", 1000, 1000)\n\n        self.assertEqual(set(cookies_sent.keys()), {\"shared-cookie\", \"max-age-cookie\"})\n\n        cookies_sent = self.timed_request(\"http://maxagetest.com/\", 1000, 2000)\n\n        self.assertEqual(set(cookies_sent.keys()), {\"shared-cookie\"})",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.timed_request",
          "body": "def timed_request(self, url: str, update_time: float, send_time: float) -> 'BaseCookie[str]':\n    freeze_update_time: Union[datetime.datetime, datetime.timedelta]\n    freeze_send_time: Union[datetime.datetime, datetime.timedelta]\n    if isinstance(update_time, int):\n        freeze_update_time = datetime.timedelta(seconds=update_time)\n    else:\n        freeze_update_time = datetime.datetime.fromtimestamp(update_time)\n    if isinstance(send_time, int):\n        freeze_send_time = datetime.timedelta(seconds=send_time)\n    else:\n        freeze_send_time = datetime.datetime.fromtimestamp(send_time)\n    with freeze_time(freeze_update_time):\n        self.jar.update_cookies(self.cookies_to_send)\n    with freeze_time(freeze_send_time):\n        cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    return cookies_sent"
        },
        {
          "name": "self.timed_request",
          "body": "def timed_request(self, url: str, update_time: float, send_time: float) -> 'BaseCookie[str]':\n    freeze_update_time: Union[datetime.datetime, datetime.timedelta]\n    freeze_send_time: Union[datetime.datetime, datetime.timedelta]\n    if isinstance(update_time, int):\n        freeze_update_time = datetime.timedelta(seconds=update_time)\n    else:\n        freeze_update_time = datetime.datetime.fromtimestamp(update_time)\n    if isinstance(send_time, int):\n        freeze_send_time = datetime.timedelta(seconds=send_time)\n    else:\n        freeze_send_time = datetime.datetime.fromtimestamp(send_time)\n    with freeze_time(freeze_update_time):\n        self.jar.update_cookies(self.cookies_to_send)\n    with freeze_time(freeze_send_time):\n        cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    return cookies_sent"
        }
      ]
    },
    {
      "name": "test_invalid_values",
      "module": "test_cookiejar",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 734,
      "end_line_number": 748,
      "source_code": "def test_invalid_values(self) -> None:\n        cookies_sent, cookies_received = self.request_reply_with_same_url(\n            \"http://invalid-values.com/\"\n        )\n\n        self.assertEqual(\n            set(cookies_sent.keys()),\n            {\"shared-cookie\", \"invalid-max-age-cookie\", \"invalid-expires-cookie\"},\n        )\n\n        cookie = cookies_sent[\"invalid-max-age-cookie\"]\n        self.assertEqual(cookie[\"max-age\"], \"\")\n\n        cookie = cookies_sent[\"invalid-expires-cookie\"]\n        self.assertEqual(cookie[\"expires\"], \"\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.request_reply_with_same_url",
          "body": "def request_reply_with_same_url(self, url: str) -> Tuple['BaseCookie[str]', SimpleCookie]:\n    self.jar.update_cookies(self.cookies_to_send)\n    cookies_sent = self.jar.filter_cookies(URL(url))\n    self.jar.clear()\n    self.jar.update_cookies(self.cookies_to_receive, URL(url))\n    cookies_received = SimpleCookie()\n    for cookie in self.jar:\n        dict.__setitem__(cookies_received, cookie.key, cookie)\n    self.jar.clear()\n    return (cookies_sent, cookies_received)"
        }
      ]
    },
    {
      "name": "test_cookie_not_expired_when_added_after_removal",
      "module": "test_cookiejar",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 750,
      "end_line_number": 776,
      "source_code": "def test_cookie_not_expired_when_added_after_removal(self) -> None:\n        # Test case for https://github.com/aio-libs/aiohttp/issues/2084\n        timestamps = [\n            533588.993,\n            533588.993,\n            533588.993,\n            533588.993,\n            533589.093,\n            533589.093,\n        ]\n\n        loop = mock.Mock()\n        loop.time.side_effect = itertools.chain(\n            timestamps, itertools.cycle([timestamps[-1]])\n        )\n\n        async def make_jar() -> CookieJar:\n            return CookieJar(unsafe=True)\n\n        jar = self.loop.run_until_complete(make_jar())\n        # Remove `foo` cookie.\n        jar.update_cookies(SimpleCookie('foo=\"\"; Max-Age=0'))\n        # Set `foo` cookie to `bar`.\n        jar.update_cookies(SimpleCookie('foo=\"bar\"'))\n\n        # Assert that there is a cookie.\n        assert len(jar) == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(jar) == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_path_filter_diff_folder_same_name",
      "module": "test_cookiejar",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 778,
      "end_line_number": 798,
      "source_code": "def test_path_filter_diff_folder_same_name(self) -> None:\n        async def make_jar() -> CookieJar:\n            return CookieJar(unsafe=True)\n\n        jar = self.loop.run_until_complete(make_jar())\n\n        jar.update_cookies(\n            SimpleCookie(\"path-cookie=zero; Domain=pathtest.com; Path=/; \")\n        )\n        jar.update_cookies(\n            SimpleCookie(\"path-cookie=one; Domain=pathtest.com; Path=/one; \")\n        )\n        self.assertEqual(len(jar), 2)\n\n        jar_filtered = jar.filter_cookies(URL(\"http://pathtest.com/\"))\n        self.assertEqual(len(jar_filtered), 1)\n        self.assertEqual(jar_filtered[\"path-cookie\"].value, \"zero\")\n\n        jar_filtered = jar.filter_cookies(URL(\"http://pathtest.com/one\"))\n        self.assertEqual(len(jar_filtered), 1)\n        self.assertEqual(jar_filtered[\"path-cookie\"].value, \"one\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_path_filter_diff_folder_same_name_return_best_match_independent_from_put_order",
      "module": "test_cookiejar",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_cookiejar.py",
      "line_number": 800,
      "end_line_number": 828,
      "source_code": "def test_path_filter_diff_folder_same_name_return_best_match_independent_from_put_order(\n        self,\n    ) -> None:\n        async def make_jar() -> CookieJar:\n            return CookieJar(unsafe=True)\n\n        jar = self.loop.run_until_complete(make_jar())\n        jar.update_cookies(\n            SimpleCookie(\"path-cookie=one; Domain=pathtest.com; Path=/one; \")\n        )\n        jar.update_cookies(\n            SimpleCookie(\"path-cookie=zero; Domain=pathtest.com; Path=/; \")\n        )\n        jar.update_cookies(\n            SimpleCookie(\"path-cookie=two; Domain=pathtest.com; Path=/second; \")\n        )\n        self.assertEqual(len(jar), 3)\n\n        jar_filtered = jar.filter_cookies(URL(\"http://pathtest.com/\"))\n        self.assertEqual(len(jar_filtered), 1)\n        self.assertEqual(jar_filtered[\"path-cookie\"].value, \"zero\")\n\n        jar_filtered = jar.filter_cookies(URL(\"http://pathtest.com/second\"))\n        self.assertEqual(len(jar_filtered), 1)\n        self.assertEqual(jar_filtered[\"path-cookie\"].value, \"two\")\n\n        jar_filtered = jar.filter_cookies(URL(\"http://pathtest.com/one\"))\n        self.assertEqual(len(jar_filtered), 1)\n        self.assertEqual(jar_filtered[\"path-cookie\"].value, \"one\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "heapq",
        "itertools",
        "pickle",
        "unittest",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "operator.not_",
        "pathlib.Path",
        "typing.List",
        "typing.Set",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "freezegun.freeze_time",
        "yarl.URL",
        "aiohttp.CookieJar",
        "aiohttp.DummyCookieJar",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_no_warnings",
      "module": "test_circular_imports",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_circular_imports.py",
      "line_number": 91,
      "end_line_number": 118,
      "source_code": "def test_no_warnings(import_path: str) -> None:\n    \"\"\"Verify that exploding importables doesn't explode.\n\n    This is seeking for any import errors including ones caused\n    by circular imports.\n    \"\"\"\n    imp_cmd = (\n        # fmt: off\n        sys.executable,\n        \"-W\", \"error\",\n        # The following deprecation warning is triggered by importing\n        # `gunicorn.util`. Hopefully, it'll get fixed in the future. See\n        # https://github.com/benoitc/gunicorn/issues/2840 for detail.\n        \"-W\", \"ignore:module 'sre_constants' is \"\n        \"deprecated:DeprecationWarning:pkg_resources._vendor.pyparsing\",\n        # Also caused by `gunicorn.util` importing `pkg_resources`:\n        \"-W\", \"ignore:Creating a LegacyVersion has been deprecated and \"\n        \"will be removed in the next major release:\"\n        \"DeprecationWarning:\",\n        # Deprecation warning emitted by setuptools v67.5.0+ triggered by importing\n        # `gunicorn.util`.\n        \"-W\", \"ignore:pkg_resources is deprecated as an API:\"\n        \"DeprecationWarning\",\n        \"-c\", f\"import {import_path!s}\",\n        # fmt: on\n    )\n\n    subprocess.check_call(imp_cmd)",
      "docstring": "Verify that exploding importables doesn't explode.\n\nThis is seeking for any import errors including ones caused\nby circular imports.",
      "decorators": [
        "pytest.mark.parametrize('import_path', _mark_aiohttp_worker_for_skipping(_find_all_importables(aiohttp)))"
      ],
      "arguments": [
        "import_path"
      ],
      "imports": [
        "os",
        "pkgutil",
        "socket",
        "subprocess",
        "sys",
        "itertools.chain",
        "pathlib.Path",
        "types.ModuleType",
        "typing.TYPE_CHECKING",
        "typing.Generator",
        "typing.List",
        "typing.Union",
        "pytest",
        "aiohttp",
        "_pytest.mark.structures.ParameterSet"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "_mark_aiohttp_worker_for_skipping",
          "body": "def _mark_aiohttp_worker_for_skipping(importables: List[str]) -> List[Union[str, 'ParameterSet']]:\n    return [pytest.param(importable, marks=pytest.mark.skipif(not hasattr(socket, 'AF_UNIX'), reason=\"It's a UNIX-only module\")) if importable == 'aiohttp.worker' else importable for importable in importables]"
        },
        {
          "name": "_find_all_importables",
          "body": "def _find_all_importables(pkg: ModuleType) -> List[str]:\n    \"\"\"Find all importables in the project.\n\n    Return them in order.\n    \"\"\"\n    return sorted(set(chain.from_iterable((_discover_path_importables(Path(p), pkg.__name__) for p in pkg.__path__))))"
        }
      ]
    },
    {
      "name": "test_trace_config_ctx_default",
      "module": "test_tracing",
      "class_name": "TestTraceConfig",
      "file_path": "__internal__/data/aiohttp/tests/test_tracing.py",
      "line_number": 30,
      "end_line_number": 32,
      "source_code": "def test_trace_config_ctx_default(self) -> None:\n        trace_config = TraceConfig()\n        assert isinstance(trace_config.trace_config_ctx(), SimpleNamespace)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "types.SimpleNamespace",
        "typing.Any",
        "typing.Tuple",
        "unittest.mock.Mock",
        "pytest",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.tracing.Trace",
        "aiohttp.tracing.TraceConfig",
        "aiohttp.tracing.TraceConnectionCreateEndParams",
        "aiohttp.tracing.TraceConnectionCreateStartParams",
        "aiohttp.tracing.TraceConnectionQueuedEndParams",
        "aiohttp.tracing.TraceConnectionQueuedStartParams",
        "aiohttp.tracing.TraceConnectionReuseconnParams",
        "aiohttp.tracing.TraceDnsCacheHitParams",
        "aiohttp.tracing.TraceDnsCacheMissParams",
        "aiohttp.tracing.TraceDnsResolveHostEndParams",
        "aiohttp.tracing.TraceDnsResolveHostStartParams",
        "aiohttp.tracing.TraceRequestChunkSentParams",
        "aiohttp.tracing.TraceRequestEndParams",
        "aiohttp.tracing.TraceRequestExceptionParams",
        "aiohttp.tracing.TraceRequestRedirectParams",
        "aiohttp.tracing.TraceRequestStartParams",
        "aiohttp.tracing.TraceResponseChunkReceivedParams"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(trace_config.trace_config_ctx(), SimpleNamespace)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_trace_config_ctx_factory",
      "module": "test_tracing",
      "class_name": "TestTraceConfig",
      "file_path": "__internal__/data/aiohttp/tests/test_tracing.py",
      "line_number": 34,
      "end_line_number": 36,
      "source_code": "def test_trace_config_ctx_factory(self) -> None:\n        trace_config = TraceConfig(trace_config_ctx_factory=dict)\n        assert isinstance(trace_config.trace_config_ctx(), dict)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "types.SimpleNamespace",
        "typing.Any",
        "typing.Tuple",
        "unittest.mock.Mock",
        "pytest",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.tracing.Trace",
        "aiohttp.tracing.TraceConfig",
        "aiohttp.tracing.TraceConnectionCreateEndParams",
        "aiohttp.tracing.TraceConnectionCreateStartParams",
        "aiohttp.tracing.TraceConnectionQueuedEndParams",
        "aiohttp.tracing.TraceConnectionQueuedStartParams",
        "aiohttp.tracing.TraceConnectionReuseconnParams",
        "aiohttp.tracing.TraceDnsCacheHitParams",
        "aiohttp.tracing.TraceDnsCacheMissParams",
        "aiohttp.tracing.TraceDnsResolveHostEndParams",
        "aiohttp.tracing.TraceDnsResolveHostStartParams",
        "aiohttp.tracing.TraceRequestChunkSentParams",
        "aiohttp.tracing.TraceRequestEndParams",
        "aiohttp.tracing.TraceRequestExceptionParams",
        "aiohttp.tracing.TraceRequestRedirectParams",
        "aiohttp.tracing.TraceRequestStartParams",
        "aiohttp.tracing.TraceResponseChunkReceivedParams"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(trace_config.trace_config_ctx(), dict)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_trace_config_ctx_request_ctx",
      "module": "test_tracing",
      "class_name": "TestTraceConfig",
      "file_path": "__internal__/data/aiohttp/tests/test_tracing.py",
      "line_number": 38,
      "end_line_number": 44,
      "source_code": "def test_trace_config_ctx_request_ctx(self) -> None:\n        trace_request_ctx = Mock()\n        trace_config = TraceConfig()\n        trace_config_ctx = trace_config.trace_config_ctx(\n            trace_request_ctx=trace_request_ctx\n        )\n        assert trace_config_ctx.trace_request_ctx is trace_request_ctx",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "types.SimpleNamespace",
        "typing.Any",
        "typing.Tuple",
        "unittest.mock.Mock",
        "pytest",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.tracing.Trace",
        "aiohttp.tracing.TraceConfig",
        "aiohttp.tracing.TraceConnectionCreateEndParams",
        "aiohttp.tracing.TraceConnectionCreateStartParams",
        "aiohttp.tracing.TraceConnectionQueuedEndParams",
        "aiohttp.tracing.TraceConnectionQueuedStartParams",
        "aiohttp.tracing.TraceConnectionReuseconnParams",
        "aiohttp.tracing.TraceDnsCacheHitParams",
        "aiohttp.tracing.TraceDnsCacheMissParams",
        "aiohttp.tracing.TraceDnsResolveHostEndParams",
        "aiohttp.tracing.TraceDnsResolveHostStartParams",
        "aiohttp.tracing.TraceRequestChunkSentParams",
        "aiohttp.tracing.TraceRequestEndParams",
        "aiohttp.tracing.TraceRequestExceptionParams",
        "aiohttp.tracing.TraceRequestRedirectParams",
        "aiohttp.tracing.TraceRequestStartParams",
        "aiohttp.tracing.TraceResponseChunkReceivedParams"
      ],
      "fixtures": [],
      "assertions": [
        "assert trace_config_ctx.trace_request_ctx is trace_request_ctx"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_freeze",
      "module": "test_tracing",
      "class_name": "TestTraceConfig",
      "file_path": "__internal__/data/aiohttp/tests/test_tracing.py",
      "line_number": 46,
      "end_line_number": 65,
      "source_code": "def test_freeze(self) -> None:\n        trace_config = TraceConfig()\n        trace_config.freeze()\n\n        assert trace_config.on_request_start.frozen\n        assert trace_config.on_request_chunk_sent.frozen\n        assert trace_config.on_response_chunk_received.frozen\n        assert trace_config.on_request_end.frozen\n        assert trace_config.on_request_exception.frozen\n        assert trace_config.on_request_redirect.frozen\n        assert trace_config.on_connection_queued_start.frozen\n        assert trace_config.on_connection_queued_end.frozen\n        assert trace_config.on_connection_create_start.frozen\n        assert trace_config.on_connection_create_end.frozen\n        assert trace_config.on_connection_reuseconn.frozen\n        assert trace_config.on_dns_resolvehost_start.frozen\n        assert trace_config.on_dns_resolvehost_end.frozen\n        assert trace_config.on_dns_cache_hit.frozen\n        assert trace_config.on_dns_cache_miss.frozen\n        assert trace_config.on_request_headers_sent.frozen",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "types.SimpleNamespace",
        "typing.Any",
        "typing.Tuple",
        "unittest.mock.Mock",
        "pytest",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.tracing.Trace",
        "aiohttp.tracing.TraceConfig",
        "aiohttp.tracing.TraceConnectionCreateEndParams",
        "aiohttp.tracing.TraceConnectionCreateStartParams",
        "aiohttp.tracing.TraceConnectionQueuedEndParams",
        "aiohttp.tracing.TraceConnectionQueuedStartParams",
        "aiohttp.tracing.TraceConnectionReuseconnParams",
        "aiohttp.tracing.TraceDnsCacheHitParams",
        "aiohttp.tracing.TraceDnsCacheMissParams",
        "aiohttp.tracing.TraceDnsResolveHostEndParams",
        "aiohttp.tracing.TraceDnsResolveHostStartParams",
        "aiohttp.tracing.TraceRequestChunkSentParams",
        "aiohttp.tracing.TraceRequestEndParams",
        "aiohttp.tracing.TraceRequestExceptionParams",
        "aiohttp.tracing.TraceRequestRedirectParams",
        "aiohttp.tracing.TraceRequestStartParams",
        "aiohttp.tracing.TraceResponseChunkReceivedParams"
      ],
      "fixtures": [],
      "assertions": [
        "assert trace_config.on_request_start.frozen",
        "assert trace_config.on_request_chunk_sent.frozen",
        "assert trace_config.on_response_chunk_received.frozen",
        "assert trace_config.on_request_end.frozen",
        "assert trace_config.on_request_exception.frozen",
        "assert trace_config.on_request_redirect.frozen",
        "assert trace_config.on_connection_queued_start.frozen",
        "assert trace_config.on_connection_queued_end.frozen",
        "assert trace_config.on_connection_create_start.frozen",
        "assert trace_config.on_connection_create_end.frozen",
        "assert trace_config.on_connection_reuseconn.frozen",
        "assert trace_config.on_dns_resolvehost_start.frozen",
        "assert trace_config.on_dns_resolvehost_end.frozen",
        "assert trace_config.on_dns_cache_hit.frozen",
        "assert trace_config.on_dns_cache_miss.frozen",
        "assert trace_config.on_request_headers_sent.frozen"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_trace_config_ctx_default",
      "module": "test_tracing",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_tracing.py",
      "line_number": 30,
      "end_line_number": 32,
      "source_code": "def test_trace_config_ctx_default(self) -> None:\n        trace_config = TraceConfig()\n        assert isinstance(trace_config.trace_config_ctx(), SimpleNamespace)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "types.SimpleNamespace",
        "typing.Any",
        "typing.Tuple",
        "unittest.mock.Mock",
        "pytest",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.tracing.Trace",
        "aiohttp.tracing.TraceConfig",
        "aiohttp.tracing.TraceConnectionCreateEndParams",
        "aiohttp.tracing.TraceConnectionCreateStartParams",
        "aiohttp.tracing.TraceConnectionQueuedEndParams",
        "aiohttp.tracing.TraceConnectionQueuedStartParams",
        "aiohttp.tracing.TraceConnectionReuseconnParams",
        "aiohttp.tracing.TraceDnsCacheHitParams",
        "aiohttp.tracing.TraceDnsCacheMissParams",
        "aiohttp.tracing.TraceDnsResolveHostEndParams",
        "aiohttp.tracing.TraceDnsResolveHostStartParams",
        "aiohttp.tracing.TraceRequestChunkSentParams",
        "aiohttp.tracing.TraceRequestEndParams",
        "aiohttp.tracing.TraceRequestExceptionParams",
        "aiohttp.tracing.TraceRequestRedirectParams",
        "aiohttp.tracing.TraceRequestStartParams",
        "aiohttp.tracing.TraceResponseChunkReceivedParams"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(trace_config.trace_config_ctx(), SimpleNamespace)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_trace_config_ctx_factory",
      "module": "test_tracing",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_tracing.py",
      "line_number": 34,
      "end_line_number": 36,
      "source_code": "def test_trace_config_ctx_factory(self) -> None:\n        trace_config = TraceConfig(trace_config_ctx_factory=dict)\n        assert isinstance(trace_config.trace_config_ctx(), dict)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "types.SimpleNamespace",
        "typing.Any",
        "typing.Tuple",
        "unittest.mock.Mock",
        "pytest",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.tracing.Trace",
        "aiohttp.tracing.TraceConfig",
        "aiohttp.tracing.TraceConnectionCreateEndParams",
        "aiohttp.tracing.TraceConnectionCreateStartParams",
        "aiohttp.tracing.TraceConnectionQueuedEndParams",
        "aiohttp.tracing.TraceConnectionQueuedStartParams",
        "aiohttp.tracing.TraceConnectionReuseconnParams",
        "aiohttp.tracing.TraceDnsCacheHitParams",
        "aiohttp.tracing.TraceDnsCacheMissParams",
        "aiohttp.tracing.TraceDnsResolveHostEndParams",
        "aiohttp.tracing.TraceDnsResolveHostStartParams",
        "aiohttp.tracing.TraceRequestChunkSentParams",
        "aiohttp.tracing.TraceRequestEndParams",
        "aiohttp.tracing.TraceRequestExceptionParams",
        "aiohttp.tracing.TraceRequestRedirectParams",
        "aiohttp.tracing.TraceRequestStartParams",
        "aiohttp.tracing.TraceResponseChunkReceivedParams"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(trace_config.trace_config_ctx(), dict)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_trace_config_ctx_request_ctx",
      "module": "test_tracing",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_tracing.py",
      "line_number": 38,
      "end_line_number": 44,
      "source_code": "def test_trace_config_ctx_request_ctx(self) -> None:\n        trace_request_ctx = Mock()\n        trace_config = TraceConfig()\n        trace_config_ctx = trace_config.trace_config_ctx(\n            trace_request_ctx=trace_request_ctx\n        )\n        assert trace_config_ctx.trace_request_ctx is trace_request_ctx",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "types.SimpleNamespace",
        "typing.Any",
        "typing.Tuple",
        "unittest.mock.Mock",
        "pytest",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.tracing.Trace",
        "aiohttp.tracing.TraceConfig",
        "aiohttp.tracing.TraceConnectionCreateEndParams",
        "aiohttp.tracing.TraceConnectionCreateStartParams",
        "aiohttp.tracing.TraceConnectionQueuedEndParams",
        "aiohttp.tracing.TraceConnectionQueuedStartParams",
        "aiohttp.tracing.TraceConnectionReuseconnParams",
        "aiohttp.tracing.TraceDnsCacheHitParams",
        "aiohttp.tracing.TraceDnsCacheMissParams",
        "aiohttp.tracing.TraceDnsResolveHostEndParams",
        "aiohttp.tracing.TraceDnsResolveHostStartParams",
        "aiohttp.tracing.TraceRequestChunkSentParams",
        "aiohttp.tracing.TraceRequestEndParams",
        "aiohttp.tracing.TraceRequestExceptionParams",
        "aiohttp.tracing.TraceRequestRedirectParams",
        "aiohttp.tracing.TraceRequestStartParams",
        "aiohttp.tracing.TraceResponseChunkReceivedParams"
      ],
      "fixtures": [],
      "assertions": [
        "assert trace_config_ctx.trace_request_ctx is trace_request_ctx"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_freeze",
      "module": "test_tracing",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_tracing.py",
      "line_number": 46,
      "end_line_number": 65,
      "source_code": "def test_freeze(self) -> None:\n        trace_config = TraceConfig()\n        trace_config.freeze()\n\n        assert trace_config.on_request_start.frozen\n        assert trace_config.on_request_chunk_sent.frozen\n        assert trace_config.on_response_chunk_received.frozen\n        assert trace_config.on_request_end.frozen\n        assert trace_config.on_request_exception.frozen\n        assert trace_config.on_request_redirect.frozen\n        assert trace_config.on_connection_queued_start.frozen\n        assert trace_config.on_connection_queued_end.frozen\n        assert trace_config.on_connection_create_start.frozen\n        assert trace_config.on_connection_create_end.frozen\n        assert trace_config.on_connection_reuseconn.frozen\n        assert trace_config.on_dns_resolvehost_start.frozen\n        assert trace_config.on_dns_resolvehost_end.frozen\n        assert trace_config.on_dns_cache_hit.frozen\n        assert trace_config.on_dns_cache_miss.frozen\n        assert trace_config.on_request_headers_sent.frozen",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "types.SimpleNamespace",
        "typing.Any",
        "typing.Tuple",
        "unittest.mock.Mock",
        "pytest",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.tracing.Trace",
        "aiohttp.tracing.TraceConfig",
        "aiohttp.tracing.TraceConnectionCreateEndParams",
        "aiohttp.tracing.TraceConnectionCreateStartParams",
        "aiohttp.tracing.TraceConnectionQueuedEndParams",
        "aiohttp.tracing.TraceConnectionQueuedStartParams",
        "aiohttp.tracing.TraceConnectionReuseconnParams",
        "aiohttp.tracing.TraceDnsCacheHitParams",
        "aiohttp.tracing.TraceDnsCacheMissParams",
        "aiohttp.tracing.TraceDnsResolveHostEndParams",
        "aiohttp.tracing.TraceDnsResolveHostStartParams",
        "aiohttp.tracing.TraceRequestChunkSentParams",
        "aiohttp.tracing.TraceRequestEndParams",
        "aiohttp.tracing.TraceRequestExceptionParams",
        "aiohttp.tracing.TraceRequestRedirectParams",
        "aiohttp.tracing.TraceRequestStartParams",
        "aiohttp.tracing.TraceResponseChunkReceivedParams"
      ],
      "fixtures": [],
      "assertions": [
        "assert trace_config.on_request_start.frozen",
        "assert trace_config.on_request_chunk_sent.frozen",
        "assert trace_config.on_response_chunk_received.frozen",
        "assert trace_config.on_request_end.frozen",
        "assert trace_config.on_request_exception.frozen",
        "assert trace_config.on_request_redirect.frozen",
        "assert trace_config.on_connection_queued_start.frozen",
        "assert trace_config.on_connection_queued_end.frozen",
        "assert trace_config.on_connection_create_start.frozen",
        "assert trace_config.on_connection_create_end.frozen",
        "assert trace_config.on_connection_reuseconn.frozen",
        "assert trace_config.on_dns_resolvehost_start.frozen",
        "assert trace_config.on_dns_resolvehost_end.frozen",
        "assert trace_config.on_dns_cache_hit.frozen",
        "assert trace_config.on_dns_cache_miss.frozen",
        "assert trace_config.on_request_headers_sent.frozen"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_connect",
      "module": "test_proxy",
      "class_name": "TestProxy",
      "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
      "line_number": 43,
      "end_line_number": 98,
      "source_code": "def test_connect(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        req = ClientRequest(\n            \"GET\",\n            URL(\"http://www.python.org\"),\n            proxy=URL(\"http://proxy.example.com\"),\n            loop=self.loop,\n        )\n        self.assertEqual(str(req.proxy), \"http://proxy.example.com\")\n\n        # mock all the things!\n        async def make_conn() -> aiohttp.TCPConnector:\n            return aiohttp.TCPConnector()\n\n        connector = self.loop.run_until_complete(make_conn())\n        r = {\n            \"hostname\": \"hostname\",\n            \"host\": \"127.0.0.1\",\n            \"port\": 80,\n            \"family\": socket.AF_INET,\n            \"proto\": 0,\n            \"flags\": 0,\n        }\n        with mock.patch.object(\n            connector, \"_resolve_host\", autospec=True, return_value=[r]\n        ):\n            proto = mock.Mock(\n                **{\n                    \"transport.get_extra_info.return_value\": False,\n                }\n            )\n            with mock.patch.object(\n                self.loop,\n                \"create_connection\",\n                autospec=True,\n                return_value=(proto.transport, proto),\n            ):\n                conn = self.loop.run_until_complete(\n                    connector.connect(req, [], aiohttp.ClientTimeout())\n                )\n                self.assertEqual(req.url, URL(\"http://www.python.org\"))\n                self.assertIs(conn._protocol, proto)\n                self.assertIs(conn.transport, proto.transport)\n\n                ClientRequestMock.assert_called_with(\n                    \"GET\",\n                    URL(\"http://proxy.example.com\"),\n                    auth=None,\n                    headers={\"Host\": \"www.python.org\"},\n                    loop=self.loop,\n                    ssl=True,\n                )\n\n                conn.close()\n        self.loop.run_until_complete(connector.close())",
      "docstring": null,
      "decorators": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
      ],
      "arguments": [
        "self",
        "start_connection",
        "ClientRequestMock"
      ],
      "imports": [
        "asyncio",
        "gc",
        "socket",
        "ssl",
        "unittest",
        "unittest.mock",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
        "mock.Mock(**{'transport.get_extra_info.return_value': False})"
      ],
      "methods_under_test": [
        {
          "name": "connector.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "conn.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_proxy_headers",
      "module": "test_proxy",
      "class_name": "TestProxy",
      "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
      "line_number": 106,
      "end_line_number": 162,
      "source_code": "def test_proxy_headers(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        req = ClientRequest(\n            \"GET\",\n            URL(\"http://www.python.org\"),\n            proxy=URL(\"http://proxy.example.com\"),\n            proxy_headers={\"Foo\": \"Bar\"},\n            loop=self.loop,\n        )\n        self.assertEqual(str(req.proxy), \"http://proxy.example.com\")\n\n        # mock all the things!\n        async def make_conn() -> aiohttp.TCPConnector:\n            return aiohttp.TCPConnector()\n\n        connector = self.loop.run_until_complete(make_conn())\n        r = {\n            \"hostname\": \"hostname\",\n            \"host\": \"127.0.0.1\",\n            \"port\": 80,\n            \"family\": socket.AF_INET,\n            \"proto\": 0,\n            \"flags\": 0,\n        }\n        with mock.patch.object(\n            connector, \"_resolve_host\", autospec=True, return_value=[r]\n        ):\n            proto = mock.Mock(\n                **{\n                    \"transport.get_extra_info.return_value\": False,\n                }\n            )\n            with mock.patch.object(\n                self.loop,\n                \"create_connection\",\n                autospec=True,\n                return_value=(proto.transport, proto),\n            ):\n                conn = self.loop.run_until_complete(\n                    connector.connect(req, [], aiohttp.ClientTimeout())\n                )\n                self.assertEqual(req.url, URL(\"http://www.python.org\"))\n                self.assertIs(conn._protocol, proto)\n                self.assertIs(conn.transport, proto.transport)\n\n                ClientRequestMock.assert_called_with(\n                    \"GET\",\n                    URL(\"http://proxy.example.com\"),\n                    auth=None,\n                    headers={\"Host\": \"www.python.org\", \"Foo\": \"Bar\"},\n                    loop=self.loop,\n                    ssl=True,\n                )\n\n                conn.close()\n        self.loop.run_until_complete(connector.close())",
      "docstring": null,
      "decorators": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
      ],
      "arguments": [
        "self",
        "start_connection",
        "ClientRequestMock"
      ],
      "imports": [
        "asyncio",
        "gc",
        "socket",
        "ssl",
        "unittest",
        "unittest.mock",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
        "mock.Mock(**{'transport.get_extra_info.return_value': False})"
      ],
      "methods_under_test": [
        {
          "name": "connector.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "conn.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_proxy_auth",
      "module": "test_proxy",
      "class_name": "TestProxy",
      "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
      "line_number": 169,
      "end_line_number": 181,
      "source_code": "def test_proxy_auth(self, start_connection: mock.Mock) -> None:\n        with self.assertRaises(ValueError) as ctx:\n            ClientRequest(\n                \"GET\",\n                URL(\"http://python.org\"),\n                proxy=URL(\"http://proxy.example.com\"),\n                proxy_auth=(\"user\", \"pass\"),  # type: ignore[arg-type]\n                loop=mock.Mock(),\n            )\n        self.assertEqual(\n            ctx.exception.args[0],\n            \"proxy_auth must be None or BasicAuth() tuple\",\n        )",
      "docstring": null,
      "decorators": [
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
      ],
      "arguments": [
        "self",
        "start_connection"
      ],
      "imports": [
        "asyncio",
        "gc",
        "socket",
        "ssl",
        "unittest",
        "unittest.mock",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_proxy_dns_error",
      "module": "test_proxy",
      "class_name": "TestProxy",
      "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
      "line_number": 188,
      "end_line_number": 212,
      "source_code": "def test_proxy_dns_error(self, start_connection: mock.Mock) -> None:\n        async def make_conn() -> aiohttp.TCPConnector:\n            return aiohttp.TCPConnector()\n\n        connector = self.loop.run_until_complete(make_conn())\n        with mock.patch.object(\n            connector,\n            \"_resolve_host\",\n            autospec=True,\n            side_effect=OSError(\"dont take it serious\"),\n        ):\n            req = ClientRequest(\n                \"GET\",\n                URL(\"http://www.python.org\"),\n                proxy=URL(\"http://proxy.example.com\"),\n                loop=self.loop,\n            )\n            expected_headers = dict(req.headers)\n            with self.assertRaises(aiohttp.ClientConnectorError):\n                self.loop.run_until_complete(\n                    connector.connect(req, [], aiohttp.ClientTimeout())\n                )\n            self.assertEqual(req.url.path, \"/\")\n            self.assertEqual(dict(req.headers), expected_headers)\n        self.loop.run_until_complete(connector.close())",
      "docstring": null,
      "decorators": [
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
      ],
      "arguments": [
        "self",
        "start_connection"
      ],
      "imports": [
        "asyncio",
        "gc",
        "socket",
        "ssl",
        "unittest",
        "unittest.mock",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
      ],
      "methods_under_test": [
        {
          "name": "connector.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_proxy_connection_error",
      "module": "test_proxy",
      "class_name": "TestProxy",
      "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
      "line_number": 219,
      "end_line_number": 251,
      "source_code": "def test_proxy_connection_error(self, start_connection: mock.Mock) -> None:\n        async def make_conn() -> aiohttp.TCPConnector:\n            return aiohttp.TCPConnector()\n\n        connector = self.loop.run_until_complete(make_conn())\n        r = {\n            \"hostname\": \"www.python.org\",\n            \"host\": \"127.0.0.1\",\n            \"port\": 80,\n            \"family\": socket.AF_INET,\n            \"proto\": 0,\n            \"flags\": socket.AI_NUMERICHOST,\n        }\n        with mock.patch.object(\n            connector, \"_resolve_host\", autospec=True, return_value=[r]\n        ):\n            with mock.patch.object(\n                connector._loop,\n                \"create_connection\",\n                autospec=True,\n                side_effect=OSError(\"dont take it serious\"),\n            ):\n                req = ClientRequest(\n                    \"GET\",\n                    URL(\"http://www.python.org\"),\n                    proxy=URL(\"http://proxy.example.com\"),\n                    loop=self.loop,\n                )\n                with self.assertRaises(aiohttp.ClientProxyConnectionError):\n                    self.loop.run_until_complete(\n                        connector.connect(req, [], aiohttp.ClientTimeout())\n                    )\n        self.loop.run_until_complete(connector.close())",
      "docstring": null,
      "decorators": [
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
      ],
      "arguments": [
        "self",
        "start_connection"
      ],
      "imports": [
        "asyncio",
        "gc",
        "socket",
        "ssl",
        "unittest",
        "unittest.mock",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
      ],
      "methods_under_test": [
        {
          "name": "connector.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_proxy_server_hostname_default",
      "module": "test_proxy",
      "class_name": "TestProxy",
      "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
      "line_number": 259,
      "end_line_number": 332,
      "source_code": "def test_proxy_server_hostname_default(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(\n                                tls_m.call_args.kwargs[\"server_hostname\"],\n                                \"www.python.org\",\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
      "docstring": null,
      "decorators": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
      ],
      "arguments": [
        "self",
        "start_connection",
        "ClientRequestMock"
      ],
      "imports": [
        "asyncio",
        "gc",
        "socket",
        "ssl",
        "unittest",
        "unittest.mock",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": [
        {
          "name": "connector.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "proxy_resp.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "proxy_req.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "req.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_proxy_server_hostname_override",
      "module": "test_proxy",
      "class_name": "TestProxy",
      "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
      "line_number": 340,
      "end_line_number": 416,
      "source_code": "def test_proxy_server_hostname_override(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\",\n            URL(\"http://proxy.example.com\"),\n            loop=self.loop,\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                server_hostname=\"server-hostname.example.com\",\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(\n                                tls_m.call_args.kwargs[\"server_hostname\"],\n                                \"server-hostname.example.com\",\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
      "docstring": null,
      "decorators": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
      ],
      "arguments": [
        "self",
        "start_connection",
        "ClientRequestMock"
      ],
      "imports": [
        "asyncio",
        "gc",
        "socket",
        "ssl",
        "unittest",
        "unittest.mock",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": [
        {
          "name": "connector.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "proxy_resp.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "proxy_req.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "req.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_https_connect_fingerprint_mismatch",
      "module": "test_proxy",
      "class_name": "TestProxy",
      "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
      "line_number": 424,
      "end_line_number": 516,
      "source_code": "def test_https_connect_fingerprint_mismatch(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        async def make_conn() -> aiohttp.TCPConnector:\n            return aiohttp.TCPConnector(enable_cleanup_closed=cleanup)\n\n        for cleanup in (True, False):\n            with self.subTest(cleanup=cleanup):\n                proxy_req = ClientRequest(\n                    \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n                )\n                ClientRequestMock.return_value = proxy_req\n\n                class TransportMock(asyncio.Transport):\n                    def close(self) -> None:\n                        pass\n\n                proxy_resp = ClientResponse(\n                    \"get\",\n                    URL(\"http://proxy.example.com\"),\n                    request_info=mock.Mock(),\n                    writer=mock.Mock(),\n                    continue100=None,\n                    timer=TimerNoop(),\n                    traces=[],\n                    loop=self.loop,\n                    session=mock.Mock(),\n                )\n                fingerprint_mock = mock.Mock(spec=Fingerprint, auto_spec=True)\n                fingerprint_mock.check.side_effect = aiohttp.ServerFingerprintMismatch(\n                    b\"exp\", b\"got\", \"example.com\", 8080\n                )\n                with mock.patch.object(\n                    proxy_req,\n                    \"send\",\n                    autospec=True,\n                    spec_set=True,\n                    return_value=proxy_resp,\n                ), mock.patch.object(\n                    proxy_resp,\n                    \"start\",\n                    autospec=True,\n                    spec_set=True,\n                    return_value=mock.Mock(status=200),\n                ):\n                    connector = self.loop.run_until_complete(make_conn())\n                    host = [\n                        {\n                            \"hostname\": \"hostname\",\n                            \"host\": \"127.0.0.1\",\n                            \"port\": 80,\n                            \"family\": socket.AF_INET,\n                            \"proto\": 0,\n                            \"flags\": 0,\n                        }\n                    ]\n                    with mock.patch.object(\n                        connector,\n                        \"_resolve_host\",\n                        autospec=True,\n                        spec_set=True,\n                        return_value=host,\n                    ), mock.patch.object(\n                        connector,\n                        \"_get_fingerprint\",\n                        autospec=True,\n                        spec_set=True,\n                        return_value=fingerprint_mock,\n                    ), mock.patch.object(  # Called on connection to http://proxy.example.com\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        spec_set=True,\n                        return_value=(mock.Mock(), mock.Mock()),\n                    ), mock.patch.object(  # Called on connection to https://www.python.org\n                        self.loop,\n                        \"start_tls\",\n                        autospec=True,\n                        spec_set=True,\n                        return_value=TransportMock(),\n                    ):\n                        req = ClientRequest(\n                            \"GET\",\n                            URL(\"https://www.python.org\"),\n                            proxy=URL(\"http://proxy.example.com\"),\n                            loop=self.loop,\n                        )\n                        with self.assertRaises(aiohttp.ServerFingerprintMismatch):\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )",
      "docstring": null,
      "decorators": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
      ],
      "arguments": [
        "self",
        "start_connection",
        "ClientRequestMock"
      ],
      "imports": [
        "asyncio",
        "gc",
        "socket",
        "ssl",
        "unittest",
        "unittest.mock",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
        "mock.Mock(spec=Fingerprint, auto_spec=True)",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock(status=200)",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_https_connect",
      "module": "test_proxy",
      "class_name": "TestProxy",
      "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
      "line_number": 524,
      "end_line_number": 598,
      "source_code": "def test_https_connect(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ):\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
      "docstring": null,
      "decorators": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
      ],
      "arguments": [
        "self",
        "start_connection",
        "ClientRequestMock"
      ],
      "imports": [
        "asyncio",
        "gc",
        "socket",
        "ssl",
        "unittest",
        "unittest.mock",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": [
        {
          "name": "connector.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "proxy_resp.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "proxy_req.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "req.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_https_connect_certificate_error",
      "module": "test_proxy",
      "class_name": "TestProxy",
      "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
      "line_number": 606,
      "end_line_number": 675,
      "source_code": "def test_https_connect_certificate_error(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    # Called on connection to http://proxy.example.com\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        # Called on connection to https://www.python.org\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            side_effect=ssl.CertificateError,\n                        ):\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            with self.assertRaises(\n                                aiohttp.ClientConnectorCertificateError\n                            ):\n                                self.loop.run_until_complete(\n                                    connector._create_connection(\n                                        req, [], aiohttp.ClientTimeout()\n                                    )\n                                )\n                self.loop.run_until_complete(connector.close())",
      "docstring": null,
      "decorators": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
      ],
      "arguments": [
        "self",
        "start_connection",
        "ClientRequestMock"
      ],
      "imports": [
        "asyncio",
        "gc",
        "socket",
        "ssl",
        "unittest",
        "unittest.mock",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": [
        {
          "name": "connector.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_https_connect_ssl_error",
      "module": "test_proxy",
      "class_name": "TestProxy",
      "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
      "line_number": 683,
      "end_line_number": 750,
      "source_code": "def test_https_connect_ssl_error(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    # Called on connection to http://proxy.example.com\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        # Called on connection to https://www.python.org\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            side_effect=ssl.SSLError,\n                        ):\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            with self.assertRaises(aiohttp.ClientConnectorSSLError):\n                                self.loop.run_until_complete(\n                                    connector._create_connection(\n                                        req, [], aiohttp.ClientTimeout()\n                                    )\n                                )\n                self.loop.run_until_complete(connector.close())",
      "docstring": null,
      "decorators": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
      ],
      "arguments": [
        "self",
        "start_connection",
        "ClientRequestMock"
      ],
      "imports": [
        "asyncio",
        "gc",
        "socket",
        "ssl",
        "unittest",
        "unittest.mock",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": [
        {
          "name": "connector.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_https_connect_http_proxy_error",
      "module": "test_proxy",
      "class_name": "TestProxy",
      "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
      "line_number": 758,
      "end_line_number": 826,
      "source_code": "def test_https_connect_http_proxy_error(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 400\n                m.return_value.reason = \"bad request\"\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    tr.get_extra_info.return_value = None\n                    # Called on connection to http://proxy.example.com\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        req = ClientRequest(\n                            \"GET\",\n                            URL(\"https://www.python.org\"),\n                            proxy=URL(\"http://proxy.example.com\"),\n                            loop=self.loop,\n                        )\n                        with self.assertRaisesRegex(\n                            aiohttp.ClientHttpProxyError, \"400, message='bad request'\"\n                        ):\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                        self.loop.run_until_complete(proxy_req.close())\n                        proxy_resp.close()\n                        self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
      "docstring": null,
      "decorators": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
      ],
      "arguments": [
        "self",
        "start_connection",
        "ClientRequestMock"
      ],
      "imports": [
        "asyncio",
        "gc",
        "socket",
        "ssl",
        "unittest",
        "unittest.mock",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": [
        {
          "name": "connector.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "proxy_resp.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "proxy_req.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "req.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_https_connect_resp_start_error",
      "module": "test_proxy",
      "class_name": "TestProxy",
      "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
      "line_number": 834,
      "end_line_number": 896,
      "source_code": "def test_https_connect_resp_start_error(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(\n                proxy_resp, \"start\", autospec=True, side_effect=OSError(\"error message\")\n            ):\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    tr.get_extra_info.return_value = None\n                    # Called on connection to http://proxy.example.com\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        req = ClientRequest(\n                            \"GET\",\n                            URL(\"https://www.python.org\"),\n                            proxy=URL(\"http://proxy.example.com\"),\n                            loop=self.loop,\n                        )\n                        with self.assertRaisesRegex(OSError, \"error message\"):\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n                self.loop.run_until_complete(connector.close())",
      "docstring": null,
      "decorators": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
      ],
      "arguments": [
        "self",
        "start_connection",
        "ClientRequestMock"
      ],
      "imports": [
        "asyncio",
        "gc",
        "socket",
        "ssl",
        "unittest",
        "unittest.mock",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": [
        {
          "name": "connector.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_request_port",
      "module": "test_proxy",
      "class_name": "TestProxy",
      "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
      "line_number": 904,
      "end_line_number": 943,
      "source_code": "def test_request_port(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        async def make_conn() -> aiohttp.TCPConnector:\n            return aiohttp.TCPConnector()\n\n        connector = self.loop.run_until_complete(make_conn())\n        r = {\n            \"hostname\": \"hostname\",\n            \"host\": \"127.0.0.1\",\n            \"port\": 80,\n            \"family\": socket.AF_INET,\n            \"proto\": 0,\n            \"flags\": 0,\n        }\n        with mock.patch.object(\n            connector, \"_resolve_host\", autospec=True, return_value=[r]\n        ):\n            tr, proto = mock.Mock(), mock.Mock()\n            tr.get_extra_info.return_value = None\n            # Called on connection to http://proxy.example.com\n            with mock.patch.object(\n                self.loop, \"create_connection\", autospec=True, return_value=(tr, proto)\n            ):\n                req = ClientRequest(\n                    \"GET\",\n                    URL(\"http://localhost:1234/path\"),\n                    proxy=URL(\"http://proxy.example.com\"),\n                    loop=self.loop,\n                )\n                self.loop.run_until_complete(\n                    connector._create_connection(req, [], aiohttp.ClientTimeout())\n                )\n                self.assertEqual(req.url, URL(\"http://localhost:1234/path\"))\n        self.loop.run_until_complete(connector.close())",
      "docstring": null,
      "decorators": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
      ],
      "arguments": [
        "self",
        "start_connection",
        "ClientRequestMock"
      ],
      "imports": [
        "asyncio",
        "gc",
        "socket",
        "ssl",
        "unittest",
        "unittest.mock",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": [
        {
          "name": "connector.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_proxy_auth_property",
      "module": "test_proxy",
      "class_name": "TestProxy",
      "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
      "line_number": 945,
      "end_line_number": 953,
      "source_code": "def test_proxy_auth_property(self) -> None:\n        req = aiohttp.ClientRequest(\n            \"GET\",\n            URL(\"http://localhost:1234/path\"),\n            proxy=URL(\"http://proxy.example.com\"),\n            proxy_auth=aiohttp.helpers.BasicAuth(\"user\", \"pass\"),\n            loop=self.loop,\n        )\n        self.assertEqual((\"user\", \"pass\", \"latin1\"), req.proxy_auth)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "gc",
        "socket",
        "ssl",
        "unittest",
        "unittest.mock",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_proxy_auth_property_default",
      "module": "test_proxy",
      "class_name": "TestProxy",
      "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
      "line_number": 955,
      "end_line_number": 962,
      "source_code": "def test_proxy_auth_property_default(self) -> None:\n        req = aiohttp.ClientRequest(\n            \"GET\",\n            URL(\"http://localhost:1234/path\"),\n            proxy=URL(\"http://proxy.example.com\"),\n            loop=self.loop,\n        )\n        self.assertIsNone(req.proxy_auth)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "gc",
        "socket",
        "ssl",
        "unittest",
        "unittest.mock",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_https_connect_pass_ssl_context",
      "module": "test_proxy",
      "class_name": "TestProxy",
      "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
      "line_number": 970,
      "end_line_number": 1052,
      "source_code": "def test_https_connect_pass_ssl_context(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            tls_m.assert_called_with(\n                                mock.ANY,\n                                mock.ANY,\n                                _SSL_CONTEXT_VERIFIED,\n                                server_hostname=\"www.python.org\",\n                                ssl_handshake_timeout=mock.ANY,\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
      "docstring": null,
      "decorators": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
      ],
      "arguments": [
        "self",
        "start_connection",
        "ClientRequestMock"
      ],
      "imports": [
        "asyncio",
        "gc",
        "socket",
        "ssl",
        "unittest",
        "unittest.mock",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": [
        {
          "name": "connector.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "proxy_resp.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "proxy_req.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "req.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_https_auth",
      "module": "test_proxy",
      "class_name": "TestProxy",
      "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
      "line_number": 1060,
      "end_line_number": 1146,
      "source_code": "def test_https_auth(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\",\n            URL(\"http://proxy.example.com\"),\n            auth=aiohttp.helpers.BasicAuth(\"user\", \"pass\"),\n            loop=self.loop,\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ) as host_m:\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ):\n                            self.assertIn(\"AUTHORIZATION\", proxy_req.headers)\n                            self.assertNotIn(\"PROXY-AUTHORIZATION\", proxy_req.headers)\n\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.assertNotIn(\"AUTHORIZATION\", req.headers)\n                            self.assertNotIn(\"PROXY-AUTHORIZATION\", req.headers)\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertNotIn(\"AUTHORIZATION\", req.headers)\n                            self.assertNotIn(\"PROXY-AUTHORIZATION\", req.headers)\n                            self.assertNotIn(\"AUTHORIZATION\", proxy_req.headers)\n                            self.assertIn(\"PROXY-AUTHORIZATION\", proxy_req.headers)\n\n                            host_m.assert_called_with(\n                                \"proxy.example.com\", 80, traces=mock.ANY\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
      "docstring": null,
      "decorators": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
      ],
      "arguments": [
        "self",
        "start_connection",
        "ClientRequestMock"
      ],
      "imports": [
        "asyncio",
        "gc",
        "socket",
        "ssl",
        "unittest",
        "unittest.mock",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": [
        {
          "name": "connector.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "proxy_resp.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "proxy_req.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "req.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_connect",
      "module": "test_proxy",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
      "line_number": 43,
      "end_line_number": 98,
      "source_code": "def test_connect(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        req = ClientRequest(\n            \"GET\",\n            URL(\"http://www.python.org\"),\n            proxy=URL(\"http://proxy.example.com\"),\n            loop=self.loop,\n        )\n        self.assertEqual(str(req.proxy), \"http://proxy.example.com\")\n\n        # mock all the things!\n        async def make_conn() -> aiohttp.TCPConnector:\n            return aiohttp.TCPConnector()\n\n        connector = self.loop.run_until_complete(make_conn())\n        r = {\n            \"hostname\": \"hostname\",\n            \"host\": \"127.0.0.1\",\n            \"port\": 80,\n            \"family\": socket.AF_INET,\n            \"proto\": 0,\n            \"flags\": 0,\n        }\n        with mock.patch.object(\n            connector, \"_resolve_host\", autospec=True, return_value=[r]\n        ):\n            proto = mock.Mock(\n                **{\n                    \"transport.get_extra_info.return_value\": False,\n                }\n            )\n            with mock.patch.object(\n                self.loop,\n                \"create_connection\",\n                autospec=True,\n                return_value=(proto.transport, proto),\n            ):\n                conn = self.loop.run_until_complete(\n                    connector.connect(req, [], aiohttp.ClientTimeout())\n                )\n                self.assertEqual(req.url, URL(\"http://www.python.org\"))\n                self.assertIs(conn._protocol, proto)\n                self.assertIs(conn.transport, proto.transport)\n\n                ClientRequestMock.assert_called_with(\n                    \"GET\",\n                    URL(\"http://proxy.example.com\"),\n                    auth=None,\n                    headers={\"Host\": \"www.python.org\"},\n                    loop=self.loop,\n                    ssl=True,\n                )\n\n                conn.close()\n        self.loop.run_until_complete(connector.close())",
      "docstring": null,
      "decorators": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
      ],
      "arguments": [
        "self",
        "start_connection",
        "ClientRequestMock"
      ],
      "imports": [
        "asyncio",
        "gc",
        "socket",
        "ssl",
        "unittest",
        "unittest.mock",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
        "mock.Mock(**{'transport.get_extra_info.return_value': False})"
      ],
      "methods_under_test": [
        {
          "name": "connector.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "conn.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_proxy_headers",
      "module": "test_proxy",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
      "line_number": 106,
      "end_line_number": 162,
      "source_code": "def test_proxy_headers(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        req = ClientRequest(\n            \"GET\",\n            URL(\"http://www.python.org\"),\n            proxy=URL(\"http://proxy.example.com\"),\n            proxy_headers={\"Foo\": \"Bar\"},\n            loop=self.loop,\n        )\n        self.assertEqual(str(req.proxy), \"http://proxy.example.com\")\n\n        # mock all the things!\n        async def make_conn() -> aiohttp.TCPConnector:\n            return aiohttp.TCPConnector()\n\n        connector = self.loop.run_until_complete(make_conn())\n        r = {\n            \"hostname\": \"hostname\",\n            \"host\": \"127.0.0.1\",\n            \"port\": 80,\n            \"family\": socket.AF_INET,\n            \"proto\": 0,\n            \"flags\": 0,\n        }\n        with mock.patch.object(\n            connector, \"_resolve_host\", autospec=True, return_value=[r]\n        ):\n            proto = mock.Mock(\n                **{\n                    \"transport.get_extra_info.return_value\": False,\n                }\n            )\n            with mock.patch.object(\n                self.loop,\n                \"create_connection\",\n                autospec=True,\n                return_value=(proto.transport, proto),\n            ):\n                conn = self.loop.run_until_complete(\n                    connector.connect(req, [], aiohttp.ClientTimeout())\n                )\n                self.assertEqual(req.url, URL(\"http://www.python.org\"))\n                self.assertIs(conn._protocol, proto)\n                self.assertIs(conn.transport, proto.transport)\n\n                ClientRequestMock.assert_called_with(\n                    \"GET\",\n                    URL(\"http://proxy.example.com\"),\n                    auth=None,\n                    headers={\"Host\": \"www.python.org\", \"Foo\": \"Bar\"},\n                    loop=self.loop,\n                    ssl=True,\n                )\n\n                conn.close()\n        self.loop.run_until_complete(connector.close())",
      "docstring": null,
      "decorators": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
      ],
      "arguments": [
        "self",
        "start_connection",
        "ClientRequestMock"
      ],
      "imports": [
        "asyncio",
        "gc",
        "socket",
        "ssl",
        "unittest",
        "unittest.mock",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
        "mock.Mock(**{'transport.get_extra_info.return_value': False})"
      ],
      "methods_under_test": [
        {
          "name": "connector.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "conn.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_proxy_auth",
      "module": "test_proxy",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
      "line_number": 169,
      "end_line_number": 181,
      "source_code": "def test_proxy_auth(self, start_connection: mock.Mock) -> None:\n        with self.assertRaises(ValueError) as ctx:\n            ClientRequest(\n                \"GET\",\n                URL(\"http://python.org\"),\n                proxy=URL(\"http://proxy.example.com\"),\n                proxy_auth=(\"user\", \"pass\"),  # type: ignore[arg-type]\n                loop=mock.Mock(),\n            )\n        self.assertEqual(\n            ctx.exception.args[0],\n            \"proxy_auth must be None or BasicAuth() tuple\",\n        )",
      "docstring": null,
      "decorators": [
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
      ],
      "arguments": [
        "self",
        "start_connection"
      ],
      "imports": [
        "asyncio",
        "gc",
        "socket",
        "ssl",
        "unittest",
        "unittest.mock",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_proxy_dns_error",
      "module": "test_proxy",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
      "line_number": 188,
      "end_line_number": 212,
      "source_code": "def test_proxy_dns_error(self, start_connection: mock.Mock) -> None:\n        async def make_conn() -> aiohttp.TCPConnector:\n            return aiohttp.TCPConnector()\n\n        connector = self.loop.run_until_complete(make_conn())\n        with mock.patch.object(\n            connector,\n            \"_resolve_host\",\n            autospec=True,\n            side_effect=OSError(\"dont take it serious\"),\n        ):\n            req = ClientRequest(\n                \"GET\",\n                URL(\"http://www.python.org\"),\n                proxy=URL(\"http://proxy.example.com\"),\n                loop=self.loop,\n            )\n            expected_headers = dict(req.headers)\n            with self.assertRaises(aiohttp.ClientConnectorError):\n                self.loop.run_until_complete(\n                    connector.connect(req, [], aiohttp.ClientTimeout())\n                )\n            self.assertEqual(req.url.path, \"/\")\n            self.assertEqual(dict(req.headers), expected_headers)\n        self.loop.run_until_complete(connector.close())",
      "docstring": null,
      "decorators": [
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
      ],
      "arguments": [
        "self",
        "start_connection"
      ],
      "imports": [
        "asyncio",
        "gc",
        "socket",
        "ssl",
        "unittest",
        "unittest.mock",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
      ],
      "methods_under_test": [
        {
          "name": "connector.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_proxy_connection_error",
      "module": "test_proxy",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
      "line_number": 219,
      "end_line_number": 251,
      "source_code": "def test_proxy_connection_error(self, start_connection: mock.Mock) -> None:\n        async def make_conn() -> aiohttp.TCPConnector:\n            return aiohttp.TCPConnector()\n\n        connector = self.loop.run_until_complete(make_conn())\n        r = {\n            \"hostname\": \"www.python.org\",\n            \"host\": \"127.0.0.1\",\n            \"port\": 80,\n            \"family\": socket.AF_INET,\n            \"proto\": 0,\n            \"flags\": socket.AI_NUMERICHOST,\n        }\n        with mock.patch.object(\n            connector, \"_resolve_host\", autospec=True, return_value=[r]\n        ):\n            with mock.patch.object(\n                connector._loop,\n                \"create_connection\",\n                autospec=True,\n                side_effect=OSError(\"dont take it serious\"),\n            ):\n                req = ClientRequest(\n                    \"GET\",\n                    URL(\"http://www.python.org\"),\n                    proxy=URL(\"http://proxy.example.com\"),\n                    loop=self.loop,\n                )\n                with self.assertRaises(aiohttp.ClientProxyConnectionError):\n                    self.loop.run_until_complete(\n                        connector.connect(req, [], aiohttp.ClientTimeout())\n                    )\n        self.loop.run_until_complete(connector.close())",
      "docstring": null,
      "decorators": [
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
      ],
      "arguments": [
        "self",
        "start_connection"
      ],
      "imports": [
        "asyncio",
        "gc",
        "socket",
        "ssl",
        "unittest",
        "unittest.mock",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
      ],
      "methods_under_test": [
        {
          "name": "connector.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_proxy_server_hostname_default",
      "module": "test_proxy",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
      "line_number": 259,
      "end_line_number": 332,
      "source_code": "def test_proxy_server_hostname_default(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(\n                                tls_m.call_args.kwargs[\"server_hostname\"],\n                                \"www.python.org\",\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
      "docstring": null,
      "decorators": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
      ],
      "arguments": [
        "self",
        "start_connection",
        "ClientRequestMock"
      ],
      "imports": [
        "asyncio",
        "gc",
        "socket",
        "ssl",
        "unittest",
        "unittest.mock",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": [
        {
          "name": "connector.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "proxy_resp.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "proxy_req.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "req.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_proxy_server_hostname_override",
      "module": "test_proxy",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
      "line_number": 340,
      "end_line_number": 416,
      "source_code": "def test_proxy_server_hostname_override(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\",\n            URL(\"http://proxy.example.com\"),\n            loop=self.loop,\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                server_hostname=\"server-hostname.example.com\",\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(\n                                tls_m.call_args.kwargs[\"server_hostname\"],\n                                \"server-hostname.example.com\",\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
      "docstring": null,
      "decorators": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
      ],
      "arguments": [
        "self",
        "start_connection",
        "ClientRequestMock"
      ],
      "imports": [
        "asyncio",
        "gc",
        "socket",
        "ssl",
        "unittest",
        "unittest.mock",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": [
        {
          "name": "connector.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "proxy_resp.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "proxy_req.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "req.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_https_connect_fingerprint_mismatch",
      "module": "test_proxy",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
      "line_number": 424,
      "end_line_number": 516,
      "source_code": "def test_https_connect_fingerprint_mismatch(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        async def make_conn() -> aiohttp.TCPConnector:\n            return aiohttp.TCPConnector(enable_cleanup_closed=cleanup)\n\n        for cleanup in (True, False):\n            with self.subTest(cleanup=cleanup):\n                proxy_req = ClientRequest(\n                    \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n                )\n                ClientRequestMock.return_value = proxy_req\n\n                class TransportMock(asyncio.Transport):\n                    def close(self) -> None:\n                        pass\n\n                proxy_resp = ClientResponse(\n                    \"get\",\n                    URL(\"http://proxy.example.com\"),\n                    request_info=mock.Mock(),\n                    writer=mock.Mock(),\n                    continue100=None,\n                    timer=TimerNoop(),\n                    traces=[],\n                    loop=self.loop,\n                    session=mock.Mock(),\n                )\n                fingerprint_mock = mock.Mock(spec=Fingerprint, auto_spec=True)\n                fingerprint_mock.check.side_effect = aiohttp.ServerFingerprintMismatch(\n                    b\"exp\", b\"got\", \"example.com\", 8080\n                )\n                with mock.patch.object(\n                    proxy_req,\n                    \"send\",\n                    autospec=True,\n                    spec_set=True,\n                    return_value=proxy_resp,\n                ), mock.patch.object(\n                    proxy_resp,\n                    \"start\",\n                    autospec=True,\n                    spec_set=True,\n                    return_value=mock.Mock(status=200),\n                ):\n                    connector = self.loop.run_until_complete(make_conn())\n                    host = [\n                        {\n                            \"hostname\": \"hostname\",\n                            \"host\": \"127.0.0.1\",\n                            \"port\": 80,\n                            \"family\": socket.AF_INET,\n                            \"proto\": 0,\n                            \"flags\": 0,\n                        }\n                    ]\n                    with mock.patch.object(\n                        connector,\n                        \"_resolve_host\",\n                        autospec=True,\n                        spec_set=True,\n                        return_value=host,\n                    ), mock.patch.object(\n                        connector,\n                        \"_get_fingerprint\",\n                        autospec=True,\n                        spec_set=True,\n                        return_value=fingerprint_mock,\n                    ), mock.patch.object(  # Called on connection to http://proxy.example.com\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        spec_set=True,\n                        return_value=(mock.Mock(), mock.Mock()),\n                    ), mock.patch.object(  # Called on connection to https://www.python.org\n                        self.loop,\n                        \"start_tls\",\n                        autospec=True,\n                        spec_set=True,\n                        return_value=TransportMock(),\n                    ):\n                        req = ClientRequest(\n                            \"GET\",\n                            URL(\"https://www.python.org\"),\n                            proxy=URL(\"http://proxy.example.com\"),\n                            loop=self.loop,\n                        )\n                        with self.assertRaises(aiohttp.ServerFingerprintMismatch):\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )",
      "docstring": null,
      "decorators": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
      ],
      "arguments": [
        "self",
        "start_connection",
        "ClientRequestMock"
      ],
      "imports": [
        "asyncio",
        "gc",
        "socket",
        "ssl",
        "unittest",
        "unittest.mock",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
        "mock.Mock(spec=Fingerprint, auto_spec=True)",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock(status=200)",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_https_connect",
      "module": "test_proxy",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
      "line_number": 524,
      "end_line_number": 598,
      "source_code": "def test_https_connect(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ):\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
      "docstring": null,
      "decorators": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
      ],
      "arguments": [
        "self",
        "start_connection",
        "ClientRequestMock"
      ],
      "imports": [
        "asyncio",
        "gc",
        "socket",
        "ssl",
        "unittest",
        "unittest.mock",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": [
        {
          "name": "connector.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "proxy_resp.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "proxy_req.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "req.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_https_connect_certificate_error",
      "module": "test_proxy",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
      "line_number": 606,
      "end_line_number": 675,
      "source_code": "def test_https_connect_certificate_error(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    # Called on connection to http://proxy.example.com\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        # Called on connection to https://www.python.org\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            side_effect=ssl.CertificateError,\n                        ):\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            with self.assertRaises(\n                                aiohttp.ClientConnectorCertificateError\n                            ):\n                                self.loop.run_until_complete(\n                                    connector._create_connection(\n                                        req, [], aiohttp.ClientTimeout()\n                                    )\n                                )\n                self.loop.run_until_complete(connector.close())",
      "docstring": null,
      "decorators": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
      ],
      "arguments": [
        "self",
        "start_connection",
        "ClientRequestMock"
      ],
      "imports": [
        "asyncio",
        "gc",
        "socket",
        "ssl",
        "unittest",
        "unittest.mock",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": [
        {
          "name": "connector.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_https_connect_ssl_error",
      "module": "test_proxy",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
      "line_number": 683,
      "end_line_number": 750,
      "source_code": "def test_https_connect_ssl_error(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    # Called on connection to http://proxy.example.com\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        # Called on connection to https://www.python.org\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            side_effect=ssl.SSLError,\n                        ):\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            with self.assertRaises(aiohttp.ClientConnectorSSLError):\n                                self.loop.run_until_complete(\n                                    connector._create_connection(\n                                        req, [], aiohttp.ClientTimeout()\n                                    )\n                                )\n                self.loop.run_until_complete(connector.close())",
      "docstring": null,
      "decorators": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
      ],
      "arguments": [
        "self",
        "start_connection",
        "ClientRequestMock"
      ],
      "imports": [
        "asyncio",
        "gc",
        "socket",
        "ssl",
        "unittest",
        "unittest.mock",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": [
        {
          "name": "connector.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_https_connect_http_proxy_error",
      "module": "test_proxy",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
      "line_number": 758,
      "end_line_number": 826,
      "source_code": "def test_https_connect_http_proxy_error(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 400\n                m.return_value.reason = \"bad request\"\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    tr.get_extra_info.return_value = None\n                    # Called on connection to http://proxy.example.com\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        req = ClientRequest(\n                            \"GET\",\n                            URL(\"https://www.python.org\"),\n                            proxy=URL(\"http://proxy.example.com\"),\n                            loop=self.loop,\n                        )\n                        with self.assertRaisesRegex(\n                            aiohttp.ClientHttpProxyError, \"400, message='bad request'\"\n                        ):\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                        self.loop.run_until_complete(proxy_req.close())\n                        proxy_resp.close()\n                        self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
      "docstring": null,
      "decorators": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
      ],
      "arguments": [
        "self",
        "start_connection",
        "ClientRequestMock"
      ],
      "imports": [
        "asyncio",
        "gc",
        "socket",
        "ssl",
        "unittest",
        "unittest.mock",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": [
        {
          "name": "connector.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "proxy_resp.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "proxy_req.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "req.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_https_connect_resp_start_error",
      "module": "test_proxy",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
      "line_number": 834,
      "end_line_number": 896,
      "source_code": "def test_https_connect_resp_start_error(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(\n                proxy_resp, \"start\", autospec=True, side_effect=OSError(\"error message\")\n            ):\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    tr.get_extra_info.return_value = None\n                    # Called on connection to http://proxy.example.com\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        req = ClientRequest(\n                            \"GET\",\n                            URL(\"https://www.python.org\"),\n                            proxy=URL(\"http://proxy.example.com\"),\n                            loop=self.loop,\n                        )\n                        with self.assertRaisesRegex(OSError, \"error message\"):\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n                self.loop.run_until_complete(connector.close())",
      "docstring": null,
      "decorators": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
      ],
      "arguments": [
        "self",
        "start_connection",
        "ClientRequestMock"
      ],
      "imports": [
        "asyncio",
        "gc",
        "socket",
        "ssl",
        "unittest",
        "unittest.mock",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": [
        {
          "name": "connector.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_request_port",
      "module": "test_proxy",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
      "line_number": 904,
      "end_line_number": 943,
      "source_code": "def test_request_port(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        async def make_conn() -> aiohttp.TCPConnector:\n            return aiohttp.TCPConnector()\n\n        connector = self.loop.run_until_complete(make_conn())\n        r = {\n            \"hostname\": \"hostname\",\n            \"host\": \"127.0.0.1\",\n            \"port\": 80,\n            \"family\": socket.AF_INET,\n            \"proto\": 0,\n            \"flags\": 0,\n        }\n        with mock.patch.object(\n            connector, \"_resolve_host\", autospec=True, return_value=[r]\n        ):\n            tr, proto = mock.Mock(), mock.Mock()\n            tr.get_extra_info.return_value = None\n            # Called on connection to http://proxy.example.com\n            with mock.patch.object(\n                self.loop, \"create_connection\", autospec=True, return_value=(tr, proto)\n            ):\n                req = ClientRequest(\n                    \"GET\",\n                    URL(\"http://localhost:1234/path\"),\n                    proxy=URL(\"http://proxy.example.com\"),\n                    loop=self.loop,\n                )\n                self.loop.run_until_complete(\n                    connector._create_connection(req, [], aiohttp.ClientTimeout())\n                )\n                self.assertEqual(req.url, URL(\"http://localhost:1234/path\"))\n        self.loop.run_until_complete(connector.close())",
      "docstring": null,
      "decorators": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
      ],
      "arguments": [
        "self",
        "start_connection",
        "ClientRequestMock"
      ],
      "imports": [
        "asyncio",
        "gc",
        "socket",
        "ssl",
        "unittest",
        "unittest.mock",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": [
        {
          "name": "connector.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_proxy_auth_property",
      "module": "test_proxy",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
      "line_number": 945,
      "end_line_number": 953,
      "source_code": "def test_proxy_auth_property(self) -> None:\n        req = aiohttp.ClientRequest(\n            \"GET\",\n            URL(\"http://localhost:1234/path\"),\n            proxy=URL(\"http://proxy.example.com\"),\n            proxy_auth=aiohttp.helpers.BasicAuth(\"user\", \"pass\"),\n            loop=self.loop,\n        )\n        self.assertEqual((\"user\", \"pass\", \"latin1\"), req.proxy_auth)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "gc",
        "socket",
        "ssl",
        "unittest",
        "unittest.mock",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_proxy_auth_property_default",
      "module": "test_proxy",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
      "line_number": 955,
      "end_line_number": 962,
      "source_code": "def test_proxy_auth_property_default(self) -> None:\n        req = aiohttp.ClientRequest(\n            \"GET\",\n            URL(\"http://localhost:1234/path\"),\n            proxy=URL(\"http://proxy.example.com\"),\n            loop=self.loop,\n        )\n        self.assertIsNone(req.proxy_auth)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "gc",
        "socket",
        "ssl",
        "unittest",
        "unittest.mock",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_https_connect_pass_ssl_context",
      "module": "test_proxy",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
      "line_number": 970,
      "end_line_number": 1052,
      "source_code": "def test_https_connect_pass_ssl_context(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            tls_m.assert_called_with(\n                                mock.ANY,\n                                mock.ANY,\n                                _SSL_CONTEXT_VERIFIED,\n                                server_hostname=\"www.python.org\",\n                                ssl_handshake_timeout=mock.ANY,\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
      "docstring": null,
      "decorators": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
      ],
      "arguments": [
        "self",
        "start_connection",
        "ClientRequestMock"
      ],
      "imports": [
        "asyncio",
        "gc",
        "socket",
        "ssl",
        "unittest",
        "unittest.mock",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": [
        {
          "name": "connector.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "proxy_resp.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "proxy_req.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "req.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_https_auth",
      "module": "test_proxy",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
      "line_number": 1060,
      "end_line_number": 1146,
      "source_code": "def test_https_auth(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\",\n            URL(\"http://proxy.example.com\"),\n            auth=aiohttp.helpers.BasicAuth(\"user\", \"pass\"),\n            loop=self.loop,\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ) as host_m:\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ):\n                            self.assertIn(\"AUTHORIZATION\", proxy_req.headers)\n                            self.assertNotIn(\"PROXY-AUTHORIZATION\", proxy_req.headers)\n\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.assertNotIn(\"AUTHORIZATION\", req.headers)\n                            self.assertNotIn(\"PROXY-AUTHORIZATION\", req.headers)\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertNotIn(\"AUTHORIZATION\", req.headers)\n                            self.assertNotIn(\"PROXY-AUTHORIZATION\", req.headers)\n                            self.assertNotIn(\"AUTHORIZATION\", proxy_req.headers)\n                            self.assertIn(\"PROXY-AUTHORIZATION\", proxy_req.headers)\n\n                            host_m.assert_called_with(\n                                \"proxy.example.com\", 80, traces=mock.ANY\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
      "docstring": null,
      "decorators": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
      ],
      "arguments": [
        "self",
        "start_connection",
        "ClientRequestMock"
      ],
      "imports": [
        "asyncio",
        "gc",
        "socket",
        "ssl",
        "unittest",
        "unittest.mock",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.patch('aiohttp.connector.ClientRequest')",
        "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": [
        {
          "name": "connector.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "proxy_resp.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "proxy_req.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "req.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_entry_func_empty",
      "module": "test_web_cli",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_cli.py",
      "line_number": 10,
      "end_line_number": 17,
      "source_code": "def test_entry_func_empty(mocker: MockerFixture) -> None:\n    error = mocker.patch(\"aiohttp.web.ArgumentParser.error\", side_effect=SystemExit)\n    argv = [\"\"]\n\n    with pytest.raises(SystemExit):\n        web.main(argv)\n\n    error.assert_called_with(\"'entry-func' not in 'module:function' syntax\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "mocker"
      ],
      "imports": [
        "sys",
        "unittest.mock",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.web"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mocker.patch('aiohttp.web.ArgumentParser.error', side_effect=SystemExit)"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_entry_func_only_module",
      "module": "test_web_cli",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_cli.py",
      "line_number": 20,
      "end_line_number": 27,
      "source_code": "def test_entry_func_only_module(mocker: MockerFixture) -> None:\n    argv = [\"test\"]\n    error = mocker.patch(\"aiohttp.web.ArgumentParser.error\", side_effect=SystemExit)\n\n    with pytest.raises(SystemExit):\n        web.main(argv)\n\n    error.assert_called_with(\"'entry-func' not in 'module:function' syntax\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "mocker"
      ],
      "imports": [
        "sys",
        "unittest.mock",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.web"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mocker.patch('aiohttp.web.ArgumentParser.error', side_effect=SystemExit)"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_entry_func_only_function",
      "module": "test_web_cli",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_cli.py",
      "line_number": 30,
      "end_line_number": 37,
      "source_code": "def test_entry_func_only_function(mocker: MockerFixture) -> None:\n    argv = [\":test\"]\n    error = mocker.patch(\"aiohttp.web.ArgumentParser.error\", side_effect=SystemExit)\n\n    with pytest.raises(SystemExit):\n        web.main(argv)\n\n    error.assert_called_with(\"'entry-func' not in 'module:function' syntax\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "mocker"
      ],
      "imports": [
        "sys",
        "unittest.mock",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.web"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mocker.patch('aiohttp.web.ArgumentParser.error', side_effect=SystemExit)"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_entry_func_only_separator",
      "module": "test_web_cli",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_cli.py",
      "line_number": 40,
      "end_line_number": 47,
      "source_code": "def test_entry_func_only_separator(mocker: MockerFixture) -> None:\n    argv = [\":\"]\n    error = mocker.patch(\"aiohttp.web.ArgumentParser.error\", side_effect=SystemExit)\n\n    with pytest.raises(SystemExit):\n        web.main(argv)\n\n    error.assert_called_with(\"'entry-func' not in 'module:function' syntax\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "mocker"
      ],
      "imports": [
        "sys",
        "unittest.mock",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.web"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mocker.patch('aiohttp.web.ArgumentParser.error', side_effect=SystemExit)"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_entry_func_relative_module",
      "module": "test_web_cli",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_cli.py",
      "line_number": 50,
      "end_line_number": 57,
      "source_code": "def test_entry_func_relative_module(mocker: MockerFixture) -> None:\n    argv = [\".a.b:c\"]\n\n    error = mocker.patch(\"aiohttp.web.ArgumentParser.error\", side_effect=SystemExit)\n    with pytest.raises(SystemExit):\n        web.main(argv)\n\n    error.assert_called_with(\"relative module names not supported\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "mocker"
      ],
      "imports": [
        "sys",
        "unittest.mock",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.web"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mocker.patch('aiohttp.web.ArgumentParser.error', side_effect=SystemExit)"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_entry_func_non_existent_module",
      "module": "test_web_cli",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_cli.py",
      "line_number": 60,
      "end_line_number": 69,
      "source_code": "def test_entry_func_non_existent_module(mocker: MockerFixture) -> None:\n    argv = [\"alpha.beta:func\"]\n\n    mocker.patch(\"aiohttp.web.import_module\", side_effect=ImportError(\"Test Error\"))\n    error = mocker.patch(\"aiohttp.web.ArgumentParser.error\", side_effect=SystemExit)\n\n    with pytest.raises(SystemExit):\n        web.main(argv)\n\n    error.assert_called_with(\"unable to import alpha.beta: Test Error\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "mocker"
      ],
      "imports": [
        "sys",
        "unittest.mock",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.web"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mocker.patch('aiohttp.web.import_module', side_effect=ImportError('Test Error'))",
        "mocker.patch('aiohttp.web.ArgumentParser.error', side_effect=SystemExit)"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_entry_func_non_existent_attribute",
      "module": "test_web_cli",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_cli.py",
      "line_number": 72,
      "end_line_number": 84,
      "source_code": "def test_entry_func_non_existent_attribute(mocker: MockerFixture) -> None:\n    argv = [\"alpha.beta:func\"]\n    import_module = mocker.patch(\"aiohttp.web.import_module\")\n    error = mocker.patch(\"aiohttp.web.ArgumentParser.error\", side_effect=SystemExit)\n    module = import_module(\"alpha.beta\")\n    del module.func\n\n    with pytest.raises(SystemExit):\n        web.main(argv)\n\n    error.assert_called_with(\n        \"module {!r} has no attribute {!r}\".format(\"alpha.beta\", \"func\")\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "mocker"
      ],
      "imports": [
        "sys",
        "unittest.mock",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.web"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mocker.patch('aiohttp.web.import_module')",
        "mocker.patch('aiohttp.web.ArgumentParser.error', side_effect=SystemExit)"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_path_no_host",
      "module": "test_web_cli",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_cli.py",
      "line_number": 88,
      "end_line_number": 96,
      "source_code": "def test_path_no_host(mocker: MockerFixture, monkeypatch: pytest.MonkeyPatch) -> None:\n    argv = \"--path=test_path.sock alpha.beta:func\".split()\n    mocker.patch(\"aiohttp.web.import_module\")\n\n    run_app = mocker.patch(\"aiohttp.web.run_app\")\n    with pytest.raises(SystemExit):\n        web.main(argv)\n\n    run_app.assert_called_with(mock.ANY, path=\"test_path.sock\", host=None, port=None)",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(sys.platform.startswith('win32'), reason='Windows not Unix')"
      ],
      "arguments": [
        "mocker",
        "monkeypatch"
      ],
      "imports": [
        "sys",
        "unittest.mock",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.web"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mocker.patch('aiohttp.web.import_module')",
        "mocker.patch('aiohttp.web.run_app')"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_path_and_host",
      "module": "test_web_cli",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_cli.py",
      "line_number": 100,
      "end_line_number": 110,
      "source_code": "def test_path_and_host(mocker: MockerFixture, monkeypatch: pytest.MonkeyPatch) -> None:\n    argv = \"--path=test_path.sock --host=localhost --port=8000 alpha.beta:func\".split()\n    mocker.patch(\"aiohttp.web.import_module\")\n\n    run_app = mocker.patch(\"aiohttp.web.run_app\")\n    with pytest.raises(SystemExit):\n        web.main(argv)\n\n    run_app.assert_called_with(\n        mock.ANY, path=\"test_path.sock\", host=\"localhost\", port=8000\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(sys.platform.startswith('win32'), reason='Windows not Unix')"
      ],
      "arguments": [
        "mocker",
        "monkeypatch"
      ],
      "imports": [
        "sys",
        "unittest.mock",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.web"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mocker.patch('aiohttp.web.import_module')",
        "mocker.patch('aiohttp.web.run_app')"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_path_when_unsupported",
      "module": "test_web_cli",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_cli.py",
      "line_number": 113,
      "end_line_number": 126,
      "source_code": "def test_path_when_unsupported(\n    mocker: MockerFixture, monkeypatch: pytest.MonkeyPatch\n) -> None:\n    argv = \"--path=test_path.sock alpha.beta:func\".split()\n    mocker.patch(\"aiohttp.web.import_module\")\n    monkeypatch.delattr(\"socket.AF_UNIX\", raising=False)\n\n    error = mocker.patch(\"aiohttp.web.ArgumentParser.error\", side_effect=SystemExit)\n    with pytest.raises(SystemExit):\n        web.main(argv)\n\n    error.assert_called_with(\n        \"file system paths not supported by your operating environment\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "mocker",
        "monkeypatch"
      ],
      "imports": [
        "sys",
        "unittest.mock",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.web"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mocker.patch('aiohttp.web.import_module')",
        "mocker.patch('aiohttp.web.ArgumentParser.error', side_effect=SystemExit)"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_entry_func_call",
      "module": "test_web_cli",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_cli.py",
      "line_number": 129,
      "end_line_number": 143,
      "source_code": "def test_entry_func_call(mocker: MockerFixture) -> None:\n    mocker.patch(\"aiohttp.web.run_app\")\n    import_module = mocker.patch(\"aiohttp.web.import_module\")\n    argv = (\n        \"-H testhost -P 6666 --extra-optional-eins alpha.beta:func \"\n        \"--extra-optional-zwei extra positional args\"\n    ).split()\n    module = import_module(\"alpha.beta\")\n\n    with pytest.raises(SystemExit):\n        web.main(argv)\n\n    module.func.assert_called_with(\n        (\"--extra-optional-eins --extra-optional-zwei extra positional args\").split()\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "mocker"
      ],
      "imports": [
        "sys",
        "unittest.mock",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.web"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mocker.patch('aiohttp.web.run_app')",
        "mocker.patch('aiohttp.web.import_module')"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_running_application",
      "module": "test_web_cli",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_cli.py",
      "line_number": 146,
      "end_line_number": 161,
      "source_code": "def test_running_application(mocker: MockerFixture) -> None:\n    run_app = mocker.patch(\"aiohttp.web.run_app\")\n    import_module = mocker.patch(\"aiohttp.web.import_module\")\n    exit = mocker.patch(\"aiohttp.web.ArgumentParser.exit\", side_effect=SystemExit)\n    argv = (\n        \"-H testhost -P 6666 --extra-optional-eins alpha.beta:func \"\n        \"--extra-optional-zwei extra positional args\"\n    ).split()\n    module = import_module(\"alpha.beta\")\n    app = module.func()\n\n    with pytest.raises(SystemExit):\n        web.main(argv)\n\n    run_app.assert_called_with(app, host=\"testhost\", port=6666, path=None)\n    exit.assert_called_with(message=\"Stopped\\n\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "mocker"
      ],
      "imports": [
        "sys",
        "unittest.mock",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.web"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mocker.patch('aiohttp.web.run_app')",
        "mocker.patch('aiohttp.web.import_module')",
        "mocker.patch('aiohttp.web.ArgumentParser.exit', side_effect=SystemExit)"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_websocket_ready",
      "module": "test_web_websocket",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_websocket.py",
      "line_number": 178,
      "end_line_number": 181,
      "source_code": "def test_websocket_ready() -> None:\n    websocket_ready = WebSocketReady(True, \"chat\")\n    assert websocket_ready.ok is True\n    assert websocket_ready.protocol == \"chat\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "time",
        "typing.Optional",
        "typing.Protocol",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "pytest_mock.MockerFixture",
        "aiohttp.WSMsgType",
        "aiohttp.web",
        "aiohttp.http.WS_CLOSED_MESSAGE",
        "aiohttp.http.WS_CLOSING_MESSAGE",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.streams.EofStream",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_ws.WebSocketReady"
      ],
      "fixtures": [],
      "assertions": [
        "assert websocket_ready.ok is True",
        "assert websocket_ready.protocol == 'chat'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_websocket_not_ready",
      "module": "test_web_websocket",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_websocket.py",
      "line_number": 184,
      "end_line_number": 187,
      "source_code": "def test_websocket_not_ready() -> None:\n    websocket_ready = WebSocketReady(False, None)\n    assert websocket_ready.ok is False\n    assert websocket_ready.protocol is None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "time",
        "typing.Optional",
        "typing.Protocol",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "pytest_mock.MockerFixture",
        "aiohttp.WSMsgType",
        "aiohttp.web",
        "aiohttp.http.WS_CLOSED_MESSAGE",
        "aiohttp.http.WS_CLOSING_MESSAGE",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.streams.EofStream",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_ws.WebSocketReady"
      ],
      "fixtures": [],
      "assertions": [
        "assert websocket_ready.ok is False",
        "assert websocket_ready.protocol is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_websocket_ready_unknown_protocol",
      "module": "test_web_websocket",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_websocket.py",
      "line_number": 190,
      "end_line_number": 193,
      "source_code": "def test_websocket_ready_unknown_protocol() -> None:\n    websocket_ready = WebSocketReady(True, None)\n    assert websocket_ready.ok is True\n    assert websocket_ready.protocol is None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "time",
        "typing.Optional",
        "typing.Protocol",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "pytest_mock.MockerFixture",
        "aiohttp.WSMsgType",
        "aiohttp.web",
        "aiohttp.http.WS_CLOSED_MESSAGE",
        "aiohttp.http.WS_CLOSING_MESSAGE",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.streams.EofStream",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_ws.WebSocketReady"
      ],
      "fixtures": [],
      "assertions": [
        "assert websocket_ready.ok is True",
        "assert websocket_ready.protocol is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_bool_websocket_ready",
      "module": "test_web_websocket",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_websocket.py",
      "line_number": 196,
      "end_line_number": 198,
      "source_code": "def test_bool_websocket_ready() -> None:\n    websocket_ready = WebSocketReady(True, None)\n    assert bool(websocket_ready) is True",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "time",
        "typing.Optional",
        "typing.Protocol",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "pytest_mock.MockerFixture",
        "aiohttp.WSMsgType",
        "aiohttp.web",
        "aiohttp.http.WS_CLOSED_MESSAGE",
        "aiohttp.http.WS_CLOSING_MESSAGE",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.streams.EofStream",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_ws.WebSocketReady"
      ],
      "fixtures": [],
      "assertions": [
        "assert bool(websocket_ready) is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_bool_websocket_not_ready",
      "module": "test_web_websocket",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_websocket.py",
      "line_number": 201,
      "end_line_number": 203,
      "source_code": "def test_bool_websocket_not_ready() -> None:\n    websocket_ready = WebSocketReady(False, None)\n    assert bool(websocket_ready) is False",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "time",
        "typing.Optional",
        "typing.Protocol",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "pytest_mock.MockerFixture",
        "aiohttp.WSMsgType",
        "aiohttp.web",
        "aiohttp.http.WS_CLOSED_MESSAGE",
        "aiohttp.http.WS_CLOSING_MESSAGE",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.streams.EofStream",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_ws.WebSocketReady"
      ],
      "fixtures": [],
      "assertions": [
        "assert bool(websocket_ready) is False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_can_prepare_ok",
      "module": "test_web_websocket",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_websocket.py",
      "line_number": 206,
      "end_line_number": 209,
      "source_code": "def test_can_prepare_ok(make_request: _RequestMaker) -> None:\n    req = make_request(\"GET\", \"/\", protocols=True)\n    ws = web.WebSocketResponse(protocols=(\"chat\",))\n    assert WebSocketReady(True, \"chat\") == ws.can_prepare(req)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "time",
        "typing.Optional",
        "typing.Protocol",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "pytest_mock.MockerFixture",
        "aiohttp.WSMsgType",
        "aiohttp.web",
        "aiohttp.http.WS_CLOSED_MESSAGE",
        "aiohttp.http.WS_CLOSING_MESSAGE",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.streams.EofStream",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_ws.WebSocketReady"
      ],
      "fixtures": [],
      "assertions": [
        "assert WebSocketReady(True, 'chat') == ws.can_prepare(req)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_can_prepare_unknown_protocol",
      "module": "test_web_websocket",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_websocket.py",
      "line_number": 212,
      "end_line_number": 215,
      "source_code": "def test_can_prepare_unknown_protocol(make_request: _RequestMaker) -> None:\n    req = make_request(\"GET\", \"/\")\n    ws = web.WebSocketResponse()\n    assert WebSocketReady(True, None) == ws.can_prepare(req)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "time",
        "typing.Optional",
        "typing.Protocol",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "pytest_mock.MockerFixture",
        "aiohttp.WSMsgType",
        "aiohttp.web",
        "aiohttp.http.WS_CLOSED_MESSAGE",
        "aiohttp.http.WS_CLOSING_MESSAGE",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.streams.EofStream",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_ws.WebSocketReady"
      ],
      "fixtures": [],
      "assertions": [
        "assert WebSocketReady(True, None) == ws.can_prepare(req)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_can_prepare_without_upgrade",
      "module": "test_web_websocket",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_websocket.py",
      "line_number": 218,
      "end_line_number": 221,
      "source_code": "def test_can_prepare_without_upgrade(make_request: _RequestMaker) -> None:\n    req = make_request(\"GET\", \"/\", headers=CIMultiDict({}))\n    ws = web.WebSocketResponse()\n    assert WebSocketReady(False, None) == ws.can_prepare(req)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "time",
        "typing.Optional",
        "typing.Protocol",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "pytest_mock.MockerFixture",
        "aiohttp.WSMsgType",
        "aiohttp.web",
        "aiohttp.http.WS_CLOSED_MESSAGE",
        "aiohttp.http.WS_CLOSING_MESSAGE",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.streams.EofStream",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_ws.WebSocketReady"
      ],
      "fixtures": [],
      "assertions": [
        "assert WebSocketReady(False, None) == ws.can_prepare(req)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_closed_after_ctor",
      "module": "test_web_websocket",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_websocket.py",
      "line_number": 234,
      "end_line_number": 237,
      "source_code": "def test_closed_after_ctor() -> None:\n    ws = web.WebSocketResponse()\n    assert not ws.closed\n    assert ws.close_code is None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "time",
        "typing.Optional",
        "typing.Protocol",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "pytest_mock.MockerFixture",
        "aiohttp.WSMsgType",
        "aiohttp.web",
        "aiohttp.http.WS_CLOSED_MESSAGE",
        "aiohttp.http.WS_CLOSING_MESSAGE",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.streams.EofStream",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_ws.WebSocketReady"
      ],
      "fixtures": [],
      "assertions": [
        "assert not ws.closed",
        "assert ws.close_code is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_all_http_exceptions_exported",
      "module": "test_web_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 13,
      "end_line_number": 20,
      "source_code": "def test_all_http_exceptions_exported() -> None:\n    assert \"HTTPException\" in web.__all__\n    for name in dir(web):\n        if name.startswith(\"_\"):\n            continue\n        obj = getattr(web, name)\n        if isinstance(obj, type) and issubclass(obj, web.HTTPException):\n            assert name in web.__all__",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'HTTPException' in web.__all__",
        "assert name in web.__all__"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_terminal_classes_has_status_code",
      "module": "test_web_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 80,
      "end_line_number": 97,
      "source_code": "def test_terminal_classes_has_status_code() -> None:\n    terminals = set()\n    for name in dir(web):\n        obj = getattr(web, name)\n        if isinstance(obj, type) and issubclass(obj, web.HTTPException):\n            terminals.add(obj)\n\n    dup = frozenset(terminals)\n    for cls1 in dup:\n        for cls2 in dup:\n            if cls1 in cls2.__bases__:\n                terminals.discard(cls1)\n\n    for cls in terminals:\n        assert cls.status_code is not None\n    codes = collections.Counter(cls.status_code for cls in terminals)\n    assert None not in codes\n    assert 1 == codes.most_common(1)[0][1]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert None not in codes",
        "assert 1 == codes.most_common(1)[0][1]",
        "assert cls.status_code is not None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_with_text",
      "module": "test_web_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 100,
      "end_line_number": 104,
      "source_code": "def test_with_text() -> None:\n    resp = web.HTTPNotFound(text=\"Page not found\")\n    assert 404 == resp.status\n    assert \"Page not found\" == resp.text\n    assert \"text/plain\" == resp.headers[\"Content-Type\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert 404 == resp.status",
        "assert 'Page not found' == resp.text",
        "assert 'text/plain' == resp.headers['Content-Type']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_default_text",
      "module": "test_web_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 107,
      "end_line_number": 109,
      "source_code": "def test_default_text() -> None:\n    resp = web.HTTPOk()\n    assert \"200: OK\" == resp.text",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert '200: OK' == resp.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_empty_text_204",
      "module": "test_web_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 112,
      "end_line_number": 114,
      "source_code": "def test_empty_text_204() -> None:\n    resp = web.HTTPNoContent()\n    assert resp.text is None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.text is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_empty_text_205",
      "module": "test_web_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 117,
      "end_line_number": 119,
      "source_code": "def test_empty_text_205() -> None:\n    resp = web.HTTPResetContent()\n    assert resp.text is None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.text is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_empty_text_304",
      "module": "test_web_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 122,
      "end_line_number": 124,
      "source_code": "def test_empty_text_304() -> None:\n    resp = web.HTTPNoContent()\n    resp.text is None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_no_link_451",
      "module": "test_web_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 127,
      "end_line_number": 129,
      "source_code": "def test_no_link_451() -> None:\n    with pytest.raises(TypeError):\n        web.HTTPUnavailableForLegalReasons()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_link_none_451",
      "module": "test_web_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 132,
      "end_line_number": 135,
      "source_code": "def test_link_none_451() -> None:\n    resp = web.HTTPUnavailableForLegalReasons(link=None)\n    assert resp.link is None\n    assert \"Link\" not in resp.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.link is None",
        "assert 'Link' not in resp.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_link_empty_451",
      "module": "test_web_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 138,
      "end_line_number": 141,
      "source_code": "def test_link_empty_451() -> None:\n    resp = web.HTTPUnavailableForLegalReasons(link=\"\")\n    assert resp.link is None\n    assert \"Link\" not in resp.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.link is None",
        "assert 'Link' not in resp.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_link_str_451",
      "module": "test_web_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 144,
      "end_line_number": 147,
      "source_code": "def test_link_str_451() -> None:\n    resp = web.HTTPUnavailableForLegalReasons(link=\"http://warning.or.kr/\")\n    assert resp.link == URL(\"http://warning.or.kr/\")\n    assert resp.headers[\"Link\"] == '<http://warning.or.kr/>; rel=\"blocked-by\"'",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.link == URL('http://warning.or.kr/')",
        "assert resp.headers['Link'] == '<http://warning.or.kr/>; rel=\"blocked-by\"'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_link_url_451",
      "module": "test_web_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 150,
      "end_line_number": 153,
      "source_code": "def test_link_url_451() -> None:\n    resp = web.HTTPUnavailableForLegalReasons(link=URL(\"http://warning.or.kr/\"))\n    assert resp.link == URL(\"http://warning.or.kr/\")\n    assert resp.headers[\"Link\"] == '<http://warning.or.kr/>; rel=\"blocked-by\"'",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.link == URL('http://warning.or.kr/')",
        "assert resp.headers['Link'] == '<http://warning.or.kr/>; rel=\"blocked-by\"'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_link_CRLF_451",
      "module": "test_web_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 156,
      "end_line_number": 158,
      "source_code": "def test_link_CRLF_451() -> None:\n    resp = web.HTTPUnavailableForLegalReasons(link=\"http://warning.or.kr/\\r\\n\")\n    assert \"\\r\\n\" not in resp.headers[\"Link\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert '\\r\\n' not in resp.headers['Link']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_HTTPException_retains_cause",
      "module": "test_web_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 161,
      "end_line_number": 169,
      "source_code": "def test_HTTPException_retains_cause() -> None:\n    with pytest.raises(web.HTTPException) as ei:\n        try:\n            raise Exception(\"CustomException\")\n        except Exception as exc:\n            raise web.HTTPException() from exc\n    tb = \"\".join(format_exception(ei.type, ei.value, ei.tb))\n    assert \"CustomException\" in tb\n    assert \"direct cause\" in tb",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'CustomException' in tb",
        "assert 'direct cause' in tb"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor_all",
      "module": "test_web_exceptions",
      "class_name": "TestHTTPOk",
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 173,
      "end_line_number": 184,
      "source_code": "def test_ctor_all(self) -> None:\n        resp = web.HTTPOk(\n            headers={\"X-Custom\": \"value\"},\n            reason=\"Done\",\n            text=\"text\",\n            content_type=\"custom\",\n        )\n        assert resp.text == \"text\"\n        compare: Mapping[str, str] = {\"X-Custom\": \"value\", \"Content-Type\": \"custom\"}\n        assert resp.headers == compare\n        assert resp.reason == \"Done\"\n        assert resp.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.text == 'text'",
        "assert resp.headers == compare",
        "assert resp.reason == 'Done'",
        "assert resp.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_multiline_reason",
      "module": "test_web_exceptions",
      "class_name": "TestHTTPOk",
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 186,
      "end_line_number": 188,
      "source_code": "def test_multiline_reason(self) -> None:\n        with pytest.raises(ValueError, match=r\"Reason cannot contain \\\\n\"):\n            web.HTTPOk(reason=\"Bad\\r\\nInjected-header: foo\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_pickle",
      "module": "test_web_exceptions",
      "class_name": "TestHTTPOk",
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 190,
      "end_line_number": 205,
      "source_code": "def test_pickle(self) -> None:\n        resp = web.HTTPOk(\n            headers={\"X-Custom\": \"value\"},\n            reason=\"Done\",\n            text=\"text\",\n            content_type=\"custom\",\n        )\n        resp.foo = \"bar\"  # type: ignore[attr-defined]\n        for proto in range(2, pickle.HIGHEST_PROTOCOL + 1):\n            pickled = pickle.dumps(resp, proto)\n            resp2 = pickle.loads(pickled)\n            assert resp2.text == \"text\"\n            assert resp2.headers == resp.headers\n            assert resp2.reason == \"Done\"\n            assert resp2.status == 200\n            assert resp2.foo == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp2.text == 'text'",
        "assert resp2.headers == resp.headers",
        "assert resp2.reason == 'Done'",
        "assert resp2.status == 200",
        "assert resp2.foo == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_location_str",
      "module": "test_web_exceptions",
      "class_name": "TestHTTPFound",
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 222,
      "end_line_number": 225,
      "source_code": "def test_location_str(self) -> None:\n        exc = web.HTTPFound(location=\"/redirect\")\n        assert exc.location == URL(\"/redirect\")\n        assert exc.headers[\"Location\"] == \"/redirect\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert exc.location == URL('/redirect')",
        "assert exc.headers['Location'] == '/redirect'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_location_url",
      "module": "test_web_exceptions",
      "class_name": "TestHTTPFound",
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 227,
      "end_line_number": 230,
      "source_code": "def test_location_url(self) -> None:\n        exc = web.HTTPFound(location=URL(\"/redirect\"))\n        assert exc.location == URL(\"/redirect\")\n        assert exc.headers[\"Location\"] == \"/redirect\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert exc.location == URL('/redirect')",
        "assert exc.headers['Location'] == '/redirect'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_empty_location",
      "module": "test_web_exceptions",
      "class_name": "TestHTTPFound",
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 232,
      "end_line_number": 236,
      "source_code": "def test_empty_location(self) -> None:\n        with pytest.raises(ValueError):\n            web.HTTPFound(location=\"\")\n        with pytest.raises(ValueError):\n            web.HTTPFound(location=None)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_location_CRLF",
      "module": "test_web_exceptions",
      "class_name": "TestHTTPFound",
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 238,
      "end_line_number": 240,
      "source_code": "def test_location_CRLF(self) -> None:\n        exc = web.HTTPFound(location=\"/redirect\\r\\n\")\n        assert \"\\r\\n\" not in exc.headers[\"Location\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert '\\r\\n' not in exc.headers['Location']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_pickle",
      "module": "test_web_exceptions",
      "class_name": "TestHTTPFound",
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 242,
      "end_line_number": 259,
      "source_code": "def test_pickle(self) -> None:\n        resp = web.HTTPFound(\n            location=\"http://example.com\",\n            headers={\"X-Custom\": \"value\"},\n            reason=\"Wow\",\n            text=\"text\",\n            content_type=\"custom\",\n        )\n        resp.foo = \"bar\"  # type: ignore[attr-defined]\n        for proto in range(2, pickle.HIGHEST_PROTOCOL + 1):\n            pickled = pickle.dumps(resp, proto)\n            resp2 = pickle.loads(pickled)\n            assert resp2.location == URL(\"http://example.com\")\n            assert resp2.text == \"text\"\n            assert resp2.headers == resp.headers\n            assert resp2.reason == \"Wow\"\n            assert resp2.status == 302\n            assert resp2.foo == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp2.location == URL('http://example.com')",
        "assert resp2.text == 'text'",
        "assert resp2.headers == resp.headers",
        "assert resp2.reason == 'Wow'",
        "assert resp2.status == 302",
        "assert resp2.foo == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_pickle",
      "module": "test_web_exceptions",
      "class_name": "TestHTTPMethodNotAllowed",
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 298,
      "end_line_number": 317,
      "source_code": "def test_pickle(self) -> None:\n        resp = web.HTTPMethodNotAllowed(\n            method=\"GET\",\n            allowed_methods=(\"POST\", \"PUT\"),\n            headers={\"X-Custom\": \"value\"},\n            reason=\"Unsupported\",\n            text=\"text\",\n            content_type=\"custom\",\n        )\n        resp.foo = \"bar\"  # type: ignore[attr-defined]\n        for proto in range(2, pickle.HIGHEST_PROTOCOL + 1):\n            pickled = pickle.dumps(resp, proto)\n            resp2 = pickle.loads(pickled)\n            assert resp2.method == \"GET\"\n            assert resp2.allowed_methods == {\"POST\", \"PUT\"}\n            assert resp2.text == \"text\"\n            assert resp2.headers == resp.headers\n            assert resp2.reason == \"Unsupported\"\n            assert resp2.status == 405\n            assert resp2.foo == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp2.method == 'GET'",
        "assert resp2.allowed_methods == {'POST', 'PUT'}",
        "assert resp2.text == 'text'",
        "assert resp2.headers == resp.headers",
        "assert resp2.reason == 'Unsupported'",
        "assert resp2.status == 405",
        "assert resp2.foo == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor",
      "module": "test_web_exceptions",
      "class_name": "TestHTTPRequestEntityTooLarge",
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 321,
      "end_line_number": 334,
      "source_code": "def test_ctor(self) -> None:\n        resp = web.HTTPRequestEntityTooLarge(\n            max_size=100,\n            actual_size=123,\n            headers={\"X-Custom\": \"value\"},\n            reason=\"Too large\",\n        )\n        assert resp.text == (\n            \"Maximum request body size 100 exceeded, actual body size 123\"\n        )\n        compare: Mapping[str, str] = {\"X-Custom\": \"value\", \"Content-Type\": \"text/plain\"}\n        assert resp.headers == compare\n        assert resp.reason == \"Too large\"\n        assert resp.status == 413",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.text == 'Maximum request body size 100 exceeded, actual body size 123'",
        "assert resp.headers == compare",
        "assert resp.reason == 'Too large'",
        "assert resp.status == 413"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_pickle",
      "module": "test_web_exceptions",
      "class_name": "TestHTTPRequestEntityTooLarge",
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 336,
      "end_line_number": 348,
      "source_code": "def test_pickle(self) -> None:\n        resp = web.HTTPRequestEntityTooLarge(\n            100, actual_size=123, headers={\"X-Custom\": \"value\"}, reason=\"Too large\"\n        )\n        resp.foo = \"bar\"  # type: ignore[attr-defined]\n        for proto in range(2, pickle.HIGHEST_PROTOCOL + 1):\n            pickled = pickle.dumps(resp, proto)\n            resp2 = pickle.loads(pickled)\n            assert resp2.text == resp.text\n            assert resp2.headers == resp.headers\n            assert resp2.reason == \"Too large\"\n            assert resp2.status == 413\n            assert resp2.foo == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp2.text == resp.text",
        "assert resp2.headers == resp.headers",
        "assert resp2.reason == 'Too large'",
        "assert resp2.status == 413",
        "assert resp2.foo == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor",
      "module": "test_web_exceptions",
      "class_name": "TestHTTPUnavailableForLegalReasons",
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 352,
      "end_line_number": 369,
      "source_code": "def test_ctor(self) -> None:\n        exc = web.HTTPUnavailableForLegalReasons(\n            link=\"http://warning.or.kr/\",\n            headers={\"X-Custom\": \"value\"},\n            reason=\"Zaprescheno\",\n            text=\"text\",\n            content_type=\"custom\",\n        )\n        assert exc.link == URL(\"http://warning.or.kr/\")\n        assert exc.text == \"text\"\n        compare: Mapping[str, str] = {\n            \"X-Custom\": \"value\",\n            \"Content-Type\": \"custom\",\n            \"Link\": '<http://warning.or.kr/>; rel=\"blocked-by\"',\n        }\n        assert exc.headers == compare\n        assert exc.reason == \"Zaprescheno\"\n        assert exc.status == 451",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert exc.link == URL('http://warning.or.kr/')",
        "assert exc.text == 'text'",
        "assert exc.headers == compare",
        "assert exc.reason == 'Zaprescheno'",
        "assert exc.status == 451"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_no_link",
      "module": "test_web_exceptions",
      "class_name": "TestHTTPUnavailableForLegalReasons",
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 371,
      "end_line_number": 373,
      "source_code": "def test_no_link(self) -> None:\n        with pytest.raises(TypeError):\n            web.HTTPUnavailableForLegalReasons()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_none_link",
      "module": "test_web_exceptions",
      "class_name": "TestHTTPUnavailableForLegalReasons",
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 375,
      "end_line_number": 378,
      "source_code": "def test_none_link(self) -> None:\n        exc = web.HTTPUnavailableForLegalReasons(link=None)\n        assert exc.link is None\n        assert \"Link\" not in exc.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert exc.link is None",
        "assert 'Link' not in exc.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_empty_link",
      "module": "test_web_exceptions",
      "class_name": "TestHTTPUnavailableForLegalReasons",
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 380,
      "end_line_number": 383,
      "source_code": "def test_empty_link(self) -> None:\n        exc = web.HTTPUnavailableForLegalReasons(link=\"\")\n        assert exc.link is None\n        assert \"Link\" not in exc.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert exc.link is None",
        "assert 'Link' not in exc.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_link_str",
      "module": "test_web_exceptions",
      "class_name": "TestHTTPUnavailableForLegalReasons",
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 385,
      "end_line_number": 388,
      "source_code": "def test_link_str(self) -> None:\n        exc = web.HTTPUnavailableForLegalReasons(link=\"http://warning.or.kr/\")\n        assert exc.link == URL(\"http://warning.or.kr/\")\n        assert exc.headers[\"Link\"] == '<http://warning.or.kr/>; rel=\"blocked-by\"'",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert exc.link == URL('http://warning.or.kr/')",
        "assert exc.headers['Link'] == '<http://warning.or.kr/>; rel=\"blocked-by\"'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_link_url",
      "module": "test_web_exceptions",
      "class_name": "TestHTTPUnavailableForLegalReasons",
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 390,
      "end_line_number": 393,
      "source_code": "def test_link_url(self) -> None:\n        exc = web.HTTPUnavailableForLegalReasons(link=URL(\"http://warning.or.kr/\"))\n        assert exc.link == URL(\"http://warning.or.kr/\")\n        assert exc.headers[\"Link\"] == '<http://warning.or.kr/>; rel=\"blocked-by\"'",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert exc.link == URL('http://warning.or.kr/')",
        "assert exc.headers['Link'] == '<http://warning.or.kr/>; rel=\"blocked-by\"'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_link_CRLF",
      "module": "test_web_exceptions",
      "class_name": "TestHTTPUnavailableForLegalReasons",
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 395,
      "end_line_number": 397,
      "source_code": "def test_link_CRLF(self) -> None:\n        exc = web.HTTPUnavailableForLegalReasons(link=\"http://warning.or.kr/\\r\\n\")\n        assert \"\\r\\n\" not in exc.headers[\"Link\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert '\\r\\n' not in exc.headers['Link']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_pickle",
      "module": "test_web_exceptions",
      "class_name": "TestHTTPUnavailableForLegalReasons",
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 399,
      "end_line_number": 416,
      "source_code": "def test_pickle(self) -> None:\n        resp = web.HTTPUnavailableForLegalReasons(\n            link=\"http://warning.or.kr/\",\n            headers={\"X-Custom\": \"value\"},\n            reason=\"Zaprescheno\",\n            text=\"text\",\n            content_type=\"custom\",\n        )\n        resp.foo = \"bar\"  # type: ignore[attr-defined]\n        for proto in range(2, pickle.HIGHEST_PROTOCOL + 1):\n            pickled = pickle.dumps(resp, proto)\n            resp2 = pickle.loads(pickled)\n            assert resp2.link == URL(\"http://warning.or.kr/\")\n            assert resp2.text == \"text\"\n            assert resp2.headers == resp.headers\n            assert resp2.reason == \"Zaprescheno\"\n            assert resp2.status == 451\n            assert resp2.foo == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp2.link == URL('http://warning.or.kr/')",
        "assert resp2.text == 'text'",
        "assert resp2.headers == resp.headers",
        "assert resp2.reason == 'Zaprescheno'",
        "assert resp2.status == 451",
        "assert resp2.foo == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor_all",
      "module": "test_web_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 173,
      "end_line_number": 184,
      "source_code": "def test_ctor_all(self) -> None:\n        resp = web.HTTPOk(\n            headers={\"X-Custom\": \"value\"},\n            reason=\"Done\",\n            text=\"text\",\n            content_type=\"custom\",\n        )\n        assert resp.text == \"text\"\n        compare: Mapping[str, str] = {\"X-Custom\": \"value\", \"Content-Type\": \"custom\"}\n        assert resp.headers == compare\n        assert resp.reason == \"Done\"\n        assert resp.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.text == 'text'",
        "assert resp.headers == compare",
        "assert resp.reason == 'Done'",
        "assert resp.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_multiline_reason",
      "module": "test_web_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 186,
      "end_line_number": 188,
      "source_code": "def test_multiline_reason(self) -> None:\n        with pytest.raises(ValueError, match=r\"Reason cannot contain \\\\n\"):\n            web.HTTPOk(reason=\"Bad\\r\\nInjected-header: foo\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_pickle",
      "module": "test_web_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 190,
      "end_line_number": 205,
      "source_code": "def test_pickle(self) -> None:\n        resp = web.HTTPOk(\n            headers={\"X-Custom\": \"value\"},\n            reason=\"Done\",\n            text=\"text\",\n            content_type=\"custom\",\n        )\n        resp.foo = \"bar\"  # type: ignore[attr-defined]\n        for proto in range(2, pickle.HIGHEST_PROTOCOL + 1):\n            pickled = pickle.dumps(resp, proto)\n            resp2 = pickle.loads(pickled)\n            assert resp2.text == \"text\"\n            assert resp2.headers == resp.headers\n            assert resp2.reason == \"Done\"\n            assert resp2.status == 200\n            assert resp2.foo == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp2.text == 'text'",
        "assert resp2.headers == resp.headers",
        "assert resp2.reason == 'Done'",
        "assert resp2.status == 200",
        "assert resp2.foo == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_location_str",
      "module": "test_web_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 222,
      "end_line_number": 225,
      "source_code": "def test_location_str(self) -> None:\n        exc = web.HTTPFound(location=\"/redirect\")\n        assert exc.location == URL(\"/redirect\")\n        assert exc.headers[\"Location\"] == \"/redirect\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert exc.location == URL('/redirect')",
        "assert exc.headers['Location'] == '/redirect'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_location_url",
      "module": "test_web_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 227,
      "end_line_number": 230,
      "source_code": "def test_location_url(self) -> None:\n        exc = web.HTTPFound(location=URL(\"/redirect\"))\n        assert exc.location == URL(\"/redirect\")\n        assert exc.headers[\"Location\"] == \"/redirect\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert exc.location == URL('/redirect')",
        "assert exc.headers['Location'] == '/redirect'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_empty_location",
      "module": "test_web_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 232,
      "end_line_number": 236,
      "source_code": "def test_empty_location(self) -> None:\n        with pytest.raises(ValueError):\n            web.HTTPFound(location=\"\")\n        with pytest.raises(ValueError):\n            web.HTTPFound(location=None)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_location_CRLF",
      "module": "test_web_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 238,
      "end_line_number": 240,
      "source_code": "def test_location_CRLF(self) -> None:\n        exc = web.HTTPFound(location=\"/redirect\\r\\n\")\n        assert \"\\r\\n\" not in exc.headers[\"Location\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert '\\r\\n' not in exc.headers['Location']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_pickle",
      "module": "test_web_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 242,
      "end_line_number": 259,
      "source_code": "def test_pickle(self) -> None:\n        resp = web.HTTPFound(\n            location=\"http://example.com\",\n            headers={\"X-Custom\": \"value\"},\n            reason=\"Wow\",\n            text=\"text\",\n            content_type=\"custom\",\n        )\n        resp.foo = \"bar\"  # type: ignore[attr-defined]\n        for proto in range(2, pickle.HIGHEST_PROTOCOL + 1):\n            pickled = pickle.dumps(resp, proto)\n            resp2 = pickle.loads(pickled)\n            assert resp2.location == URL(\"http://example.com\")\n            assert resp2.text == \"text\"\n            assert resp2.headers == resp.headers\n            assert resp2.reason == \"Wow\"\n            assert resp2.status == 302\n            assert resp2.foo == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp2.location == URL('http://example.com')",
        "assert resp2.text == 'text'",
        "assert resp2.headers == resp.headers",
        "assert resp2.reason == 'Wow'",
        "assert resp2.status == 302",
        "assert resp2.foo == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_pickle",
      "module": "test_web_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 298,
      "end_line_number": 317,
      "source_code": "def test_pickle(self) -> None:\n        resp = web.HTTPMethodNotAllowed(\n            method=\"GET\",\n            allowed_methods=(\"POST\", \"PUT\"),\n            headers={\"X-Custom\": \"value\"},\n            reason=\"Unsupported\",\n            text=\"text\",\n            content_type=\"custom\",\n        )\n        resp.foo = \"bar\"  # type: ignore[attr-defined]\n        for proto in range(2, pickle.HIGHEST_PROTOCOL + 1):\n            pickled = pickle.dumps(resp, proto)\n            resp2 = pickle.loads(pickled)\n            assert resp2.method == \"GET\"\n            assert resp2.allowed_methods == {\"POST\", \"PUT\"}\n            assert resp2.text == \"text\"\n            assert resp2.headers == resp.headers\n            assert resp2.reason == \"Unsupported\"\n            assert resp2.status == 405\n            assert resp2.foo == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp2.method == 'GET'",
        "assert resp2.allowed_methods == {'POST', 'PUT'}",
        "assert resp2.text == 'text'",
        "assert resp2.headers == resp.headers",
        "assert resp2.reason == 'Unsupported'",
        "assert resp2.status == 405",
        "assert resp2.foo == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor",
      "module": "test_web_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 321,
      "end_line_number": 334,
      "source_code": "def test_ctor(self) -> None:\n        resp = web.HTTPRequestEntityTooLarge(\n            max_size=100,\n            actual_size=123,\n            headers={\"X-Custom\": \"value\"},\n            reason=\"Too large\",\n        )\n        assert resp.text == (\n            \"Maximum request body size 100 exceeded, actual body size 123\"\n        )\n        compare: Mapping[str, str] = {\"X-Custom\": \"value\", \"Content-Type\": \"text/plain\"}\n        assert resp.headers == compare\n        assert resp.reason == \"Too large\"\n        assert resp.status == 413",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.text == 'Maximum request body size 100 exceeded, actual body size 123'",
        "assert resp.headers == compare",
        "assert resp.reason == 'Too large'",
        "assert resp.status == 413"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_pickle",
      "module": "test_web_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 336,
      "end_line_number": 348,
      "source_code": "def test_pickle(self) -> None:\n        resp = web.HTTPRequestEntityTooLarge(\n            100, actual_size=123, headers={\"X-Custom\": \"value\"}, reason=\"Too large\"\n        )\n        resp.foo = \"bar\"  # type: ignore[attr-defined]\n        for proto in range(2, pickle.HIGHEST_PROTOCOL + 1):\n            pickled = pickle.dumps(resp, proto)\n            resp2 = pickle.loads(pickled)\n            assert resp2.text == resp.text\n            assert resp2.headers == resp.headers\n            assert resp2.reason == \"Too large\"\n            assert resp2.status == 413\n            assert resp2.foo == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp2.text == resp.text",
        "assert resp2.headers == resp.headers",
        "assert resp2.reason == 'Too large'",
        "assert resp2.status == 413",
        "assert resp2.foo == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor",
      "module": "test_web_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 352,
      "end_line_number": 369,
      "source_code": "def test_ctor(self) -> None:\n        exc = web.HTTPUnavailableForLegalReasons(\n            link=\"http://warning.or.kr/\",\n            headers={\"X-Custom\": \"value\"},\n            reason=\"Zaprescheno\",\n            text=\"text\",\n            content_type=\"custom\",\n        )\n        assert exc.link == URL(\"http://warning.or.kr/\")\n        assert exc.text == \"text\"\n        compare: Mapping[str, str] = {\n            \"X-Custom\": \"value\",\n            \"Content-Type\": \"custom\",\n            \"Link\": '<http://warning.or.kr/>; rel=\"blocked-by\"',\n        }\n        assert exc.headers == compare\n        assert exc.reason == \"Zaprescheno\"\n        assert exc.status == 451",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert exc.link == URL('http://warning.or.kr/')",
        "assert exc.text == 'text'",
        "assert exc.headers == compare",
        "assert exc.reason == 'Zaprescheno'",
        "assert exc.status == 451"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_no_link",
      "module": "test_web_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 371,
      "end_line_number": 373,
      "source_code": "def test_no_link(self) -> None:\n        with pytest.raises(TypeError):\n            web.HTTPUnavailableForLegalReasons()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_none_link",
      "module": "test_web_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 375,
      "end_line_number": 378,
      "source_code": "def test_none_link(self) -> None:\n        exc = web.HTTPUnavailableForLegalReasons(link=None)\n        assert exc.link is None\n        assert \"Link\" not in exc.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert exc.link is None",
        "assert 'Link' not in exc.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_empty_link",
      "module": "test_web_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 380,
      "end_line_number": 383,
      "source_code": "def test_empty_link(self) -> None:\n        exc = web.HTTPUnavailableForLegalReasons(link=\"\")\n        assert exc.link is None\n        assert \"Link\" not in exc.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert exc.link is None",
        "assert 'Link' not in exc.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_link_str",
      "module": "test_web_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 385,
      "end_line_number": 388,
      "source_code": "def test_link_str(self) -> None:\n        exc = web.HTTPUnavailableForLegalReasons(link=\"http://warning.or.kr/\")\n        assert exc.link == URL(\"http://warning.or.kr/\")\n        assert exc.headers[\"Link\"] == '<http://warning.or.kr/>; rel=\"blocked-by\"'",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert exc.link == URL('http://warning.or.kr/')",
        "assert exc.headers['Link'] == '<http://warning.or.kr/>; rel=\"blocked-by\"'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_link_url",
      "module": "test_web_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 390,
      "end_line_number": 393,
      "source_code": "def test_link_url(self) -> None:\n        exc = web.HTTPUnavailableForLegalReasons(link=URL(\"http://warning.or.kr/\"))\n        assert exc.link == URL(\"http://warning.or.kr/\")\n        assert exc.headers[\"Link\"] == '<http://warning.or.kr/>; rel=\"blocked-by\"'",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert exc.link == URL('http://warning.or.kr/')",
        "assert exc.headers['Link'] == '<http://warning.or.kr/>; rel=\"blocked-by\"'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_link_CRLF",
      "module": "test_web_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 395,
      "end_line_number": 397,
      "source_code": "def test_link_CRLF(self) -> None:\n        exc = web.HTTPUnavailableForLegalReasons(link=\"http://warning.or.kr/\\r\\n\")\n        assert \"\\r\\n\" not in exc.headers[\"Link\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert '\\r\\n' not in exc.headers['Link']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_pickle",
      "module": "test_web_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_exceptions.py",
      "line_number": 399,
      "end_line_number": 416,
      "source_code": "def test_pickle(self) -> None:\n        resp = web.HTTPUnavailableForLegalReasons(\n            link=\"http://warning.or.kr/\",\n            headers={\"X-Custom\": \"value\"},\n            reason=\"Zaprescheno\",\n            text=\"text\",\n            content_type=\"custom\",\n        )\n        resp.foo = \"bar\"  # type: ignore[attr-defined]\n        for proto in range(2, pickle.HIGHEST_PROTOCOL + 1):\n            pickled = pickle.dumps(resp, proto)\n            resp2 = pickle.loads(pickled)\n            assert resp2.link == URL(\"http://warning.or.kr/\")\n            assert resp2.text == \"text\"\n            assert resp2.headers == resp.headers\n            assert resp2.reason == \"Zaprescheno\"\n            assert resp2.status == 451\n            assert resp2.foo == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections",
        "pickle",
        "traceback.format_exception",
        "typing.Mapping",
        "typing.NoReturn",
        "pytest",
        "yarl.URL",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp2.link == URL('http://warning.or.kr/')",
        "assert resp2.text == 'text'",
        "assert resp2.headers == resp.headers",
        "assert resp2.reason == 'Zaprescheno'",
        "assert resp2.status == 451",
        "assert resp2.foo == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_register_uncommon_http_methods",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 59,
      "end_line_number": 73,
      "source_code": "def test_register_uncommon_http_methods(router: web.UrlDispatcher) -> None:\n    uncommon_http_methods = {\n        \"PROPFIND\",\n        \"PROPPATCH\",\n        \"COPY\",\n        \"LOCK\",\n        \"UNLOCK\",\n        \"MOVE\",\n        \"SUBSCRIBE\",\n        \"UNSUBSCRIBE\",\n        \"NOTIFY\",\n    }\n\n    for method in uncommon_http_methods:\n        router.add_route(method, \"/handler/to/path\", make_handler())",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        }
      ]
    },
    {
      "name": "test_add_invalid_path",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 218,
      "end_line_number": 221,
      "source_code": "def test_add_invalid_path(router: web.UrlDispatcher) -> None:\n    handler = make_handler()\n    with pytest.raises(ValueError):\n        router.add_route(\"GET\", \"/{/\", handler)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        }
      ]
    },
    {
      "name": "test_add_url_invalid1",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 224,
      "end_line_number": 227,
      "source_code": "def test_add_url_invalid1(router: web.UrlDispatcher) -> None:\n    handler = make_handler()\n    with pytest.raises(ValueError):\n        router.add_route(\"post\", \"/post/{id\", handler)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        }
      ]
    },
    {
      "name": "test_add_url_invalid2",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 230,
      "end_line_number": 233,
      "source_code": "def test_add_url_invalid2(router: web.UrlDispatcher) -> None:\n    handler = make_handler()\n    with pytest.raises(ValueError):\n        router.add_route(\"post\", \"/post/{id{}}\", handler)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        }
      ]
    },
    {
      "name": "test_add_url_invalid3",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 236,
      "end_line_number": 239,
      "source_code": "def test_add_url_invalid3(router: web.UrlDispatcher) -> None:\n    handler = make_handler()\n    with pytest.raises(ValueError):\n        router.add_route(\"post\", \"/post/{id{}\", handler)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        }
      ]
    },
    {
      "name": "test_add_url_invalid4",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 242,
      "end_line_number": 245,
      "source_code": "def test_add_url_invalid4(router: web.UrlDispatcher) -> None:\n    handler = make_handler()\n    with pytest.raises(ValueError):\n        router.add_route(\"post\", '/post/{id\"}', handler)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        }
      ]
    },
    {
      "name": "test_double_add_url_with_the_same_name",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 322,
      "end_line_number": 329,
      "source_code": "def test_double_add_url_with_the_same_name(router: web.UrlDispatcher) -> None:\n    handler1 = make_handler()\n    handler2 = make_handler()\n    router.add_route(\"GET\", \"/get\", handler1, name=\"name\")\n\n    with pytest.raises(ValueError) as ctx:\n        router.add_route(\"GET\", \"/get_other\", handler2, name=\"name\")\n    assert str(ctx.value).startswith(\"Duplicate 'name', already handled by\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(ctx.value).startswith(\"Duplicate 'name', already handled by\")"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        },
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        }
      ]
    },
    {
      "name": "test_route_plain",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 332,
      "end_line_number": 338,
      "source_code": "def test_route_plain(router: web.UrlDispatcher) -> None:\n    handler = make_handler()\n    route = router.add_route(\"GET\", \"/get\", handler, name=\"name\")\n    route2 = next(iter(router[\"name\"]))\n    url = route2.url_for()\n    assert \"/get\" == str(url)\n    assert route is route2",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert '/get' == str(url)",
        "assert route is route2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        }
      ]
    },
    {
      "name": "test_route_unknown_route_name",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 341,
      "end_line_number": 343,
      "source_code": "def test_route_unknown_route_name(router: web.UrlDispatcher) -> None:\n    with pytest.raises(KeyError):\n        router[\"unknown\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_route_dynamic",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 346,
      "end_line_number": 353,
      "source_code": "def test_route_dynamic(router: web.UrlDispatcher) -> None:\n    handler = make_handler()\n    route = router.add_route(\"GET\", \"/get/{name}\", handler, name=\"name\")\n\n    route2 = next(iter(router[\"name\"]))\n    url = route2.url_for(name=\"John\")\n    assert \"/get/John\" == str(url)\n    assert route is route2",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert '/get/John' == str(url)",
        "assert route is route2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        }
      ]
    },
    {
      "name": "test_add_static_path_checks",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 356,
      "end_line_number": 363,
      "source_code": "def test_add_static_path_checks(\n    router: web.UrlDispatcher, tmp_path: pathlib.Path\n) -> None:\n    \"\"\"Test that static paths must exist and be directories.\"\"\"\n    with pytest.raises(ValueError, match=\"does not exist\"):\n        router.add_static(\"/\", tmp_path / \"does-not-exist\")\n        with pytest.raises(ValueError, match=\"is not a directory\"):\n            router.add_static(\"/\", __file__)",
      "docstring": "Test that static paths must exist and be directories.",
      "decorators": [],
      "arguments": [
        "router",
        "tmp_path"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_add_static_path_resolution",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 366,
      "end_line_number": 370,
      "source_code": "def test_add_static_path_resolution(router: web.UrlDispatcher) -> None:\n    \"\"\"Test that static paths are expanded and absolute.\"\"\"\n    res = router.add_static(\"/\", \"~/..\")\n    directory = str(res.get_info()[\"directory\"])\n    assert directory == str(pathlib.Path.home().parent)",
      "docstring": "Test that static paths are expanded and absolute.",
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert directory == str(pathlib.Path.home().parent)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_add_static",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 373,
      "end_line_number": 380,
      "source_code": "def test_add_static(router: web.UrlDispatcher) -> None:\n    resource = router.add_static(\n        \"/st\", pathlib.Path(aiohttp.__file__).parent, name=\"static\"\n    )\n    assert router[\"static\"] is resource\n    url = resource.url_for(filename=\"/dir/a.txt\")\n    assert \"/st/dir/a.txt\" == str(url)\n    assert len(resource) == 2",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert router['static'] is resource",
        "assert '/st/dir/a.txt' == str(url)",
        "assert len(resource) == 2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_add_static_append_version",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 383,
      "end_line_number": 389,
      "source_code": "def test_add_static_append_version(router: web.UrlDispatcher) -> None:\n    resource = router.add_static(\"/st\", pathlib.Path(__file__).parent, name=\"static\")\n    url = resource.url_for(filename=\"/data.unknown_mime_type\", append_version=True)\n    expect_url = (\n        \"/st/data.unknown_mime_type?v=aUsn8CHEhhszc81d28QmlcBW0KQpfS2F4trgQKhOYd8%3D\"\n    )\n    assert expect_url == str(url)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert expect_url == str(url)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_add_static_append_version_set_from_constructor",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 392,
      "end_line_number": 402,
      "source_code": "def test_add_static_append_version_set_from_constructor(\n    router: web.UrlDispatcher,\n) -> None:\n    resource = router.add_static(\n        \"/st\", pathlib.Path(__file__).parent, append_version=True, name=\"static\"\n    )\n    url = resource.url_for(filename=\"/data.unknown_mime_type\")\n    expect_url = (\n        \"/st/data.unknown_mime_type?v=aUsn8CHEhhszc81d28QmlcBW0KQpfS2F4trgQKhOYd8%3D\"\n    )\n    assert expect_url == str(url)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert expect_url == str(url)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_add_static_append_version_override_constructor",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 405,
      "end_line_number": 413,
      "source_code": "def test_add_static_append_version_override_constructor(\n    router: web.UrlDispatcher,\n) -> None:\n    resource = router.add_static(\n        \"/st\", pathlib.Path(__file__).parent, append_version=True, name=\"static\"\n    )\n    url = resource.url_for(filename=\"/data.unknown_mime_type\", append_version=False)\n    expect_url = \"/st/data.unknown_mime_type\"\n    assert expect_url == str(url)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert expect_url == str(url)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_add_static_append_version_filename_without_slash",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 416,
      "end_line_number": 424,
      "source_code": "def test_add_static_append_version_filename_without_slash(\n    router: web.UrlDispatcher,\n) -> None:\n    resource = router.add_static(\"/st\", pathlib.Path(__file__).parent, name=\"static\")\n    url = resource.url_for(filename=\"data.unknown_mime_type\", append_version=True)\n    expect_url = (\n        \"/st/data.unknown_mime_type?v=aUsn8CHEhhszc81d28QmlcBW0KQpfS2F4trgQKhOYd8%3D\"\n    )\n    assert expect_url == str(url)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert expect_url == str(url)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_add_static_append_version_non_exists_file",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 427,
      "end_line_number": 430,
      "source_code": "def test_add_static_append_version_non_exists_file(router: web.UrlDispatcher) -> None:\n    resource = router.add_static(\"/st\", pathlib.Path(__file__).parent, name=\"static\")\n    url = resource.url_for(filename=\"/non_exists_file\", append_version=True)\n    assert \"/st/non_exists_file\" == str(url)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert '/st/non_exists_file' == str(url)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_add_static_append_version_non_exists_file_without_slash",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 433,
      "end_line_number": 438,
      "source_code": "def test_add_static_append_version_non_exists_file_without_slash(\n    router: web.UrlDispatcher,\n) -> None:\n    resource = router.add_static(\"/st\", pathlib.Path(__file__).parent, name=\"static\")\n    url = resource.url_for(filename=\"non_exists_file\", append_version=True)\n    assert \"/st/non_exists_file\" == str(url)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert '/st/non_exists_file' == str(url)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_add_static_append_version_follow_symlink",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 441,
      "end_line_number": 460,
      "source_code": "def test_add_static_append_version_follow_symlink(\n    router: web.UrlDispatcher, tmp_path: pathlib.Path\n) -> None:\n    # Tests the access to a symlink, in static folder with apeend_version\n    symlink_path = tmp_path / \"append_version_symlink\"\n    symlink_target_path = pathlib.Path(__file__).parent\n    pathlib.Path(str(symlink_path)).symlink_to(str(symlink_target_path), True)\n\n    # Register global static route:\n    resource = router.add_static(\n        \"/st\", str(tmp_path), follow_symlinks=True, append_version=True\n    )\n\n    url = resource.url_for(filename=\"/append_version_symlink/data.unknown_mime_type\")\n\n    expect_url = (\n        \"/st/append_version_symlink/data.unknown_mime_type?\"\n        \"v=aUsn8CHEhhszc81d28QmlcBW0KQpfS2F4trgQKhOYd8%3D\"\n    )\n    assert expect_url == str(url)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router",
        "tmp_path"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert expect_url == str(url)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_add_static_append_version_not_follow_symlink",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 463,
      "end_line_number": 480,
      "source_code": "def test_add_static_append_version_not_follow_symlink(\n    router: web.UrlDispatcher, tmp_path: pathlib.Path\n) -> None:\n    # Tests the access to a symlink, in static folder with apeend_version\n\n    symlink_path = tmp_path / \"append_version_symlink\"\n    symlink_target_path = pathlib.Path(__file__).parent\n\n    pathlib.Path(str(symlink_path)).symlink_to(str(symlink_target_path), True)\n\n    # Register global static route:\n    resource = router.add_static(\n        \"/st\", str(tmp_path), follow_symlinks=False, append_version=True\n    )\n\n    filename = \"/append_version_symlink/data.unknown_mime_type\"\n    url = resource.url_for(filename=filename)\n    assert \"/st/append_version_symlink/data.unknown_mime_type\" == str(url)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router",
        "tmp_path"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert '/st/append_version_symlink/data.unknown_mime_type' == str(url)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_add_static_quoting",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 483,
      "end_line_number": 494,
      "source_code": "def test_add_static_quoting(router: web.UrlDispatcher) -> None:\n    resource = router.add_static(\n        \"/\u043f\u0440\u0435 %2F\u0444\u0438\u043a\u0441\", pathlib.Path(aiohttp.__file__).parent, name=\"static\"\n    )\n    assert router[\"static\"] is resource\n    url = resource.url_for(filename=\"/1 2/\u0444\u0430\u0439\u043b%2F.txt\")\n    assert url.path == \"/\u043f\u0440\u0435 /\u0444\u0438\u043a\u0441/1 2/\u0444\u0430\u0439\u043b%2F.txt\"\n    assert str(url) == (\n        \"/%D0%BF%D1%80%D0%B5%20%2F%D1%84%D0%B8%D0%BA%D1%81\"\n        \"/1%202/%D1%84%D0%B0%D0%B9%D0%BB%252F.txt\"\n    )\n    assert len(resource) == 2",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert router['static'] is resource",
        "assert url.path == '/\u043f\u0440\u0435 /\u0444\u0438\u043a\u0441/1 2/\u0444\u0430\u0439\u043b%2F.txt'",
        "assert str(url) == '/%D0%BF%D1%80%D0%B5%20%2F%D1%84%D0%B8%D0%BA%D1%81/1%202/%D1%84%D0%B0%D0%B9%D0%BB%252F.txt'",
        "assert len(resource) == 2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_plain_not_match",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 497,
      "end_line_number": 502,
      "source_code": "def test_plain_not_match(router: web.UrlDispatcher) -> None:\n    handler = make_handler()\n    router.add_route(\"GET\", \"/get/path\", handler, name=\"name\")\n    route = router[\"name\"]\n    assert isinstance(route, web.Resource)\n    assert route._match(\"/another/path\") is None",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(route, web.Resource)",
        "assert route._match('/another/path') is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        }
      ]
    },
    {
      "name": "test_dynamic_not_match",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 505,
      "end_line_number": 510,
      "source_code": "def test_dynamic_not_match(router: web.UrlDispatcher) -> None:\n    handler = make_handler()\n    router.add_route(\"GET\", \"/get/{name}\", handler, name=\"name\")\n    route = router[\"name\"]\n    assert isinstance(route, web.Resource)\n    assert route._match(\"/another/path\") is None",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(route, web.Resource)",
        "assert route._match('/another/path') is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        }
      ]
    },
    {
      "name": "test_dynamic_with_trailing_slash",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 520,
      "end_line_number": 525,
      "source_code": "def test_dynamic_with_trailing_slash(router: web.UrlDispatcher) -> None:\n    handler = make_handler()\n    router.add_route(\"GET\", \"/get/{name}/\", handler, name=\"name\")\n    route = router[\"name\"]\n    assert isinstance(route, web.Resource)\n    assert {\"name\": \"John\"} == route._match(\"/get/John/\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(route, web.Resource)",
        "assert {'name': 'John'} == route._match('/get/John/')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        }
      ]
    },
    {
      "name": "test_len",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 528,
      "end_line_number": 532,
      "source_code": "def test_len(router: web.UrlDispatcher) -> None:\n    handler = make_handler()\n    router.add_route(\"GET\", \"/get1\", handler, name=\"name1\")\n    router.add_route(\"GET\", \"/get2\", handler, name=\"name2\")\n    assert 2 == len(router)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert 2 == len(router)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        }
      ]
    },
    {
      "name": "test_iter",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 535,
      "end_line_number": 539,
      "source_code": "def test_iter(router: web.UrlDispatcher) -> None:\n    handler = make_handler()\n    router.add_route(\"GET\", \"/get1\", handler, name=\"name1\")\n    router.add_route(\"GET\", \"/get2\", handler, name=\"name2\")\n    assert {\"name1\", \"name2\"} == set(iter(router))",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert {'name1', 'name2'} == set(iter(router))"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        }
      ]
    },
    {
      "name": "test_contains",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 542,
      "end_line_number": 547,
      "source_code": "def test_contains(router: web.UrlDispatcher) -> None:\n    handler = make_handler()\n    router.add_route(\"GET\", \"/get1\", handler, name=\"name1\")\n    router.add_route(\"GET\", \"/get2\", handler, name=\"name2\")\n    assert \"name1\" in router\n    assert \"name3\" not in router",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'name1' in router",
        "assert 'name3' not in router"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        }
      ]
    },
    {
      "name": "test_static_repr",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 550,
      "end_line_number": 552,
      "source_code": "def test_static_repr(router: web.UrlDispatcher) -> None:\n    router.add_static(\"/get\", pathlib.Path(aiohttp.__file__).parent, name=\"name\")\n    assert repr(router[\"name\"]).startswith(\"<StaticResource 'name' /get\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(router['name']).startswith(\"<StaticResource 'name' /get\")"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_static_adds_slash",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 555,
      "end_line_number": 557,
      "source_code": "def test_static_adds_slash(router: web.UrlDispatcher) -> None:\n    route = router.add_static(\"/prefix\", pathlib.Path(aiohttp.__file__).parent)\n    assert \"/prefix\" == route._prefix",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert '/prefix' == route._prefix"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_static_remove_trailing_slash",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 560,
      "end_line_number": 562,
      "source_code": "def test_static_remove_trailing_slash(router: web.UrlDispatcher) -> None:\n    route = router.add_static(\"/prefix/\", pathlib.Path(aiohttp.__file__).parent)\n    assert \"/prefix\" == route._prefix",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert '/prefix' == route._prefix"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_add_route_with_invalid_re",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 621,
      "end_line_number": 633,
      "source_code": "def test_add_route_with_invalid_re(router: web.UrlDispatcher) -> None:\n    handler = make_handler()\n    with pytest.raises(ValueError) as ctx:\n        router.add_route(\"GET\", r\"/handler/{to:+++}\", handler)\n    s = str(ctx.value)\n    assert s.startswith(\n        \"Bad pattern '\"\n        + PATH_SEP\n        + \"handler\"\n        + PATH_SEP\n        + \"(?P<to>+++)': nothing to repeat\"\n    )\n    assert ctx.value.__cause__ is None",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert s.startswith(\"Bad pattern '\" + PATH_SEP + 'handler' + PATH_SEP + \"(?P<to>+++)': nothing to repeat\")",
        "assert ctx.value.__cause__ is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        }
      ]
    },
    {
      "name": "test_route_dynamic_with_regex_spec",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 636,
      "end_line_number": 641,
      "source_code": "def test_route_dynamic_with_regex_spec(router: web.UrlDispatcher) -> None:\n    handler = make_handler()\n    route = router.add_route(\"GET\", r\"/get/{num:^\\d+}\", handler, name=\"name\")\n\n    url = route.url_for(num=\"123\")\n    assert \"/get/123\" == str(url)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert '/get/123' == str(url)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        }
      ]
    },
    {
      "name": "test_route_dynamic_with_regex_spec_and_trailing_slash",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 644,
      "end_line_number": 651,
      "source_code": "def test_route_dynamic_with_regex_spec_and_trailing_slash(\n    router: web.UrlDispatcher,\n) -> None:\n    handler = make_handler()\n    route = router.add_route(\"GET\", r\"/get/{num:^\\d+}/\", handler, name=\"name\")\n\n    url = route.url_for(num=\"123\")\n    assert \"/get/123/\" == str(url)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert '/get/123/' == str(url)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        }
      ]
    },
    {
      "name": "test_route_dynamic_with_regex",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 654,
      "end_line_number": 659,
      "source_code": "def test_route_dynamic_with_regex(router: web.UrlDispatcher) -> None:\n    handler = make_handler()\n    route = router.add_route(\"GET\", r\"/{one}/{two:.+}\", handler)\n\n    url = route.url_for(one=\"1\", two=\"2\")\n    assert \"/1/2\" == str(url)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert '/1/2' == str(url)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        }
      ]
    },
    {
      "name": "test_route_dynamic_quoting",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 662,
      "end_line_number": 671,
      "source_code": "def test_route_dynamic_quoting(router: web.UrlDispatcher) -> None:\n    handler = make_handler()\n    route = router.add_route(\"GET\", r\"/\u043f\u0440\u0435 %2F\u0444\u0438\u043a\u0441/{arg}\", handler)\n\n    url = route.url_for(arg=\"1 2/\u0442\u0435\u043a\u0441\u0442%2F\")\n    assert url.path == \"/\u043f\u0440\u0435 /\u0444\u0438\u043a\u0441/1 2/\u0442\u0435\u043a\u0441\u0442%2F\"\n    assert str(url) == (\n        \"/%D0%BF%D1%80%D0%B5%20%2F%D1%84%D0%B8%D0%BA%D1%81\"\n        \"/1%202/%D1%82%D0%B5%D0%BA%D1%81%D1%82%252F\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert url.path == '/\u043f\u0440\u0435 /\u0444\u0438\u043a\u0441/1 2/\u0442\u0435\u043a\u0441\u0442%2F'",
        "assert str(url) == '/%D0%BF%D1%80%D0%B5%20%2F%D1%84%D0%B8%D0%BA%D1%81/1%202/%D1%82%D0%B5%D0%BA%D1%81%D1%82%252F'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        }
      ]
    },
    {
      "name": "test_default_expect_handler",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 712,
      "end_line_number": 714,
      "source_code": "def test_default_expect_handler(router: web.UrlDispatcher) -> None:\n    route = router.add_route(\"GET\", \"/\", make_handler())\n    assert route._expect_handler is _default_expect_handler",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert route._expect_handler is _default_expect_handler"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        }
      ]
    },
    {
      "name": "test_custom_expect_handler_plain",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 717,
      "end_line_number": 723,
      "source_code": "def test_custom_expect_handler_plain(router: web.UrlDispatcher) -> None:\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    route = router.add_route(\"GET\", \"/\", make_handler(), expect_handler=handler)\n    assert route._expect_handler is handler\n    assert isinstance(route, web.ResourceRoute)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert route._expect_handler is handler",
        "assert isinstance(route, web.ResourceRoute)",
        "assert False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        }
      ]
    },
    {
      "name": "test_custom_expect_handler_dynamic",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 726,
      "end_line_number": 734,
      "source_code": "def test_custom_expect_handler_dynamic(router: web.UrlDispatcher) -> None:\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    route = router.add_route(\n        \"GET\", \"/get/{name}\", make_handler(), expect_handler=handler\n    )\n    assert route._expect_handler is handler\n    assert isinstance(route, web.ResourceRoute)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert route._expect_handler is handler",
        "assert isinstance(route, web.ResourceRoute)",
        "assert False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        }
      ]
    },
    {
      "name": "test_expect_handler_non_coroutine",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 737,
      "end_line_number": 742,
      "source_code": "def test_expect_handler_non_coroutine(router: web.UrlDispatcher) -> None:\n    def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    with pytest.raises(AssertionError):\n        router.add_route(\"GET\", \"/\", make_handler(), expect_handler=handler)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        }
      ]
    },
    {
      "name": "test_add_route_not_started_with_slash",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 791,
      "end_line_number": 794,
      "source_code": "def test_add_route_not_started_with_slash(router: web.UrlDispatcher) -> None:\n    with pytest.raises(ValueError):\n        handler = make_handler()\n        router.add_route(\"GET\", \"invalid_path\", handler)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        }
      ]
    },
    {
      "name": "test_add_route_invalid_method",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 797,
      "end_line_number": 810,
      "source_code": "def test_add_route_invalid_method(router: web.UrlDispatcher) -> None:\n    sample_bad_methods = {\n        \"BAD METHOD\",\n        \"B@D_METHOD\",\n        \"[BAD_METHOD]\",\n        \"{BAD_METHOD}\",\n        \"(BAD_METHOD)\",\n        \"B?D_METHOD\",\n    }\n\n    for bad_method in sample_bad_methods:\n        with pytest.raises(ValueError):\n            handler = make_handler()\n            router.add_route(bad_method, \"/path\", handler)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        }
      ]
    },
    {
      "name": "test_routes_view_len",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 813,
      "end_line_number": 817,
      "source_code": "def test_routes_view_len(\n    router: web.UrlDispatcher, fill_routes: Callable[[], List[web.AbstractRoute]]\n) -> None:\n    fill_routes()\n    assert 4 == len(router.routes())",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router",
        "fill_routes"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert 4 == len(router.routes())"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "fill_routes",
          "body": "@pytest.fixture\ndef fill_routes(router: web.UrlDispatcher) -> Callable[[], List[web.AbstractRoute]]:\n\n    def go() -> List[web.AbstractRoute]:\n        route1 = router.add_route('GET', '/plain', make_handler())\n        route2 = router.add_route('GET', '/variable/{name}', make_handler())\n        resource = router.add_static('/static', pathlib.Path(aiohttp.__file__).parent)\n        return [route1, route2] + list(resource)\n    return go"
        }
      ]
    },
    {
      "name": "test_routes_view_iter",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 820,
      "end_line_number": 824,
      "source_code": "def test_routes_view_iter(\n    router: web.UrlDispatcher, fill_routes: Callable[[], List[web.AbstractRoute]]\n) -> None:\n    routes = fill_routes()\n    assert list(routes) == list(router.routes())",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router",
        "fill_routes"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert list(routes) == list(router.routes())"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "fill_routes",
          "body": "@pytest.fixture\ndef fill_routes(router: web.UrlDispatcher) -> Callable[[], List[web.AbstractRoute]]:\n\n    def go() -> List[web.AbstractRoute]:\n        route1 = router.add_route('GET', '/plain', make_handler())\n        route2 = router.add_route('GET', '/variable/{name}', make_handler())\n        resource = router.add_static('/static', pathlib.Path(aiohttp.__file__).parent)\n        return [route1, route2] + list(resource)\n    return go"
        }
      ]
    },
    {
      "name": "test_routes_view_contains",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 827,
      "end_line_number": 832,
      "source_code": "def test_routes_view_contains(\n    router: web.UrlDispatcher, fill_routes: Callable[[], List[web.AbstractRoute]]\n) -> None:\n    routes = fill_routes()\n    for route in routes:\n        assert route in router.routes()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router",
        "fill_routes"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert route in router.routes()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "fill_routes",
          "body": "@pytest.fixture\ndef fill_routes(router: web.UrlDispatcher) -> Callable[[], List[web.AbstractRoute]]:\n\n    def go() -> List[web.AbstractRoute]:\n        route1 = router.add_route('GET', '/plain', make_handler())\n        route2 = router.add_route('GET', '/variable/{name}', make_handler())\n        resource = router.add_static('/static', pathlib.Path(aiohttp.__file__).parent)\n        return [route1, route2] + list(resource)\n    return go"
        }
      ]
    },
    {
      "name": "test_routes_abc",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 835,
      "end_line_number": 838,
      "source_code": "def test_routes_abc(router: web.UrlDispatcher) -> None:\n    assert isinstance(router.routes(), Sized)\n    assert isinstance(router.routes(), Iterable)\n    assert isinstance(router.routes(), Container)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(router.routes(), Sized)",
        "assert isinstance(router.routes(), Iterable)",
        "assert isinstance(router.routes(), Container)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_named_resources_abc",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 841,
      "end_line_number": 843,
      "source_code": "def test_named_resources_abc(router: web.UrlDispatcher) -> None:\n    assert isinstance(router.named_resources(), Mapping)\n    assert not isinstance(router.named_resources(), MutableMapping)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(router.named_resources(), Mapping)",
        "assert not isinstance(router.named_resources(), MutableMapping)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_named_resources",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 846,
      "end_line_number": 859,
      "source_code": "def test_named_resources(router: web.UrlDispatcher) -> None:\n    route1 = router.add_route(\"GET\", \"/plain\", make_handler(), name=\"route1\")\n    route2 = router.add_route(\"GET\", \"/variable/{name}\", make_handler(), name=\"route2\")\n    route3 = router.add_static(\n        \"/static\", pathlib.Path(aiohttp.__file__).parent, name=\"route3\"\n    )\n    names = {route1.name, route2.name, route3.name}\n\n    assert 3 == len(router.named_resources())\n\n    for name in names:\n        assert name is not None\n        assert name in router.named_resources()\n        assert isinstance(router.named_resources()[name], web.AbstractResource)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert 3 == len(router.named_resources())",
        "assert name is not None",
        "assert name in router.named_resources()",
        "assert isinstance(router.named_resources()[name], web.AbstractResource)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        },
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        }
      ]
    },
    {
      "name": "test_resource_iter",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 862,
      "end_line_number": 870,
      "source_code": "def test_resource_iter(router: web.UrlDispatcher) -> None:\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    resource = router.add_resource(\"/path\")\n    r1 = resource.add_route(\"GET\", handler)\n    r2 = resource.add_route(\"POST\", handler)\n    assert 2 == len(resource)\n    assert [r1, r2] == list(resource)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert 2 == len(resource)",
        "assert [r1, r2] == list(resource)",
        "assert False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_view_route",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 873,
      "end_line_number": 877,
      "source_code": "def test_view_route(router: web.UrlDispatcher) -> None:\n    resource = router.add_resource(\"/path\")\n\n    route = resource.add_route(\"*\", web.View)\n    assert web.View is route.handler",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert web.View is route.handler"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_resource_route_match",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 880,
      "end_line_number": 887,
      "source_code": "def test_resource_route_match(router: web.UrlDispatcher) -> None:\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    resource = router.add_resource(\"/path\")\n    route = resource.add_route(\"GET\", handler)\n    assert isinstance(route.resource, web.Resource)\n    assert {} == route.resource._match(\"/path\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(route.resource, web.Resource)",
        "assert {} == route.resource._match('/path')",
        "assert False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_error_on_double_route_adding",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 890,
      "end_line_number": 898,
      "source_code": "def test_error_on_double_route_adding(router: web.UrlDispatcher) -> None:\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    resource = router.add_resource(\"/path\")\n\n    resource.add_route(\"GET\", handler)\n    with pytest.raises(RuntimeError):\n        resource.add_route(\"GET\", handler)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_error_on_adding_route_after_wildcard",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 901,
      "end_line_number": 909,
      "source_code": "def test_error_on_adding_route_after_wildcard(router: web.UrlDispatcher) -> None:\n    async def handler(request: web.Request) -> NoReturn:\n        assert False\n\n    resource = router.add_resource(\"/path\")\n\n    resource.add_route(\"*\", handler)\n    with pytest.raises(RuntimeError):\n        resource.add_route(\"GET\", handler)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_static_resource_get_info",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 963,
      "end_line_number": 970,
      "source_code": "def test_static_resource_get_info(router: web.UrlDispatcher) -> None:\n    directory = pathlib.Path(aiohttp.__file__).parent.resolve()\n    resource = router.add_static(\"/st\", directory)\n    info = resource.get_info()\n    assert len(info) == 3\n    assert info[\"directory\"] == directory\n    assert info[\"prefix\"] == \"/st\"\n    assert all([type(r) is web.ResourceRoute for r in info[\"routes\"].values()])",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(info) == 3",
        "assert info['directory'] == directory",
        "assert info['prefix'] == '/st'",
        "assert all([type(r) is web.ResourceRoute for r in info['routes'].values()])"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_resources_view_len",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 981,
      "end_line_number": 984,
      "source_code": "def test_resources_view_len(router: web.UrlDispatcher) -> None:\n    router.add_resource(\"/plain\")\n    router.add_resource(\"/variable/{name}\")\n    assert 2 == len(router.resources())",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert 2 == len(router.resources())"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_resources_view_iter",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 987,
      "end_line_number": 991,
      "source_code": "def test_resources_view_iter(router: web.UrlDispatcher) -> None:\n    resource1 = router.add_resource(\"/plain\")\n    resource2 = router.add_resource(\"/variable/{name}\")\n    resources = [resource1, resource2]\n    assert list(resources) == list(router.resources())",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert list(resources) == list(router.resources())"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_resources_view_contains",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 994,
      "end_line_number": 999,
      "source_code": "def test_resources_view_contains(router: web.UrlDispatcher) -> None:\n    resource1 = router.add_resource(\"/plain\")\n    resource2 = router.add_resource(\"/variable/{name}\")\n    resources = [resource1, resource2]\n    for resource in resources:\n        assert resource in router.resources()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert resource in router.resources()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_resources_abc",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 1002,
      "end_line_number": 1005,
      "source_code": "def test_resources_abc(router: web.UrlDispatcher) -> None:\n    assert isinstance(router.resources(), Sized)\n    assert isinstance(router.resources(), Iterable)\n    assert isinstance(router.resources(), Container)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(router.resources(), Sized)",
        "assert isinstance(router.resources(), Iterable)",
        "assert isinstance(router.resources(), Container)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_static_route_user_home",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 1008,
      "end_line_number": 1015,
      "source_code": "def test_static_route_user_home(router: web.UrlDispatcher) -> None:\n    here = pathlib.Path(aiohttp.__file__).parent\n    try:\n        static_dir = pathlib.Path(\"~\") / here.relative_to(pathlib.Path.home())\n    except ValueError:\n        pytest.skip(\"aiohttp folder is not placed in user's HOME\")\n    route = router.add_static(\"/st\", str(static_dir))\n    assert here == route.get_info()[\"directory\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert here == route.get_info()['directory']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_static_route_points_to_file",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 1018,
      "end_line_number": 1021,
      "source_code": "def test_static_route_points_to_file(router: web.UrlDispatcher) -> None:\n    here = pathlib.Path(aiohttp.__file__).parent / \"__init__.py\"\n    with pytest.raises(ValueError):\n        router.add_static(\"/st\", here)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_url_for_in_static_resource",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 1047,
      "end_line_number": 1049,
      "source_code": "def test_url_for_in_static_resource(router: web.UrlDispatcher) -> None:\n    resource = router.add_static(\"/static\", pathlib.Path(aiohttp.__file__).parent)\n    assert URL(\"/static/file.txt\") == resource.url_for(filename=\"file.txt\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert URL('/static/file.txt') == resource.url_for(filename='file.txt')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_url_for_in_static_resource_pathlib",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 1052,
      "end_line_number": 1056,
      "source_code": "def test_url_for_in_static_resource_pathlib(router: web.UrlDispatcher) -> None:\n    resource = router.add_static(\"/static\", pathlib.Path(aiohttp.__file__).parent)\n    assert URL(\"/static/file.txt\") == resource.url_for(\n        filename=pathlib.Path(\"file.txt\")\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert URL('/static/file.txt') == resource.url_for(filename=pathlib.Path('file.txt'))"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_url_for_in_resource_route",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 1059,
      "end_line_number": 1061,
      "source_code": "def test_url_for_in_resource_route(router: web.UrlDispatcher) -> None:\n    route = router.add_route(\"GET\", \"/get/{name}\", make_handler(), name=\"name\")\n    assert URL(\"/get/John\") == route.url_for(name=\"John\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert URL('/get/John') == route.url_for(name='John')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        }
      ]
    },
    {
      "name": "test_subapp_get_info",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 1064,
      "end_line_number": 1067,
      "source_code": "def test_subapp_get_info(app: web.Application) -> None:\n    subapp = web.Application()\n    resource = subapp.add_subapp(\"/pre\", subapp)\n    assert resource.get_info() == {\"prefix\": \"/pre\", \"app\": subapp}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert resource.get_info() == {'prefix': '/pre', 'app': subapp}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_domain_validation_error",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 1080,
      "end_line_number": 1082,
      "source_code": "def test_domain_validation_error(domain: Optional[str], error: Type[Exception]) -> None:\n    with pytest.raises(error):\n        Domain(domain)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('domain,error', [(None, TypeError), ('', ValueError), ('http://dom', ValueError), ('*.example.com', ValueError), ('example$com', ValueError)])"
      ],
      "arguments": [
        "domain",
        "error"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_domain_valid",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 1085,
      "end_line_number": 1088,
      "source_code": "def test_domain_valid() -> None:\n    assert Domain(\"example.com:81\").canonical == \"example.com:81\"\n    assert MaskDomain(\"*.example.com\").canonical == r\".*\\.example\\.com\"\n    assert Domain(\"\u043f\u0443\u043d\u0438.\u043a\u043e\u0434\").canonical == \"xn--h1ajfq.xn--d1alm\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert Domain('example.com:81').canonical == 'example.com:81'",
        "assert MaskDomain('*.example.com').canonical == '.*\\\\.example\\\\.com'",
        "assert Domain('\u043f\u0443\u043d\u0438.\u043a\u043e\u0434').canonical == 'xn--h1ajfq.xn--d1alm'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_match_domain",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 1103,
      "end_line_number": 1108,
      "source_code": "def test_match_domain(a: str, b: str, result: bool) -> None:\n    if \"*\" in a:\n        rule: Domain = MaskDomain(a)\n    else:\n        rule = Domain(a)\n    assert rule.match_domain(b) is result",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('a,b,result', [('example.com', 'example.com', True), ('example.com:81', 'example.com:81', True), ('example.com:81', 'example.com', False), ('\u043f\u0443\u043d\u0438\u043a\u043e\u0434', 'xn--d1ahgkhc2a', True), ('*.example.com', 'jpg.example.com', True), ('*.example.com', 'a.example.com', True), ('*.example.com', 'example.com', False)])"
      ],
      "arguments": [
        "a",
        "b",
        "result"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert rule.match_domain(b) is result"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_add_subapp_errors",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 1111,
      "end_line_number": 1113,
      "source_code": "def test_add_subapp_errors(app: web.Application) -> None:\n    with pytest.raises(TypeError):\n        app.add_subapp(1, web.Application())",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_subapp_rule_resource",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 1116,
      "end_line_number": 1130,
      "source_code": "def test_subapp_rule_resource(app: web.Application) -> None:\n    subapp = web.Application()\n    subapp.router.add_get(\"/\", make_handler())\n    rule = Domain(\"example.com\")\n    assert rule.get_info() == {\"domain\": \"example.com\"}\n    resource = app.add_domain(\"example.com\", subapp)\n    assert resource.canonical == \"example.com\"\n    assert resource.get_info() == {\"rule\": resource._rule, \"app\": subapp}\n    resource.add_prefix(\"/a\")\n    resource.raw_match(\"/b\")\n    assert len(resource)\n    assert list(resource)\n    assert repr(resource).startswith(\"<MatchedSubAppResource\")\n    with pytest.raises(RuntimeError):\n        resource.url_for()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert rule.get_info() == {'domain': 'example.com'}",
        "assert resource.canonical == 'example.com'",
        "assert resource.get_info() == {'rule': resource._rule, 'app': subapp}",
        "assert len(resource)",
        "assert list(resource)",
        "assert repr(resource).startswith('<MatchedSubAppResource')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        }
      ]
    },
    {
      "name": "test_subapp_url_for",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 1176,
      "end_line_number": 1180,
      "source_code": "def test_subapp_url_for(app: web.Application) -> None:\n    subapp = web.Application()\n    resource = app.add_subapp(\"/pre\", subapp)\n    with pytest.raises(RuntimeError):\n        resource.url_for()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_subapp_repr",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 1183,
      "end_line_number": 1186,
      "source_code": "def test_subapp_repr(app: web.Application) -> None:\n    subapp = web.Application()\n    resource = app.add_subapp(\"/pre\", subapp)\n    assert repr(resource).startswith(\"<PrefixedSubAppResource /pre -> <Application\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(resource).startswith('<PrefixedSubAppResource /pre -> <Application')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_subapp_len",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 1189,
      "end_line_number": 1194,
      "source_code": "def test_subapp_len(app: web.Application) -> None:\n    subapp = web.Application()\n    subapp.router.add_get(\"/\", make_handler(), allow_head=False)\n    subapp.router.add_post(\"/\", make_handler())\n    resource = app.add_subapp(\"/pre\", subapp)\n    assert len(resource) == 2",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(resource) == 2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        },
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        }
      ]
    },
    {
      "name": "test_subapp_iter",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 1197,
      "end_line_number": 1202,
      "source_code": "def test_subapp_iter(app: web.Application) -> None:\n    subapp = web.Application()\n    r1 = subapp.router.add_get(\"/\", make_handler(), allow_head=False)\n    r2 = subapp.router.add_post(\"/\", make_handler())\n    resource = app.add_subapp(\"/pre\", subapp)\n    assert list(resource) == [r1, r2]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert list(resource) == [r1, r2]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        },
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        }
      ]
    },
    {
      "name": "test_invalid_route_name",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 1212,
      "end_line_number": 1214,
      "source_code": "def test_invalid_route_name(router: web.UrlDispatcher, route_name: str) -> None:\n    with pytest.raises(ValueError):\n        router.add_get(\"/\", make_handler(), name=route_name)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('route_name', ('invalid name', 'class'))"
      ],
      "arguments": [
        "router",
        "route_name"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        }
      ]
    },
    {
      "name": "test_frozen_router",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 1217,
      "end_line_number": 1220,
      "source_code": "def test_frozen_router(router: web.UrlDispatcher) -> None:\n    router.freeze()\n    with pytest.raises(RuntimeError):\n        router.add_get(\"/\", make_handler())",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        }
      ]
    },
    {
      "name": "test_frozen_router_subapp",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 1223,
      "end_line_number": 1227,
      "source_code": "def test_frozen_router_subapp(app: web.Application) -> None:\n    subapp = web.Application()\n    subapp.freeze()\n    with pytest.raises(RuntimeError):\n        app.add_subapp(\"/pre\", subapp)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_frozen_app_on_subapp",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 1230,
      "end_line_number": 1234,
      "source_code": "def test_frozen_app_on_subapp(app: web.Application) -> None:\n    app.freeze()\n    subapp = web.Application()\n    with pytest.raises(RuntimeError):\n        app.add_subapp(\"/pre\", subapp)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_set_options_route",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 1237,
      "end_line_number": 1251,
      "source_code": "def test_set_options_route(router: web.UrlDispatcher) -> None:\n    resource = router.add_static(\"/static\", pathlib.Path(aiohttp.__file__).parent)\n    options = None\n    for route in resource:\n        if route.method == \"OPTIONS\":\n            options = route\n    assert options is None\n    resource.set_options_route(make_handler())\n    for route in resource:\n        if route.method == \"OPTIONS\":\n            options = route\n    assert options is not None\n\n    with pytest.raises(RuntimeError):\n        resource.set_options_route(make_handler())",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert options is None",
        "assert options is not None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        },
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        }
      ]
    },
    {
      "name": "test_dynamic_url_with_name_started_from_underscore",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 1254,
      "end_line_number": 1258,
      "source_code": "def test_dynamic_url_with_name_started_from_underscore(\n    router: web.UrlDispatcher,\n) -> None:\n    route = router.add_route(\"GET\", \"/get/{_name}\", make_handler())\n    assert URL(\"/get/John\") == route.url_for(_name=\"John\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "router"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert URL('/get/John') == route.url_for(_name='John')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_handler",
          "body": "def make_handler(appname: str) -> Handler:\n\n    async def handler(request: web.Request) -> web.Response:\n        values.append(f'{appname}: {request.app[my_value]}')\n        return web.Response(text='Ok')\n    return handler"
        }
      ]
    },
    {
      "name": "test_cannot_add_subapp_with_empty_prefix",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 1261,
      "end_line_number": 1264,
      "source_code": "def test_cannot_add_subapp_with_empty_prefix(app: web.Application) -> None:\n    subapp = web.Application()\n    with pytest.raises(ValueError):\n        app.add_subapp(\"\", subapp)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_cannot_add_subapp_with_slash_prefix",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 1267,
      "end_line_number": 1270,
      "source_code": "def test_cannot_add_subapp_with_slash_prefix(app: web.Application) -> None:\n    subapp = web.Application()\n    with pytest.raises(ValueError):\n        app.add_subapp(\"/\", subapp)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_plain_resource_canonical",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 1285,
      "end_line_number": 1288,
      "source_code": "def test_plain_resource_canonical() -> None:\n    canonical = \"/plain/path\"\n    res = web.PlainResource(path=canonical)\n    assert res.canonical == canonical",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert res.canonical == canonical"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_dynamic_resource_canonical",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 1291,
      "end_line_number": 1300,
      "source_code": "def test_dynamic_resource_canonical() -> None:\n    canonicals = {\n        \"/get/{name}\": \"/get/{name}\",\n        r\"/get/{num:^\\d+}\": \"/get/{num}\",\n        r\"/handler/{to:\\d+}\": r\"/handler/{to}\",\n        r\"/{one}/{two:.+}\": r\"/{one}/{two}\",\n    }\n    for pattern, canonical in canonicals.items():\n        res = web.DynamicResource(path=pattern)\n        assert res.canonical == canonical",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert res.canonical == canonical"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_static_resource_canonical",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 1303,
      "end_line_number": 1308,
      "source_code": "def test_static_resource_canonical() -> None:\n    prefix = \"/prefix\"\n    directory = str(pathlib.Path(aiohttp.__file__).parent)\n    canonical = prefix\n    res = web.StaticResource(prefix=prefix, directory=directory)\n    assert res.canonical == canonical",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert res.canonical == canonical"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_prefixed_subapp_resource_canonical",
      "module": "test_urldispatch",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_urldispatch.py",
      "line_number": 1311,
      "end_line_number": 1315,
      "source_code": "def test_prefixed_subapp_resource_canonical(app: web.Application) -> None:\n    canonical = \"/prefix\"\n    subapp = web.Application()\n    res = subapp.add_subapp(canonical, subapp)\n    assert res.canonical == canonical",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "pathlib",
        "re",
        "collections.abc.Container",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.MutableMapping",
        "collections.abc.Sized",
        "functools.partial",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Type",
        "urllib.parse.quote",
        "urllib.parse.unquote",
        "pytest",
        "yarl.URL",
        "aiohttp",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_urldispatcher.PATH_SEP",
        "aiohttp.web_urldispatcher.Domain",
        "aiohttp.web_urldispatcher.MaskDomain",
        "aiohttp.web_urldispatcher.SystemRoute",
        "aiohttp.web_urldispatcher._default_expect_handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert res.canonical == canonical"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_parse_mimetype",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 77,
      "end_line_number": 81,
      "source_code": "def test_parse_mimetype(mimetype: str, expected: helpers.MimeType) -> None:\n    result = helpers.parse_mimetype(mimetype)\n\n    assert isinstance(result, helpers.MimeType)\n    assert result == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('mimetype, expected', [('', helpers.MimeType('', '', '', MultiDictProxy(MultiDict()))), ('*', helpers.MimeType('*', '*', '', MultiDictProxy(MultiDict()))), ('application/json', helpers.MimeType('application', 'json', '', MultiDictProxy(MultiDict()))), ('application/json;  charset=utf-8', helpers.MimeType('application', 'json', '', MultiDictProxy(MultiDict({'charset': 'utf-8'})))), ('application/json; charset=utf-8;', helpers.MimeType('application', 'json', '', MultiDictProxy(MultiDict({'charset': 'utf-8'})))), ('ApPlIcAtIoN/JSON;ChaRseT=\"UTF-8\"', helpers.MimeType('application', 'json', '', MultiDictProxy(MultiDict({'charset': 'UTF-8'})))), ('application/rss+xml', helpers.MimeType('application', 'rss', 'xml', MultiDictProxy(MultiDict()))), ('text/plain;base64', helpers.MimeType('text', 'plain', '', MultiDictProxy(MultiDict({'base64': ''}))))])"
      ],
      "arguments": [
        "mimetype",
        "expected"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(result, helpers.MimeType)",
        "assert result == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_guess_filename_with_file_object",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 87,
      "end_line_number": 90,
      "source_code": "def test_guess_filename_with_file_object(tmp_path: Path) -> None:\n    file_path = tmp_path / \"test_guess_filename\"\n    with file_path.open(\"w+b\") as fp:\n        assert helpers.guess_filename(fp, \"no-throw\") is not None",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmp_path"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert helpers.guess_filename(fp, 'no-throw') is not None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_guess_filename_with_path",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 93,
      "end_line_number": 95,
      "source_code": "def test_guess_filename_with_path(tmp_path: Path) -> None:\n    file_path = tmp_path / \"test_guess_filename\"\n    assert helpers.guess_filename(file_path, \"no-throw\") is not None",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmp_path"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert helpers.guess_filename(file_path, 'no-throw') is not None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_guess_filename_with_default",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 98,
      "end_line_number": 99,
      "source_code": "def test_guess_filename_with_default() -> None:\n    assert helpers.guess_filename(None, \"no-throw\") == \"no-throw\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert helpers.guess_filename(None, 'no-throw') == 'no-throw'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_basic_auth1",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 105,
      "end_line_number": 108,
      "source_code": "def test_basic_auth1() -> None:\n    # missing password here\n    with pytest.raises(ValueError):\n        helpers.BasicAuth(None)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_basic_auth2",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 111,
      "end_line_number": 113,
      "source_code": "def test_basic_auth2() -> None:\n    with pytest.raises(ValueError):\n        helpers.BasicAuth(\"nkim\", None)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_basic_with_auth_colon_in_login",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 116,
      "end_line_number": 118,
      "source_code": "def test_basic_with_auth_colon_in_login() -> None:\n    with pytest.raises(ValueError):\n        helpers.BasicAuth(\"nkim:1\", \"pwd\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_basic_auth3",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 121,
      "end_line_number": 124,
      "source_code": "def test_basic_auth3() -> None:\n    auth = helpers.BasicAuth(\"nkim\")\n    assert auth.login == \"nkim\"\n    assert auth.password == \"\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert auth.login == 'nkim'",
        "assert auth.password == ''"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_basic_auth4",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 127,
      "end_line_number": 131,
      "source_code": "def test_basic_auth4() -> None:\n    auth = helpers.BasicAuth(\"nkim\", \"pwd\")\n    assert auth.login == \"nkim\"\n    assert auth.password == \"pwd\"\n    assert auth.encode() == \"Basic bmtpbTpwd2Q=\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert auth.login == 'nkim'",
        "assert auth.password == 'pwd'",
        "assert auth.encode() == 'Basic bmtpbTpwd2Q='"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_basic_auth_decode",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 141,
      "end_line_number": 144,
      "source_code": "def test_basic_auth_decode(header: str) -> None:\n    auth = helpers.BasicAuth.decode(header)\n    assert auth.login == \"nkim\"\n    assert auth.password == \"pwd\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('header', ('Basic bmtpbTpwd2Q=', 'basic bmtpbTpwd2Q='))"
      ],
      "arguments": [
        "header"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert auth.login == 'nkim'",
        "assert auth.password == 'pwd'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "helpers.BasicAuth.decode",
          "body": "def decode(self, encoding: str='utf-8', errors: str='strict') -> str:\n    assert False"
        }
      ]
    },
    {
      "name": "test_basic_auth_invalid",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 147,
      "end_line_number": 149,
      "source_code": "def test_basic_auth_invalid() -> None:\n    with pytest.raises(ValueError):\n        helpers.BasicAuth.decode(\"bmtpbTpwd2Q=\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "helpers.BasicAuth.decode",
          "body": "def decode(self, encoding: str='utf-8', errors: str='strict') -> str:\n    assert False"
        }
      ]
    },
    {
      "name": "test_basic_auth_decode_not_basic",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 152,
      "end_line_number": 154,
      "source_code": "def test_basic_auth_decode_not_basic() -> None:\n    with pytest.raises(ValueError):\n        helpers.BasicAuth.decode(\"Complex bmtpbTpwd2Q=\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "helpers.BasicAuth.decode",
          "body": "def decode(self, encoding: str='utf-8', errors: str='strict') -> str:\n    assert False"
        }
      ]
    },
    {
      "name": "test_basic_auth_decode_bad_base64",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 157,
      "end_line_number": 159,
      "source_code": "def test_basic_auth_decode_bad_base64() -> None:\n    with pytest.raises(ValueError):\n        helpers.BasicAuth.decode(\"Basic bmtpbTpwd2Q\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "helpers.BasicAuth.decode",
          "body": "def decode(self, encoding: str='utf-8', errors: str='strict') -> str:\n    assert False"
        }
      ]
    },
    {
      "name": "test_basic_auth_decode_illegal_chars_base64",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 163,
      "end_line_number": 165,
      "source_code": "def test_basic_auth_decode_illegal_chars_base64(header: str) -> None:\n    with pytest.raises(ValueError, match=\"Invalid base64 encoding.\"):\n        helpers.BasicAuth.decode(header)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('header', ('Basic ???', 'Basic   '))"
      ],
      "arguments": [
        "header"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "helpers.BasicAuth.decode",
          "body": "def decode(self, encoding: str='utf-8', errors: str='strict') -> str:\n    assert False"
        }
      ]
    },
    {
      "name": "test_basic_auth_decode_invalid_credentials",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 168,
      "end_line_number": 171,
      "source_code": "def test_basic_auth_decode_invalid_credentials() -> None:\n    with pytest.raises(ValueError, match=\"Invalid credentials.\"):\n        header = \"Basic {}\".format(base64.b64encode(b\"username\").decode())\n        helpers.BasicAuth.decode(header)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "helpers.BasicAuth.decode",
          "body": "def decode(self, encoding: str='utf-8', errors: str='strict') -> str:\n    assert False"
        }
      ]
    },
    {
      "name": "test_basic_auth_decode_blank_username",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 192,
      "end_line_number": 196,
      "source_code": "def test_basic_auth_decode_blank_username(\n    credentials: str, expected_auth: helpers.BasicAuth\n) -> None:\n    header = f\"Basic {base64.b64encode(credentials.encode()).decode()}\"\n    assert helpers.BasicAuth.decode(header) == expected_auth",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('credentials, expected_auth', ((':', helpers.BasicAuth(login='', password='', encoding='latin1')), ('username:', helpers.BasicAuth(login='username', password='', encoding='latin1')), (':password', helpers.BasicAuth(login='', password='password', encoding='latin1')), ('username:password', helpers.BasicAuth(login='username', password='password', encoding='latin1'))))"
      ],
      "arguments": [
        "credentials",
        "expected_auth"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert helpers.BasicAuth.decode(header) == expected_auth"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "helpers.BasicAuth.decode",
          "body": "def decode(self, encoding: str='utf-8', errors: str='strict') -> str:\n    assert False"
        }
      ]
    },
    {
      "name": "test_basic_auth_from_url",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 199,
      "end_line_number": 204,
      "source_code": "def test_basic_auth_from_url() -> None:\n    url = URL(\"http://user:pass@example.com\")\n    auth = helpers.BasicAuth.from_url(url)\n    assert auth is not None\n    assert auth.login == \"user\"\n    assert auth.password == \"pass\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert auth is not None",
        "assert auth.login == 'user'",
        "assert auth.password == 'pass'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_basic_auth_no_user_from_url",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 207,
      "end_line_number": 212,
      "source_code": "def test_basic_auth_no_user_from_url() -> None:\n    url = URL(\"http://:pass@example.com\")\n    auth = helpers.BasicAuth.from_url(url)\n    assert auth is not None\n    assert auth.login == \"\"\n    assert auth.password == \"pass\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert auth is not None",
        "assert auth.login == ''",
        "assert auth.password == 'pass'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_basic_auth_no_auth_from_url",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 215,
      "end_line_number": 218,
      "source_code": "def test_basic_auth_no_auth_from_url() -> None:\n    url = URL(\"http://example.com\")\n    auth = helpers.BasicAuth.from_url(url)\n    assert auth is None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert auth is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_basic_auth_from_not_url",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 221,
      "end_line_number": 223,
      "source_code": "def test_basic_auth_from_not_url() -> None:\n    with pytest.raises(TypeError):\n        helpers.BasicAuth.from_url(\"http://user:pass@example.com\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_is_ip_address",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 229,
      "end_line_number": 236,
      "source_code": "def test_is_ip_address() -> None:\n    assert helpers.is_ip_address(\"127.0.0.1\")\n    assert helpers.is_ip_address(\"::1\")\n    assert helpers.is_ip_address(\"FE80:0000:0000:0000:0202:B3FF:FE1E:8329\")\n\n    # Hostnames\n    assert not helpers.is_ip_address(\"localhost\")\n    assert not helpers.is_ip_address(\"www.example.com\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert helpers.is_ip_address('127.0.0.1')",
        "assert helpers.is_ip_address('::1')",
        "assert helpers.is_ip_address('FE80:0000:0000:0000:0202:B3FF:FE1E:8329')",
        "assert not helpers.is_ip_address('localhost')",
        "assert not helpers.is_ip_address('www.example.com')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ipv4_addresses",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 239,
      "end_line_number": 246,
      "source_code": "def test_ipv4_addresses() -> None:\n    ip_addresses = [\n        \"0.0.0.0\",\n        \"127.0.0.1\",\n        \"255.255.255.255\",\n    ]\n    for address in ip_addresses:\n        assert helpers.is_ip_address(address)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert helpers.is_ip_address(address)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ipv6_addresses",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 249,
      "end_line_number": 261,
      "source_code": "def test_ipv6_addresses() -> None:\n    ip_addresses = [\n        \"0:0:0:0:0:0:0:0\",\n        \"FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF\",\n        \"00AB:0002:3008:8CFD:00AB:0002:3008:8CFD\",\n        \"00ab:0002:3008:8cfd:00ab:0002:3008:8cfd\",\n        \"AB:02:3008:8CFD:AB:02:3008:8CFD\",\n        \"AB:02:3008:8CFD::02:3008:8CFD\",\n        \"::\",\n        \"1::1\",\n    ]\n    for address in ip_addresses:\n        assert helpers.is_ip_address(address)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert helpers.is_ip_address(address)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_host_addresses",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 264,
      "end_line_number": 272,
      "source_code": "def test_host_addresses() -> None:\n    hosts = [\n        \"www.four.part.host\",\n        \"www.python.org\",\n        \"foo.bar\",\n        \"localhost\",\n    ]\n    for host in hosts:\n        assert not helpers.is_ip_address(host)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert not helpers.is_ip_address(host)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_is_ip_address_invalid_type",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 275,
      "end_line_number": 280,
      "source_code": "def test_is_ip_address_invalid_type() -> None:\n    with pytest.raises(TypeError):\n        helpers.is_ip_address(123)  # type: ignore[arg-type]\n\n    with pytest.raises(TypeError):\n        helpers.is_ip_address(object())",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_timeout_handle",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 286,
      "end_line_number": 292,
      "source_code": "def test_timeout_handle(loop: asyncio.AbstractEventLoop) -> None:\n    handle = helpers.TimeoutHandle(loop, 10.2)\n    cb = mock.Mock()\n    handle.register(cb)\n    assert cb == handle._callbacks[0][0]\n    handle.close()\n    assert not handle._callbacks",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert cb == handle._callbacks[0][0]",
        "assert not handle._callbacks"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": [
        {
          "name": "handle.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_when_timeout_smaller_second",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 295,
      "end_line_number": 307,
      "source_code": "def test_when_timeout_smaller_second(loop: asyncio.AbstractEventLoop) -> None:\n    timeout = 0.1\n    timer = loop.time() + timeout\n\n    handle = helpers.TimeoutHandle(loop, timeout)\n    assert handle is not None\n    start_handle = handle.start()\n    assert start_handle is not None\n    when = start_handle.when()\n    handle.close()\n\n    assert isinstance(when, float)\n    assert when - timer == pytest.approx(0, abs=0.001)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert handle is not None",
        "assert start_handle is not None",
        "assert isinstance(when, float)",
        "assert when - timer == pytest.approx(0, abs=0.001)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "handle.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_when_timeout_smaller_second_with_low_threshold",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 310,
      "end_line_number": 324,
      "source_code": "def test_when_timeout_smaller_second_with_low_threshold(\n    loop: asyncio.AbstractEventLoop,\n) -> None:\n    timeout = 0.1\n    timer = loop.time() + timeout\n\n    handle = helpers.TimeoutHandle(loop, timeout, 0.01)\n    assert handle is not None\n    start_handle = handle.start()\n    assert start_handle is not None\n    when = start_handle.when()\n    handle.close()\n\n    assert isinstance(when, int)\n    assert when == ceil(timer)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert handle is not None",
        "assert start_handle is not None",
        "assert isinstance(when, int)",
        "assert when == ceil(timer)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "handle.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_timeout_handle_cb_exc",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 327,
      "end_line_number": 334,
      "source_code": "def test_timeout_handle_cb_exc(loop: asyncio.AbstractEventLoop) -> None:\n    handle = helpers.TimeoutHandle(loop, 10.2)\n    cb = mock.Mock()\n    handle.register(cb)\n    cb.side_effect = ValueError()\n    handle()\n    assert cb.called\n    assert not handle._callbacks",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert cb.called",
        "assert not handle._callbacks"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_timer_context_not_cancelled",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 337,
      "end_line_number": 348,
      "source_code": "def test_timer_context_not_cancelled() -> None:\n    with mock.patch(\"aiohttp.helpers.asyncio\") as m_asyncio:\n        m_asyncio.TimeoutError = asyncio.TimeoutError\n        loop = mock.Mock()\n        ctx = helpers.TimerContext(loop)\n        ctx.timeout()\n\n        with pytest.raises(asyncio.TimeoutError):\n            with ctx:\n                pass\n\n        assert not m_asyncio.current_task.return_value.cancel.called",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert not m_asyncio.current_task.return_value.cancel.called"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.patch('aiohttp.helpers.asyncio')",
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_timer_context_no_task",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 405,
      "end_line_number": 408,
      "source_code": "def test_timer_context_no_task(loop: asyncio.AbstractEventLoop) -> None:\n    with pytest.raises(RuntimeError):\n        with helpers.TimerContext(loop):\n            pass",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ceil_call_later",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 441,
      "end_line_number": 446,
      "source_code": "def test_ceil_call_later() -> None:\n    cb = mock.Mock()\n    loop = mock.Mock()\n    loop.time.return_value = 10.1\n    helpers.call_later(cb, 10.1, loop)\n    loop.call_at.assert_called_with(21.0, cb)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_ceil_call_later_with_small_threshold",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 474,
      "end_line_number": 479,
      "source_code": "def test_ceil_call_later_with_small_threshold() -> None:\n    cb = mock.Mock()\n    loop = mock.Mock()\n    loop.time.return_value = 10.1\n    helpers.call_later(cb, 4.5, loop, 1)\n    loop.call_at.assert_called_with(15, cb)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_ceil_call_later_no_timeout",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 482,
      "end_line_number": 486,
      "source_code": "def test_ceil_call_later_no_timeout() -> None:\n    cb = mock.Mock()\n    loop = mock.Mock()\n    helpers.call_later(cb, 0, loop)\n    assert not loop.call_at.called",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert not loop.call_at.called"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_content_disposition",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 533,
      "end_line_number": 539,
      "source_code": "def test_content_disposition(\n    params: Dict[str, str], quote_fields: bool, _charset: str, expected: str\n) -> None:\n    result = helpers.content_disposition_header(\n        \"attachment\", quote_fields=quote_fields, _charset=_charset, params=params\n    )\n    assert result == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('params, quote_fields, _charset, expected', [(dict(foo='bar'), True, 'utf-8', 'attachment; foo=\"bar\"'), (dict(foo='bar[]'), True, 'utf-8', 'attachment; foo=\"bar[]\"'), (dict(foo=' a\"\"b\\\\'), True, 'utf-8', 'attachment; foo=\"\\\\ a\\\\\"\\\\\"b\\\\\\\\\"'), (dict(foo='b\u00e4r'), True, 'utf-8', \"attachment; foo*=utf-8''b%C3%A4r\"), (dict(foo='b\u00e4r \"\\\\'), False, 'utf-8', 'attachment; foo=\"b\u00e4r \\\\\"\\\\\\\\\"'), (dict(foo='b\u00e4r'), True, 'latin-1', \"attachment; foo*=latin-1''b%E4r\"), (dict(filename='b\u00e4r'), True, 'utf-8', 'attachment; filename=\"b%C3%A4r\"'), (dict(filename='b\u00e4r'), True, 'latin-1', 'attachment; filename=\"b%E4r\"'), (dict(filename='b\u00e4r \"\\\\'), False, 'utf-8', 'attachment; filename=\"b\u00e4r \\\\\"\\\\\\\\\"')])"
      ],
      "arguments": [
        "params",
        "quote_fields",
        "_charset",
        "expected"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert result == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_content_disposition_bad_type",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 542,
      "end_line_number": 550,
      "source_code": "def test_content_disposition_bad_type() -> None:\n    with pytest.raises(ValueError):\n        helpers.content_disposition_header(\"foo bar\")\n    with pytest.raises(ValueError):\n        helpers.content_disposition_header(\"\u2014\u00c7\u2013\u00b5\u2014\u00c5\u2014\u00c7\")\n    with pytest.raises(ValueError):\n        helpers.content_disposition_header(\"foo\\x00bar\")\n    with pytest.raises(ValueError):\n        helpers.content_disposition_header(\"\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_set_content_disposition_bad_param",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 553,
      "end_line_number": 561,
      "source_code": "def test_set_content_disposition_bad_param() -> None:\n    with pytest.raises(ValueError):\n        helpers.content_disposition_header(\"inline\", params={\"foo bar\": \"baz\"})\n    with pytest.raises(ValueError):\n        helpers.content_disposition_header(\"inline\", params={\"\u2014\u00c7\u2013\u00b5\u2014\u00c5\u2014\u00c7\": \"baz\"})\n    with pytest.raises(ValueError):\n        helpers.content_disposition_header(\"inline\", params={\"\": \"baz\"})\n    with pytest.raises(ValueError):\n        helpers.content_disposition_header(\"inline\", params={\"foo\\x00bar\": \"baz\"})",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_proxies_from_env",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 579,
      "end_line_number": 584,
      "source_code": "def test_proxies_from_env(url_input: str, expected_scheme: str) -> None:\n    url = URL(url_input)\n    ret = helpers.proxies_from_env()\n    assert ret.keys() == {expected_scheme}\n    assert ret[expected_scheme].proxy == url\n    assert ret[expected_scheme].proxy_auth is None",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize(('proxy_env_vars', 'url_input', 'expected_scheme'), (({'http_proxy': 'http://aiohttp.io/path'}, 'http://aiohttp.io/path', 'http'), ({'https_proxy': 'http://aiohttp.io/path'}, 'http://aiohttp.io/path', 'https'), ({'ws_proxy': 'http://aiohttp.io/path'}, 'http://aiohttp.io/path', 'ws'), ({'wss_proxy': 'http://aiohttp.io/path'}, 'http://aiohttp.io/path', 'wss')), indirect=['proxy_env_vars'], ids=('http', 'https', 'ws', 'wss'))",
        "pytest.mark.usefixtures('proxy_env_vars')"
      ],
      "arguments": [
        "url_input",
        "expected_scheme"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert ret.keys() == {expected_scheme}",
        "assert ret[expected_scheme].proxy == url",
        "assert ret[expected_scheme].proxy_auth is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_proxies_from_env_skipped",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 601,
      "end_line_number": 610,
      "source_code": "def test_proxies_from_env_skipped(\n    caplog: pytest.LogCaptureFixture, url_input: str, expected_scheme: str\n) -> None:\n    url = URL(url_input)\n    assert helpers.proxies_from_env() == {}\n    assert len(caplog.records) == 1\n    log_message = \"{proto!s} proxies {url!s} are not supported, ignoring\".format(\n        proto=expected_scheme.upper(), url=url\n    )\n    assert caplog.record_tuples == [(\"aiohttp.client\", 30, log_message)]",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize(('proxy_env_vars', 'url_input', 'expected_scheme'), (({'https_proxy': 'https://aiohttp.io/path'}, 'https://aiohttp.io/path', 'https'), ({'wss_proxy': 'wss://aiohttp.io/path'}, 'wss://aiohttp.io/path', 'wss')), indirect=['proxy_env_vars'], ids=('https', 'wss'))",
        "pytest.mark.usefixtures('proxy_env_vars')"
      ],
      "arguments": [
        "caplog",
        "url_input",
        "expected_scheme"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert helpers.proxies_from_env() == {}",
        "assert len(caplog.records) == 1",
        "assert caplog.record_tuples == [('aiohttp.client', 30, log_message)]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_proxies_from_env_http_with_auth",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 626,
      "end_line_number": 635,
      "source_code": "def test_proxies_from_env_http_with_auth(url_input: str, expected_scheme: str) -> None:\n    url = URL(\"http://user:pass@aiohttp.io/path\")\n    ret = helpers.proxies_from_env()\n    assert ret.keys() == {expected_scheme}\n    assert ret[expected_scheme].proxy == url.with_user(None)\n    proxy_auth = ret[expected_scheme].proxy_auth\n    assert proxy_auth is not None\n    assert proxy_auth.login == \"user\"\n    assert proxy_auth.password == \"pass\"\n    assert proxy_auth.encoding == \"latin1\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize(('proxy_env_vars', 'url_input', 'expected_scheme'), (({'http_proxy': 'http://user:pass@aiohttp.io/path'}, 'http://user:pass@aiohttp.io/path', 'http'),), indirect=['proxy_env_vars'], ids=('http',))",
        "pytest.mark.usefixtures('proxy_env_vars')"
      ],
      "arguments": [
        "url_input",
        "expected_scheme"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert ret.keys() == {expected_scheme}",
        "assert ret[expected_scheme].proxy == url.with_user(None)",
        "assert proxy_auth is not None",
        "assert proxy_auth.login == 'user'",
        "assert proxy_auth.password == 'pass'",
        "assert proxy_auth.encoding == 'latin1'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get_env_proxy_for_url_negative",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 699,
      "end_line_number": 702,
      "source_code": "def test_get_env_proxy_for_url_negative(url_input: str, expected_err_msg: str) -> None:\n    url = URL(url_input)\n    with pytest.raises(LookupError, match=expected_err_msg):\n        helpers.get_env_proxy_for_url(url)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize(('proxy_env_vars', 'url_input', 'expected_err_msg'), (({'no_proxy': 'aiohttp.io'}, 'http://aiohttp.io/path', \"Proxying is disallowed for `'aiohttp.io'`\"), ({'no_proxy': 'aiohttp.io,proxy.com'}, 'http://aiohttp.io/path', \"Proxying is disallowed for `'aiohttp.io'`\"), ({'http_proxy': 'http://example.com'}, 'https://aiohttp.io/path', 'No proxies found for `https://aiohttp.io/path` in the env'), ({'https_proxy': 'https://example.com'}, 'http://aiohttp.io/path', 'No proxies found for `http://aiohttp.io/path` in the env'), ({}, 'https://aiohttp.io/path', 'No proxies found for `https://aiohttp.io/path` in the env'), ({'https_proxy': 'https://example.com'}, '', 'No proxies found for `` in the env')), indirect=['proxy_env_vars'], ids=('url_matches_the_no_proxy_list', 'url_matches_the_no_proxy_list_multiple', 'url_scheme_does_not_match_http_proxy_list', 'url_scheme_does_not_match_https_proxy_list', 'no_proxies_are_set', 'url_is_empty'))",
        "pytest.mark.usefixtures('proxy_env_vars')"
      ],
      "arguments": [
        "url_input",
        "expected_err_msg"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get_env_proxy_for_url",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 722,
      "end_line_number": 727,
      "source_code": "def test_get_env_proxy_for_url(proxy_env_vars: Dict[str, str], url_input: str) -> None:\n    url = URL(url_input)\n    proxy, proxy_auth = helpers.get_env_proxy_for_url(url)\n    proxy_list = proxy_env_vars[url.scheme + \"_proxy\"]\n    assert proxy == URL(proxy_list)\n    assert proxy_auth is None",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize(('proxy_env_vars', 'url_input'), (({'http_proxy': 'http://example.com'}, 'http://aiohttp.io/path'), ({'https_proxy': 'http://example.com'}, 'https://aiohttp.io/path'), ({'http_proxy': 'http://example.com,http://proxy.org'}, 'http://aiohttp.io/path')), indirect=['proxy_env_vars'], ids=('url_scheme_match_http_proxy_list', 'url_scheme_match_https_proxy_list', 'url_scheme_match_http_proxy_list_multiple'))"
      ],
      "arguments": [
        "proxy_env_vars",
        "url_input"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert proxy == URL(proxy_list)",
        "assert proxy_auth is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_inheritance",
      "module": "test_helpers",
      "class_name": "TestChainMapProxy",
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 770,
      "end_line_number": 774,
      "source_code": "def test_inheritance(self) -> None:\n        with pytest.raises(TypeError):\n\n            class A(helpers.ChainMapProxy):  # type: ignore[misc]\n                pass",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_getitem",
      "module": "test_helpers",
      "class_name": "TestChainMapProxy",
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 776,
      "end_line_number": 781,
      "source_code": "def test_getitem(self) -> None:\n        d1: AppKeyDict = {\"a\": 2, \"b\": 3}\n        d2: AppKeyDict = {\"a\": 1}\n        cp = helpers.ChainMapProxy([d1, d2])\n        assert cp[\"a\"] == 2\n        assert cp[\"b\"] == 3",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert cp['a'] == 2",
        "assert cp['b'] == 3"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_getitem_not_found",
      "module": "test_helpers",
      "class_name": "TestChainMapProxy",
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 783,
      "end_line_number": 787,
      "source_code": "def test_getitem_not_found(self) -> None:\n        d: AppKeyDict = {\"a\": 1}\n        cp = helpers.ChainMapProxy([d])\n        with pytest.raises(KeyError):\n            cp[\"b\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get",
      "module": "test_helpers",
      "class_name": "TestChainMapProxy",
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 789,
      "end_line_number": 793,
      "source_code": "def test_get(self) -> None:\n        d1: AppKeyDict = {\"a\": 2, \"b\": 3}\n        d2: AppKeyDict = {\"a\": 1}\n        cp = helpers.ChainMapProxy([d1, d2])\n        assert cp.get(\"a\") == 2",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert cp.get('a') == 2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get_default",
      "module": "test_helpers",
      "class_name": "TestChainMapProxy",
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 795,
      "end_line_number": 799,
      "source_code": "def test_get_default(self) -> None:\n        d1: AppKeyDict = {\"a\": 2, \"b\": 3}\n        d2: AppKeyDict = {\"a\": 1}\n        cp = helpers.ChainMapProxy([d1, d2])\n        assert cp.get(\"c\", 4) == 4",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert cp.get('c', 4) == 4"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get_non_default",
      "module": "test_helpers",
      "class_name": "TestChainMapProxy",
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 801,
      "end_line_number": 805,
      "source_code": "def test_get_non_default(self) -> None:\n        d1: AppKeyDict = {\"a\": 2, \"b\": 3}\n        d2: AppKeyDict = {\"a\": 1}\n        cp = helpers.ChainMapProxy([d1, d2])\n        assert cp.get(\"a\", 4) == 2",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert cp.get('a', 4) == 2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_len",
      "module": "test_helpers",
      "class_name": "TestChainMapProxy",
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 807,
      "end_line_number": 811,
      "source_code": "def test_len(self) -> None:\n        d1: AppKeyDict = {\"a\": 2, \"b\": 3}\n        d2: AppKeyDict = {\"a\": 1}\n        cp = helpers.ChainMapProxy([d1, d2])\n        assert len(cp) == 2",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(cp) == 2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_iter",
      "module": "test_helpers",
      "class_name": "TestChainMapProxy",
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 813,
      "end_line_number": 817,
      "source_code": "def test_iter(self) -> None:\n        d1: AppKeyDict = {\"a\": 2, \"b\": 3}\n        d2: AppKeyDict = {\"a\": 1}\n        cp = helpers.ChainMapProxy([d1, d2])\n        assert set(cp) == {\"a\", \"b\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert set(cp) == {'a', 'b'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_contains",
      "module": "test_helpers",
      "class_name": "TestChainMapProxy",
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 819,
      "end_line_number": 825,
      "source_code": "def test_contains(self) -> None:\n        d1: AppKeyDict = {\"a\": 2, \"b\": 3}\n        d2: AppKeyDict = {\"a\": 1}\n        cp = helpers.ChainMapProxy([d1, d2])\n        assert \"a\" in cp\n        assert \"b\" in cp\n        assert \"c\" not in cp",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'a' in cp",
        "assert 'b' in cp",
        "assert 'c' not in cp"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_bool",
      "module": "test_helpers",
      "class_name": "TestChainMapProxy",
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 827,
      "end_line_number": 830,
      "source_code": "def test_bool(self) -> None:\n        assert helpers.ChainMapProxy([{\"a\": 1}])\n        assert not helpers.ChainMapProxy([{}, {}])\n        assert not helpers.ChainMapProxy([])",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert helpers.ChainMapProxy([{'a': 1}])",
        "assert not helpers.ChainMapProxy([{}, {}])",
        "assert not helpers.ChainMapProxy([])"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_repr",
      "module": "test_helpers",
      "class_name": "TestChainMapProxy",
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 832,
      "end_line_number": 837,
      "source_code": "def test_repr(self) -> None:\n        d1: AppKeyDict = {\"a\": 2, \"b\": 3}\n        d2: AppKeyDict = {\"a\": 1}\n        cp = helpers.ChainMapProxy([d1, d2])\n        expected = f\"ChainMapProxy({d1!r}, {d2!r})\"\n        assert expected == repr(cp)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert expected == repr(cp)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_is_expected_content_type_json_match_exact",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 840,
      "end_line_number": 845,
      "source_code": "def test_is_expected_content_type_json_match_exact() -> None:\n    expected_ct = \"application/json\"\n    response_ct = \"application/json\"\n    assert is_expected_content_type(\n        response_content_type=response_ct, expected_content_type=expected_ct\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert is_expected_content_type(response_content_type=response_ct, expected_content_type=expected_ct)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_is_expected_content_type_json_match_partially",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 848,
      "end_line_number": 853,
      "source_code": "def test_is_expected_content_type_json_match_partially() -> None:\n    expected_ct = \"application/json\"\n    response_ct = \"application/alto-costmap+json\"  # mime-type from rfc7285\n    assert is_expected_content_type(\n        response_content_type=response_ct, expected_content_type=expected_ct\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert is_expected_content_type(response_content_type=response_ct, expected_content_type=expected_ct)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_is_expected_content_type_non_application_json_suffix",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 856,
      "end_line_number": 861,
      "source_code": "def test_is_expected_content_type_non_application_json_suffix() -> None:\n    expected_ct = \"application/json\"\n    response_ct = \"model/gltf+json\"  # rfc 6839\n    assert is_expected_content_type(\n        response_content_type=response_ct, expected_content_type=expected_ct\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert is_expected_content_type(response_content_type=response_ct, expected_content_type=expected_ct)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_is_expected_content_type_non_application_json_private_suffix",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 864,
      "end_line_number": 869,
      "source_code": "def test_is_expected_content_type_non_application_json_private_suffix() -> None:\n    expected_ct = \"application/json\"\n    response_ct = \"x-foo/bar+json\"  # rfc 6839\n    assert is_expected_content_type(\n        response_content_type=response_ct, expected_content_type=expected_ct\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert is_expected_content_type(response_content_type=response_ct, expected_content_type=expected_ct)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_is_expected_content_type_json_non_lowercase",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 872,
      "end_line_number": 878,
      "source_code": "def test_is_expected_content_type_json_non_lowercase() -> None:\n    \"\"\"Per RFC 2045, media type matching is case insensitive.\"\"\"\n    expected_ct = \"application/json\"\n    response_ct = \"Application/JSON\"\n    assert is_expected_content_type(\n        response_content_type=response_ct, expected_content_type=expected_ct\n    )",
      "docstring": "Per RFC 2045, media type matching is case insensitive.",
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert is_expected_content_type(response_content_type=response_ct, expected_content_type=expected_ct)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_is_expected_content_type_json_trailing_chars",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 881,
      "end_line_number": 886,
      "source_code": "def test_is_expected_content_type_json_trailing_chars() -> None:\n    expected_ct = \"application/json\"\n    response_ct = \"application/json-seq\"\n    assert not is_expected_content_type(\n        response_content_type=response_ct, expected_content_type=expected_ct\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert not is_expected_content_type(response_content_type=response_ct, expected_content_type=expected_ct)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_is_expected_content_type_non_json_match_exact",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 889,
      "end_line_number": 894,
      "source_code": "def test_is_expected_content_type_non_json_match_exact() -> None:\n    expected_ct = \"text/javascript\"\n    response_ct = \"text/javascript\"\n    assert is_expected_content_type(\n        response_content_type=response_ct, expected_content_type=expected_ct\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert is_expected_content_type(response_content_type=response_ct, expected_content_type=expected_ct)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_is_expected_content_type_non_json_not_match",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 897,
      "end_line_number": 902,
      "source_code": "def test_is_expected_content_type_non_json_not_match() -> None:\n    expected_ct = \"application/json\"\n    response_ct = \"text/plain\"\n    assert not is_expected_content_type(\n        response_content_type=response_ct, expected_content_type=expected_ct\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert not is_expected_content_type(response_content_type=response_ct, expected_content_type=expected_ct)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_cookies_mixin",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 911,
      "end_line_number": 937,
      "source_code": "def test_cookies_mixin() -> None:\n    sut = CookieImplementation()\n\n    assert sut.cookies == {}\n    assert str(sut.cookies) == \"\"\n\n    sut.set_cookie(\"name\", \"value\")\n    assert str(sut.cookies) == \"Set-Cookie: name=value; Path=/\"\n    sut.set_cookie(\"name\", \"other_value\")\n    assert str(sut.cookies) == \"Set-Cookie: name=other_value; Path=/\"\n\n    sut.cookies[\"name\"] = \"another_other_value\"\n    sut.cookies[\"name\"][\"max-age\"] = 10\n    assert (\n        str(sut.cookies) == \"Set-Cookie: name=another_other_value; Max-Age=10; Path=/\"\n    )\n\n    sut.del_cookie(\"name\")\n    expected = (\n        'Set-Cookie: name=\"\"; '\n        \"expires=Thu, 01 Jan 1970 00:00:00 GMT; Max-Age=0; Path=/\"\n    )\n    assert str(sut.cookies) == expected\n\n    sut.set_cookie(\"name\", \"value\", domain=\"local.host\")\n    expected = \"Set-Cookie: name=value; Domain=local.host; Path=/\"\n    assert str(sut.cookies) == expected",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert sut.cookies == {}",
        "assert str(sut.cookies) == ''",
        "assert str(sut.cookies) == 'Set-Cookie: name=value; Path=/'",
        "assert str(sut.cookies) == 'Set-Cookie: name=other_value; Path=/'",
        "assert str(sut.cookies) == 'Set-Cookie: name=another_other_value; Max-Age=10; Path=/'",
        "assert str(sut.cookies) == expected",
        "assert str(sut.cookies) == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_cookies_mixin_path",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 940,
      "end_line_number": 969,
      "source_code": "def test_cookies_mixin_path() -> None:\n    sut = CookieImplementation()\n\n    assert sut.cookies == {}\n\n    sut.set_cookie(\"name\", \"value\", path=\"/some/path\")\n    assert str(sut.cookies) == \"Set-Cookie: name=value; Path=/some/path\"\n    sut.set_cookie(\"name\", \"value\", expires=\"123\")\n    assert str(sut.cookies) == \"Set-Cookie: name=value; expires=123; Path=/\"\n    sut.set_cookie(\n        \"name\",\n        \"value\",\n        domain=\"example.com\",\n        path=\"/home\",\n        expires=\"123\",\n        max_age=\"10\",\n        secure=True,\n        httponly=True,\n        samesite=\"lax\",\n    )\n    assert (\n        str(sut.cookies).lower() == \"set-cookie: name=value; \"\n        \"domain=example.com; \"\n        \"expires=123; \"\n        \"httponly; \"\n        \"max-age=10; \"\n        \"path=/home; \"\n        \"samesite=lax; \"\n        \"secure\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert sut.cookies == {}",
        "assert str(sut.cookies) == 'Set-Cookie: name=value; Path=/some/path'",
        "assert str(sut.cookies) == 'Set-Cookie: name=value; expires=123; Path=/'",
        "assert str(sut.cookies).lower() == 'set-cookie: name=value; domain=example.com; expires=123; httponly; max-age=10; path=/home; samesite=lax; secure'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_sutonse_cookie__issue_del_cookie",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 972,
      "end_line_number": 983,
      "source_code": "def test_sutonse_cookie__issue_del_cookie() -> None:\n    sut = CookieImplementation()\n\n    assert sut.cookies == {}\n    assert str(sut.cookies) == \"\"\n\n    sut.del_cookie(\"name\")\n    expected = (\n        'Set-Cookie: name=\"\"; '\n        \"expires=Thu, 01 Jan 1970 00:00:00 GMT; Max-Age=0; Path=/\"\n    )\n    assert str(sut.cookies) == expected",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert sut.cookies == {}",
        "assert str(sut.cookies) == ''",
        "assert str(sut.cookies) == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_cookie_set_after_del",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 986,
      "end_line_number": 993,
      "source_code": "def test_cookie_set_after_del() -> None:\n    sut = CookieImplementation()\n\n    sut.del_cookie(\"name\")\n    sut.set_cookie(\"name\", \"val\")\n    # check for Max-Age dropped\n    expected = \"Set-Cookie: name=val; Path=/\"\n    assert str(sut.cookies) == expected",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(sut.cookies) == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_populate_with_cookies",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 996,
      "end_line_number": 1002,
      "source_code": "def test_populate_with_cookies() -> None:\n    cookies_mixin = CookieImplementation()\n    cookies_mixin.set_cookie(\"name\", \"value\")\n    headers = CIMultiDict[str]()\n\n    helpers.populate_with_cookies(headers, cookies_mixin.cookies)\n    assert headers == CIMultiDict({\"Set-Cookie\": \"name=value; Path=/\"})",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert headers == CIMultiDict({'Set-Cookie': 'name=value; Path=/'})"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_parse_http_date",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 1026,
      "end_line_number": 1027,
      "source_code": "def test_parse_http_date(value: str, expected: Optional[datetime.datetime]) -> None:\n    assert parse_http_date(value) == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize(['value', 'expected'], [pytest.param('xxyyzz', None), pytest.param('Tue, 08 Oct 4446413 00:56:40 GMT', None), pytest.param('Tue, 08 Oct 2000 00:56:80 GMT', None), pytest.param('Tue, 08 Oct 2000 00:56:40 GMT', datetime.datetime(2000, 10, 8, 0, 56, 40, tzinfo=datetime.timezone.utc)), pytest.param('Tue, 08 Oct 2000 00:56:40 +0900', datetime.datetime(2000, 10, 8, 0, 56, 40, tzinfo=datetime.timezone.utc))])"
      ],
      "arguments": [
        "value",
        "expected"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert parse_http_date(value) == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_netrc_from_env",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 1041,
      "end_line_number": 1047,
      "source_code": "def test_netrc_from_env(expected_username: str) -> None:\n    \"\"\"Test that reading netrc files from env works as expected\"\"\"\n    netrc_obj = helpers.netrc_from_env()\n    assert netrc_obj is not None\n    auth = netrc_obj.authenticators(\"example.com\")\n    assert auth is not None\n    assert auth[0] == expected_username",
      "docstring": "Test that reading netrc files from env works as expected",
      "decorators": [
        "pytest.mark.parametrize(['netrc_contents', 'expected_username'], [('machine example.com login username password pass\\n', 'username')], indirect=('netrc_contents',))",
        "pytest.mark.usefixtures('netrc_contents')"
      ],
      "arguments": [
        "expected_username"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert netrc_obj is not None",
        "assert auth is not None",
        "assert auth[0] == expected_username"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_netrc_from_home_does_not_raise_if_access_denied",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 1061,
      "end_line_number": 1067,
      "source_code": "def test_netrc_from_home_does_not_raise_if_access_denied(\n    protected_dir: Path, monkeypatch: pytest.MonkeyPatch\n) -> None:\n    monkeypatch.setattr(Path, \"home\", lambda: protected_dir)\n    monkeypatch.delenv(\"NETRC\", raising=False)\n\n    helpers.netrc_from_env()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "protected_dir",
        "monkeypatch"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_basicauth_present_in_netrc",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 1089,
      "end_line_number": 1095,
      "source_code": "def test_basicauth_present_in_netrc(\n    expected_auth: helpers.BasicAuth,\n) -> None:\n    \"\"\"Test that netrc file contents are properly parsed into BasicAuth tuples\"\"\"\n    netrc_obj = helpers.netrc_from_env()\n\n    assert expected_auth == helpers.basicauth_from_netrc(netrc_obj, \"example.com\")",
      "docstring": "Test that netrc file contents are properly parsed into BasicAuth tuples",
      "decorators": [
        "pytest.mark.parametrize(['netrc_contents', 'expected_auth'], [('machine example.com login username password pass\\n', helpers.BasicAuth('username', 'pass')), ('machine example.com account username password pass\\n', helpers.BasicAuth('username', 'pass')), ('machine example.com password pass\\n', helpers.BasicAuth('', 'pass'))], indirect=('netrc_contents',))",
        "pytest.mark.usefixtures('netrc_contents')"
      ],
      "arguments": [
        "expected_auth"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert expected_auth == helpers.basicauth_from_netrc(netrc_obj, 'example.com')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_read_basicauth_from_empty_netrc",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 1106,
      "end_line_number": 1113,
      "source_code": "def test_read_basicauth_from_empty_netrc() -> None:\n    \"\"\"Test that an error is raised if netrc doesn't have an entry for our host\"\"\"\n    netrc_obj = helpers.netrc_from_env()\n\n    with pytest.raises(\n        LookupError, match=\"No entry for example.com found in the `.netrc` file.\"\n    ):\n        helpers.basicauth_from_netrc(netrc_obj, \"example.com\")",
      "docstring": "Test that an error is raised if netrc doesn't have an entry for our host",
      "decorators": [
        "pytest.mark.parametrize(['netrc_contents'], [('',)], indirect=('netrc_contents',))",
        "pytest.mark.usefixtures('netrc_contents')"
      ],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_method_must_be_empty_body",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 1116,
      "end_line_number": 1120,
      "source_code": "def test_method_must_be_empty_body() -> None:\n    \"\"\"Test that HEAD is the only method that unequivocally must have an empty body.\"\"\"\n    assert method_must_be_empty_body(\"HEAD\") is True\n    # CONNECT is only empty on a successful response\n    assert method_must_be_empty_body(\"CONNECT\") is False",
      "docstring": "Test that HEAD is the only method that unequivocally must have an empty body.",
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert method_must_be_empty_body('HEAD') is True",
        "assert method_must_be_empty_body('CONNECT') is False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_should_remove_content_length_is_subset_of_must_be_empty_body",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 1123,
      "end_line_number": 1151,
      "source_code": "def test_should_remove_content_length_is_subset_of_must_be_empty_body() -> None:\n    \"\"\"Test should_remove_content_length is always a subset of must_be_empty_body.\"\"\"\n    assert should_remove_content_length(\"GET\", 101) is True\n    assert must_be_empty_body(\"GET\", 101) is True\n\n    assert should_remove_content_length(\"GET\", 102) is True\n    assert must_be_empty_body(\"GET\", 102) is True\n\n    assert should_remove_content_length(\"GET\", 204) is True\n    assert must_be_empty_body(\"GET\", 204) is True\n\n    assert should_remove_content_length(\"GET\", 204) is True\n    assert must_be_empty_body(\"GET\", 204) is True\n\n    assert should_remove_content_length(\"GET\", 200) is False\n    assert must_be_empty_body(\"GET\", 200) is False\n\n    assert should_remove_content_length(\"HEAD\", 200) is False\n    assert must_be_empty_body(\"HEAD\", 200) is True\n\n    # CONNECT is only empty on a successful response\n    assert should_remove_content_length(\"CONNECT\", 200) is True\n    assert must_be_empty_body(\"CONNECT\", 200) is True\n\n    assert should_remove_content_length(\"CONNECT\", 201) is True\n    assert must_be_empty_body(\"CONNECT\", 201) is True\n\n    assert should_remove_content_length(\"CONNECT\", 300) is False\n    assert must_be_empty_body(\"CONNECT\", 300) is False",
      "docstring": "Test should_remove_content_length is always a subset of must_be_empty_body.",
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert should_remove_content_length('GET', 101) is True",
        "assert must_be_empty_body('GET', 101) is True",
        "assert should_remove_content_length('GET', 102) is True",
        "assert must_be_empty_body('GET', 102) is True",
        "assert should_remove_content_length('GET', 204) is True",
        "assert must_be_empty_body('GET', 204) is True",
        "assert should_remove_content_length('GET', 204) is True",
        "assert must_be_empty_body('GET', 204) is True",
        "assert should_remove_content_length('GET', 200) is False",
        "assert must_be_empty_body('GET', 200) is False",
        "assert should_remove_content_length('HEAD', 200) is False",
        "assert must_be_empty_body('HEAD', 200) is True",
        "assert should_remove_content_length('CONNECT', 200) is True",
        "assert must_be_empty_body('CONNECT', 200) is True",
        "assert should_remove_content_length('CONNECT', 201) is True",
        "assert must_be_empty_body('CONNECT', 201) is True",
        "assert should_remove_content_length('CONNECT', 300) is False",
        "assert must_be_empty_body('CONNECT', 300) is False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_inheritance",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 770,
      "end_line_number": 774,
      "source_code": "def test_inheritance(self) -> None:\n        with pytest.raises(TypeError):\n\n            class A(helpers.ChainMapProxy):  # type: ignore[misc]\n                pass",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_getitem",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 776,
      "end_line_number": 781,
      "source_code": "def test_getitem(self) -> None:\n        d1: AppKeyDict = {\"a\": 2, \"b\": 3}\n        d2: AppKeyDict = {\"a\": 1}\n        cp = helpers.ChainMapProxy([d1, d2])\n        assert cp[\"a\"] == 2\n        assert cp[\"b\"] == 3",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert cp['a'] == 2",
        "assert cp['b'] == 3"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_getitem_not_found",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 783,
      "end_line_number": 787,
      "source_code": "def test_getitem_not_found(self) -> None:\n        d: AppKeyDict = {\"a\": 1}\n        cp = helpers.ChainMapProxy([d])\n        with pytest.raises(KeyError):\n            cp[\"b\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 789,
      "end_line_number": 793,
      "source_code": "def test_get(self) -> None:\n        d1: AppKeyDict = {\"a\": 2, \"b\": 3}\n        d2: AppKeyDict = {\"a\": 1}\n        cp = helpers.ChainMapProxy([d1, d2])\n        assert cp.get(\"a\") == 2",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert cp.get('a') == 2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get_default",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 795,
      "end_line_number": 799,
      "source_code": "def test_get_default(self) -> None:\n        d1: AppKeyDict = {\"a\": 2, \"b\": 3}\n        d2: AppKeyDict = {\"a\": 1}\n        cp = helpers.ChainMapProxy([d1, d2])\n        assert cp.get(\"c\", 4) == 4",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert cp.get('c', 4) == 4"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get_non_default",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 801,
      "end_line_number": 805,
      "source_code": "def test_get_non_default(self) -> None:\n        d1: AppKeyDict = {\"a\": 2, \"b\": 3}\n        d2: AppKeyDict = {\"a\": 1}\n        cp = helpers.ChainMapProxy([d1, d2])\n        assert cp.get(\"a\", 4) == 2",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert cp.get('a', 4) == 2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_len",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 807,
      "end_line_number": 811,
      "source_code": "def test_len(self) -> None:\n        d1: AppKeyDict = {\"a\": 2, \"b\": 3}\n        d2: AppKeyDict = {\"a\": 1}\n        cp = helpers.ChainMapProxy([d1, d2])\n        assert len(cp) == 2",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(cp) == 2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_iter",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 813,
      "end_line_number": 817,
      "source_code": "def test_iter(self) -> None:\n        d1: AppKeyDict = {\"a\": 2, \"b\": 3}\n        d2: AppKeyDict = {\"a\": 1}\n        cp = helpers.ChainMapProxy([d1, d2])\n        assert set(cp) == {\"a\", \"b\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert set(cp) == {'a', 'b'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_contains",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 819,
      "end_line_number": 825,
      "source_code": "def test_contains(self) -> None:\n        d1: AppKeyDict = {\"a\": 2, \"b\": 3}\n        d2: AppKeyDict = {\"a\": 1}\n        cp = helpers.ChainMapProxy([d1, d2])\n        assert \"a\" in cp\n        assert \"b\" in cp\n        assert \"c\" not in cp",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'a' in cp",
        "assert 'b' in cp",
        "assert 'c' not in cp"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_bool",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 827,
      "end_line_number": 830,
      "source_code": "def test_bool(self) -> None:\n        assert helpers.ChainMapProxy([{\"a\": 1}])\n        assert not helpers.ChainMapProxy([{}, {}])\n        assert not helpers.ChainMapProxy([])",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert helpers.ChainMapProxy([{'a': 1}])",
        "assert not helpers.ChainMapProxy([{}, {}])",
        "assert not helpers.ChainMapProxy([])"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_repr",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_helpers.py",
      "line_number": 832,
      "end_line_number": 837,
      "source_code": "def test_repr(self) -> None:\n        d1: AppKeyDict = {\"a\": 2, \"b\": 3}\n        d2: AppKeyDict = {\"a\": 1}\n        cp = helpers.ChainMapProxy([d1, d2])\n        expected = f\"ChainMapProxy({d1!r}, {d2!r})\"\n        assert expected == repr(cp)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "base64",
        "datetime",
        "gc",
        "sys",
        "weakref",
        "math.ceil",
        "math.modf",
        "pathlib.Path",
        "typing.Dict",
        "typing.Iterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "urllib.request.getproxies_environment",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "multidict.MultiDictProxy",
        "yarl.URL",
        "aiohttp.helpers",
        "aiohttp.web",
        "aiohttp.helpers.is_expected_content_type",
        "aiohttp.helpers.method_must_be_empty_body",
        "aiohttp.helpers.must_be_empty_body",
        "aiohttp.helpers.parse_http_date",
        "aiohttp.helpers.should_remove_content_length"
      ],
      "fixtures": [],
      "assertions": [
        "assert expected == repr(cp)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor",
      "module": "test_http_exceptions",
      "class_name": "TestHttpProcessingError",
      "file_path": "__internal__/data/aiohttp/tests/test_http_exceptions.py",
      "line_number": 11,
      "end_line_number": 17,
      "source_code": "def test_ctor(self) -> None:\n        err = http_exceptions.HttpProcessingError(\n            code=500, message=\"Internal error\", headers=CIMultiDict()\n        )\n        assert err.code == 500\n        assert err.message == \"Internal error\"\n        assert err.headers == CIMultiDict()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pickle",
        "multidict.CIMultiDict",
        "aiohttp.http_exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert err.code == 500",
        "assert err.message == 'Internal error'",
        "assert err.headers == CIMultiDict()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_pickle",
      "module": "test_http_exceptions",
      "class_name": "TestHttpProcessingError",
      "file_path": "__internal__/data/aiohttp/tests/test_http_exceptions.py",
      "line_number": 19,
      "end_line_number": 30,
      "source_code": "def test_pickle(self) -> None:\n        err = http_exceptions.HttpProcessingError(\n            code=500, message=\"Internal error\", headers=CIMultiDict()\n        )\n        err.foo = \"bar\"  # type: ignore[attr-defined]\n        for proto in range(pickle.HIGHEST_PROTOCOL + 1):\n            pickled = pickle.dumps(err, proto)\n            err2 = pickle.loads(pickled)\n            assert err2.code == 500\n            assert err2.message == \"Internal error\"\n            assert err2.headers == CIMultiDict()\n            assert err2.foo == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pickle",
        "multidict.CIMultiDict",
        "aiohttp.http_exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert err2.code == 500",
        "assert err2.message == 'Internal error'",
        "assert err2.headers == CIMultiDict()",
        "assert err2.foo == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_str",
      "module": "test_http_exceptions",
      "class_name": "TestHttpProcessingError",
      "file_path": "__internal__/data/aiohttp/tests/test_http_exceptions.py",
      "line_number": 32,
      "end_line_number": 36,
      "source_code": "def test_str(self) -> None:\n        err = http_exceptions.HttpProcessingError(\n            code=500, message=\"Internal error\", headers=CIMultiDict()\n        )\n        assert str(err) == \"500, message:\\n  Internal error\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pickle",
        "multidict.CIMultiDict",
        "aiohttp.http_exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(err) == '500, message:\\n  Internal error'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_repr",
      "module": "test_http_exceptions",
      "class_name": "TestHttpProcessingError",
      "file_path": "__internal__/data/aiohttp/tests/test_http_exceptions.py",
      "line_number": 38,
      "end_line_number": 42,
      "source_code": "def test_repr(self) -> None:\n        err = http_exceptions.HttpProcessingError(\n            code=500, message=\"Internal error\", headers=CIMultiDict()\n        )\n        assert repr(err) == (\"<HttpProcessingError: 500, message='Internal error'>\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pickle",
        "multidict.CIMultiDict",
        "aiohttp.http_exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(err) == \"<HttpProcessingError: 500, message='Internal error'>\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor",
      "module": "test_http_exceptions",
      "class_name": "TestBadHttpMessage",
      "file_path": "__internal__/data/aiohttp/tests/test_http_exceptions.py",
      "line_number": 46,
      "end_line_number": 50,
      "source_code": "def test_ctor(self) -> None:\n        err = http_exceptions.BadHttpMessage(\"Bad HTTP message\", headers=CIMultiDict())\n        assert err.code == 400\n        assert err.message == \"Bad HTTP message\"\n        assert err.headers == CIMultiDict()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pickle",
        "multidict.CIMultiDict",
        "aiohttp.http_exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert err.code == 400",
        "assert err.message == 'Bad HTTP message'",
        "assert err.headers == CIMultiDict()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_pickle",
      "module": "test_http_exceptions",
      "class_name": "TestBadHttpMessage",
      "file_path": "__internal__/data/aiohttp/tests/test_http_exceptions.py",
      "line_number": 52,
      "end_line_number": 63,
      "source_code": "def test_pickle(self) -> None:\n        err = http_exceptions.BadHttpMessage(\n            message=\"Bad HTTP message\", headers=CIMultiDict()\n        )\n        err.foo = \"bar\"  # type: ignore[attr-defined]\n        for proto in range(pickle.HIGHEST_PROTOCOL + 1):\n            pickled = pickle.dumps(err, proto)\n            err2 = pickle.loads(pickled)\n            assert err2.code == 400\n            assert err2.message == \"Bad HTTP message\"\n            assert err2.headers == {}\n            assert err2.foo == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pickle",
        "multidict.CIMultiDict",
        "aiohttp.http_exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert err2.code == 400",
        "assert err2.message == 'Bad HTTP message'",
        "assert err2.headers == {}",
        "assert err2.foo == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_str",
      "module": "test_http_exceptions",
      "class_name": "TestBadHttpMessage",
      "file_path": "__internal__/data/aiohttp/tests/test_http_exceptions.py",
      "line_number": 65,
      "end_line_number": 69,
      "source_code": "def test_str(self) -> None:\n        err = http_exceptions.BadHttpMessage(\n            message=\"Bad HTTP message\", headers=CIMultiDict()\n        )\n        assert str(err) == \"400, message:\\n  Bad HTTP message\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pickle",
        "multidict.CIMultiDict",
        "aiohttp.http_exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(err) == '400, message:\\n  Bad HTTP message'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_repr",
      "module": "test_http_exceptions",
      "class_name": "TestBadHttpMessage",
      "file_path": "__internal__/data/aiohttp/tests/test_http_exceptions.py",
      "line_number": 71,
      "end_line_number": 75,
      "source_code": "def test_repr(self) -> None:\n        err = http_exceptions.BadHttpMessage(\n            message=\"Bad HTTP message\", headers=CIMultiDict()\n        )\n        assert repr(err) == \"<BadHttpMessage: 400, message='Bad HTTP message'>\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pickle",
        "multidict.CIMultiDict",
        "aiohttp.http_exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(err) == \"<BadHttpMessage: 400, message='Bad HTTP message'>\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor",
      "module": "test_http_exceptions",
      "class_name": "TestLineTooLong",
      "file_path": "__internal__/data/aiohttp/tests/test_http_exceptions.py",
      "line_number": 79,
      "end_line_number": 83,
      "source_code": "def test_ctor(self) -> None:\n        err = http_exceptions.LineTooLong(\"spam\", \"10\", \"12\")\n        assert err.code == 400\n        assert err.message == \"Got more than 10 bytes (12) when reading spam.\"\n        assert err.headers is None",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pickle",
        "multidict.CIMultiDict",
        "aiohttp.http_exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert err.code == 400",
        "assert err.message == 'Got more than 10 bytes (12) when reading spam.'",
        "assert err.headers is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_pickle",
      "module": "test_http_exceptions",
      "class_name": "TestLineTooLong",
      "file_path": "__internal__/data/aiohttp/tests/test_http_exceptions.py",
      "line_number": 85,
      "end_line_number": 94,
      "source_code": "def test_pickle(self) -> None:\n        err = http_exceptions.LineTooLong(line=\"spam\", limit=\"10\", actual_size=\"12\")\n        err.foo = \"bar\"  # type: ignore[attr-defined]\n        for proto in range(pickle.HIGHEST_PROTOCOL + 1):\n            pickled = pickle.dumps(err, proto)\n            err2 = pickle.loads(pickled)\n            assert err2.code == 400\n            assert err2.message == (\"Got more than 10 bytes (12) when reading spam.\")\n            assert err2.headers is None\n            assert err2.foo == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pickle",
        "multidict.CIMultiDict",
        "aiohttp.http_exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert err2.code == 400",
        "assert err2.message == 'Got more than 10 bytes (12) when reading spam.'",
        "assert err2.headers is None",
        "assert err2.foo == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_str",
      "module": "test_http_exceptions",
      "class_name": "TestLineTooLong",
      "file_path": "__internal__/data/aiohttp/tests/test_http_exceptions.py",
      "line_number": 96,
      "end_line_number": 99,
      "source_code": "def test_str(self) -> None:\n        err = http_exceptions.LineTooLong(line=\"spam\", limit=\"10\", actual_size=\"12\")\n        expected = \"400, message:\\n  Got more than 10 bytes (12) when reading spam.\"\n        assert str(err) == expected",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pickle",
        "multidict.CIMultiDict",
        "aiohttp.http_exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(err) == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_repr",
      "module": "test_http_exceptions",
      "class_name": "TestLineTooLong",
      "file_path": "__internal__/data/aiohttp/tests/test_http_exceptions.py",
      "line_number": 101,
      "end_line_number": 106,
      "source_code": "def test_repr(self) -> None:\n        err = http_exceptions.LineTooLong(line=\"spam\", limit=\"10\", actual_size=\"12\")\n        assert repr(err) == (\n            \"<LineTooLong: 400, message='Got more than \"\n            \"10 bytes (12) when reading spam.'>\"\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pickle",
        "multidict.CIMultiDict",
        "aiohttp.http_exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(err) == \"<LineTooLong: 400, message='Got more than 10 bytes (12) when reading spam.'>\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor",
      "module": "test_http_exceptions",
      "class_name": "TestInvalidHeader",
      "file_path": "__internal__/data/aiohttp/tests/test_http_exceptions.py",
      "line_number": 110,
      "end_line_number": 114,
      "source_code": "def test_ctor(self) -> None:\n        err = http_exceptions.InvalidHeader(\"X-Spam\")\n        assert err.code == 400\n        assert err.message == \"Invalid HTTP header: 'X-Spam'\"\n        assert err.headers is None",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pickle",
        "multidict.CIMultiDict",
        "aiohttp.http_exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert err.code == 400",
        "assert err.message == \"Invalid HTTP header: 'X-Spam'\"",
        "assert err.headers is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_pickle",
      "module": "test_http_exceptions",
      "class_name": "TestInvalidHeader",
      "file_path": "__internal__/data/aiohttp/tests/test_http_exceptions.py",
      "line_number": 116,
      "end_line_number": 125,
      "source_code": "def test_pickle(self) -> None:\n        err = http_exceptions.InvalidHeader(hdr=\"X-Spam\")\n        err.foo = \"bar\"  # type: ignore[attr-defined]\n        for proto in range(pickle.HIGHEST_PROTOCOL + 1):\n            pickled = pickle.dumps(err, proto)\n            err2 = pickle.loads(pickled)\n            assert err2.code == 400\n            assert err2.message == \"Invalid HTTP header: 'X-Spam'\"\n            assert err2.headers is None\n            assert err2.foo == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pickle",
        "multidict.CIMultiDict",
        "aiohttp.http_exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert err2.code == 400",
        "assert err2.message == \"Invalid HTTP header: 'X-Spam'\"",
        "assert err2.headers is None",
        "assert err2.foo == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_str",
      "module": "test_http_exceptions",
      "class_name": "TestInvalidHeader",
      "file_path": "__internal__/data/aiohttp/tests/test_http_exceptions.py",
      "line_number": 127,
      "end_line_number": 129,
      "source_code": "def test_str(self) -> None:\n        err = http_exceptions.InvalidHeader(hdr=\"X-Spam\")\n        assert str(err) == \"400, message:\\n  Invalid HTTP header: 'X-Spam'\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pickle",
        "multidict.CIMultiDict",
        "aiohttp.http_exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(err) == \"400, message:\\n  Invalid HTTP header: 'X-Spam'\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_repr",
      "module": "test_http_exceptions",
      "class_name": "TestInvalidHeader",
      "file_path": "__internal__/data/aiohttp/tests/test_http_exceptions.py",
      "line_number": 131,
      "end_line_number": 134,
      "source_code": "def test_repr(self) -> None:\n        err = http_exceptions.InvalidHeader(hdr=\"X-Spam\")\n        expected = \"<InvalidHeader: 400, message=\\\"Invalid HTTP header: 'X-Spam'\\\">\"\n        assert repr(err) == expected",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pickle",
        "multidict.CIMultiDict",
        "aiohttp.http_exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(err) == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor",
      "module": "test_http_exceptions",
      "class_name": "TestBadStatusLine",
      "file_path": "__internal__/data/aiohttp/tests/test_http_exceptions.py",
      "line_number": 138,
      "end_line_number": 141,
      "source_code": "def test_ctor(self) -> None:\n        err = http_exceptions.BadStatusLine(\"Test\")\n        assert err.line == \"Test\"\n        assert str(err) == \"400, message:\\n  Bad status line 'Test'\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pickle",
        "multidict.CIMultiDict",
        "aiohttp.http_exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert err.line == 'Test'",
        "assert str(err) == \"400, message:\\n  Bad status line 'Test'\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor2",
      "module": "test_http_exceptions",
      "class_name": "TestBadStatusLine",
      "file_path": "__internal__/data/aiohttp/tests/test_http_exceptions.py",
      "line_number": 143,
      "end_line_number": 146,
      "source_code": "def test_ctor2(self) -> None:\n        err = http_exceptions.BadStatusLine(\"\")\n        assert err.line == \"\"\n        assert str(err) == \"400, message:\\n  Bad status line ''\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pickle",
        "multidict.CIMultiDict",
        "aiohttp.http_exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert err.line == ''",
        "assert str(err) == \"400, message:\\n  Bad status line ''\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_pickle",
      "module": "test_http_exceptions",
      "class_name": "TestBadStatusLine",
      "file_path": "__internal__/data/aiohttp/tests/test_http_exceptions.py",
      "line_number": 148,
      "end_line_number": 155,
      "source_code": "def test_pickle(self) -> None:\n        err = http_exceptions.BadStatusLine(\"Test\")\n        err.foo = \"bar\"  # type: ignore[attr-defined]\n        for proto in range(pickle.HIGHEST_PROTOCOL + 1):\n            pickled = pickle.dumps(err, proto)\n            err2 = pickle.loads(pickled)\n            assert err2.line == \"Test\"\n            assert err2.foo == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pickle",
        "multidict.CIMultiDict",
        "aiohttp.http_exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert err2.line == 'Test'",
        "assert err2.foo == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor",
      "module": "test_http_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_exceptions.py",
      "line_number": 11,
      "end_line_number": 17,
      "source_code": "def test_ctor(self) -> None:\n        err = http_exceptions.HttpProcessingError(\n            code=500, message=\"Internal error\", headers=CIMultiDict()\n        )\n        assert err.code == 500\n        assert err.message == \"Internal error\"\n        assert err.headers == CIMultiDict()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pickle",
        "multidict.CIMultiDict",
        "aiohttp.http_exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert err.code == 500",
        "assert err.message == 'Internal error'",
        "assert err.headers == CIMultiDict()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_pickle",
      "module": "test_http_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_exceptions.py",
      "line_number": 19,
      "end_line_number": 30,
      "source_code": "def test_pickle(self) -> None:\n        err = http_exceptions.HttpProcessingError(\n            code=500, message=\"Internal error\", headers=CIMultiDict()\n        )\n        err.foo = \"bar\"  # type: ignore[attr-defined]\n        for proto in range(pickle.HIGHEST_PROTOCOL + 1):\n            pickled = pickle.dumps(err, proto)\n            err2 = pickle.loads(pickled)\n            assert err2.code == 500\n            assert err2.message == \"Internal error\"\n            assert err2.headers == CIMultiDict()\n            assert err2.foo == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pickle",
        "multidict.CIMultiDict",
        "aiohttp.http_exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert err2.code == 500",
        "assert err2.message == 'Internal error'",
        "assert err2.headers == CIMultiDict()",
        "assert err2.foo == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_str",
      "module": "test_http_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_exceptions.py",
      "line_number": 32,
      "end_line_number": 36,
      "source_code": "def test_str(self) -> None:\n        err = http_exceptions.HttpProcessingError(\n            code=500, message=\"Internal error\", headers=CIMultiDict()\n        )\n        assert str(err) == \"500, message:\\n  Internal error\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pickle",
        "multidict.CIMultiDict",
        "aiohttp.http_exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(err) == '500, message:\\n  Internal error'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_repr",
      "module": "test_http_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_exceptions.py",
      "line_number": 38,
      "end_line_number": 42,
      "source_code": "def test_repr(self) -> None:\n        err = http_exceptions.HttpProcessingError(\n            code=500, message=\"Internal error\", headers=CIMultiDict()\n        )\n        assert repr(err) == (\"<HttpProcessingError: 500, message='Internal error'>\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pickle",
        "multidict.CIMultiDict",
        "aiohttp.http_exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(err) == \"<HttpProcessingError: 500, message='Internal error'>\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor",
      "module": "test_http_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_exceptions.py",
      "line_number": 46,
      "end_line_number": 50,
      "source_code": "def test_ctor(self) -> None:\n        err = http_exceptions.BadHttpMessage(\"Bad HTTP message\", headers=CIMultiDict())\n        assert err.code == 400\n        assert err.message == \"Bad HTTP message\"\n        assert err.headers == CIMultiDict()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pickle",
        "multidict.CIMultiDict",
        "aiohttp.http_exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert err.code == 400",
        "assert err.message == 'Bad HTTP message'",
        "assert err.headers == CIMultiDict()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_pickle",
      "module": "test_http_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_exceptions.py",
      "line_number": 52,
      "end_line_number": 63,
      "source_code": "def test_pickle(self) -> None:\n        err = http_exceptions.BadHttpMessage(\n            message=\"Bad HTTP message\", headers=CIMultiDict()\n        )\n        err.foo = \"bar\"  # type: ignore[attr-defined]\n        for proto in range(pickle.HIGHEST_PROTOCOL + 1):\n            pickled = pickle.dumps(err, proto)\n            err2 = pickle.loads(pickled)\n            assert err2.code == 400\n            assert err2.message == \"Bad HTTP message\"\n            assert err2.headers == {}\n            assert err2.foo == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pickle",
        "multidict.CIMultiDict",
        "aiohttp.http_exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert err2.code == 400",
        "assert err2.message == 'Bad HTTP message'",
        "assert err2.headers == {}",
        "assert err2.foo == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_str",
      "module": "test_http_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_exceptions.py",
      "line_number": 65,
      "end_line_number": 69,
      "source_code": "def test_str(self) -> None:\n        err = http_exceptions.BadHttpMessage(\n            message=\"Bad HTTP message\", headers=CIMultiDict()\n        )\n        assert str(err) == \"400, message:\\n  Bad HTTP message\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pickle",
        "multidict.CIMultiDict",
        "aiohttp.http_exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(err) == '400, message:\\n  Bad HTTP message'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_repr",
      "module": "test_http_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_exceptions.py",
      "line_number": 71,
      "end_line_number": 75,
      "source_code": "def test_repr(self) -> None:\n        err = http_exceptions.BadHttpMessage(\n            message=\"Bad HTTP message\", headers=CIMultiDict()\n        )\n        assert repr(err) == \"<BadHttpMessage: 400, message='Bad HTTP message'>\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pickle",
        "multidict.CIMultiDict",
        "aiohttp.http_exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(err) == \"<BadHttpMessage: 400, message='Bad HTTP message'>\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor",
      "module": "test_http_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_exceptions.py",
      "line_number": 79,
      "end_line_number": 83,
      "source_code": "def test_ctor(self) -> None:\n        err = http_exceptions.LineTooLong(\"spam\", \"10\", \"12\")\n        assert err.code == 400\n        assert err.message == \"Got more than 10 bytes (12) when reading spam.\"\n        assert err.headers is None",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pickle",
        "multidict.CIMultiDict",
        "aiohttp.http_exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert err.code == 400",
        "assert err.message == 'Got more than 10 bytes (12) when reading spam.'",
        "assert err.headers is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_pickle",
      "module": "test_http_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_exceptions.py",
      "line_number": 85,
      "end_line_number": 94,
      "source_code": "def test_pickle(self) -> None:\n        err = http_exceptions.LineTooLong(line=\"spam\", limit=\"10\", actual_size=\"12\")\n        err.foo = \"bar\"  # type: ignore[attr-defined]\n        for proto in range(pickle.HIGHEST_PROTOCOL + 1):\n            pickled = pickle.dumps(err, proto)\n            err2 = pickle.loads(pickled)\n            assert err2.code == 400\n            assert err2.message == (\"Got more than 10 bytes (12) when reading spam.\")\n            assert err2.headers is None\n            assert err2.foo == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pickle",
        "multidict.CIMultiDict",
        "aiohttp.http_exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert err2.code == 400",
        "assert err2.message == 'Got more than 10 bytes (12) when reading spam.'",
        "assert err2.headers is None",
        "assert err2.foo == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_str",
      "module": "test_http_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_exceptions.py",
      "line_number": 96,
      "end_line_number": 99,
      "source_code": "def test_str(self) -> None:\n        err = http_exceptions.LineTooLong(line=\"spam\", limit=\"10\", actual_size=\"12\")\n        expected = \"400, message:\\n  Got more than 10 bytes (12) when reading spam.\"\n        assert str(err) == expected",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pickle",
        "multidict.CIMultiDict",
        "aiohttp.http_exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(err) == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_repr",
      "module": "test_http_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_exceptions.py",
      "line_number": 101,
      "end_line_number": 106,
      "source_code": "def test_repr(self) -> None:\n        err = http_exceptions.LineTooLong(line=\"spam\", limit=\"10\", actual_size=\"12\")\n        assert repr(err) == (\n            \"<LineTooLong: 400, message='Got more than \"\n            \"10 bytes (12) when reading spam.'>\"\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pickle",
        "multidict.CIMultiDict",
        "aiohttp.http_exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(err) == \"<LineTooLong: 400, message='Got more than 10 bytes (12) when reading spam.'>\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor",
      "module": "test_http_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_exceptions.py",
      "line_number": 110,
      "end_line_number": 114,
      "source_code": "def test_ctor(self) -> None:\n        err = http_exceptions.InvalidHeader(\"X-Spam\")\n        assert err.code == 400\n        assert err.message == \"Invalid HTTP header: 'X-Spam'\"\n        assert err.headers is None",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pickle",
        "multidict.CIMultiDict",
        "aiohttp.http_exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert err.code == 400",
        "assert err.message == \"Invalid HTTP header: 'X-Spam'\"",
        "assert err.headers is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_pickle",
      "module": "test_http_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_exceptions.py",
      "line_number": 116,
      "end_line_number": 125,
      "source_code": "def test_pickle(self) -> None:\n        err = http_exceptions.InvalidHeader(hdr=\"X-Spam\")\n        err.foo = \"bar\"  # type: ignore[attr-defined]\n        for proto in range(pickle.HIGHEST_PROTOCOL + 1):\n            pickled = pickle.dumps(err, proto)\n            err2 = pickle.loads(pickled)\n            assert err2.code == 400\n            assert err2.message == \"Invalid HTTP header: 'X-Spam'\"\n            assert err2.headers is None\n            assert err2.foo == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pickle",
        "multidict.CIMultiDict",
        "aiohttp.http_exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert err2.code == 400",
        "assert err2.message == \"Invalid HTTP header: 'X-Spam'\"",
        "assert err2.headers is None",
        "assert err2.foo == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_str",
      "module": "test_http_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_exceptions.py",
      "line_number": 127,
      "end_line_number": 129,
      "source_code": "def test_str(self) -> None:\n        err = http_exceptions.InvalidHeader(hdr=\"X-Spam\")\n        assert str(err) == \"400, message:\\n  Invalid HTTP header: 'X-Spam'\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pickle",
        "multidict.CIMultiDict",
        "aiohttp.http_exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(err) == \"400, message:\\n  Invalid HTTP header: 'X-Spam'\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_repr",
      "module": "test_http_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_exceptions.py",
      "line_number": 131,
      "end_line_number": 134,
      "source_code": "def test_repr(self) -> None:\n        err = http_exceptions.InvalidHeader(hdr=\"X-Spam\")\n        expected = \"<InvalidHeader: 400, message=\\\"Invalid HTTP header: 'X-Spam'\\\">\"\n        assert repr(err) == expected",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pickle",
        "multidict.CIMultiDict",
        "aiohttp.http_exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(err) == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor",
      "module": "test_http_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_exceptions.py",
      "line_number": 138,
      "end_line_number": 141,
      "source_code": "def test_ctor(self) -> None:\n        err = http_exceptions.BadStatusLine(\"Test\")\n        assert err.line == \"Test\"\n        assert str(err) == \"400, message:\\n  Bad status line 'Test'\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pickle",
        "multidict.CIMultiDict",
        "aiohttp.http_exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert err.line == 'Test'",
        "assert str(err) == \"400, message:\\n  Bad status line 'Test'\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor2",
      "module": "test_http_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_exceptions.py",
      "line_number": 143,
      "end_line_number": 146,
      "source_code": "def test_ctor2(self) -> None:\n        err = http_exceptions.BadStatusLine(\"\")\n        assert err.line == \"\"\n        assert str(err) == \"400, message:\\n  Bad status line ''\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pickle",
        "multidict.CIMultiDict",
        "aiohttp.http_exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert err.line == ''",
        "assert str(err) == \"400, message:\\n  Bad status line ''\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_pickle",
      "module": "test_http_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_exceptions.py",
      "line_number": 148,
      "end_line_number": 155,
      "source_code": "def test_pickle(self) -> None:\n        err = http_exceptions.BadStatusLine(\"Test\")\n        err.foo = \"bar\"  # type: ignore[attr-defined]\n        for proto in range(pickle.HIGHEST_PROTOCOL + 1):\n            pickled = pickle.dumps(err, proto)\n            err2 = pickle.loads(pickled)\n            assert err2.line == \"Test\"\n            assert err2.foo == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pickle",
        "multidict.CIMultiDict",
        "aiohttp.http_exceptions"
      ],
      "fixtures": [],
      "assertions": [
        "assert err2.line == 'Test'",
        "assert err2.foo == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_tcp_nodelay_exception",
      "module": "test_tcp_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_tcp_helpers.py",
      "line_number": 23,
      "end_line_number": 31,
      "source_code": "def test_tcp_nodelay_exception() -> None:\n    transport = mock.Mock()\n    s = mock.Mock()\n    s.setsockopt = mock.Mock()\n    s.family = socket.AF_INET\n    s.setsockopt.side_effect = OSError\n    transport.get_extra_info.return_value = s\n    tcp_nodelay(transport, True)\n    s.setsockopt.assert_called_with(socket.IPPROTO_TCP, socket.TCP_NODELAY, True)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "socket",
        "unittest.mock",
        "pytest",
        "aiohttp.tcp_helpers.tcp_nodelay"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_tcp_nodelay_enable",
      "module": "test_tcp_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_tcp_helpers.py",
      "line_number": 34,
      "end_line_number": 39,
      "source_code": "def test_tcp_nodelay_enable() -> None:\n    transport = mock.Mock()\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        transport.get_extra_info.return_value = s\n        tcp_nodelay(transport, True)\n        assert s.getsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "socket",
        "unittest.mock",
        "pytest",
        "aiohttp.tcp_helpers.tcp_nodelay"
      ],
      "fixtures": [],
      "assertions": [
        "assert s.getsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_tcp_nodelay_enable_and_disable",
      "module": "test_tcp_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_tcp_helpers.py",
      "line_number": 42,
      "end_line_number": 49,
      "source_code": "def test_tcp_nodelay_enable_and_disable() -> None:\n    transport = mock.Mock()\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        transport.get_extra_info.return_value = s\n        tcp_nodelay(transport, True)\n        assert s.getsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY)\n        tcp_nodelay(transport, False)\n        assert not s.getsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "socket",
        "unittest.mock",
        "pytest",
        "aiohttp.tcp_helpers.tcp_nodelay"
      ],
      "fixtures": [],
      "assertions": [
        "assert s.getsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY)",
        "assert not s.getsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_tcp_nodelay_enable_ipv6",
      "module": "test_tcp_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_tcp_helpers.py",
      "line_number": 53,
      "end_line_number": 58,
      "source_code": "def test_tcp_nodelay_enable_ipv6() -> None:\n    transport = mock.Mock()\n    with socket.socket(socket.AF_INET6, socket.SOCK_STREAM) as s:\n        transport.get_extra_info.return_value = s\n        tcp_nodelay(transport, True)\n        assert s.getsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY)",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(not has_ipv6, reason='IPv6 is not available')"
      ],
      "arguments": [],
      "imports": [
        "socket",
        "unittest.mock",
        "pytest",
        "aiohttp.tcp_helpers.tcp_nodelay"
      ],
      "fixtures": [],
      "assertions": [
        "assert s.getsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_tcp_nodelay_enable_unix",
      "module": "test_tcp_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_tcp_helpers.py",
      "line_number": 62,
      "end_line_number": 68,
      "source_code": "def test_tcp_nodelay_enable_unix() -> None:\n    # do not set nodelay for unix socket\n    transport = mock.Mock()\n    s = mock.Mock(family=socket.AF_UNIX, type=socket.SOCK_STREAM)\n    transport.get_extra_info.return_value = s\n    tcp_nodelay(transport, True)\n    assert not s.setsockopt.called",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(not hasattr(socket, 'AF_UNIX'), reason='requires unix sockets')"
      ],
      "arguments": [],
      "imports": [
        "socket",
        "unittest.mock",
        "pytest",
        "aiohttp.tcp_helpers.tcp_nodelay"
      ],
      "fixtures": [],
      "assertions": [
        "assert not s.setsockopt.called"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock(family=socket.AF_UNIX, type=socket.SOCK_STREAM)"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_tcp_nodelay_enable_no_socket",
      "module": "test_tcp_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_tcp_helpers.py",
      "line_number": 71,
      "end_line_number": 74,
      "source_code": "def test_tcp_nodelay_enable_no_socket() -> None:\n    transport = mock.Mock()\n    transport.get_extra_info.return_value = None\n    tcp_nodelay(transport, True)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "socket",
        "unittest.mock",
        "pytest",
        "aiohttp.tcp_helpers.tcp_nodelay"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_payloadwriter_properties",
      "module": "test_http_writer",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_writer.py",
      "line_number": 39,
      "end_line_number": 46,
      "source_code": "def test_payloadwriter_properties(\n    transport: asyncio.Transport,\n    protocol: BaseProtocol,\n    loop: asyncio.AbstractEventLoop,\n) -> None:\n    writer = http.StreamWriter(protocol, loop)\n    assert writer.protocol == protocol\n    assert writer.transport == transport",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "transport",
        "protocol",
        "loop"
      ],
      "imports": [
        "array",
        "asyncio",
        "typing.Any",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "aiohttp.ClientConnectionResetError",
        "aiohttp.http",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [
        "assert writer.protocol == protocol",
        "assert writer.transport == transport"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_client_request_update_cookies",
      "module": "test_benchmarks_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_client_request.py",
      "line_number": 13,
      "end_line_number": 23,
      "source_code": "def test_client_request_update_cookies(\n    loop: asyncio.AbstractEventLoop, benchmark: BenchmarkFixture\n) -> None:\n    req = ClientRequest(\"get\", URL(\"http://python.org\"), loop=loop)\n    morsel: \"Morsel[str]\" = Morsel()\n    morsel.set(key=\"string\", val=\"Another string\", coded_val=\"really\")\n    morsel_cookie = {\"str\": morsel}\n\n    @benchmark\n    def _run() -> None:\n        req.update_cookies(cookies=morsel_cookie)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop",
        "benchmark"
      ],
      "imports": [
        "asyncio",
        "http.cookies.Morsel",
        "pytest_codspeed.BenchmarkFixture",
        "yarl.URL",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.http_writer.HttpVersion11"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_create_client_request_with_cookies",
      "module": "test_benchmarks_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_client_request.py",
      "line_number": 26,
      "end_line_number": 45,
      "source_code": "def test_create_client_request_with_cookies(\n    loop: asyncio.AbstractEventLoop, benchmark: BenchmarkFixture\n) -> None:\n    url = URL(\"http://python.org\")\n\n    @benchmark\n    def _run() -> None:\n        ClientRequest(\n            method=\"get\",\n            url=url,\n            loop=loop,\n            headers=None,\n            data=None,\n            cookies={\"cookie\": \"value\"},\n            auth=None,\n            version=HttpVersion11,\n            compress=False,\n            chunked=None,\n            expect100=False,\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop",
        "benchmark"
      ],
      "imports": [
        "asyncio",
        "http.cookies.Morsel",
        "pytest_codspeed.BenchmarkFixture",
        "yarl.URL",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.http_writer.HttpVersion11"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_create_client_request_with_headers",
      "module": "test_benchmarks_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_client_request.py",
      "line_number": 48,
      "end_line_number": 67,
      "source_code": "def test_create_client_request_with_headers(\n    loop: asyncio.AbstractEventLoop, benchmark: BenchmarkFixture\n) -> None:\n    url = URL(\"http://python.org\")\n\n    @benchmark\n    def _run() -> None:\n        ClientRequest(\n            method=\"get\",\n            url=url,\n            loop=loop,\n            headers={\"header\": \"value\", \"another\": \"header\"},\n            data=None,\n            cookies=None,\n            auth=None,\n            version=HttpVersion11,\n            compress=False,\n            chunked=None,\n            expect100=False,\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop",
        "benchmark"
      ],
      "imports": [
        "asyncio",
        "http.cookies.Morsel",
        "pytest_codspeed.BenchmarkFixture",
        "yarl.URL",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.http_writer.HttpVersion11"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_parse_empty",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 10,
      "end_line_number": 13,
      "source_code": "def test_parse_empty(self) -> None:\n        disptype, params = parse_content_disposition(None)\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_inlonly",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 15,
      "end_line_number": 18,
      "source_code": "def test_inlonly(self) -> None:\n        disptype, params = parse_content_disposition(\"inline\")\n        assert \"inline\" == disptype\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'inline' == disptype",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_inlonlyquoted",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 20,
      "end_line_number": 24,
      "source_code": "def test_inlonlyquoted(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition('\"inline\"')\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_semicolon",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 26,
      "end_line_number": 31,
      "source_code": "def test_semicolon(self) -> None:\n        disptype, params = parse_content_disposition(\n            'form-data; name=\"data\"; filename=\"file ; name.mp4\"'\n        )\n        assert disptype == \"form-data\"\n        assert params == {\"name\": \"data\", \"filename\": \"file ; name.mp4\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype == 'form-data'",
        "assert params == {'name': 'data', 'filename': 'file ; name.mp4'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_inlwithasciifilename",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 33,
      "end_line_number": 36,
      "source_code": "def test_inlwithasciifilename(self) -> None:\n        disptype, params = parse_content_disposition('inline; filename=\"foo.html\"')\n        assert \"inline\" == disptype\n        assert {\"filename\": \"foo.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'inline' == disptype",
        "assert {'filename': 'foo.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_inlwithfnattach",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 38,
      "end_line_number": 43,
      "source_code": "def test_inlwithfnattach(self) -> None:\n        disptype, params = parse_content_disposition(\n            'inline; filename=\"Not an attachment!\"'\n        )\n        assert \"inline\" == disptype\n        assert {\"filename\": \"Not an attachment!\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'inline' == disptype",
        "assert {'filename': 'Not an attachment!'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attonly",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 45,
      "end_line_number": 48,
      "source_code": "def test_attonly(self) -> None:\n        disptype, params = parse_content_disposition(\"attachment\")\n        assert \"attachment\" == disptype\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attonlyquoted",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 50,
      "end_line_number": 54,
      "source_code": "def test_attonlyquoted(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition('\"attachment\"')\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attonlyucase",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 56,
      "end_line_number": 59,
      "source_code": "def test_attonlyucase(self) -> None:\n        disptype, params = parse_content_disposition(\"ATTACHMENT\")\n        assert \"attachment\" == disptype\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithasciifilename",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 61,
      "end_line_number": 64,
      "source_code": "def test_attwithasciifilename(self) -> None:\n        disptype, params = parse_content_disposition('attachment; filename=\"foo.html\"')\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"foo.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': 'foo.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_inlwithasciifilenamepdf",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 66,
      "end_line_number": 69,
      "source_code": "def test_inlwithasciifilenamepdf(self) -> None:\n        disptype, params = parse_content_disposition('attachment; filename=\"foo.pdf\"')\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"foo.pdf\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': 'foo.pdf'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithasciifilename25",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 71,
      "end_line_number": 76,
      "source_code": "def test_attwithasciifilename25(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; filename=\"0000000000111111111122222\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"0000000000111111111122222\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': '0000000000111111111122222'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithasciifilename35",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 78,
      "end_line_number": 83,
      "source_code": "def test_attwithasciifilename35(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; filename=\"00000000001111111111222222222233333\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"00000000001111111111222222222233333\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': '00000000001111111111222222222233333'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithasciifnescapedchar",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 85,
      "end_line_number": 90,
      "source_code": "def test_attwithasciifnescapedchar(self) -> None:\n        disptype, params = parse_content_disposition(\n            r'attachment; filename=\"f\\oo.html\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"foo.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': 'foo.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithasciifnescapedquote",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 92,
      "end_line_number": 97,
      "source_code": "def test_attwithasciifnescapedquote(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; filename=\"\"quoting\" tested.html\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename\": '\"quoting\" tested.html'} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': '\"quoting\" tested.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithquotedsemicolon",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 100,
      "end_line_number": 105,
      "source_code": "def test_attwithquotedsemicolon(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; filename=\"Here\\'s a semicolon;.html\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"Here's a semicolon;.html\"} == params",
      "docstring": null,
      "decorators": [
        "pytest.mark.skip('need more smart parser which respects quoted text')"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': \"Here's a semicolon;.html\"} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfilenameandextparam",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 107,
      "end_line_number": 112,
      "source_code": "def test_attwithfilenameandextparam(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; foo=\"bar\"; filename=\"foo.html\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"foo.html\", \"foo\": \"bar\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': 'foo.html', 'foo': 'bar'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfilenameandextparamescaped",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 114,
      "end_line_number": 119,
      "source_code": "def test_attwithfilenameandextparamescaped(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; foo=\"\"\\\\\";filename=\"foo.html\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"foo.html\", \"foo\": '\"\\\\'} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': 'foo.html', 'foo': '\"\\\\'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithasciifilenameucase",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 121,
      "end_line_number": 124,
      "source_code": "def test_attwithasciifilenameucase(self) -> None:\n        disptype, params = parse_content_disposition('attachment; FILENAME=\"foo.html\"')\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"foo.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': 'foo.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithasciifilenamenq",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 126,
      "end_line_number": 129,
      "source_code": "def test_attwithasciifilenamenq(self) -> None:\n        disptype, params = parse_content_disposition(\"attachment; filename=foo.html\")\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"foo.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': 'foo.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithtokfncommanq",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 131,
      "end_line_number": 137,
      "source_code": "def test_attwithtokfncommanq(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\n                \"attachment; filename=foo,bar.html\"\n            )\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithasciifilenamenqs",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 139,
      "end_line_number": 145,
      "source_code": "def test_attwithasciifilenamenqs(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\n                \"attachment; filename=foo.html ;\"\n            )\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attemptyparam",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 147,
      "end_line_number": 151,
      "source_code": "def test_attemptyparam(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\"attachment; ;filename=foo\")\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithasciifilenamenqws",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 153,
      "end_line_number": 159,
      "source_code": "def test_attwithasciifilenamenqws(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\n                \"attachment; filename=foo bar.html\"\n            )\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfntokensq",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 161,
      "end_line_number": 164,
      "source_code": "def test_attwithfntokensq(self) -> None:\n        disptype, params = parse_content_disposition(\"attachment; filename='foo.html'\")\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"'foo.html'\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': \"'foo.html'\"} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithisofnplain",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 166,
      "end_line_number": 171,
      "source_code": "def test_attwithisofnplain(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; filename=\"foo-\u00e4.html\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"foo-\u00e4.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': 'foo-\u00e4.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithutf8fnplain",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 173,
      "end_line_number": 178,
      "source_code": "def test_attwithutf8fnplain(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; filename=\"foo-\u00c3\u00a4.html\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"foo-\u00c3\u00a4.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': 'foo-\u00c3\u00a4.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfnrawpctenca",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 180,
      "end_line_number": 185,
      "source_code": "def test_attwithfnrawpctenca(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; filename=\"foo-%41.html\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"foo-%41.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': 'foo-%41.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfnusingpct",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 187,
      "end_line_number": 190,
      "source_code": "def test_attwithfnusingpct(self) -> None:\n        disptype, params = parse_content_disposition('attachment; filename=\"50%.html\"')\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"50%.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': '50%.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfnrawpctencaq",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 192,
      "end_line_number": 197,
      "source_code": "def test_attwithfnrawpctencaq(self) -> None:\n        disptype, params = parse_content_disposition(\n            r'attachment; filename=\"foo-%\\41.html\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename\": r\"foo-%41.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': 'foo-%41.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithnamepct",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 199,
      "end_line_number": 204,
      "source_code": "def test_attwithnamepct(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; filename=\"foo-%41.html\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"foo-%41.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': 'foo-%41.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfilenamepctandiso",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 206,
      "end_line_number": 211,
      "source_code": "def test_attwithfilenamepctandiso(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; filename=\"\u00e4-%41.html\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"\u00e4-%41.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': '\u00e4-%41.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfnrawpctenclong",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 213,
      "end_line_number": 218,
      "source_code": "def test_attwithfnrawpctenclong(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; filename=\"foo-%c3%a4-%e2%82%ac.html\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"foo-%c3%a4-%e2%82%ac.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': 'foo-%c3%a4-%e2%82%ac.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithasciifilenamews1",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 220,
      "end_line_number": 223,
      "source_code": "def test_attwithasciifilenamews1(self) -> None:\n        disptype, params = parse_content_disposition('attachment; filename =\"foo.html\"')\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"foo.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': 'foo.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwith2filenames",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 225,
      "end_line_number": 231,
      "source_code": "def test_attwith2filenames(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\n                'attachment; filename=\"foo.html\"; filename=\"bar.html\"'\n            )\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfnbrokentoken",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 233,
      "end_line_number": 239,
      "source_code": "def test_attfnbrokentoken(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\n                \"attachment; filename=foo[1](2).html\"\n            )\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfnbrokentokeniso",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 241,
      "end_line_number": 247,
      "source_code": "def test_attfnbrokentokeniso(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\n                \"attachment; filename=foo-\u00e4.html\"\n            )\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfnbrokentokenutf",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 249,
      "end_line_number": 255,
      "source_code": "def test_attfnbrokentokenutf(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\n                \"attachment; filename=foo-\u00c3\u00a4.html\"\n            )\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attmissingdisposition",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 257,
      "end_line_number": 261,
      "source_code": "def test_attmissingdisposition(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\"filename=foo.html\")\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attmissingdisposition2",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 263,
      "end_line_number": 267,
      "source_code": "def test_attmissingdisposition2(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\"x=y; filename=foo.html\")\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attmissingdisposition3",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 269,
      "end_line_number": 275,
      "source_code": "def test_attmissingdisposition3(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\n                '\"foo; filename=bar;baz\"; filename=qux'\n            )\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attmissingdisposition4",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 277,
      "end_line_number": 283,
      "source_code": "def test_attmissingdisposition4(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\n                \"filename=foo.html, filename=bar.html\"\n            )\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_emptydisposition",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 285,
      "end_line_number": 289,
      "source_code": "def test_emptydisposition(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\"; filename=foo.html\")\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_doublecolon",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 291,
      "end_line_number": 297,
      "source_code": "def test_doublecolon(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\n                \": inline; attachment; filename=foo.html\"\n            )\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attandinline",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 299,
      "end_line_number": 305,
      "source_code": "def test_attandinline(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\n                \"inline; attachment; filename=foo.html\"\n            )\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attandinline2",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 307,
      "end_line_number": 313,
      "source_code": "def test_attandinline2(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\n                \"attachment; inline; filename=foo.html\"\n            )\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attbrokenquotedfn",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 315,
      "end_line_number": 321,
      "source_code": "def test_attbrokenquotedfn(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\n                'attachment; filename=\"foo.html\".txt'\n            )\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attbrokenquotedfn2",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 323,
      "end_line_number": 327,
      "source_code": "def test_attbrokenquotedfn2(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition('attachment; filename=\"bar')\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attbrokenquotedfn3",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 329,
      "end_line_number": 335,
      "source_code": "def test_attbrokenquotedfn3(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\n                'attachment; filename=foo\"bar;baz\"qux'\n            )\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attmultinstances",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 337,
      "end_line_number": 343,
      "source_code": "def test_attmultinstances(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\n                \"attachment; filename=foo.html, attachment; filename=bar.html\"\n            )\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attmissingdelim",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 345,
      "end_line_number": 351,
      "source_code": "def test_attmissingdelim(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\n                \"attachment; foo=foo filename=bar\"\n            )\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attmissingdelim2",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 353,
      "end_line_number": 359,
      "source_code": "def test_attmissingdelim2(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\n                \"attachment; filename=bar foo=foo\"\n            )\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attmissingdelim3",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 361,
      "end_line_number": 365,
      "source_code": "def test_attmissingdelim3(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\"attachment filename=bar\")\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attreversed",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 367,
      "end_line_number": 373,
      "source_code": "def test_attreversed(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\n                \"filename=foo.html; attachment\"\n            )\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attconfusedparam",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 375,
      "end_line_number": 378,
      "source_code": "def test_attconfusedparam(self) -> None:\n        disptype, params = parse_content_disposition(\"attachment; xfilename=foo.html\")\n        assert \"attachment\" == disptype\n        assert {\"xfilename\": \"foo.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'xfilename': 'foo.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attabspath",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 380,
      "end_line_number": 383,
      "source_code": "def test_attabspath(self) -> None:\n        disptype, params = parse_content_disposition('attachment; filename=\"/foo.html\"')\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"foo.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': 'foo.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attabspathwin",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 385,
      "end_line_number": 390,
      "source_code": "def test_attabspathwin(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; filename=\"\\\\foo.html\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"foo.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': 'foo.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attcdate",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 392,
      "end_line_number": 397,
      "source_code": "def test_attcdate(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; creation-date=\"Wed, 12 Feb 1997 16:29:51 -0500\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"creation-date\": \"Wed, 12 Feb 1997 16:29:51 -0500\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'creation-date': 'Wed, 12 Feb 1997 16:29:51 -0500'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attmdate",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 399,
      "end_line_number": 404,
      "source_code": "def test_attmdate(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; modification-date=\"Wed, 12 Feb 1997 16:29:51 -0500\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"modification-date\": \"Wed, 12 Feb 1997 16:29:51 -0500\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'modification-date': 'Wed, 12 Feb 1997 16:29:51 -0500'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_dispext",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 406,
      "end_line_number": 409,
      "source_code": "def test_dispext(self) -> None:\n        disptype, params = parse_content_disposition(\"foobar\")\n        assert \"foobar\" == disptype\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'foobar' == disptype",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_dispextbadfn",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 411,
      "end_line_number": 416,
      "source_code": "def test_dispextbadfn(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; example=\"filename=example.txt\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"example\": \"filename=example.txt\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'example': 'filename=example.txt'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithisofn2231iso",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 418,
      "end_line_number": 423,
      "source_code": "def test_attwithisofn2231iso(self) -> None:\n        disptype, params = parse_content_disposition(\n            \"attachment; filename*=iso-8859-1''foo-%E4.html\"\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename*\": \"foo-\u00e4.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename*': 'foo-\u00e4.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfn2231utf8",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 425,
      "end_line_number": 430,
      "source_code": "def test_attwithfn2231utf8(self) -> None:\n        disptype, params = parse_content_disposition(\n            \"attachment; filename*=UTF-8''foo-%c3%a4-%e2%82%ac.html\"\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename*\": \"foo-\u00e4-\u20ac.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename*': 'foo-\u00e4-\u20ac.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfn2231noc",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 432,
      "end_line_number": 437,
      "source_code": "def test_attwithfn2231noc(self) -> None:\n        disptype, params = parse_content_disposition(\n            \"attachment; filename*=''foo-%c3%a4-%e2%82%ac.html\"\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename*\": \"foo-\u00e4-\u20ac.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename*': 'foo-\u00e4-\u20ac.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfn2231utf8comp",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 439,
      "end_line_number": 444,
      "source_code": "def test_attwithfn2231utf8comp(self) -> None:\n        disptype, params = parse_content_disposition(\n            \"attachment; filename*=UTF-8''foo-a%cc%88.html\"\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename*\": \"foo-a\u0308.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename*': 'foo-a\u0308.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfn2231utf8_bad",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 447,
      "end_line_number": 453,
      "source_code": "def test_attwithfn2231utf8_bad(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionParam):\n            disptype, params = parse_content_disposition(\n                \"attachment; filename*=iso-8859-1''foo-%c3%a4-%e2%82%ac.html\"\n            )\n        assert \"attachment\" == disptype\n        assert {} == params",
      "docstring": null,
      "decorators": [
        "pytest.mark.skip('should raise decoding error: %82 is invalid for latin1')"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfn2231iso_bad",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 456,
      "end_line_number": 462,
      "source_code": "def test_attwithfn2231iso_bad(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionParam):\n            disptype, params = parse_content_disposition(\n                \"attachment; filename*=utf-8''foo-%E4.html\"\n            )\n        assert \"attachment\" == disptype\n        assert {} == params",
      "docstring": null,
      "decorators": [
        "pytest.mark.skip('should raise decoding error: %E4 is invalid for utf-8')"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfn2231ws1",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 464,
      "end_line_number": 470,
      "source_code": "def test_attwithfn2231ws1(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionParam):\n            disptype, params = parse_content_disposition(\n                \"attachment; filename *=UTF-8''foo-%c3%a4.html\"\n            )\n        assert \"attachment\" == disptype\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfn2231ws2",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 472,
      "end_line_number": 477,
      "source_code": "def test_attwithfn2231ws2(self) -> None:\n        disptype, params = parse_content_disposition(\n            \"attachment; filename*= UTF-8''foo-%c3%a4.html\"\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename*\": \"foo-\u00e4.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename*': 'foo-\u00e4.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfn2231ws3",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 479,
      "end_line_number": 484,
      "source_code": "def test_attwithfn2231ws3(self) -> None:\n        disptype, params = parse_content_disposition(\n            \"attachment; filename* =UTF-8''foo-%c3%a4.html\"\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename*\": \"foo-\u00e4.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename*': 'foo-\u00e4.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfn2231quot",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 486,
      "end_line_number": 492,
      "source_code": "def test_attwithfn2231quot(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionParam):\n            disptype, params = parse_content_disposition(\n                \"attachment; filename*=\\\"UTF-8''foo-%c3%a4.html\\\"\"\n            )\n        assert \"attachment\" == disptype\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfn2231quot2",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 494,
      "end_line_number": 500,
      "source_code": "def test_attwithfn2231quot2(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionParam):\n            disptype, params = parse_content_disposition(\n                'attachment; filename*=\"foo%20bar.html\"'\n            )\n        assert \"attachment\" == disptype\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfn2231singleqmissing",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 502,
      "end_line_number": 508,
      "source_code": "def test_attwithfn2231singleqmissing(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionParam):\n            disptype, params = parse_content_disposition(\n                \"attachment; filename*=UTF-8'foo-%c3%a4.html\"\n            )\n        assert \"attachment\" == disptype\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfn2231nbadpct1",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 511,
      "end_line_number": 517,
      "source_code": "def test_attwithfn2231nbadpct1(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionParam):\n            disptype, params = parse_content_disposition(\n                \"attachment; filename*=UTF-8''foo%\"\n            )\n        assert \"attachment\" == disptype\n        assert {} == params",
      "docstring": null,
      "decorators": [
        "pytest.mark.skip('urllib.parse.unquote is tolerate to standalone % chars')"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfn2231nbadpct2",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 520,
      "end_line_number": 526,
      "source_code": "def test_attwithfn2231nbadpct2(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionParam):\n            disptype, params = parse_content_disposition(\n                \"attachment; filename*=UTF-8''f%oo.html\"\n            )\n        assert \"attachment\" == disptype\n        assert {} == params",
      "docstring": null,
      "decorators": [
        "pytest.mark.skip('urllib.parse.unquote is tolerate to standalone % chars')"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfn2231dpct",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 528,
      "end_line_number": 533,
      "source_code": "def test_attwithfn2231dpct(self) -> None:\n        disptype, params = parse_content_disposition(\n            \"attachment; filename*=UTF-8''A-%2541.html\"\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename*\": \"A-%41.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename*': 'A-%41.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfn2231abspathdisguised",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 535,
      "end_line_number": 540,
      "source_code": "def test_attwithfn2231abspathdisguised(self) -> None:\n        disptype, params = parse_content_disposition(\n            \"attachment; filename*=UTF-8''%5cfoo.html\"\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename*\": \"\\\\foo.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename*': '\\\\foo.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfncont",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 542,
      "end_line_number": 547,
      "source_code": "def test_attfncont(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; filename*0=\"foo.\"; filename*1=\"html\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename*0\": \"foo.\", \"filename*1\": \"html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename*0': 'foo.', 'filename*1': 'html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfncontqs",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 549,
      "end_line_number": 554,
      "source_code": "def test_attfncontqs(self) -> None:\n        disptype, params = parse_content_disposition(\n            r'attachment; filename*0=\"foo\"; filename*1=\"\\b\\a\\r.html\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename*0\": \"foo\", \"filename*1\": \"bar.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename*0': 'foo', 'filename*1': 'bar.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfncontenc",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 556,
      "end_line_number": 561,
      "source_code": "def test_attfncontenc(self) -> None:\n        disptype, params = parse_content_disposition(\n            \"attachment; filename*0*=UTF-8\" + 'foo-%c3%a4; filename*1=\".html\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename*0*\": \"UTF-8foo-%c3%a4\", \"filename*1\": \".html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename*0*': 'UTF-8foo-%c3%a4', 'filename*1': '.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfncontlz",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 563,
      "end_line_number": 568,
      "source_code": "def test_attfncontlz(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; filename*0=\"foo\"; filename*01=\"bar\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename*0\": \"foo\", \"filename*01\": \"bar\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename*0': 'foo', 'filename*01': 'bar'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfncontnc",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 570,
      "end_line_number": 575,
      "source_code": "def test_attfncontnc(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; filename*0=\"foo\"; filename*2=\"bar\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename*0\": \"foo\", \"filename*2\": \"bar\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename*0': 'foo', 'filename*2': 'bar'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfnconts1",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 577,
      "end_line_number": 582,
      "source_code": "def test_attfnconts1(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; filename*0=\"foo.\"; filename*2=\"html\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename*0\": \"foo.\", \"filename*2\": \"html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename*0': 'foo.', 'filename*2': 'html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfncontord",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 584,
      "end_line_number": 589,
      "source_code": "def test_attfncontord(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; filename*1=\"bar\"; filename*0=\"foo\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename*0\": \"foo\", \"filename*1\": \"bar\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename*0': 'foo', 'filename*1': 'bar'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfnboth",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 591,
      "end_line_number": 596,
      "source_code": "def test_attfnboth(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; filename=\"foo-ae.html\";' + \" filename*=UTF-8''foo-%c3%a4.html\"\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"foo-ae.html\", \"filename*\": \"foo-\u00e4.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': 'foo-ae.html', 'filename*': 'foo-\u00e4.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfnboth2",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 598,
      "end_line_number": 603,
      "source_code": "def test_attfnboth2(self) -> None:\n        disptype, params = parse_content_disposition(\n            \"attachment; filename*=UTF-8''foo-%c3%a4.html;\" + ' filename=\"foo-ae.html\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"foo-ae.html\", \"filename*\": \"foo-\u00e4.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': 'foo-ae.html', 'filename*': 'foo-\u00e4.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfnboth3",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 605,
      "end_line_number": 614,
      "source_code": "def test_attfnboth3(self) -> None:\n        disptype, params = parse_content_disposition(\n            \"attachment; filename*0*=ISO-8859-15''euro-sign%3d%a4;\"\n            \" filename*=ISO-8859-1''currency-sign%3d%a4\"\n        )\n        assert \"attachment\" == disptype\n        assert {\n            \"filename*\": \"currency-sign=\u00a4\",\n            \"filename*0*\": \"ISO-8859-15''euro-sign%3d%a4\",\n        } == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename*': 'currency-sign=\u00a4', 'filename*0*': \"ISO-8859-15''euro-sign%3d%a4\"} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attnewandfn",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 616,
      "end_line_number": 621,
      "source_code": "def test_attnewandfn(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; foobar=x; filename=\"foo.html\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"foobar\": \"x\", \"filename\": \"foo.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'foobar': 'x', 'filename': 'foo.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attrfc2047token",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 623,
      "end_line_number": 629,
      "source_code": "def test_attrfc2047token(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\n                \"attachment; filename==?ISO-8859-1?Q?foo-=E4.html?=\"\n            )\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attrfc2047quoted",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 631,
      "end_line_number": 636,
      "source_code": "def test_attrfc2047quoted(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; filename=\"=?ISO-8859-1?Q?foo-=E4.html?=\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"=?ISO-8859-1?Q?foo-=E4.html?=\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': '=?ISO-8859-1?Q?foo-=E4.html?='} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_bad_continuous_param",
      "module": "test_multipart_helpers",
      "class_name": "TestParseContentDisposition",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 638,
      "end_line_number": 644,
      "source_code": "def test_bad_continuous_param(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionParam):\n            disptype, params = parse_content_disposition(\n                \"attachment; filename*0=foo bar\"\n            )\n        assert \"attachment\" == disptype\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_no_filename",
      "module": "test_multipart_helpers",
      "class_name": "TestContentDispositionFilename",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 650,
      "end_line_number": 652,
      "source_code": "def test_no_filename(self) -> None:\n        assert content_disposition_filename({}) is None\n        assert content_disposition_filename({\"foo\": \"bar\"}) is None",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert content_disposition_filename({}) is None",
        "assert content_disposition_filename({'foo': 'bar'}) is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_filename",
      "module": "test_multipart_helpers",
      "class_name": "TestContentDispositionFilename",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 654,
      "end_line_number": 656,
      "source_code": "def test_filename(self) -> None:\n        params = {\"filename\": \"foo.html\"}\n        assert \"foo.html\" == content_disposition_filename(params)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'foo.html' == content_disposition_filename(params)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_filename_ext",
      "module": "test_multipart_helpers",
      "class_name": "TestContentDispositionFilename",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 658,
      "end_line_number": 660,
      "source_code": "def test_filename_ext(self) -> None:\n        params = {\"filename*\": \"\u0444\u0430\u0439\u043b.html\"}\n        assert \"\u0444\u0430\u0439\u043b.html\" == content_disposition_filename(params)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert '\u0444\u0430\u0439\u043b.html' == content_disposition_filename(params)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfncont",
      "module": "test_multipart_helpers",
      "class_name": "TestContentDispositionFilename",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 662,
      "end_line_number": 664,
      "source_code": "def test_attfncont(self) -> None:\n        params = {\"filename*0\": \"foo.\", \"filename*1\": \"html\"}\n        assert \"foo.html\" == content_disposition_filename(params)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'foo.html' == content_disposition_filename(params)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfncontqs",
      "module": "test_multipart_helpers",
      "class_name": "TestContentDispositionFilename",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 666,
      "end_line_number": 668,
      "source_code": "def test_attfncontqs(self) -> None:\n        params = {\"filename*0\": \"foo\", \"filename*1\": \"bar.html\"}\n        assert \"foobar.html\" == content_disposition_filename(params)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'foobar.html' == content_disposition_filename(params)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfncontenc",
      "module": "test_multipart_helpers",
      "class_name": "TestContentDispositionFilename",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 670,
      "end_line_number": 672,
      "source_code": "def test_attfncontenc(self) -> None:\n        params = {\"filename*0*\": \"UTF-8''foo-%c3%a4\", \"filename*1\": \".html\"}\n        assert \"foo-\u00e4.html\" == content_disposition_filename(params)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'foo-\u00e4.html' == content_disposition_filename(params)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfncontlz",
      "module": "test_multipart_helpers",
      "class_name": "TestContentDispositionFilename",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 674,
      "end_line_number": 676,
      "source_code": "def test_attfncontlz(self) -> None:\n        params = {\"filename*0\": \"foo\", \"filename*01\": \"bar\"}\n        assert \"foo\" == content_disposition_filename(params)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'foo' == content_disposition_filename(params)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfncontnc",
      "module": "test_multipart_helpers",
      "class_name": "TestContentDispositionFilename",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 678,
      "end_line_number": 680,
      "source_code": "def test_attfncontnc(self) -> None:\n        params = {\"filename*0\": \"foo\", \"filename*2\": \"bar\"}\n        assert \"foo\" == content_disposition_filename(params)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'foo' == content_disposition_filename(params)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfnconts1",
      "module": "test_multipart_helpers",
      "class_name": "TestContentDispositionFilename",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 682,
      "end_line_number": 684,
      "source_code": "def test_attfnconts1(self) -> None:\n        params = {\"filename*1\": \"foo\", \"filename*2\": \"bar\"}\n        assert content_disposition_filename(params) is None",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert content_disposition_filename(params) is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfnboth",
      "module": "test_multipart_helpers",
      "class_name": "TestContentDispositionFilename",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 686,
      "end_line_number": 688,
      "source_code": "def test_attfnboth(self) -> None:\n        params = {\"filename\": \"foo-ae.html\", \"filename*\": \"foo-\u00e4.html\"}\n        assert \"foo-\u00e4.html\" == content_disposition_filename(params)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'foo-\u00e4.html' == content_disposition_filename(params)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfnboth3",
      "module": "test_multipart_helpers",
      "class_name": "TestContentDispositionFilename",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 690,
      "end_line_number": 695,
      "source_code": "def test_attfnboth3(self) -> None:\n        params = {\n            \"filename*0*\": \"ISO-8859-15''euro-sign%3d%a4\",\n            \"filename*\": \"currency-sign=\u00a4\",\n        }\n        assert \"currency-sign=\u00a4\" == content_disposition_filename(params)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'currency-sign=\u00a4' == content_disposition_filename(params)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attrfc2047quoted",
      "module": "test_multipart_helpers",
      "class_name": "TestContentDispositionFilename",
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 697,
      "end_line_number": 699,
      "source_code": "def test_attrfc2047quoted(self) -> None:\n        params = {\"filename\": \"=?ISO-8859-1?Q?foo-=E4.html?=\"}\n        assert \"=?ISO-8859-1?Q?foo-=E4.html?=\" == content_disposition_filename(params)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert '=?ISO-8859-1?Q?foo-=E4.html?=' == content_disposition_filename(params)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_parse_empty",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 10,
      "end_line_number": 13,
      "source_code": "def test_parse_empty(self) -> None:\n        disptype, params = parse_content_disposition(None)\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_inlonly",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 15,
      "end_line_number": 18,
      "source_code": "def test_inlonly(self) -> None:\n        disptype, params = parse_content_disposition(\"inline\")\n        assert \"inline\" == disptype\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'inline' == disptype",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_inlonlyquoted",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 20,
      "end_line_number": 24,
      "source_code": "def test_inlonlyquoted(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition('\"inline\"')\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_semicolon",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 26,
      "end_line_number": 31,
      "source_code": "def test_semicolon(self) -> None:\n        disptype, params = parse_content_disposition(\n            'form-data; name=\"data\"; filename=\"file ; name.mp4\"'\n        )\n        assert disptype == \"form-data\"\n        assert params == {\"name\": \"data\", \"filename\": \"file ; name.mp4\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype == 'form-data'",
        "assert params == {'name': 'data', 'filename': 'file ; name.mp4'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_inlwithasciifilename",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 33,
      "end_line_number": 36,
      "source_code": "def test_inlwithasciifilename(self) -> None:\n        disptype, params = parse_content_disposition('inline; filename=\"foo.html\"')\n        assert \"inline\" == disptype\n        assert {\"filename\": \"foo.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'inline' == disptype",
        "assert {'filename': 'foo.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_inlwithfnattach",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 38,
      "end_line_number": 43,
      "source_code": "def test_inlwithfnattach(self) -> None:\n        disptype, params = parse_content_disposition(\n            'inline; filename=\"Not an attachment!\"'\n        )\n        assert \"inline\" == disptype\n        assert {\"filename\": \"Not an attachment!\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'inline' == disptype",
        "assert {'filename': 'Not an attachment!'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attonly",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 45,
      "end_line_number": 48,
      "source_code": "def test_attonly(self) -> None:\n        disptype, params = parse_content_disposition(\"attachment\")\n        assert \"attachment\" == disptype\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attonlyquoted",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 50,
      "end_line_number": 54,
      "source_code": "def test_attonlyquoted(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition('\"attachment\"')\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attonlyucase",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 56,
      "end_line_number": 59,
      "source_code": "def test_attonlyucase(self) -> None:\n        disptype, params = parse_content_disposition(\"ATTACHMENT\")\n        assert \"attachment\" == disptype\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithasciifilename",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 61,
      "end_line_number": 64,
      "source_code": "def test_attwithasciifilename(self) -> None:\n        disptype, params = parse_content_disposition('attachment; filename=\"foo.html\"')\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"foo.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': 'foo.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_inlwithasciifilenamepdf",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 66,
      "end_line_number": 69,
      "source_code": "def test_inlwithasciifilenamepdf(self) -> None:\n        disptype, params = parse_content_disposition('attachment; filename=\"foo.pdf\"')\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"foo.pdf\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': 'foo.pdf'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithasciifilename25",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 71,
      "end_line_number": 76,
      "source_code": "def test_attwithasciifilename25(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; filename=\"0000000000111111111122222\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"0000000000111111111122222\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': '0000000000111111111122222'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithasciifilename35",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 78,
      "end_line_number": 83,
      "source_code": "def test_attwithasciifilename35(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; filename=\"00000000001111111111222222222233333\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"00000000001111111111222222222233333\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': '00000000001111111111222222222233333'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithasciifnescapedchar",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 85,
      "end_line_number": 90,
      "source_code": "def test_attwithasciifnescapedchar(self) -> None:\n        disptype, params = parse_content_disposition(\n            r'attachment; filename=\"f\\oo.html\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"foo.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': 'foo.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithasciifnescapedquote",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 92,
      "end_line_number": 97,
      "source_code": "def test_attwithasciifnescapedquote(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; filename=\"\"quoting\" tested.html\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename\": '\"quoting\" tested.html'} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': '\"quoting\" tested.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithquotedsemicolon",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 100,
      "end_line_number": 105,
      "source_code": "def test_attwithquotedsemicolon(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; filename=\"Here\\'s a semicolon;.html\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"Here's a semicolon;.html\"} == params",
      "docstring": null,
      "decorators": [
        "pytest.mark.skip('need more smart parser which respects quoted text')"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': \"Here's a semicolon;.html\"} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfilenameandextparam",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 107,
      "end_line_number": 112,
      "source_code": "def test_attwithfilenameandextparam(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; foo=\"bar\"; filename=\"foo.html\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"foo.html\", \"foo\": \"bar\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': 'foo.html', 'foo': 'bar'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfilenameandextparamescaped",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 114,
      "end_line_number": 119,
      "source_code": "def test_attwithfilenameandextparamescaped(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; foo=\"\"\\\\\";filename=\"foo.html\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"foo.html\", \"foo\": '\"\\\\'} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': 'foo.html', 'foo': '\"\\\\'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithasciifilenameucase",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 121,
      "end_line_number": 124,
      "source_code": "def test_attwithasciifilenameucase(self) -> None:\n        disptype, params = parse_content_disposition('attachment; FILENAME=\"foo.html\"')\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"foo.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': 'foo.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithasciifilenamenq",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 126,
      "end_line_number": 129,
      "source_code": "def test_attwithasciifilenamenq(self) -> None:\n        disptype, params = parse_content_disposition(\"attachment; filename=foo.html\")\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"foo.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': 'foo.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithtokfncommanq",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 131,
      "end_line_number": 137,
      "source_code": "def test_attwithtokfncommanq(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\n                \"attachment; filename=foo,bar.html\"\n            )\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithasciifilenamenqs",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 139,
      "end_line_number": 145,
      "source_code": "def test_attwithasciifilenamenqs(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\n                \"attachment; filename=foo.html ;\"\n            )\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attemptyparam",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 147,
      "end_line_number": 151,
      "source_code": "def test_attemptyparam(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\"attachment; ;filename=foo\")\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithasciifilenamenqws",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 153,
      "end_line_number": 159,
      "source_code": "def test_attwithasciifilenamenqws(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\n                \"attachment; filename=foo bar.html\"\n            )\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfntokensq",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 161,
      "end_line_number": 164,
      "source_code": "def test_attwithfntokensq(self) -> None:\n        disptype, params = parse_content_disposition(\"attachment; filename='foo.html'\")\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"'foo.html'\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': \"'foo.html'\"} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithisofnplain",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 166,
      "end_line_number": 171,
      "source_code": "def test_attwithisofnplain(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; filename=\"foo-\u00e4.html\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"foo-\u00e4.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': 'foo-\u00e4.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithutf8fnplain",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 173,
      "end_line_number": 178,
      "source_code": "def test_attwithutf8fnplain(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; filename=\"foo-\u00c3\u00a4.html\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"foo-\u00c3\u00a4.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': 'foo-\u00c3\u00a4.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfnrawpctenca",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 180,
      "end_line_number": 185,
      "source_code": "def test_attwithfnrawpctenca(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; filename=\"foo-%41.html\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"foo-%41.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': 'foo-%41.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfnusingpct",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 187,
      "end_line_number": 190,
      "source_code": "def test_attwithfnusingpct(self) -> None:\n        disptype, params = parse_content_disposition('attachment; filename=\"50%.html\"')\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"50%.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': '50%.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfnrawpctencaq",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 192,
      "end_line_number": 197,
      "source_code": "def test_attwithfnrawpctencaq(self) -> None:\n        disptype, params = parse_content_disposition(\n            r'attachment; filename=\"foo-%\\41.html\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename\": r\"foo-%41.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': 'foo-%41.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithnamepct",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 199,
      "end_line_number": 204,
      "source_code": "def test_attwithnamepct(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; filename=\"foo-%41.html\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"foo-%41.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': 'foo-%41.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfilenamepctandiso",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 206,
      "end_line_number": 211,
      "source_code": "def test_attwithfilenamepctandiso(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; filename=\"\u00e4-%41.html\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"\u00e4-%41.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': '\u00e4-%41.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfnrawpctenclong",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 213,
      "end_line_number": 218,
      "source_code": "def test_attwithfnrawpctenclong(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; filename=\"foo-%c3%a4-%e2%82%ac.html\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"foo-%c3%a4-%e2%82%ac.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': 'foo-%c3%a4-%e2%82%ac.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithasciifilenamews1",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 220,
      "end_line_number": 223,
      "source_code": "def test_attwithasciifilenamews1(self) -> None:\n        disptype, params = parse_content_disposition('attachment; filename =\"foo.html\"')\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"foo.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': 'foo.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwith2filenames",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 225,
      "end_line_number": 231,
      "source_code": "def test_attwith2filenames(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\n                'attachment; filename=\"foo.html\"; filename=\"bar.html\"'\n            )\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfnbrokentoken",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 233,
      "end_line_number": 239,
      "source_code": "def test_attfnbrokentoken(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\n                \"attachment; filename=foo[1](2).html\"\n            )\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfnbrokentokeniso",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 241,
      "end_line_number": 247,
      "source_code": "def test_attfnbrokentokeniso(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\n                \"attachment; filename=foo-\u00e4.html\"\n            )\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfnbrokentokenutf",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 249,
      "end_line_number": 255,
      "source_code": "def test_attfnbrokentokenutf(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\n                \"attachment; filename=foo-\u00c3\u00a4.html\"\n            )\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attmissingdisposition",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 257,
      "end_line_number": 261,
      "source_code": "def test_attmissingdisposition(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\"filename=foo.html\")\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attmissingdisposition2",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 263,
      "end_line_number": 267,
      "source_code": "def test_attmissingdisposition2(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\"x=y; filename=foo.html\")\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attmissingdisposition3",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 269,
      "end_line_number": 275,
      "source_code": "def test_attmissingdisposition3(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\n                '\"foo; filename=bar;baz\"; filename=qux'\n            )\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attmissingdisposition4",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 277,
      "end_line_number": 283,
      "source_code": "def test_attmissingdisposition4(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\n                \"filename=foo.html, filename=bar.html\"\n            )\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_emptydisposition",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 285,
      "end_line_number": 289,
      "source_code": "def test_emptydisposition(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\"; filename=foo.html\")\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_doublecolon",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 291,
      "end_line_number": 297,
      "source_code": "def test_doublecolon(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\n                \": inline; attachment; filename=foo.html\"\n            )\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attandinline",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 299,
      "end_line_number": 305,
      "source_code": "def test_attandinline(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\n                \"inline; attachment; filename=foo.html\"\n            )\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attandinline2",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 307,
      "end_line_number": 313,
      "source_code": "def test_attandinline2(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\n                \"attachment; inline; filename=foo.html\"\n            )\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attbrokenquotedfn",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 315,
      "end_line_number": 321,
      "source_code": "def test_attbrokenquotedfn(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\n                'attachment; filename=\"foo.html\".txt'\n            )\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attbrokenquotedfn2",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 323,
      "end_line_number": 327,
      "source_code": "def test_attbrokenquotedfn2(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition('attachment; filename=\"bar')\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attbrokenquotedfn3",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 329,
      "end_line_number": 335,
      "source_code": "def test_attbrokenquotedfn3(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\n                'attachment; filename=foo\"bar;baz\"qux'\n            )\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attmultinstances",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 337,
      "end_line_number": 343,
      "source_code": "def test_attmultinstances(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\n                \"attachment; filename=foo.html, attachment; filename=bar.html\"\n            )\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attmissingdelim",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 345,
      "end_line_number": 351,
      "source_code": "def test_attmissingdelim(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\n                \"attachment; foo=foo filename=bar\"\n            )\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attmissingdelim2",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 353,
      "end_line_number": 359,
      "source_code": "def test_attmissingdelim2(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\n                \"attachment; filename=bar foo=foo\"\n            )\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attmissingdelim3",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 361,
      "end_line_number": 365,
      "source_code": "def test_attmissingdelim3(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\"attachment filename=bar\")\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attreversed",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 367,
      "end_line_number": 373,
      "source_code": "def test_attreversed(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\n                \"filename=foo.html; attachment\"\n            )\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attconfusedparam",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 375,
      "end_line_number": 378,
      "source_code": "def test_attconfusedparam(self) -> None:\n        disptype, params = parse_content_disposition(\"attachment; xfilename=foo.html\")\n        assert \"attachment\" == disptype\n        assert {\"xfilename\": \"foo.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'xfilename': 'foo.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attabspath",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 380,
      "end_line_number": 383,
      "source_code": "def test_attabspath(self) -> None:\n        disptype, params = parse_content_disposition('attachment; filename=\"/foo.html\"')\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"foo.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': 'foo.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attabspathwin",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 385,
      "end_line_number": 390,
      "source_code": "def test_attabspathwin(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; filename=\"\\\\foo.html\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"foo.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': 'foo.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attcdate",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 392,
      "end_line_number": 397,
      "source_code": "def test_attcdate(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; creation-date=\"Wed, 12 Feb 1997 16:29:51 -0500\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"creation-date\": \"Wed, 12 Feb 1997 16:29:51 -0500\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'creation-date': 'Wed, 12 Feb 1997 16:29:51 -0500'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attmdate",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 399,
      "end_line_number": 404,
      "source_code": "def test_attmdate(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; modification-date=\"Wed, 12 Feb 1997 16:29:51 -0500\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"modification-date\": \"Wed, 12 Feb 1997 16:29:51 -0500\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'modification-date': 'Wed, 12 Feb 1997 16:29:51 -0500'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_dispext",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 406,
      "end_line_number": 409,
      "source_code": "def test_dispext(self) -> None:\n        disptype, params = parse_content_disposition(\"foobar\")\n        assert \"foobar\" == disptype\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'foobar' == disptype",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_dispextbadfn",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 411,
      "end_line_number": 416,
      "source_code": "def test_dispextbadfn(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; example=\"filename=example.txt\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"example\": \"filename=example.txt\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'example': 'filename=example.txt'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithisofn2231iso",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 418,
      "end_line_number": 423,
      "source_code": "def test_attwithisofn2231iso(self) -> None:\n        disptype, params = parse_content_disposition(\n            \"attachment; filename*=iso-8859-1''foo-%E4.html\"\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename*\": \"foo-\u00e4.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename*': 'foo-\u00e4.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfn2231utf8",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 425,
      "end_line_number": 430,
      "source_code": "def test_attwithfn2231utf8(self) -> None:\n        disptype, params = parse_content_disposition(\n            \"attachment; filename*=UTF-8''foo-%c3%a4-%e2%82%ac.html\"\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename*\": \"foo-\u00e4-\u20ac.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename*': 'foo-\u00e4-\u20ac.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfn2231noc",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 432,
      "end_line_number": 437,
      "source_code": "def test_attwithfn2231noc(self) -> None:\n        disptype, params = parse_content_disposition(\n            \"attachment; filename*=''foo-%c3%a4-%e2%82%ac.html\"\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename*\": \"foo-\u00e4-\u20ac.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename*': 'foo-\u00e4-\u20ac.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfn2231utf8comp",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 439,
      "end_line_number": 444,
      "source_code": "def test_attwithfn2231utf8comp(self) -> None:\n        disptype, params = parse_content_disposition(\n            \"attachment; filename*=UTF-8''foo-a%cc%88.html\"\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename*\": \"foo-a\u0308.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename*': 'foo-a\u0308.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfn2231utf8_bad",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 447,
      "end_line_number": 453,
      "source_code": "def test_attwithfn2231utf8_bad(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionParam):\n            disptype, params = parse_content_disposition(\n                \"attachment; filename*=iso-8859-1''foo-%c3%a4-%e2%82%ac.html\"\n            )\n        assert \"attachment\" == disptype\n        assert {} == params",
      "docstring": null,
      "decorators": [
        "pytest.mark.skip('should raise decoding error: %82 is invalid for latin1')"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfn2231iso_bad",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 456,
      "end_line_number": 462,
      "source_code": "def test_attwithfn2231iso_bad(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionParam):\n            disptype, params = parse_content_disposition(\n                \"attachment; filename*=utf-8''foo-%E4.html\"\n            )\n        assert \"attachment\" == disptype\n        assert {} == params",
      "docstring": null,
      "decorators": [
        "pytest.mark.skip('should raise decoding error: %E4 is invalid for utf-8')"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfn2231ws1",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 464,
      "end_line_number": 470,
      "source_code": "def test_attwithfn2231ws1(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionParam):\n            disptype, params = parse_content_disposition(\n                \"attachment; filename *=UTF-8''foo-%c3%a4.html\"\n            )\n        assert \"attachment\" == disptype\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfn2231ws2",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 472,
      "end_line_number": 477,
      "source_code": "def test_attwithfn2231ws2(self) -> None:\n        disptype, params = parse_content_disposition(\n            \"attachment; filename*= UTF-8''foo-%c3%a4.html\"\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename*\": \"foo-\u00e4.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename*': 'foo-\u00e4.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfn2231ws3",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 479,
      "end_line_number": 484,
      "source_code": "def test_attwithfn2231ws3(self) -> None:\n        disptype, params = parse_content_disposition(\n            \"attachment; filename* =UTF-8''foo-%c3%a4.html\"\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename*\": \"foo-\u00e4.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename*': 'foo-\u00e4.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfn2231quot",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 486,
      "end_line_number": 492,
      "source_code": "def test_attwithfn2231quot(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionParam):\n            disptype, params = parse_content_disposition(\n                \"attachment; filename*=\\\"UTF-8''foo-%c3%a4.html\\\"\"\n            )\n        assert \"attachment\" == disptype\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfn2231quot2",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 494,
      "end_line_number": 500,
      "source_code": "def test_attwithfn2231quot2(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionParam):\n            disptype, params = parse_content_disposition(\n                'attachment; filename*=\"foo%20bar.html\"'\n            )\n        assert \"attachment\" == disptype\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfn2231singleqmissing",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 502,
      "end_line_number": 508,
      "source_code": "def test_attwithfn2231singleqmissing(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionParam):\n            disptype, params = parse_content_disposition(\n                \"attachment; filename*=UTF-8'foo-%c3%a4.html\"\n            )\n        assert \"attachment\" == disptype\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfn2231nbadpct1",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 511,
      "end_line_number": 517,
      "source_code": "def test_attwithfn2231nbadpct1(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionParam):\n            disptype, params = parse_content_disposition(\n                \"attachment; filename*=UTF-8''foo%\"\n            )\n        assert \"attachment\" == disptype\n        assert {} == params",
      "docstring": null,
      "decorators": [
        "pytest.mark.skip('urllib.parse.unquote is tolerate to standalone % chars')"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfn2231nbadpct2",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 520,
      "end_line_number": 526,
      "source_code": "def test_attwithfn2231nbadpct2(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionParam):\n            disptype, params = parse_content_disposition(\n                \"attachment; filename*=UTF-8''f%oo.html\"\n            )\n        assert \"attachment\" == disptype\n        assert {} == params",
      "docstring": null,
      "decorators": [
        "pytest.mark.skip('urllib.parse.unquote is tolerate to standalone % chars')"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfn2231dpct",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 528,
      "end_line_number": 533,
      "source_code": "def test_attwithfn2231dpct(self) -> None:\n        disptype, params = parse_content_disposition(\n            \"attachment; filename*=UTF-8''A-%2541.html\"\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename*\": \"A-%41.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename*': 'A-%41.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attwithfn2231abspathdisguised",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 535,
      "end_line_number": 540,
      "source_code": "def test_attwithfn2231abspathdisguised(self) -> None:\n        disptype, params = parse_content_disposition(\n            \"attachment; filename*=UTF-8''%5cfoo.html\"\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename*\": \"\\\\foo.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename*': '\\\\foo.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfncont",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 542,
      "end_line_number": 547,
      "source_code": "def test_attfncont(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; filename*0=\"foo.\"; filename*1=\"html\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename*0\": \"foo.\", \"filename*1\": \"html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename*0': 'foo.', 'filename*1': 'html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfncontqs",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 549,
      "end_line_number": 554,
      "source_code": "def test_attfncontqs(self) -> None:\n        disptype, params = parse_content_disposition(\n            r'attachment; filename*0=\"foo\"; filename*1=\"\\b\\a\\r.html\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename*0\": \"foo\", \"filename*1\": \"bar.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename*0': 'foo', 'filename*1': 'bar.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfncontenc",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 556,
      "end_line_number": 561,
      "source_code": "def test_attfncontenc(self) -> None:\n        disptype, params = parse_content_disposition(\n            \"attachment; filename*0*=UTF-8\" + 'foo-%c3%a4; filename*1=\".html\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename*0*\": \"UTF-8foo-%c3%a4\", \"filename*1\": \".html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename*0*': 'UTF-8foo-%c3%a4', 'filename*1': '.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfncontlz",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 563,
      "end_line_number": 568,
      "source_code": "def test_attfncontlz(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; filename*0=\"foo\"; filename*01=\"bar\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename*0\": \"foo\", \"filename*01\": \"bar\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename*0': 'foo', 'filename*01': 'bar'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfncontnc",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 570,
      "end_line_number": 575,
      "source_code": "def test_attfncontnc(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; filename*0=\"foo\"; filename*2=\"bar\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename*0\": \"foo\", \"filename*2\": \"bar\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename*0': 'foo', 'filename*2': 'bar'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfnconts1",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 577,
      "end_line_number": 582,
      "source_code": "def test_attfnconts1(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; filename*0=\"foo.\"; filename*2=\"html\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename*0\": \"foo.\", \"filename*2\": \"html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename*0': 'foo.', 'filename*2': 'html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfncontord",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 584,
      "end_line_number": 589,
      "source_code": "def test_attfncontord(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; filename*1=\"bar\"; filename*0=\"foo\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename*0\": \"foo\", \"filename*1\": \"bar\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename*0': 'foo', 'filename*1': 'bar'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfnboth",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 591,
      "end_line_number": 596,
      "source_code": "def test_attfnboth(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; filename=\"foo-ae.html\";' + \" filename*=UTF-8''foo-%c3%a4.html\"\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"foo-ae.html\", \"filename*\": \"foo-\u00e4.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': 'foo-ae.html', 'filename*': 'foo-\u00e4.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfnboth2",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 598,
      "end_line_number": 603,
      "source_code": "def test_attfnboth2(self) -> None:\n        disptype, params = parse_content_disposition(\n            \"attachment; filename*=UTF-8''foo-%c3%a4.html;\" + ' filename=\"foo-ae.html\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"foo-ae.html\", \"filename*\": \"foo-\u00e4.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': 'foo-ae.html', 'filename*': 'foo-\u00e4.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfnboth3",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 605,
      "end_line_number": 614,
      "source_code": "def test_attfnboth3(self) -> None:\n        disptype, params = parse_content_disposition(\n            \"attachment; filename*0*=ISO-8859-15''euro-sign%3d%a4;\"\n            \" filename*=ISO-8859-1''currency-sign%3d%a4\"\n        )\n        assert \"attachment\" == disptype\n        assert {\n            \"filename*\": \"currency-sign=\u00a4\",\n            \"filename*0*\": \"ISO-8859-15''euro-sign%3d%a4\",\n        } == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename*': 'currency-sign=\u00a4', 'filename*0*': \"ISO-8859-15''euro-sign%3d%a4\"} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attnewandfn",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 616,
      "end_line_number": 621,
      "source_code": "def test_attnewandfn(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; foobar=x; filename=\"foo.html\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"foobar\": \"x\", \"filename\": \"foo.html\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'foobar': 'x', 'filename': 'foo.html'} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attrfc2047token",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 623,
      "end_line_number": 629,
      "source_code": "def test_attrfc2047token(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionHeader):\n            disptype, params = parse_content_disposition(\n                \"attachment; filename==?ISO-8859-1?Q?foo-=E4.html?=\"\n            )\n        assert disptype is None\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert disptype is None",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attrfc2047quoted",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 631,
      "end_line_number": 636,
      "source_code": "def test_attrfc2047quoted(self) -> None:\n        disptype, params = parse_content_disposition(\n            'attachment; filename=\"=?ISO-8859-1?Q?foo-=E4.html?=\"'\n        )\n        assert \"attachment\" == disptype\n        assert {\"filename\": \"=?ISO-8859-1?Q?foo-=E4.html?=\"} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {'filename': '=?ISO-8859-1?Q?foo-=E4.html?='} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_bad_continuous_param",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 638,
      "end_line_number": 644,
      "source_code": "def test_bad_continuous_param(self) -> None:\n        with pytest.warns(aiohttp.BadContentDispositionParam):\n            disptype, params = parse_content_disposition(\n                \"attachment; filename*0=foo bar\"\n            )\n        assert \"attachment\" == disptype\n        assert {} == params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'attachment' == disptype",
        "assert {} == params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_no_filename",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 650,
      "end_line_number": 652,
      "source_code": "def test_no_filename(self) -> None:\n        assert content_disposition_filename({}) is None\n        assert content_disposition_filename({\"foo\": \"bar\"}) is None",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert content_disposition_filename({}) is None",
        "assert content_disposition_filename({'foo': 'bar'}) is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_filename",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 654,
      "end_line_number": 656,
      "source_code": "def test_filename(self) -> None:\n        params = {\"filename\": \"foo.html\"}\n        assert \"foo.html\" == content_disposition_filename(params)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'foo.html' == content_disposition_filename(params)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_filename_ext",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 658,
      "end_line_number": 660,
      "source_code": "def test_filename_ext(self) -> None:\n        params = {\"filename*\": \"\u0444\u0430\u0439\u043b.html\"}\n        assert \"\u0444\u0430\u0439\u043b.html\" == content_disposition_filename(params)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert '\u0444\u0430\u0439\u043b.html' == content_disposition_filename(params)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfncont",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 662,
      "end_line_number": 664,
      "source_code": "def test_attfncont(self) -> None:\n        params = {\"filename*0\": \"foo.\", \"filename*1\": \"html\"}\n        assert \"foo.html\" == content_disposition_filename(params)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'foo.html' == content_disposition_filename(params)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfncontqs",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 666,
      "end_line_number": 668,
      "source_code": "def test_attfncontqs(self) -> None:\n        params = {\"filename*0\": \"foo\", \"filename*1\": \"bar.html\"}\n        assert \"foobar.html\" == content_disposition_filename(params)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'foobar.html' == content_disposition_filename(params)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfncontenc",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 670,
      "end_line_number": 672,
      "source_code": "def test_attfncontenc(self) -> None:\n        params = {\"filename*0*\": \"UTF-8''foo-%c3%a4\", \"filename*1\": \".html\"}\n        assert \"foo-\u00e4.html\" == content_disposition_filename(params)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'foo-\u00e4.html' == content_disposition_filename(params)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfncontlz",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 674,
      "end_line_number": 676,
      "source_code": "def test_attfncontlz(self) -> None:\n        params = {\"filename*0\": \"foo\", \"filename*01\": \"bar\"}\n        assert \"foo\" == content_disposition_filename(params)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'foo' == content_disposition_filename(params)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfncontnc",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 678,
      "end_line_number": 680,
      "source_code": "def test_attfncontnc(self) -> None:\n        params = {\"filename*0\": \"foo\", \"filename*2\": \"bar\"}\n        assert \"foo\" == content_disposition_filename(params)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'foo' == content_disposition_filename(params)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfnconts1",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 682,
      "end_line_number": 684,
      "source_code": "def test_attfnconts1(self) -> None:\n        params = {\"filename*1\": \"foo\", \"filename*2\": \"bar\"}\n        assert content_disposition_filename(params) is None",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert content_disposition_filename(params) is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfnboth",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 686,
      "end_line_number": 688,
      "source_code": "def test_attfnboth(self) -> None:\n        params = {\"filename\": \"foo-ae.html\", \"filename*\": \"foo-\u00e4.html\"}\n        assert \"foo-\u00e4.html\" == content_disposition_filename(params)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'foo-\u00e4.html' == content_disposition_filename(params)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attfnboth3",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 690,
      "end_line_number": 695,
      "source_code": "def test_attfnboth3(self) -> None:\n        params = {\n            \"filename*0*\": \"ISO-8859-15''euro-sign%3d%a4\",\n            \"filename*\": \"currency-sign=\u00a4\",\n        }\n        assert \"currency-sign=\u00a4\" == content_disposition_filename(params)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'currency-sign=\u00a4' == content_disposition_filename(params)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_attrfc2047quoted",
      "module": "test_multipart_helpers",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_multipart_helpers.py",
      "line_number": 697,
      "end_line_number": 699,
      "source_code": "def test_attrfc2047quoted(self) -> None:\n        params = {\"filename\": \"=?ISO-8859-1?Q?foo-=E4.html?=\"}\n        assert \"=?ISO-8859-1?Q?foo-=E4.html?=\" == content_disposition_filename(params)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "pytest",
        "aiohttp",
        "aiohttp.content_disposition_filename",
        "aiohttp.parse_content_disposition"
      ],
      "fixtures": [],
      "assertions": [
        "assert '=?ISO-8859-1?Q?foo-=E4.html?=' == content_disposition_filename(params)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_read_one_hundred_websocket_text_messages",
      "module": "test_benchmarks_http_websocket",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_http_websocket.py",
      "line_number": 17,
      "end_line_number": 34,
      "source_code": "def test_read_one_hundred_websocket_text_messages(\n    loop: asyncio.AbstractEventLoop, benchmark: BenchmarkFixture\n) -> None:\n    \"\"\"Benchmark reading 100 WebSocket text messages.\"\"\"\n    queue: DataQueue[WSMessage] = DataQueue(loop=loop)\n    reader = WebSocketReader(queue, max_msg_size=2**16)\n    raw_message = (\n        b'\\x81~\\x01!{\"id\":1,\"src\":\"shellyplugus-c049ef8c30e4\",\"dst\":\"aios-1453812500'\n        b'8\",\"result\":{\"name\":null,\"id\":\"shellyplugus-c049ef8c30e4\",\"mac\":\"C049EF8C30E'\n        b'4\",\"slot\":1,\"model\":\"SNPL-00116US\",\"gen\":2,\"fw_id\":\"20231219-133953/1.1.0-g3'\n        b'4b5d4f\",\"ver\":\"1.1.0\",\"app\":\"PlugUS\",\"auth_en\":false,\"auth_domain\":null}}'\n    )\n    feed_data = reader.feed_data\n\n    @benchmark\n    def _run() -> None:\n        for _ in range(100):\n            feed_data(raw_message)",
      "docstring": "Benchmark reading 100 WebSocket text messages.",
      "decorators": [],
      "arguments": [
        "loop",
        "benchmark"
      ],
      "imports": [
        "asyncio",
        "pytest_codspeed.BenchmarkFixture",
        "aiohttp.DataQueue",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WebSocketWriter",
        "aiohttp.http_websocket.WSMessage",
        "aiohttp.http_websocket.WSMsgType"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_send_one_hundred_websocket_text_messages",
      "module": "test_benchmarks_http_websocket",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_http_websocket.py",
      "line_number": 54,
      "end_line_number": 67,
      "source_code": "def test_send_one_hundred_websocket_text_messages(\n    loop: asyncio.AbstractEventLoop, benchmark: BenchmarkFixture\n) -> None:\n    \"\"\"Benchmark sending 100 WebSocket text messages.\"\"\"\n    writer = WebSocketWriter(MockProtocol(loop=loop), MockTransport())\n    raw_message = b\"Hello, World!\" * 100\n\n    async def _send_one_hundred_websocket_text_messages() -> None:\n        for _ in range(100):\n            await writer.send_frame(raw_message, WSMsgType.TEXT)\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(_send_one_hundred_websocket_text_messages())",
      "docstring": "Benchmark sending 100 WebSocket text messages.",
      "decorators": [],
      "arguments": [
        "loop",
        "benchmark"
      ],
      "imports": [
        "asyncio",
        "pytest_codspeed.BenchmarkFixture",
        "aiohttp.DataQueue",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WebSocketWriter",
        "aiohttp.http_websocket.WSMessage",
        "aiohttp.http_websocket.WSMsgType"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_send_one_hundred_websocket_text_messages_with_mask",
      "module": "test_benchmarks_http_websocket",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_benchmarks_http_websocket.py",
      "line_number": 70,
      "end_line_number": 83,
      "source_code": "def test_send_one_hundred_websocket_text_messages_with_mask(\n    loop: asyncio.AbstractEventLoop, benchmark: BenchmarkFixture\n) -> None:\n    \"\"\"Benchmark sending 100 masked WebSocket text messages.\"\"\"\n    writer = WebSocketWriter(MockProtocol(loop=loop), MockTransport(), use_mask=True)\n    raw_message = b\"Hello, World!\" * 100\n\n    async def _send_one_hundred_websocket_text_messages() -> None:\n        for _ in range(100):\n            await writer.send_frame(raw_message, WSMsgType.TEXT)\n\n    @benchmark\n    def _run() -> None:\n        loop.run_until_complete(_send_one_hundred_websocket_text_messages())",
      "docstring": "Benchmark sending 100 masked WebSocket text messages.",
      "decorators": [],
      "arguments": [
        "loop",
        "benchmark"
      ],
      "imports": [
        "asyncio",
        "pytest_codspeed.BenchmarkFixture",
        "aiohttp.DataQueue",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WebSocketWriter",
        "aiohttp.http_websocket.WSMessage",
        "aiohttp.http_websocket.WSMsgType"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_connector_loop",
      "module": "test_client_session",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_session.py",
      "line_number": 350,
      "end_line_number": 368,
      "source_code": "def test_connector_loop(loop: asyncio.AbstractEventLoop) -> None:\n    with contextlib.ExitStack() as stack:\n        another_loop = asyncio.new_event_loop()\n        stack.enter_context(contextlib.closing(another_loop))\n\n        async def make_connector() -> TCPConnector:\n            return TCPConnector()\n\n        connector = another_loop.run_until_complete(make_connector())\n\n        with pytest.raises(RuntimeError) as ctx:\n\n            async def make_sess() -> ClientSession:\n                return ClientSession(connector=connector)\n\n            loop.run_until_complete(make_sess())\n        expected = \"Session and connector have to use same event loop\"\n        assert str(ctx.value).startswith(expected)\n        another_loop.run_until_complete(connector.close())",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "gc",
        "io",
        "json",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.TypedDict",
        "typing.Union",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client",
        "aiohttp.hdrs",
        "aiohttp.tracing",
        "aiohttp.web",
        "aiohttp.client.ClientSession",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector.BaseConnector",
        "aiohttp.connector.Connection",
        "aiohttp.connector.TCPConnector",
        "aiohttp.connector.UnixConnector",
        "aiohttp.cookiejar.CookieJar",
        "aiohttp.http.RawResponseMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.tracing.Trace"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(ctx.value).startswith(expected)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "connector.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_detach",
      "module": "test_client_session",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_session.py",
      "line_number": 371,
      "end_line_number": 381,
      "source_code": "def test_detach(loop: asyncio.AbstractEventLoop, session: ClientSession) -> None:\n    conn = session.connector\n    assert conn is not None\n    try:\n        assert not conn.closed\n        session.detach()\n        assert session.connector is None\n        assert session.closed\n        assert not conn.closed\n    finally:\n        loop.run_until_complete(conn.close())",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop",
        "session"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "gc",
        "io",
        "json",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.TypedDict",
        "typing.Union",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client",
        "aiohttp.hdrs",
        "aiohttp.tracing",
        "aiohttp.web",
        "aiohttp.client.ClientSession",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector.BaseConnector",
        "aiohttp.connector.Connection",
        "aiohttp.connector.TCPConnector",
        "aiohttp.connector.UnixConnector",
        "aiohttp.cookiejar.CookieJar",
        "aiohttp.http.RawResponseMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.tracing.Trace"
      ],
      "fixtures": [],
      "assertions": [
        "assert conn is not None",
        "assert not conn.closed",
        "assert session.connector is None",
        "assert session.closed",
        "assert not conn.closed"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "conn.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_client_session_inheritance",
      "module": "test_client_session",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_session.py",
      "line_number": 1030,
      "end_line_number": 1034,
      "source_code": "def test_client_session_inheritance() -> None:\n    with pytest.raises(TypeError):\n\n        class A(ClientSession):  # type: ignore[misc]\n            pass",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "contextlib",
        "gc",
        "io",
        "json",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.TypedDict",
        "typing.Union",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.MultiDict",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.client",
        "aiohttp.hdrs",
        "aiohttp.tracing",
        "aiohttp.web",
        "aiohttp.client.ClientSession",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector.BaseConnector",
        "aiohttp.connector.Connection",
        "aiohttp.connector.TCPConnector",
        "aiohttp.connector.UnixConnector",
        "aiohttp.cookiejar.CookieJar",
        "aiohttp.http.RawResponseMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.tracing.Trace"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_base_ctor",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 27,
      "end_line_number": 66,
      "source_code": "def test_base_ctor() -> None:\n    message = RawRequestMessage(\n        \"GET\",\n        \"/path/to?a=1&b=2\",\n        HttpVersion(1, 1),\n        CIMultiDictProxy(CIMultiDict()),\n        (),\n        False,\n        None,\n        False,\n        False,\n        URL(\"/path/to?a=1&b=2\"),\n    )\n\n    req = web.BaseRequest(\n        message, mock.Mock(), mock.Mock(), mock.Mock(), mock.Mock(), mock.Mock()\n    )\n\n    assert \"GET\" == req.method\n    assert HttpVersion(1, 1) == req.version\n    # MacOS may return CamelCased host name, need .lower()\n    # FQDN can be wider than host, e.g.\n    # 'fv-az397-495' in 'fv-az397-495.internal.cloudapp.net'\n    assert req.host.lower() in socket.getfqdn().lower()\n    assert \"/path/to?a=1&b=2\" == req.path_qs\n    assert \"/path/to\" == req.path\n    assert \"a=1&b=2\" == req.query_string\n    assert CIMultiDict() == req.headers\n    assert () == req.raw_headers\n\n    get = req.query\n    assert MultiDict([(\"a\", \"1\"), (\"b\", \"2\")]) == get\n    # second call should return the same object\n    assert get is req.query\n\n    assert req.keep_alive\n\n    assert \"__dict__\" not in dir(req)\n\n    assert req",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'GET' == req.method",
        "assert HttpVersion(1, 1) == req.version",
        "assert req.host.lower() in socket.getfqdn().lower()",
        "assert '/path/to?a=1&b=2' == req.path_qs",
        "assert '/path/to' == req.path",
        "assert 'a=1&b=2' == req.query_string",
        "assert CIMultiDict() == req.headers",
        "assert () == req.raw_headers",
        "assert MultiDict([('a', '1'), ('b', '2')]) == get",
        "assert get is req.query",
        "assert req.keep_alive",
        "assert '__dict__' not in dir(req)",
        "assert req"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_ctor",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 69,
      "end_line_number": 112,
      "source_code": "def test_ctor() -> None:\n    req = make_mocked_request(\"GET\", \"/path/to?a=1&b=2\")\n\n    assert \"GET\" == req.method\n    assert HttpVersion(1, 1) == req.version\n    # MacOS may return CamelCased host name, need .lower()\n    # FQDN can be wider than host, e.g.\n    # 'fv-az397-495' in 'fv-az397-495.internal.cloudapp.net'\n    assert req.host.lower() in socket.getfqdn().lower()\n    assert \"/path/to?a=1&b=2\" == req.path_qs\n    assert \"/path/to\" == req.path\n    assert \"a=1&b=2\" == req.query_string\n    assert CIMultiDict() == req.headers\n    assert () == req.raw_headers\n\n    get = req.query\n    assert MultiDict([(\"a\", \"1\"), (\"b\", \"2\")]) == get\n    # second call should return the same object\n    assert get is req.query\n\n    assert req.keep_alive\n\n    # just make sure that all lines of make_mocked_request covered\n    headers = CIMultiDict(FOO=\"bar\")\n    payload = mock.Mock()\n    protocol = mock.Mock()\n    app = mock.Mock()\n    req = make_mocked_request(\n        \"GET\",\n        \"/path/to?a=1&b=2\",\n        headers=headers,\n        protocol=protocol,\n        payload=payload,\n        app=app,\n    )\n    assert req.app is app\n    assert req.content is payload\n    assert req.protocol is protocol\n    assert req.transport is protocol.transport\n    assert req.headers == headers\n    assert req.raw_headers == ((b\"FOO\", b\"bar\"),)\n    assert req.task is req._task\n\n    assert \"__dict__\" not in dir(req)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'GET' == req.method",
        "assert HttpVersion(1, 1) == req.version",
        "assert req.host.lower() in socket.getfqdn().lower()",
        "assert '/path/to?a=1&b=2' == req.path_qs",
        "assert '/path/to' == req.path",
        "assert 'a=1&b=2' == req.query_string",
        "assert CIMultiDict() == req.headers",
        "assert () == req.raw_headers",
        "assert MultiDict([('a', '1'), ('b', '2')]) == get",
        "assert get is req.query",
        "assert req.keep_alive",
        "assert req.app is app",
        "assert req.content is payload",
        "assert req.protocol is protocol",
        "assert req.transport is protocol.transport",
        "assert req.headers == headers",
        "assert req.raw_headers == ((b'FOO', b'bar'),)",
        "assert req.task is req._task",
        "assert '__dict__' not in dir(req)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_doubleslashes",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 115,
      "end_line_number": 118,
      "source_code": "def test_doubleslashes() -> None:\n    # NB: //foo/bar is an absolute URL with foo netloc and /bar path\n    req = make_mocked_request(\"GET\", \"/bar//foo/\")\n    assert \"/bar//foo/\" == req.path",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert '/bar//foo/' == req.path"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_content_type_not_specified",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 121,
      "end_line_number": 123,
      "source_code": "def test_content_type_not_specified() -> None:\n    req = make_mocked_request(\"Get\", \"/\")\n    assert \"application/octet-stream\" == req.content_type",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'application/octet-stream' == req.content_type"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_content_type_from_spec",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 126,
      "end_line_number": 130,
      "source_code": "def test_content_type_from_spec() -> None:\n    req = make_mocked_request(\n        \"Get\", \"/\", CIMultiDict([(\"CONTENT-TYPE\", \"application/json\")])\n    )\n    assert \"application/json\" == req.content_type",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'application/json' == req.content_type"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_content_type_from_spec_with_charset",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 133,
      "end_line_number": 138,
      "source_code": "def test_content_type_from_spec_with_charset() -> None:\n    req = make_mocked_request(\n        \"Get\", \"/\", CIMultiDict([(\"CONTENT-TYPE\", \"text/html; charset=UTF-8\")])\n    )\n    assert \"text/html\" == req.content_type\n    assert \"UTF-8\" == req.charset",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'text/html' == req.content_type",
        "assert 'UTF-8' == req.charset"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_calc_content_type_on_getting_charset",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 141,
      "end_line_number": 146,
      "source_code": "def test_calc_content_type_on_getting_charset() -> None:\n    req = make_mocked_request(\n        \"Get\", \"/\", CIMultiDict([(\"CONTENT-TYPE\", \"text/html; charset=UTF-8\")])\n    )\n    assert \"UTF-8\" == req.charset\n    assert \"text/html\" == req.content_type",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'UTF-8' == req.charset",
        "assert 'text/html' == req.content_type"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_urlencoded_querystring",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 149,
      "end_line_number": 151,
      "source_code": "def test_urlencoded_querystring() -> None:\n    req = make_mocked_request(\"GET\", \"/yandsearch?text=%D1%82%D0%B5%D0%BA%D1%81%D1%82\")\n    assert {\"text\": \"\u0442\u0435\u043a\u0441\u0442\"} == req.query",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert {'text': '\u0442\u0435\u043a\u0441\u0442'} == req.query"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_non_ascii_path",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 154,
      "end_line_number": 156,
      "source_code": "def test_non_ascii_path() -> None:\n    req = make_mocked_request(\"GET\", \"/\u043f\u0443\u0442\u044c\")\n    assert \"/\u043f\u0443\u0442\u044c\" == req.path",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert '/\u043f\u0443\u0442\u044c' == req.path"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_non_ascii_raw_path",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 159,
      "end_line_number": 161,
      "source_code": "def test_non_ascii_raw_path() -> None:\n    req = make_mocked_request(\"GET\", \"/\u043f\u0443\u0442\u044c\")\n    assert \"/\u043f\u0443\u0442\u044c\" == req.raw_path",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert '/\u043f\u0443\u0442\u044c' == req.raw_path"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_absolute_url",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 164,
      "end_line_number": 169,
      "source_code": "def test_absolute_url() -> None:\n    req = make_mocked_request(\"GET\", \"https://example.com/path/to?a=1\")\n    assert req.url == URL(\"https://example.com/path/to?a=1\")\n    assert req.scheme == \"https\"\n    assert req.host == \"example.com\"\n    assert req.rel_url == URL.build(path=\"/path/to\", query={\"a\": \"1\"})",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.url == URL('https://example.com/path/to?a=1')",
        "assert req.scheme == 'https'",
        "assert req.host == 'example.com'",
        "assert req.rel_url == URL.build(path='/path/to', query={'a': '1'})"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_clone_absolute_scheme",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 172,
      "end_line_number": 177,
      "source_code": "def test_clone_absolute_scheme() -> None:\n    req = make_mocked_request(\"GET\", \"https://example.com/path/to?a=1\")\n    assert req.scheme == \"https\"\n    req2 = req.clone(scheme=\"http\")\n    assert req2.scheme == \"http\"\n    assert req2.url.scheme == \"http\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.scheme == 'https'",
        "assert req2.scheme == 'http'",
        "assert req2.url.scheme == 'http'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_clone_absolute_host",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 180,
      "end_line_number": 185,
      "source_code": "def test_clone_absolute_host() -> None:\n    req = make_mocked_request(\"GET\", \"https://example.com/path/to?a=1\")\n    assert req.host == \"example.com\"\n    req2 = req.clone(host=\"foo.test\")\n    assert req2.host == \"foo.test\"\n    assert req2.url.host == \"foo.test\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.host == 'example.com'",
        "assert req2.host == 'foo.test'",
        "assert req2.url.host == 'foo.test'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_content_length",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 188,
      "end_line_number": 191,
      "source_code": "def test_content_length() -> None:\n    req = make_mocked_request(\"Get\", \"/\", CIMultiDict([(\"CONTENT-LENGTH\", \"123\")]))\n\n    assert 123 == req.content_length",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert 123 == req.content_length"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_range_to_slice_head",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 194,
      "end_line_number": 199,
      "source_code": "def test_range_to_slice_head() -> None:\n    req = make_mocked_request(\n        \"GET\", \"/\", headers=CIMultiDict([(\"RANGE\", \"bytes=0-499\")])\n    )\n    assert isinstance(req.http_range, slice)\n    assert req.http_range.start == 0 and req.http_range.stop == 500",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(req.http_range, slice)",
        "assert req.http_range.start == 0 and req.http_range.stop == 500"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_range_to_slice_mid",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 202,
      "end_line_number": 207,
      "source_code": "def test_range_to_slice_mid() -> None:\n    req = make_mocked_request(\n        \"GET\", \"/\", headers=CIMultiDict([(\"RANGE\", \"bytes=500-999\")])\n    )\n    assert isinstance(req.http_range, slice)\n    assert req.http_range.start == 500 and req.http_range.stop == 1000",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(req.http_range, slice)",
        "assert req.http_range.start == 500 and req.http_range.stop == 1000"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_range_to_slice_tail_start",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 210,
      "end_line_number": 215,
      "source_code": "def test_range_to_slice_tail_start() -> None:\n    req = make_mocked_request(\n        \"GET\", \"/\", headers=CIMultiDict([(\"RANGE\", \"bytes=9500-\")])\n    )\n    assert isinstance(req.http_range, slice)\n    assert req.http_range.start == 9500 and req.http_range.stop is None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(req.http_range, slice)",
        "assert req.http_range.start == 9500 and req.http_range.stop is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_range_to_slice_tail_stop",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 218,
      "end_line_number": 223,
      "source_code": "def test_range_to_slice_tail_stop() -> None:\n    req = make_mocked_request(\n        \"GET\", \"/\", headers=CIMultiDict([(\"RANGE\", \"bytes=-500\")])\n    )\n    assert isinstance(req.http_range, slice)\n    assert req.http_range.start == -500 and req.http_range.stop is None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(req.http_range, slice)",
        "assert req.http_range.start == -500 and req.http_range.stop is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_non_keepalive_on_http10",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 226,
      "end_line_number": 228,
      "source_code": "def test_non_keepalive_on_http10() -> None:\n    req = make_mocked_request(\"GET\", \"/\", version=HttpVersion(1, 0))\n    assert not req.keep_alive",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert not req.keep_alive"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_non_keepalive_on_closing",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 231,
      "end_line_number": 233,
      "source_code": "def test_non_keepalive_on_closing() -> None:\n    req = make_mocked_request(\"GET\", \"/\", closing=True)\n    assert not req.keep_alive",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert not req.keep_alive"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_no_request_cookies",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 260,
      "end_line_number": 266,
      "source_code": "def test_no_request_cookies() -> None:\n    req = make_mocked_request(\"GET\", \"/\")\n\n    assert req.cookies == {}\n\n    cookies = req.cookies\n    assert cookies is req.cookies",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.cookies == {}",
        "assert cookies is req.cookies"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_request_cookie",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 269,
      "end_line_number": 273,
      "source_code": "def test_request_cookie() -> None:\n    headers = CIMultiDict(COOKIE=\"cookie1=value1; cookie2=value2\")\n    req = make_mocked_request(\"GET\", \"/\", headers=headers)\n\n    assert req.cookies == {\"cookie1\": \"value1\", \"cookie2\": \"value2\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.cookies == {'cookie1': 'value1', 'cookie2': 'value2'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_request_cookie__set_item",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 276,
      "end_line_number": 283,
      "source_code": "def test_request_cookie__set_item() -> None:\n    headers = CIMultiDict(COOKIE=\"name=value\")\n    req = make_mocked_request(\"GET\", \"/\", headers=headers)\n\n    assert req.cookies == {\"name\": \"value\"}\n\n    with pytest.raises(TypeError):\n        req.cookies[\"my\"] = \"value\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.cookies == {'name': 'value'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_match_info",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 286,
      "end_line_number": 288,
      "source_code": "def test_match_info() -> None:\n    req = make_mocked_request(\"GET\", \"/\")\n    assert req._match_info is req.match_info",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert req._match_info is req.match_info"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_request_is_mutable_mapping",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 291,
      "end_line_number": 295,
      "source_code": "def test_request_is_mutable_mapping() -> None:\n    req = make_mocked_request(\"GET\", \"/\")\n    assert isinstance(req, MutableMapping)\n    req[\"key\"] = \"value\"\n    assert \"value\" == req[\"key\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(req, MutableMapping)",
        "assert 'value' == req['key']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_request_delitem",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 298,
      "end_line_number": 303,
      "source_code": "def test_request_delitem() -> None:\n    req = make_mocked_request(\"GET\", \"/\")\n    req[\"key\"] = \"value\"\n    assert \"value\" == req[\"key\"]\n    del req[\"key\"]\n    assert \"key\" not in req",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'value' == req['key']",
        "assert 'key' not in req"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_request_len",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 306,
      "end_line_number": 310,
      "source_code": "def test_request_len() -> None:\n    req = make_mocked_request(\"GET\", \"/\")\n    assert len(req) == 0\n    req[\"key\"] = \"value\"\n    assert len(req) == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(req) == 0",
        "assert len(req) == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_request_iter",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 313,
      "end_line_number": 317,
      "source_code": "def test_request_iter() -> None:\n    req = make_mocked_request(\"GET\", \"/\")\n    req[\"key\"] = \"value\"\n    req[\"key2\"] = \"value2\"\n    assert set(req) == {\"key\", \"key2\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert set(req) == {'key', 'key2'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test___repr__",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 320,
      "end_line_number": 322,
      "source_code": "def test___repr__() -> None:\n    req = make_mocked_request(\"GET\", \"/path/to\")\n    assert \"<Request GET /path/to >\" == repr(req)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert '<Request GET /path/to >' == repr(req)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test___repr___non_ascii_path",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 325,
      "end_line_number": 327,
      "source_code": "def test___repr___non_ascii_path() -> None:\n    req = make_mocked_request(\"GET\", \"/path/\\U0001f415\\U0001f308\")\n    assert \"<Request GET /path/\\\\U0001f415\\\\U0001f308 >\" == repr(req)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert '<Request GET /path/\\\\U0001f415\\\\U0001f308 >' == repr(req)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_http_scheme",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 330,
      "end_line_number": 333,
      "source_code": "def test_http_scheme() -> None:\n    req = make_mocked_request(\"GET\", \"/\", headers={\"Host\": \"example.com\"})\n    assert \"http\" == req.scheme\n    assert req.secure is False",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'http' == req.scheme",
        "assert req.secure is False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_https_scheme_by_ssl_transport",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 336,
      "end_line_number": 342,
      "source_code": "def test_https_scheme_by_ssl_transport() -> None:\n    context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n    req = make_mocked_request(\n        \"GET\", \"/\", headers={\"Host\": \"example.com\"}, sslcontext=context\n    )\n    assert \"https\" == req.scheme\n    assert req.secure is True",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'https' == req.scheme",
        "assert req.secure is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_single_forwarded_header",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 345,
      "end_line_number": 351,
      "source_code": "def test_single_forwarded_header() -> None:\n    header = \"by=identifier;for=identifier;host=identifier;proto=identifier\"\n    req = make_mocked_request(\"GET\", \"/\", headers=CIMultiDict({\"Forwarded\": header}))\n    assert req.forwarded[0][\"by\"] == \"identifier\"\n    assert req.forwarded[0][\"for\"] == \"identifier\"\n    assert req.forwarded[0][\"host\"] == \"identifier\"\n    assert req.forwarded[0][\"proto\"] == \"identifier\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.forwarded[0]['by'] == 'identifier'",
        "assert req.forwarded[0]['for'] == 'identifier'",
        "assert req.forwarded[0]['host'] == 'identifier'",
        "assert req.forwarded[0]['proto'] == 'identifier'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_forwarded_node_identifier",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 363,
      "end_line_number": 366,
      "source_code": "def test_forwarded_node_identifier(forward_for_in: str, forward_for_out: str) -> None:\n    header = f\"for={forward_for_in}\"\n    req = make_mocked_request(\"GET\", \"/\", headers=CIMultiDict({\"Forwarded\": header}))\n    assert req.forwarded == ({\"for\": forward_for_out},)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('forward_for_in, forward_for_out', [('1.2.3.4:1234', '1.2.3.4:1234'), ('1.2.3.4', '1.2.3.4'), ('\"[2001:db8:cafe::17]:1234\"', '[2001:db8:cafe::17]:1234'), ('\"[2001:db8:cafe::17]\"', '[2001:db8:cafe::17]')])"
      ],
      "arguments": [
        "forward_for_in",
        "forward_for_out"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.forwarded == ({'for': forward_for_out},)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_single_forwarded_header_camelcase",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 369,
      "end_line_number": 375,
      "source_code": "def test_single_forwarded_header_camelcase() -> None:\n    header = \"bY=identifier;fOr=identifier;HOst=identifier;pRoTO=identifier\"\n    req = make_mocked_request(\"GET\", \"/\", headers=CIMultiDict({\"Forwarded\": header}))\n    assert req.forwarded[0][\"by\"] == \"identifier\"\n    assert req.forwarded[0][\"for\"] == \"identifier\"\n    assert req.forwarded[0][\"host\"] == \"identifier\"\n    assert req.forwarded[0][\"proto\"] == \"identifier\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.forwarded[0]['by'] == 'identifier'",
        "assert req.forwarded[0]['for'] == 'identifier'",
        "assert req.forwarded[0]['host'] == 'identifier'",
        "assert req.forwarded[0]['proto'] == 'identifier'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_single_forwarded_header_single_param",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 378,
      "end_line_number": 381,
      "source_code": "def test_single_forwarded_header_single_param() -> None:\n    header = \"BY=identifier\"\n    req = make_mocked_request(\"GET\", \"/\", headers=CIMultiDict({\"Forwarded\": header}))\n    assert req.forwarded[0][\"by\"] == \"identifier\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.forwarded[0]['by'] == 'identifier'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_single_forwarded_header_multiple_param",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 384,
      "end_line_number": 391,
      "source_code": "def test_single_forwarded_header_multiple_param() -> None:\n    header = \"By=identifier1,BY=identifier2,  By=identifier3 ,  BY=identifier4\"\n    req = make_mocked_request(\"GET\", \"/\", headers=CIMultiDict({\"Forwarded\": header}))\n    assert len(req.forwarded) == 4\n    assert req.forwarded[0][\"by\"] == \"identifier1\"\n    assert req.forwarded[1][\"by\"] == \"identifier2\"\n    assert req.forwarded[2][\"by\"] == \"identifier3\"\n    assert req.forwarded[3][\"by\"] == \"identifier4\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(req.forwarded) == 4",
        "assert req.forwarded[0]['by'] == 'identifier1'",
        "assert req.forwarded[1]['by'] == 'identifier2'",
        "assert req.forwarded[2]['by'] == 'identifier3'",
        "assert req.forwarded[3]['by'] == 'identifier4'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_single_forwarded_header_quoted_escaped",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 394,
      "end_line_number": 398,
      "source_code": "def test_single_forwarded_header_quoted_escaped() -> None:\n    header = r'BY=identifier;pROTO=\"\\lala lan\\d\\~ 123\\!&\"'\n    req = make_mocked_request(\"GET\", \"/\", headers=CIMultiDict({\"Forwarded\": header}))\n    assert req.forwarded[0][\"by\"] == \"identifier\"\n    assert req.forwarded[0][\"proto\"] == \"lala land~ 123!&\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.forwarded[0]['by'] == 'identifier'",
        "assert req.forwarded[0]['proto'] == 'lala land~ 123!&'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_single_forwarded_header_custom_param",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 401,
      "end_line_number": 407,
      "source_code": "def test_single_forwarded_header_custom_param() -> None:\n    header = r'BY=identifier;PROTO=https;SOME=\"other, \\\"value\\\"\"'\n    req = make_mocked_request(\"GET\", \"/\", headers=CIMultiDict({\"Forwarded\": header}))\n    assert len(req.forwarded) == 1\n    assert req.forwarded[0][\"by\"] == \"identifier\"\n    assert req.forwarded[0][\"proto\"] == \"https\"\n    assert req.forwarded[0][\"some\"] == 'other, \"value\"'",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(req.forwarded) == 1",
        "assert req.forwarded[0]['by'] == 'identifier'",
        "assert req.forwarded[0]['proto'] == 'https'",
        "assert req.forwarded[0]['some'] == 'other, \"value\"'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_single_forwarded_header_empty_params",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 410,
      "end_line_number": 415,
      "source_code": "def test_single_forwarded_header_empty_params() -> None:\n    # This is allowed by the grammar given in RFC 7239\n    header = \";For=identifier;;PROTO=https;;;\"\n    req = make_mocked_request(\"GET\", \"/\", headers=CIMultiDict({\"Forwarded\": header}))\n    assert req.forwarded[0][\"for\"] == \"identifier\"\n    assert req.forwarded[0][\"proto\"] == \"https\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.forwarded[0]['for'] == 'identifier'",
        "assert req.forwarded[0]['proto'] == 'https'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_single_forwarded_header_bad_separator",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 418,
      "end_line_number": 421,
      "source_code": "def test_single_forwarded_header_bad_separator() -> None:\n    header = \"BY=identifier PROTO=https\"\n    req = make_mocked_request(\"GET\", \"/\", headers=CIMultiDict({\"Forwarded\": header}))\n    assert \"proto\" not in req.forwarded[0]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'proto' not in req.forwarded[0]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_single_forwarded_header_injection1",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 424,
      "end_line_number": 433,
      "source_code": "def test_single_forwarded_header_injection1() -> None:\n    # We might receive a header like this if we're sitting behind a reverse\n    # proxy that blindly appends a forwarded-element without checking\n    # the syntax of existing field-values. We should be able to recover\n    # the appended element anyway.\n    header = 'for=_injected;by=\", for=_real'\n    req = make_mocked_request(\"GET\", \"/\", headers=CIMultiDict({\"Forwarded\": header}))\n    assert len(req.forwarded) == 2\n    assert \"by\" not in req.forwarded[0]\n    assert req.forwarded[1][\"for\"] == \"_real\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(req.forwarded) == 2",
        "assert 'by' not in req.forwarded[0]",
        "assert req.forwarded[1]['for'] == '_real'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_single_forwarded_header_injection2",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 436,
      "end_line_number": 441,
      "source_code": "def test_single_forwarded_header_injection2() -> None:\n    header = \"very bad syntax, for=_real\"\n    req = make_mocked_request(\"GET\", \"/\", headers=CIMultiDict({\"Forwarded\": header}))\n    assert len(req.forwarded) == 2\n    assert \"for\" not in req.forwarded[0]\n    assert req.forwarded[1][\"for\"] == \"_real\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(req.forwarded) == 2",
        "assert 'for' not in req.forwarded[0]",
        "assert req.forwarded[1]['for'] == '_real'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_single_forwarded_header_long_quoted_string",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 444,
      "end_line_number": 447,
      "source_code": "def test_single_forwarded_header_long_quoted_string() -> None:\n    header = 'for=\"' + \"\\\\\\\\\" * 5000 + '\"'\n    req = make_mocked_request(\"GET\", \"/\", headers=CIMultiDict({\"Forwarded\": header}))\n    assert req.forwarded[0][\"for\"] == \"\\\\\" * 5000",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.forwarded[0]['for'] == '\\\\' * 5000"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_multiple_forwarded_headers",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 450,
      "end_line_number": 460,
      "source_code": "def test_multiple_forwarded_headers() -> None:\n    headers = CIMultiDict[str]()\n    headers.add(\"Forwarded\", \"By=identifier1;for=identifier2, BY=identifier3\")\n    headers.add(\"Forwarded\", \"By=identifier4;fOr=identifier5\")\n    req = make_mocked_request(\"GET\", \"/\", headers=headers)\n    assert len(req.forwarded) == 3\n    assert req.forwarded[0][\"by\"] == \"identifier1\"\n    assert req.forwarded[0][\"for\"] == \"identifier2\"\n    assert req.forwarded[1][\"by\"] == \"identifier3\"\n    assert req.forwarded[2][\"by\"] == \"identifier4\"\n    assert req.forwarded[2][\"for\"] == \"identifier5\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(req.forwarded) == 3",
        "assert req.forwarded[0]['by'] == 'identifier1'",
        "assert req.forwarded[0]['for'] == 'identifier2'",
        "assert req.forwarded[1]['by'] == 'identifier3'",
        "assert req.forwarded[2]['by'] == 'identifier4'",
        "assert req.forwarded[2]['for'] == 'identifier5'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_multiple_forwarded_headers_bad_syntax",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 463,
      "end_line_number": 474,
      "source_code": "def test_multiple_forwarded_headers_bad_syntax() -> None:\n    headers = CIMultiDict[str]()\n    headers.add(\"Forwarded\", \"for=_1;by=_2\")\n    headers.add(\"Forwarded\", \"invalid value\")\n    headers.add(\"Forwarded\", \"\")\n    headers.add(\"Forwarded\", \"for=_3;by=_4\")\n    req = make_mocked_request(\"GET\", \"/\", headers=headers)\n    assert len(req.forwarded) == 4\n    assert req.forwarded[0][\"for\"] == \"_1\"\n    assert \"for\" not in req.forwarded[1]\n    assert \"for\" not in req.forwarded[2]\n    assert req.forwarded[3][\"by\"] == \"_4\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(req.forwarded) == 4",
        "assert req.forwarded[0]['for'] == '_1'",
        "assert 'for' not in req.forwarded[1]",
        "assert 'for' not in req.forwarded[2]",
        "assert req.forwarded[3]['by'] == '_4'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_multiple_forwarded_headers_injection",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 477,
      "end_line_number": 487,
      "source_code": "def test_multiple_forwarded_headers_injection() -> None:\n    headers = CIMultiDict[str]()\n    # This could be sent by an attacker, hoping to \"shadow\" the second header.\n    headers.add(\"Forwarded\", 'for=_injected;by=\"')\n    # This is added by our trusted reverse proxy.\n    headers.add(\"Forwarded\", \"for=_real;by=_actual_proxy\")\n    req = make_mocked_request(\"GET\", \"/\", headers=headers)\n    assert len(req.forwarded) == 2\n    assert \"by\" not in req.forwarded[0]\n    assert req.forwarded[1][\"for\"] == \"_real\"\n    assert req.forwarded[1][\"by\"] == \"_actual_proxy\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(req.forwarded) == 2",
        "assert 'by' not in req.forwarded[0]",
        "assert req.forwarded[1]['for'] == '_real'",
        "assert req.forwarded[1]['by'] == '_actual_proxy'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_host_by_host_header",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 490,
      "end_line_number": 492,
      "source_code": "def test_host_by_host_header() -> None:\n    req = make_mocked_request(\"GET\", \"/\", headers=CIMultiDict({\"Host\": \"example.com\"}))\n    assert req.host == \"example.com\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.host == 'example.com'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_raw_headers",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 495,
      "end_line_number": 497,
      "source_code": "def test_raw_headers() -> None:\n    req = make_mocked_request(\"GET\", \"/\", headers=CIMultiDict({\"X-HEADER\": \"aaa\"}))\n    assert req.raw_headers == ((b\"X-HEADER\", b\"aaa\"),)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.raw_headers == ((b'X-HEADER', b'aaa'),)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_rel_url",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 500,
      "end_line_number": 502,
      "source_code": "def test_rel_url() -> None:\n    req = make_mocked_request(\"GET\", \"/path\")\n    assert URL(\"/path\") == req.rel_url",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert URL('/path') == req.rel_url"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_url_url",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 505,
      "end_line_number": 507,
      "source_code": "def test_url_url() -> None:\n    req = make_mocked_request(\"GET\", \"/path\", headers={\"HOST\": \"example.com\"})\n    assert URL(\"http://example.com/path\") == req.url",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert URL('http://example.com/path') == req.url"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_url_non_default_port",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 510,
      "end_line_number": 512,
      "source_code": "def test_url_non_default_port() -> None:\n    req = make_mocked_request(\"GET\", \"/path\", headers={\"HOST\": \"example.com:8123\"})\n    assert req.url == URL(\"http://example.com:8123/path\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.url == URL('http://example.com:8123/path')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_url_ipv6",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 515,
      "end_line_number": 517,
      "source_code": "def test_url_ipv6() -> None:\n    req = make_mocked_request(\"GET\", \"/path\", headers={\"HOST\": \"[::1]:8123\"})\n    assert req.url == URL(\"http://[::1]:8123/path\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.url == URL('http://[::1]:8123/path')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_clone",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 520,
      "end_line_number": 524,
      "source_code": "def test_clone() -> None:\n    req = make_mocked_request(\"GET\", \"/path\")\n    req2 = req.clone()\n    assert req2.method == \"GET\"\n    assert req2.rel_url == URL(\"/path\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert req2.method == 'GET'",
        "assert req2.rel_url == URL('/path')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_clone_client_max_size",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 527,
      "end_line_number": 531,
      "source_code": "def test_clone_client_max_size() -> None:\n    req = make_mocked_request(\"GET\", \"/path\", client_max_size=1024)\n    req2 = req.clone()\n    assert req._client_max_size == req2._client_max_size\n    assert req2._client_max_size == 1024",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert req._client_max_size == req2._client_max_size",
        "assert req2._client_max_size == 1024"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_clone_override_client_max_size",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 534,
      "end_line_number": 537,
      "source_code": "def test_clone_override_client_max_size() -> None:\n    req = make_mocked_request(\"GET\", \"/path\", client_max_size=1024)\n    req2 = req.clone(client_max_size=2048)\n    assert req2.client_max_size == 2048",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert req2.client_max_size == 2048"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_clone_method",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 540,
      "end_line_number": 544,
      "source_code": "def test_clone_method() -> None:\n    req = make_mocked_request(\"GET\", \"/path\")\n    req2 = req.clone(method=\"POST\")\n    assert req2.method == \"POST\"\n    assert req2.rel_url == URL(\"/path\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert req2.method == 'POST'",
        "assert req2.rel_url == URL('/path')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_clone_rel_url",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 547,
      "end_line_number": 550,
      "source_code": "def test_clone_rel_url() -> None:\n    req = make_mocked_request(\"GET\", \"/path\")\n    req2 = req.clone(rel_url=URL(\"/path2\"))\n    assert req2.rel_url == URL(\"/path2\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert req2.rel_url == URL('/path2')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_clone_rel_url_str",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 553,
      "end_line_number": 556,
      "source_code": "def test_clone_rel_url_str() -> None:\n    req = make_mocked_request(\"GET\", \"/path\")\n    req2 = req.clone(rel_url=\"/path2\")\n    assert req2.rel_url == URL(\"/path2\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert req2.rel_url == URL('/path2')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_clone_headers",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 559,
      "end_line_number": 563,
      "source_code": "def test_clone_headers() -> None:\n    req = make_mocked_request(\"GET\", \"/path\", headers={\"A\": \"B\"})\n    req2 = req.clone(headers=CIMultiDict({\"B\": \"C\"}))\n    assert req2.headers == CIMultiDict({\"B\": \"C\"})\n    assert req2.raw_headers == ((b\"B\", b\"C\"),)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert req2.headers == CIMultiDict({'B': 'C'})",
        "assert req2.raw_headers == ((b'B', b'C'),)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_clone_headers_dict",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 566,
      "end_line_number": 570,
      "source_code": "def test_clone_headers_dict() -> None:\n    req = make_mocked_request(\"GET\", \"/path\", headers={\"A\": \"B\"})\n    req2 = req.clone(headers={\"B\": \"C\"})\n    assert req2.headers == CIMultiDict({\"B\": \"C\"})\n    assert req2.raw_headers == ((b\"B\", b\"C\"),)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert req2.headers == CIMultiDict({'B': 'C'})",
        "assert req2.raw_headers == ((b'B', b'C'),)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_remote_peername_tcp",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 691,
      "end_line_number": 695,
      "source_code": "def test_remote_peername_tcp() -> None:\n    transp = mock.Mock()\n    transp.get_extra_info.return_value = (\"10.10.10.10\", 1234)\n    req = make_mocked_request(\"GET\", \"/\", transport=transp)\n    assert req.remote == \"10.10.10.10\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.remote == '10.10.10.10'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_remote_peername_unix",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 698,
      "end_line_number": 702,
      "source_code": "def test_remote_peername_unix() -> None:\n    transp = mock.Mock()\n    transp.get_extra_info.return_value = \"/path/to/sock\"\n    req = make_mocked_request(\"GET\", \"/\", transport=transp)\n    assert req.remote == \"/path/to/sock\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.remote == '/path/to/sock'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_save_state_on_clone",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 705,
      "end_line_number": 711,
      "source_code": "def test_save_state_on_clone() -> None:\n    req = make_mocked_request(\"GET\", \"/\")\n    req[\"key\"] = \"val\"\n    req2 = req.clone()\n    req2[\"key\"] = \"val2\"\n    assert req[\"key\"] == \"val\"\n    assert req2[\"key\"] == \"val2\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert req['key'] == 'val'",
        "assert req2['key'] == 'val2'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_clone_scheme",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 714,
      "end_line_number": 719,
      "source_code": "def test_clone_scheme() -> None:\n    req = make_mocked_request(\"GET\", \"/\")\n    assert req.scheme == \"http\"\n    req2 = req.clone(scheme=\"https\")\n    assert req2.scheme == \"https\"\n    assert req2.url.scheme == \"https\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.scheme == 'http'",
        "assert req2.scheme == 'https'",
        "assert req2.url.scheme == 'https'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_clone_host",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 722,
      "end_line_number": 727,
      "source_code": "def test_clone_host() -> None:\n    req = make_mocked_request(\"GET\", \"/\")\n    assert req.host != \"example.com\"\n    req2 = req.clone(host=\"example.com\")\n    assert req2.host == \"example.com\"\n    assert req2.url.host == \"example.com\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.host != 'example.com'",
        "assert req2.host == 'example.com'",
        "assert req2.url.host == 'example.com'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_clone_remote",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 730,
      "end_line_number": 734,
      "source_code": "def test_clone_remote() -> None:\n    req = make_mocked_request(\"GET\", \"/\")\n    assert req.remote != \"11.11.11.11\"\n    req2 = req.clone(remote=\"11.11.11.11\")\n    assert req2.remote == \"11.11.11.11\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.remote != '11.11.11.11'",
        "assert req2.remote == '11.11.11.11'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_remote_with_closed_transport",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 737,
      "end_line_number": 742,
      "source_code": "def test_remote_with_closed_transport() -> None:\n    transp = mock.Mock()\n    transp.get_extra_info.return_value = (\"10.10.10.10\", 1234)\n    req = make_mocked_request(\"GET\", \"/\", transport=transp)\n    req._protocol = None  # type: ignore[assignment]\n    assert req.remote == \"10.10.10.10\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.remote == '10.10.10.10'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_url_http_with_closed_transport",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 745,
      "end_line_number": 748,
      "source_code": "def test_url_http_with_closed_transport() -> None:\n    req = make_mocked_request(\"GET\", \"/\")\n    req._protocol = None  # type: ignore[assignment]\n    assert str(req.url).startswith(\"http://\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(req.url).startswith('http://')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_url_https_with_closed_transport",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 751,
      "end_line_number": 755,
      "source_code": "def test_url_https_with_closed_transport() -> None:\n    c = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n    req = make_mocked_request(\"GET\", \"/\", sslcontext=c)\n    req._protocol = None  # type: ignore[assignment]\n    assert str(req.url).startswith(\"https://\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(req.url).startswith('https://')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_eq",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 781,
      "end_line_number": 785,
      "source_code": "def test_eq() -> None:\n    req1 = make_mocked_request(\"GET\", \"/path/to?a=1&b=2\")\n    req2 = make_mocked_request(\"GET\", \"/path/to?a=1&b=2\")\n    assert req1 != req2\n    assert req1 == req1",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert req1 != req2",
        "assert req1 == req1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_weakref_creation",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 828,
      "end_line_number": 830,
      "source_code": "def test_weakref_creation() -> None:\n    req = make_mocked_request(\"GET\", \"/\")\n    weakref.ref(req)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_etag_headers",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 872,
      "end_line_number": 876,
      "source_code": "def test_etag_headers(\n    header: str, header_attr: str, header_val: str, expected: Tuple[ETag, ...]\n) -> None:\n    req = make_mocked_request(\"GET\", \"/\", headers={header: header_val})\n    assert getattr(req, header_attr) == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize(('header', 'header_attr'), (pytest.param('If-Match', 'if_match'), pytest.param('If-None-Match', 'if_none_match')))",
        "pytest.mark.parametrize(('header_val', 'expected'), (pytest.param('\"67ab43\", W/\"54ed21\", \"7892,dd\"', (ETag(is_weak=False, value='67ab43'), ETag(is_weak=True, value='54ed21'), ETag(is_weak=False, value='7892,dd'))), pytest.param('\"bfc1ef-5b2c2730249c88ca92d82d\"', (ETag(is_weak=False, value='bfc1ef-5b2c2730249c88ca92d82d'),)), pytest.param('\"valid-tag\", \"also-valid-tag\",somegarbage\"last-tag\"', (ETag(is_weak=False, value='valid-tag'), ETag(is_weak=False, value='also-valid-tag'))), pytest.param('\"ascii\", \"\u044d\u0442\u043e \u0442\u043e\u0447\u043d\u043e \u043d\u0435 ascii\", \"ascii again\"', (ETag(is_weak=False, value='ascii'),)), pytest.param('*', (ETag(is_weak=False, value='*'),))))"
      ],
      "arguments": [
        "header",
        "header_attr",
        "header_val",
        "expected"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert getattr(req, header_attr) == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_datetime_headers",
      "module": "test_web_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_request.py",
      "line_number": 899,
      "end_line_number": 906,
      "source_code": "def test_datetime_headers(\n    header: str,\n    header_attr: str,\n    header_val: str,\n    expected: Optional[datetime.datetime],\n) -> None:\n    req = make_mocked_request(\"GET\", \"/\", headers={header: header_val})\n    assert getattr(req, header_attr) == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize(('header', 'header_attr'), (pytest.param('If-Modified-Since', 'if_modified_since'), pytest.param('If-Unmodified-Since', 'if_unmodified_since'), pytest.param('If-Range', 'if_range')))",
        "pytest.mark.parametrize(('header_val', 'expected'), (pytest.param('xxyyzz', None), pytest.param('Tue, 08 Oct 4446413 00:56:40 GMT', None), pytest.param('Tue, 08 Oct 2000 00:56:80 GMT', None), pytest.param('Tue, 08 Oct 2000 00:56:40 GMT', datetime.datetime(2000, 10, 8, 0, 56, 40, tzinfo=datetime.timezone.utc))))"
      ],
      "arguments": [
        "header",
        "header_attr",
        "header_val",
        "expected"
      ],
      "imports": [
        "asyncio",
        "datetime",
        "socket",
        "ssl",
        "weakref",
        "collections.abc.MutableMapping",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.MultiDict",
        "yarl.URL",
        "aiohttp.ETag",
        "aiohttp.HttpVersion",
        "aiohttp.web",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.http_parser.RawRequestMessage",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.streams.StreamReader",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert getattr(req, header_attr) == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_is_eof",
      "module": "test_streams",
      "class_name": "TestDataQueue",
      "file_path": "__internal__/data/aiohttp/tests/test_streams.py",
      "line_number": 1139,
      "end_line_number": 1142,
      "source_code": "def test_is_eof(self, buffer: streams.DataQueue[bytes]) -> None:\n        assert not buffer.is_eof()\n        buffer.feed_eof()\n        assert buffer.is_eof()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "buffer"
      ],
      "imports": [
        "abc",
        "asyncio",
        "gc",
        "types",
        "collections.defaultdict",
        "itertools.groupby",
        "typing.DefaultDict",
        "typing.Iterator",
        "typing.Sequence",
        "typing.TypeVar",
        "unittest.mock",
        "pytest",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert not buffer.is_eof()",
        "assert buffer.is_eof()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_at_eof",
      "module": "test_streams",
      "class_name": "TestDataQueue",
      "file_path": "__internal__/data/aiohttp/tests/test_streams.py",
      "line_number": 1144,
      "end_line_number": 1149,
      "source_code": "def test_at_eof(self, buffer: streams.DataQueue[bytes]) -> None:\n        assert not buffer.at_eof()\n        buffer.feed_eof()\n        assert buffer.at_eof()\n        buffer._buffer.append(b\"foo\")\n        assert not buffer.at_eof()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "buffer"
      ],
      "imports": [
        "abc",
        "asyncio",
        "gc",
        "types",
        "collections.defaultdict",
        "itertools.groupby",
        "typing.DefaultDict",
        "typing.Iterator",
        "typing.Sequence",
        "typing.TypeVar",
        "unittest.mock",
        "pytest",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert not buffer.at_eof()",
        "assert buffer.at_eof()",
        "assert not buffer.at_eof()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "buffer.at_eof",
          "body": "def at_eof(self) -> bool:\n    return self.content.tell() == len(self.content.getbuffer())"
        },
        {
          "name": "buffer.at_eof",
          "body": "def at_eof(self) -> bool:\n    return self.content.tell() == len(self.content.getbuffer())"
        },
        {
          "name": "buffer.at_eof",
          "body": "def at_eof(self) -> bool:\n    return self.content.tell() == len(self.content.getbuffer())"
        }
      ]
    },
    {
      "name": "test_feed_data",
      "module": "test_streams",
      "class_name": "TestDataQueue",
      "file_path": "__internal__/data/aiohttp/tests/test_streams.py",
      "line_number": 1151,
      "end_line_number": 1154,
      "source_code": "def test_feed_data(self, buffer: streams.DataQueue[bytes]) -> None:\n        item = b\" \"\n        buffer.feed_data(item)\n        assert [item] == list(buffer._buffer)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "buffer"
      ],
      "imports": [
        "abc",
        "asyncio",
        "gc",
        "types",
        "collections.defaultdict",
        "itertools.groupby",
        "typing.DefaultDict",
        "typing.Iterator",
        "typing.Sequence",
        "typing.TypeVar",
        "unittest.mock",
        "pytest",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert [item] == list(buffer._buffer)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_feed_eof",
      "module": "test_streams",
      "class_name": "TestDataQueue",
      "file_path": "__internal__/data/aiohttp/tests/test_streams.py",
      "line_number": 1156,
      "end_line_number": 1158,
      "source_code": "def test_feed_eof(self, buffer: streams.DataQueue[bytes]) -> None:\n        buffer.feed_eof()\n        assert buffer._eof",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "buffer"
      ],
      "imports": [
        "abc",
        "asyncio",
        "gc",
        "types",
        "collections.defaultdict",
        "itertools.groupby",
        "typing.DefaultDict",
        "typing.Iterator",
        "typing.Sequence",
        "typing.TypeVar",
        "unittest.mock",
        "pytest",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert buffer._eof"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_exception",
      "module": "test_streams",
      "class_name": "TestDataQueue",
      "file_path": "__internal__/data/aiohttp/tests/test_streams.py",
      "line_number": 1252,
      "end_line_number": 1257,
      "source_code": "def test_exception(self, buffer: streams.DataQueue[bytes]) -> None:\n        assert buffer.exception() is None\n\n        exc = ValueError()\n        buffer.set_exception(exc)\n        assert buffer.exception() is exc",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "buffer"
      ],
      "imports": [
        "abc",
        "asyncio",
        "gc",
        "types",
        "collections.defaultdict",
        "itertools.groupby",
        "typing.DefaultDict",
        "typing.Iterator",
        "typing.Sequence",
        "typing.TypeVar",
        "unittest.mock",
        "pytest",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert buffer.exception() is None",
        "assert buffer.exception() is exc"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_isinstance_check",
      "module": "test_streams",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_streams.py",
      "line_number": 1536,
      "end_line_number": 1537,
      "source_code": "def test_isinstance_check() -> None:\n    assert isinstance(streams.EMPTY_PAYLOAD, streams.StreamReader)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "abc",
        "asyncio",
        "gc",
        "types",
        "collections.defaultdict",
        "itertools.groupby",
        "typing.DefaultDict",
        "typing.Iterator",
        "typing.Sequence",
        "typing.TypeVar",
        "unittest.mock",
        "pytest",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(streams.EMPTY_PAYLOAD, streams.StreamReader)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_is_eof",
      "module": "test_streams",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_streams.py",
      "line_number": 1139,
      "end_line_number": 1142,
      "source_code": "def test_is_eof(self, buffer: streams.DataQueue[bytes]) -> None:\n        assert not buffer.is_eof()\n        buffer.feed_eof()\n        assert buffer.is_eof()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "buffer"
      ],
      "imports": [
        "abc",
        "asyncio",
        "gc",
        "types",
        "collections.defaultdict",
        "itertools.groupby",
        "typing.DefaultDict",
        "typing.Iterator",
        "typing.Sequence",
        "typing.TypeVar",
        "unittest.mock",
        "pytest",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert not buffer.is_eof()",
        "assert buffer.is_eof()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_at_eof",
      "module": "test_streams",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_streams.py",
      "line_number": 1144,
      "end_line_number": 1149,
      "source_code": "def test_at_eof(self, buffer: streams.DataQueue[bytes]) -> None:\n        assert not buffer.at_eof()\n        buffer.feed_eof()\n        assert buffer.at_eof()\n        buffer._buffer.append(b\"foo\")\n        assert not buffer.at_eof()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "buffer"
      ],
      "imports": [
        "abc",
        "asyncio",
        "gc",
        "types",
        "collections.defaultdict",
        "itertools.groupby",
        "typing.DefaultDict",
        "typing.Iterator",
        "typing.Sequence",
        "typing.TypeVar",
        "unittest.mock",
        "pytest",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert not buffer.at_eof()",
        "assert buffer.at_eof()",
        "assert not buffer.at_eof()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "buffer.at_eof",
          "body": "def at_eof(self) -> bool:\n    return self.content.tell() == len(self.content.getbuffer())"
        },
        {
          "name": "buffer.at_eof",
          "body": "def at_eof(self) -> bool:\n    return self.content.tell() == len(self.content.getbuffer())"
        },
        {
          "name": "buffer.at_eof",
          "body": "def at_eof(self) -> bool:\n    return self.content.tell() == len(self.content.getbuffer())"
        }
      ]
    },
    {
      "name": "test_feed_data",
      "module": "test_streams",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_streams.py",
      "line_number": 1151,
      "end_line_number": 1154,
      "source_code": "def test_feed_data(self, buffer: streams.DataQueue[bytes]) -> None:\n        item = b\" \"\n        buffer.feed_data(item)\n        assert [item] == list(buffer._buffer)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "buffer"
      ],
      "imports": [
        "abc",
        "asyncio",
        "gc",
        "types",
        "collections.defaultdict",
        "itertools.groupby",
        "typing.DefaultDict",
        "typing.Iterator",
        "typing.Sequence",
        "typing.TypeVar",
        "unittest.mock",
        "pytest",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert [item] == list(buffer._buffer)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_feed_eof",
      "module": "test_streams",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_streams.py",
      "line_number": 1156,
      "end_line_number": 1158,
      "source_code": "def test_feed_eof(self, buffer: streams.DataQueue[bytes]) -> None:\n        buffer.feed_eof()\n        assert buffer._eof",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "buffer"
      ],
      "imports": [
        "abc",
        "asyncio",
        "gc",
        "types",
        "collections.defaultdict",
        "itertools.groupby",
        "typing.DefaultDict",
        "typing.Iterator",
        "typing.Sequence",
        "typing.TypeVar",
        "unittest.mock",
        "pytest",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert buffer._eof"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_exception",
      "module": "test_streams",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_streams.py",
      "line_number": 1252,
      "end_line_number": 1257,
      "source_code": "def test_exception(self, buffer: streams.DataQueue[bytes]) -> None:\n        assert buffer.exception() is None\n\n        exc = ValueError()\n        buffer.set_exception(exc)\n        assert buffer.exception() is exc",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "buffer"
      ],
      "imports": [
        "abc",
        "asyncio",
        "gc",
        "types",
        "collections.defaultdict",
        "itertools.groupby",
        "typing.DefaultDict",
        "typing.Iterator",
        "typing.Sequence",
        "typing.TypeVar",
        "unittest.mock",
        "pytest",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert buffer.exception() is None",
        "assert buffer.exception() is exc"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_client",
      "module": "test_test_utils",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_test_utils.py",
      "line_number": 76,
      "end_line_number": 86,
      "source_code": "def test_client(\n    loop: asyncio.AbstractEventLoop, app: web.Application\n) -> Iterator[_TestClient]:\n    async def make_client() -> TestClient[web.Request, web.Application]:\n        return TestClient(TestServer(app))\n\n    client = loop.run_until_complete(make_client())\n\n    loop.run_until_complete(client.start_server())\n    yield client\n    loop.run_until_complete(client.close())",
      "docstring": null,
      "decorators": [
        "pytest.fixture"
      ],
      "arguments": [
        "loop",
        "app"
      ],
      "imports": [
        "asyncio",
        "gzip",
        "socket",
        "sys",
        "typing.Callable",
        "typing.Iterator",
        "typing.Mapping",
        "typing.NoReturn",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.test_utils.AioHTTPTestCase",
        "aiohttp.test_utils.RawTestServer",
        "aiohttp.test_utils.TestClient",
        "aiohttp.test_utils.TestServer",
        "aiohttp.test_utils.get_port_socket",
        "aiohttp.test_utils.loop_context",
        "aiohttp.test_utils.make_mocked_request",
        "typing.assert_type"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_get_route",
      "module": "test_test_utils",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_test_utils.py",
      "line_number": 124,
      "end_line_number": 131,
      "source_code": "def test_get_route(loop: asyncio.AbstractEventLoop, test_client: _TestClient) -> None:\n    async def test_get_route() -> None:\n        resp = await test_client.request(\"GET\", \"/\")\n        assert resp.status == 200\n        text = await resp.text()\n        assert _hello_world_str == text\n\n    loop.run_until_complete(test_get_route())",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop",
        "test_client"
      ],
      "imports": [
        "asyncio",
        "gzip",
        "socket",
        "sys",
        "typing.Callable",
        "typing.Iterator",
        "typing.Mapping",
        "typing.NoReturn",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.test_utils.AioHTTPTestCase",
        "aiohttp.test_utils.RawTestServer",
        "aiohttp.test_utils.TestClient",
        "aiohttp.test_utils.TestServer",
        "aiohttp.test_utils.get_port_socket",
        "aiohttp.test_utils.loop_context",
        "aiohttp.test_utils.make_mocked_request",
        "typing.assert_type"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status == 200",
        "assert _hello_world_str == text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_get_route",
          "body": "def test_get_route(loop: asyncio.AbstractEventLoop, test_client: _TestClient) -> None:\n\n    async def test_get_route() -> None:\n        resp = await test_client.request('GET', '/')\n        assert resp.status == 200\n        text = await resp.text()\n        assert _hello_world_str == text\n    loop.run_until_complete(test_get_route())"
        }
      ]
    },
    {
      "name": "test_make_mocked_request",
      "module": "test_test_utils",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_test_utils.py",
      "line_number": 177,
      "end_line_number": 182,
      "source_code": "def test_make_mocked_request(headers: Mapping[str, str]) -> None:\n    req = make_mocked_request(\"GET\", \"/\", headers=headers)\n    assert req.method == \"GET\"\n    assert req.path == \"/\"\n    assert isinstance(req, web.Request)\n    assert isinstance(req.headers, CIMultiDictProxy)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('headers', [{'token': 'x'}, CIMultiDict({'token': 'x'}), {}])"
      ],
      "arguments": [
        "headers"
      ],
      "imports": [
        "asyncio",
        "gzip",
        "socket",
        "sys",
        "typing.Callable",
        "typing.Iterator",
        "typing.Mapping",
        "typing.NoReturn",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.test_utils.AioHTTPTestCase",
        "aiohttp.test_utils.RawTestServer",
        "aiohttp.test_utils.TestClient",
        "aiohttp.test_utils.TestServer",
        "aiohttp.test_utils.get_port_socket",
        "aiohttp.test_utils.loop_context",
        "aiohttp.test_utils.make_mocked_request",
        "typing.assert_type"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.method == 'GET'",
        "assert req.path == '/'",
        "assert isinstance(req, web.Request)",
        "assert isinstance(req.headers, CIMultiDictProxy)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_make_mocked_request_sslcontext",
      "module": "test_test_utils",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_test_utils.py",
      "line_number": 185,
      "end_line_number": 188,
      "source_code": "def test_make_mocked_request_sslcontext() -> None:\n    req = make_mocked_request(\"GET\", \"/\")\n    assert req.transport is not None\n    assert req.transport.get_extra_info(\"sslcontext\") is None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "gzip",
        "socket",
        "sys",
        "typing.Callable",
        "typing.Iterator",
        "typing.Mapping",
        "typing.NoReturn",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.test_utils.AioHTTPTestCase",
        "aiohttp.test_utils.RawTestServer",
        "aiohttp.test_utils.TestClient",
        "aiohttp.test_utils.TestServer",
        "aiohttp.test_utils.get_port_socket",
        "aiohttp.test_utils.loop_context",
        "aiohttp.test_utils.make_mocked_request",
        "typing.assert_type"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.transport is not None",
        "assert req.transport.get_extra_info('sslcontext') is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "req.transport.get_extra_info",
          "body": "def get_extra_info(name: str, default: object=None) -> object:\n    return {valid_key: valid_value}.get(name, default)"
        }
      ]
    },
    {
      "name": "test_make_mocked_request_unknown_extra_info",
      "module": "test_test_utils",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_test_utils.py",
      "line_number": 191,
      "end_line_number": 194,
      "source_code": "def test_make_mocked_request_unknown_extra_info() -> None:\n    req = make_mocked_request(\"GET\", \"/\")\n    assert req.transport is not None\n    assert req.transport.get_extra_info(\"unknown_extra_info\") is None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "gzip",
        "socket",
        "sys",
        "typing.Callable",
        "typing.Iterator",
        "typing.Mapping",
        "typing.NoReturn",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.test_utils.AioHTTPTestCase",
        "aiohttp.test_utils.RawTestServer",
        "aiohttp.test_utils.TestClient",
        "aiohttp.test_utils.TestServer",
        "aiohttp.test_utils.get_port_socket",
        "aiohttp.test_utils.loop_context",
        "aiohttp.test_utils.make_mocked_request",
        "typing.assert_type"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.transport is not None",
        "assert req.transport.get_extra_info('unknown_extra_info') is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "req.transport.get_extra_info",
          "body": "def get_extra_info(name: str, default: object=None) -> object:\n    return {valid_key: valid_value}.get(name, default)"
        }
      ]
    },
    {
      "name": "test_make_mocked_request_app",
      "module": "test_test_utils",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_test_utils.py",
      "line_number": 197,
      "end_line_number": 200,
      "source_code": "def test_make_mocked_request_app() -> None:\n    app = mock.Mock()\n    req = make_mocked_request(\"GET\", \"/\", app=app)\n    assert req.app is app",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "gzip",
        "socket",
        "sys",
        "typing.Callable",
        "typing.Iterator",
        "typing.Mapping",
        "typing.NoReturn",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.test_utils.AioHTTPTestCase",
        "aiohttp.test_utils.RawTestServer",
        "aiohttp.test_utils.TestClient",
        "aiohttp.test_utils.TestServer",
        "aiohttp.test_utils.get_port_socket",
        "aiohttp.test_utils.loop_context",
        "aiohttp.test_utils.make_mocked_request",
        "typing.assert_type"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.app is app"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_make_mocked_request_app_can_store_values",
      "module": "test_test_utils",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_test_utils.py",
      "line_number": 203,
      "end_line_number": 206,
      "source_code": "def test_make_mocked_request_app_can_store_values() -> None:\n    req = make_mocked_request(\"GET\", \"/\")\n    req.app[\"a_field\"] = \"a_value\"\n    assert req.app[\"a_field\"] == \"a_value\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "gzip",
        "socket",
        "sys",
        "typing.Callable",
        "typing.Iterator",
        "typing.Mapping",
        "typing.NoReturn",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.test_utils.AioHTTPTestCase",
        "aiohttp.test_utils.RawTestServer",
        "aiohttp.test_utils.TestClient",
        "aiohttp.test_utils.TestServer",
        "aiohttp.test_utils.get_port_socket",
        "aiohttp.test_utils.loop_context",
        "aiohttp.test_utils.make_mocked_request",
        "typing.assert_type"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.app['a_field'] == 'a_value'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_make_mocked_request_app_access_non_existing",
      "module": "test_test_utils",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_test_utils.py",
      "line_number": 209,
      "end_line_number": 212,
      "source_code": "def test_make_mocked_request_app_access_non_existing() -> None:\n    req = make_mocked_request(\"GET\", \"/\")\n    with pytest.raises(AttributeError):\n        req.app.foo",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "gzip",
        "socket",
        "sys",
        "typing.Callable",
        "typing.Iterator",
        "typing.Mapping",
        "typing.NoReturn",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.test_utils.AioHTTPTestCase",
        "aiohttp.test_utils.RawTestServer",
        "aiohttp.test_utils.TestClient",
        "aiohttp.test_utils.TestServer",
        "aiohttp.test_utils.get_port_socket",
        "aiohttp.test_utils.loop_context",
        "aiohttp.test_utils.make_mocked_request",
        "typing.assert_type"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_make_mocked_request_match_info",
      "module": "test_test_utils",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_test_utils.py",
      "line_number": 215,
      "end_line_number": 217,
      "source_code": "def test_make_mocked_request_match_info() -> None:\n    req = make_mocked_request(\"GET\", \"/\", match_info={\"a\": \"1\", \"b\": \"2\"})\n    assert req.match_info == {\"a\": \"1\", \"b\": \"2\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "gzip",
        "socket",
        "sys",
        "typing.Callable",
        "typing.Iterator",
        "typing.Mapping",
        "typing.NoReturn",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.test_utils.AioHTTPTestCase",
        "aiohttp.test_utils.RawTestServer",
        "aiohttp.test_utils.TestClient",
        "aiohttp.test_utils.TestServer",
        "aiohttp.test_utils.get_port_socket",
        "aiohttp.test_utils.loop_context",
        "aiohttp.test_utils.make_mocked_request",
        "typing.assert_type"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.match_info == {'a': '1', 'b': '2'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_make_mocked_request_content",
      "module": "test_test_utils",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_test_utils.py",
      "line_number": 220,
      "end_line_number": 223,
      "source_code": "def test_make_mocked_request_content() -> None:\n    payload = mock.Mock()\n    req = make_mocked_request(\"GET\", \"/\", payload=payload)\n    assert req.content is payload",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "gzip",
        "socket",
        "sys",
        "typing.Callable",
        "typing.Iterator",
        "typing.Mapping",
        "typing.NoReturn",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.test_utils.AioHTTPTestCase",
        "aiohttp.test_utils.RawTestServer",
        "aiohttp.test_utils.TestClient",
        "aiohttp.test_utils.TestServer",
        "aiohttp.test_utils.get_port_socket",
        "aiohttp.test_utils.loop_context",
        "aiohttp.test_utils.make_mocked_request",
        "typing.assert_type"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.content is payload"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_make_mocked_request_transport",
      "module": "test_test_utils",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_test_utils.py",
      "line_number": 231,
      "end_line_number": 234,
      "source_code": "def test_make_mocked_request_transport() -> None:\n    transport = mock.Mock()\n    req = make_mocked_request(\"GET\", \"/\", transport=transport)\n    assert req.transport is transport",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "gzip",
        "socket",
        "sys",
        "typing.Callable",
        "typing.Iterator",
        "typing.Mapping",
        "typing.NoReturn",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.test_utils.AioHTTPTestCase",
        "aiohttp.test_utils.RawTestServer",
        "aiohttp.test_utils.TestClient",
        "aiohttp.test_utils.TestServer",
        "aiohttp.test_utils.get_port_socket",
        "aiohttp.test_utils.loop_context",
        "aiohttp.test_utils.make_mocked_request",
        "typing.assert_type"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.transport is transport"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_client_unsupported_arg",
      "module": "test_test_utils",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_test_utils.py",
      "line_number": 281,
      "end_line_number": 287,
      "source_code": "def test_client_unsupported_arg() -> None:\n    with pytest.raises(TypeError) as e:\n        TestClient(\"string\")  # type: ignore[call-overload]\n\n    assert (\n        str(e.value) == \"server must be TestServer instance, found type: <class 'str'>\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "gzip",
        "socket",
        "sys",
        "typing.Callable",
        "typing.Iterator",
        "typing.Mapping",
        "typing.NoReturn",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.test_utils.AioHTTPTestCase",
        "aiohttp.test_utils.RawTestServer",
        "aiohttp.test_utils.TestClient",
        "aiohttp.test_utils.TestServer",
        "aiohttp.test_utils.get_port_socket",
        "aiohttp.test_utils.loop_context",
        "aiohttp.test_utils.make_mocked_request",
        "typing.assert_type"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(e.value) == \"server must be TestServer instance, found type: <class 'str'>\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_testcase_no_app",
      "module": "test_test_utils",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_test_utils.py",
      "line_number": 303,
      "end_line_number": 317,
      "source_code": "def test_testcase_no_app(\n    testdir: pytest.Testdir, loop: asyncio.AbstractEventLoop\n) -> None:\n    testdir.makepyfile(\n        \"\"\"\n        from aiohttp.test_utils import AioHTTPTestCase\n\n\n        class InvalidTestCase(AioHTTPTestCase):\n            def test_noop(self) -> None:\n                pass\n        \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines([\"*TypeError*\"])",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "testdir",
        "loop"
      ],
      "imports": [
        "asyncio",
        "gzip",
        "socket",
        "sys",
        "typing.Callable",
        "typing.Iterator",
        "typing.Mapping",
        "typing.NoReturn",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.test_utils.AioHTTPTestCase",
        "aiohttp.test_utils.RawTestServer",
        "aiohttp.test_utils.TestClient",
        "aiohttp.test_utils.TestServer",
        "aiohttp.test_utils.get_port_socket",
        "aiohttp.test_utils.loop_context",
        "aiohttp.test_utils.make_mocked_request",
        "typing.assert_type"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_handshake_compress_server_notakeover",
      "module": "test_websocket_handshake",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_handshake.py",
      "line_number": 194,
      "end_line_number": 207,
      "source_code": "def test_handshake_compress_server_notakeover() -> None:\n    hdrs, sec_key = gen_ws_headers(compress=15, server_notakeover=True)\n\n    req = make_mocked_request(\"GET\", \"/\", headers=hdrs)\n\n    ws = web.WebSocketResponse()\n    headers, _, compress, notakeover = ws._handshake(req)\n\n    assert compress == 15\n    assert notakeover is True\n    assert \"Sec-Websocket-Extensions\" in headers\n    assert headers[\"Sec-Websocket-Extensions\"] == (\n        \"permessage-deflate; server_no_context_takeover\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "base64",
        "os",
        "typing.List",
        "typing.Tuple",
        "pytest",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert compress == 15",
        "assert notakeover is True",
        "assert 'Sec-Websocket-Extensions' in headers",
        "assert headers['Sec-Websocket-Extensions'] == 'permessage-deflate; server_no_context_takeover'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "gen_ws_headers",
          "body": "def gen_ws_headers(protocols: str='', compress: int=0, extension_text: str='', server_notakeover: bool=False, client_notakeover: bool=False) -> Tuple[List[Tuple[str, str]], str]:\n    key = base64.b64encode(os.urandom(16)).decode()\n    hdrs = [('Upgrade', 'websocket'), ('Connection', 'upgrade'), ('Sec-Websocket-Version', '13'), ('Sec-Websocket-Key', key)]\n    if protocols:\n        hdrs += [('Sec-Websocket-Protocol', protocols)]\n    if compress:\n        params = 'permessage-deflate'\n        if compress < 15:\n            params += '; server_max_window_bits=' + str(compress)\n        if server_notakeover:\n            params += '; server_no_context_takeover'\n        if client_notakeover:\n            params += '; client_no_context_takeover'\n        if extension_text:\n            params += '; ' + extension_text\n        hdrs += [('Sec-Websocket-Extensions', params)]\n    return (hdrs, key)"
        }
      ]
    },
    {
      "name": "test_handshake_compress_client_notakeover",
      "module": "test_websocket_handshake",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_handshake.py",
      "line_number": 210,
      "end_line_number": 221,
      "source_code": "def test_handshake_compress_client_notakeover() -> None:\n    hdrs, sec_key = gen_ws_headers(compress=15, client_notakeover=True)\n\n    req = make_mocked_request(\"GET\", \"/\", headers=hdrs)\n\n    ws = web.WebSocketResponse()\n    headers, _, compress, notakeover = ws._handshake(req)\n\n    assert \"Sec-Websocket-Extensions\" in headers\n    assert headers[\"Sec-Websocket-Extensions\"] == (\"permessage-deflate\"), hdrs\n\n    assert compress == 15",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "base64",
        "os",
        "typing.List",
        "typing.Tuple",
        "pytest",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'Sec-Websocket-Extensions' in headers",
        "assert headers['Sec-Websocket-Extensions'] == 'permessage-deflate', hdrs",
        "assert compress == 15"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "gen_ws_headers",
          "body": "def gen_ws_headers(protocols: str='', compress: int=0, extension_text: str='', server_notakeover: bool=False, client_notakeover: bool=False) -> Tuple[List[Tuple[str, str]], str]:\n    key = base64.b64encode(os.urandom(16)).decode()\n    hdrs = [('Upgrade', 'websocket'), ('Connection', 'upgrade'), ('Sec-Websocket-Version', '13'), ('Sec-Websocket-Key', key)]\n    if protocols:\n        hdrs += [('Sec-Websocket-Protocol', protocols)]\n    if compress:\n        params = 'permessage-deflate'\n        if compress < 15:\n            params += '; server_max_window_bits=' + str(compress)\n        if server_notakeover:\n            params += '; server_no_context_takeover'\n        if client_notakeover:\n            params += '; client_no_context_takeover'\n        if extension_text:\n            params += '; ' + extension_text\n        hdrs += [('Sec-Websocket-Extensions', params)]\n    return (hdrs, key)"
        }
      ]
    },
    {
      "name": "test_handshake_compress_wbits",
      "module": "test_websocket_handshake",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_handshake.py",
      "line_number": 224,
      "end_line_number": 236,
      "source_code": "def test_handshake_compress_wbits() -> None:\n    hdrs, sec_key = gen_ws_headers(compress=9)\n\n    req = make_mocked_request(\"GET\", \"/\", headers=hdrs)\n\n    ws = web.WebSocketResponse()\n    headers, _, compress, notakeover = ws._handshake(req)\n\n    assert \"Sec-Websocket-Extensions\" in headers\n    assert headers[\"Sec-Websocket-Extensions\"] == (\n        \"permessage-deflate; server_max_window_bits=9\"\n    )\n    assert compress == 9",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "base64",
        "os",
        "typing.List",
        "typing.Tuple",
        "pytest",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'Sec-Websocket-Extensions' in headers",
        "assert headers['Sec-Websocket-Extensions'] == 'permessage-deflate; server_max_window_bits=9'",
        "assert compress == 9"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "gen_ws_headers",
          "body": "def gen_ws_headers(protocols: str='', compress: int=0, extension_text: str='', server_notakeover: bool=False, client_notakeover: bool=False) -> Tuple[List[Tuple[str, str]], str]:\n    key = base64.b64encode(os.urandom(16)).decode()\n    hdrs = [('Upgrade', 'websocket'), ('Connection', 'upgrade'), ('Sec-Websocket-Version', '13'), ('Sec-Websocket-Key', key)]\n    if protocols:\n        hdrs += [('Sec-Websocket-Protocol', protocols)]\n    if compress:\n        params = 'permessage-deflate'\n        if compress < 15:\n            params += '; server_max_window_bits=' + str(compress)\n        if server_notakeover:\n            params += '; server_no_context_takeover'\n        if client_notakeover:\n            params += '; client_no_context_takeover'\n        if extension_text:\n            params += '; ' + extension_text\n        hdrs += [('Sec-Websocket-Extensions', params)]\n    return (hdrs, key)"
        }
      ]
    },
    {
      "name": "test_handshake_compress_wbits_error",
      "module": "test_websocket_handshake",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_handshake.py",
      "line_number": 239,
      "end_line_number": 248,
      "source_code": "def test_handshake_compress_wbits_error() -> None:\n    hdrs, sec_key = gen_ws_headers(compress=6)\n\n    req = make_mocked_request(\"GET\", \"/\", headers=hdrs)\n\n    ws = web.WebSocketResponse()\n    headers, _, compress, notakeover = ws._handshake(req)\n\n    assert \"Sec-Websocket-Extensions\" not in headers\n    assert compress == 0",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "base64",
        "os",
        "typing.List",
        "typing.Tuple",
        "pytest",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'Sec-Websocket-Extensions' not in headers",
        "assert compress == 0"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "gen_ws_headers",
          "body": "def gen_ws_headers(protocols: str='', compress: int=0, extension_text: str='', server_notakeover: bool=False, client_notakeover: bool=False) -> Tuple[List[Tuple[str, str]], str]:\n    key = base64.b64encode(os.urandom(16)).decode()\n    hdrs = [('Upgrade', 'websocket'), ('Connection', 'upgrade'), ('Sec-Websocket-Version', '13'), ('Sec-Websocket-Key', key)]\n    if protocols:\n        hdrs += [('Sec-Websocket-Protocol', protocols)]\n    if compress:\n        params = 'permessage-deflate'\n        if compress < 15:\n            params += '; server_max_window_bits=' + str(compress)\n        if server_notakeover:\n            params += '; server_no_context_takeover'\n        if client_notakeover:\n            params += '; client_no_context_takeover'\n        if extension_text:\n            params += '; ' + extension_text\n        hdrs += [('Sec-Websocket-Extensions', params)]\n    return (hdrs, key)"
        }
      ]
    },
    {
      "name": "test_handshake_compress_bad_ext",
      "module": "test_websocket_handshake",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_handshake.py",
      "line_number": 251,
      "end_line_number": 260,
      "source_code": "def test_handshake_compress_bad_ext() -> None:\n    hdrs, sec_key = gen_ws_headers(compress=15, extension_text=\"bad\")\n\n    req = make_mocked_request(\"GET\", \"/\", headers=hdrs)\n\n    ws = web.WebSocketResponse()\n    headers, _, compress, notakeover = ws._handshake(req)\n\n    assert \"Sec-Websocket-Extensions\" not in headers\n    assert compress == 0",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "base64",
        "os",
        "typing.List",
        "typing.Tuple",
        "pytest",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'Sec-Websocket-Extensions' not in headers",
        "assert compress == 0"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "gen_ws_headers",
          "body": "def gen_ws_headers(protocols: str='', compress: int=0, extension_text: str='', server_notakeover: bool=False, client_notakeover: bool=False) -> Tuple[List[Tuple[str, str]], str]:\n    key = base64.b64encode(os.urandom(16)).decode()\n    hdrs = [('Upgrade', 'websocket'), ('Connection', 'upgrade'), ('Sec-Websocket-Version', '13'), ('Sec-Websocket-Key', key)]\n    if protocols:\n        hdrs += [('Sec-Websocket-Protocol', protocols)]\n    if compress:\n        params = 'permessage-deflate'\n        if compress < 15:\n            params += '; server_max_window_bits=' + str(compress)\n        if server_notakeover:\n            params += '; server_no_context_takeover'\n        if client_notakeover:\n            params += '; client_no_context_takeover'\n        if extension_text:\n            params += '; ' + extension_text\n        hdrs += [('Sec-Websocket-Extensions', params)]\n    return (hdrs, key)"
        }
      ]
    },
    {
      "name": "test_handshake_compress_multi_ext_bad",
      "module": "test_websocket_handshake",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_handshake.py",
      "line_number": 263,
      "end_line_number": 274,
      "source_code": "def test_handshake_compress_multi_ext_bad() -> None:\n    hdrs, sec_key = gen_ws_headers(\n        compress=15, extension_text=\"bad, permessage-deflate\"\n    )\n\n    req = make_mocked_request(\"GET\", \"/\", headers=hdrs)\n\n    ws = web.WebSocketResponse()\n    headers, _, compress, notakeover = ws._handshake(req)\n\n    assert \"Sec-Websocket-Extensions\" in headers\n    assert headers[\"Sec-Websocket-Extensions\"] == \"permessage-deflate\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "base64",
        "os",
        "typing.List",
        "typing.Tuple",
        "pytest",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'Sec-Websocket-Extensions' in headers",
        "assert headers['Sec-Websocket-Extensions'] == 'permessage-deflate'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "gen_ws_headers",
          "body": "def gen_ws_headers(protocols: str='', compress: int=0, extension_text: str='', server_notakeover: bool=False, client_notakeover: bool=False) -> Tuple[List[Tuple[str, str]], str]:\n    key = base64.b64encode(os.urandom(16)).decode()\n    hdrs = [('Upgrade', 'websocket'), ('Connection', 'upgrade'), ('Sec-Websocket-Version', '13'), ('Sec-Websocket-Key', key)]\n    if protocols:\n        hdrs += [('Sec-Websocket-Protocol', protocols)]\n    if compress:\n        params = 'permessage-deflate'\n        if compress < 15:\n            params += '; server_max_window_bits=' + str(compress)\n        if server_notakeover:\n            params += '; server_no_context_takeover'\n        if client_notakeover:\n            params += '; client_no_context_takeover'\n        if extension_text:\n            params += '; ' + extension_text\n        hdrs += [('Sec-Websocket-Extensions', params)]\n    return (hdrs, key)"
        }
      ]
    },
    {
      "name": "test_handshake_compress_multi_ext_wbits",
      "module": "test_websocket_handshake",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_handshake.py",
      "line_number": 277,
      "end_line_number": 287,
      "source_code": "def test_handshake_compress_multi_ext_wbits() -> None:\n    hdrs, sec_key = gen_ws_headers(compress=6, extension_text=\", permessage-deflate\")\n\n    req = make_mocked_request(\"GET\", \"/\", headers=hdrs)\n\n    ws = web.WebSocketResponse()\n    headers, _, compress, notakeover = ws._handshake(req)\n\n    assert \"Sec-Websocket-Extensions\" in headers\n    assert headers[\"Sec-Websocket-Extensions\"] == \"permessage-deflate\"\n    assert compress == 15",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "base64",
        "os",
        "typing.List",
        "typing.Tuple",
        "pytest",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'Sec-Websocket-Extensions' in headers",
        "assert headers['Sec-Websocket-Extensions'] == 'permessage-deflate'",
        "assert compress == 15"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "gen_ws_headers",
          "body": "def gen_ws_headers(protocols: str='', compress: int=0, extension_text: str='', server_notakeover: bool=False, client_notakeover: bool=False) -> Tuple[List[Tuple[str, str]], str]:\n    key = base64.b64encode(os.urandom(16)).decode()\n    hdrs = [('Upgrade', 'websocket'), ('Connection', 'upgrade'), ('Sec-Websocket-Version', '13'), ('Sec-Websocket-Key', key)]\n    if protocols:\n        hdrs += [('Sec-Websocket-Protocol', protocols)]\n    if compress:\n        params = 'permessage-deflate'\n        if compress < 15:\n            params += '; server_max_window_bits=' + str(compress)\n        if server_notakeover:\n            params += '; server_no_context_takeover'\n        if client_notakeover:\n            params += '; client_no_context_takeover'\n        if extension_text:\n            params += '; ' + extension_text\n        hdrs += [('Sec-Websocket-Extensions', params)]\n    return (hdrs, key)"
        }
      ]
    },
    {
      "name": "test_handshake_no_transfer_encoding",
      "module": "test_websocket_handshake",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_handshake.py",
      "line_number": 290,
      "end_line_number": 297,
      "source_code": "def test_handshake_no_transfer_encoding() -> None:\n    hdrs, sec_key = gen_ws_headers()\n    req = make_mocked_request(\"GET\", \"/\", headers=hdrs)\n\n    ws = web.WebSocketResponse()\n    headers, _, compress, notakeover = ws._handshake(req)\n\n    assert \"Transfer-Encoding\" not in headers",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "base64",
        "os",
        "typing.List",
        "typing.Tuple",
        "pytest",
        "aiohttp.web",
        "aiohttp.test_utils.make_mocked_request"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'Transfer-Encoding' not in headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "gen_ws_headers",
          "body": "def gen_ws_headers(protocols: str='', compress: int=0, extension_text: str='', server_notakeover: bool=False, client_notakeover: bool=False) -> Tuple[List[Tuple[str, str]], str]:\n    key = base64.b64encode(os.urandom(16)).decode()\n    hdrs = [('Upgrade', 'websocket'), ('Connection', 'upgrade'), ('Sec-Websocket-Version', '13'), ('Sec-Websocket-Key', key)]\n    if protocols:\n        hdrs += [('Sec-Websocket-Protocol', protocols)]\n    if compress:\n        params = 'permessage-deflate'\n        if compress < 15:\n            params += '; server_max_window_bits=' + str(compress)\n        if server_notakeover:\n            params += '; server_no_context_takeover'\n        if client_notakeover:\n            params += '; client_no_context_takeover'\n        if extension_text:\n            params += '; ' + extension_text\n        hdrs += [('Sec-Websocket-Extensions', params)]\n    return (hdrs, key)"
        }
      ]
    },
    {
      "name": "test_init_process",
      "module": "test_worker",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_worker.py",
      "line_number": 64,
      "end_line_number": 72,
      "source_code": "def test_init_process(worker: base_worker.GunicornWebWorker) -> None:\n    with mock.patch(\"aiohttp.worker.asyncio\") as m_asyncio:\n        try:\n            worker.init_process()\n        except TypeError:\n            pass\n\n        assert m_asyncio.new_event_loop.called\n        assert m_asyncio.set_event_loop.called",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "worker"
      ],
      "imports": [
        "asyncio",
        "os",
        "socket",
        "ssl",
        "typing.TYPE_CHECKING",
        "typing.Callable",
        "typing.Dict",
        "typing.Optional",
        "unittest.mock",
        "pytest",
        "_pytest.fixtures.SubRequest",
        "aiohttp.web",
        "aiohttp.worker",
        "uvloop"
      ],
      "fixtures": [],
      "assertions": [
        "assert m_asyncio.new_event_loop.called",
        "assert m_asyncio.set_event_loop.called"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.patch('aiohttp.worker.asyncio')"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_run",
      "module": "test_worker",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_worker.py",
      "line_number": 75,
      "end_line_number": 89,
      "source_code": "def test_run(\n    worker: base_worker.GunicornWebWorker, loop: asyncio.AbstractEventLoop\n) -> None:\n    worker.log = mock.Mock()\n    worker.cfg = mock.Mock()\n    worker.cfg.access_log_format = ACCEPTABLE_LOG_FORMAT\n    worker.cfg.is_ssl = False\n    worker.cfg.graceful_timeout = 100\n    worker.sockets = []\n\n    worker.loop = loop\n    with pytest.raises(SystemExit):\n        worker.run()\n    worker.log.exception.assert_not_called()\n    assert loop.is_closed()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "worker",
        "loop"
      ],
      "imports": [
        "asyncio",
        "os",
        "socket",
        "ssl",
        "typing.TYPE_CHECKING",
        "typing.Callable",
        "typing.Dict",
        "typing.Optional",
        "unittest.mock",
        "pytest",
        "_pytest.fixtures.SubRequest",
        "aiohttp.web",
        "aiohttp.worker",
        "uvloop"
      ],
      "fixtures": [],
      "assertions": [
        "assert loop.is_closed()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": [
        {
          "name": "worker.run",
          "body": "def run(conn: Connection) -> None:\n    response = ClientResponse('get', URL('http://def-cl-resp.org'), request_info=mock.Mock(), writer=WriterMock(), continue100=None, timer=TimerNoop(), traces=[], loop=loop, session=session)\n    response._closed = False\n    response._connection = conn"
        }
      ]
    },
    {
      "name": "test_run_async_factory",
      "module": "test_worker",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_worker.py",
      "line_number": 92,
      "end_line_number": 113,
      "source_code": "def test_run_async_factory(\n    worker: base_worker.GunicornWebWorker, loop: asyncio.AbstractEventLoop\n) -> None:\n    worker.log = mock.Mock()\n    worker.cfg = mock.Mock()\n    worker.cfg.access_log_format = ACCEPTABLE_LOG_FORMAT\n    worker.cfg.is_ssl = False\n    worker.cfg.graceful_timeout = 100\n    worker.sockets = []\n    app = worker.wsgi\n\n    async def make_app() -> web.Application:\n        return app  # type: ignore[no-any-return]\n\n    worker.wsgi = make_app\n\n    worker.loop = loop\n    worker.alive = False\n    with pytest.raises(SystemExit):\n        worker.run()\n    worker.log.exception.assert_not_called()\n    assert loop.is_closed()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "worker",
        "loop"
      ],
      "imports": [
        "asyncio",
        "os",
        "socket",
        "ssl",
        "typing.TYPE_CHECKING",
        "typing.Callable",
        "typing.Dict",
        "typing.Optional",
        "unittest.mock",
        "pytest",
        "_pytest.fixtures.SubRequest",
        "aiohttp.web",
        "aiohttp.worker",
        "uvloop"
      ],
      "fixtures": [],
      "assertions": [
        "assert loop.is_closed()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": [
        {
          "name": "worker.run",
          "body": "def run(conn: Connection) -> None:\n    response = ClientResponse('get', URL('http://def-cl-resp.org'), request_info=mock.Mock(), writer=WriterMock(), continue100=None, timer=TimerNoop(), traces=[], loop=loop, session=session)\n    response._closed = False\n    response._connection = conn"
        }
      ]
    },
    {
      "name": "test_run_not_app",
      "module": "test_worker",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_worker.py",
      "line_number": 116,
      "end_line_number": 129,
      "source_code": "def test_run_not_app(\n    worker: base_worker.GunicornWebWorker, loop: asyncio.AbstractEventLoop\n) -> None:\n    worker.log = mock.Mock()\n    worker.cfg = mock.Mock()\n    worker.cfg.access_log_format = ACCEPTABLE_LOG_FORMAT\n\n    worker.loop = loop\n    worker.wsgi = \"not-app\"\n    worker.alive = False\n    with pytest.raises(SystemExit):\n        worker.run()\n    worker.log.exception.assert_called_with(\"Exception in gunicorn worker\")\n    assert loop.is_closed()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "worker",
        "loop"
      ],
      "imports": [
        "asyncio",
        "os",
        "socket",
        "ssl",
        "typing.TYPE_CHECKING",
        "typing.Callable",
        "typing.Dict",
        "typing.Optional",
        "unittest.mock",
        "pytest",
        "_pytest.fixtures.SubRequest",
        "aiohttp.web",
        "aiohttp.worker",
        "uvloop"
      ],
      "fixtures": [],
      "assertions": [
        "assert loop.is_closed()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": [
        {
          "name": "worker.run",
          "body": "def run(conn: Connection) -> None:\n    response = ClientResponse('get', URL('http://def-cl-resp.org'), request_info=mock.Mock(), writer=WriterMock(), continue100=None, timer=TimerNoop(), traces=[], loop=loop, session=session)\n    response._closed = False\n    response._connection = conn"
        }
      ]
    },
    {
      "name": "test_handle_abort",
      "module": "test_worker",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_worker.py",
      "line_number": 132,
      "end_line_number": 137,
      "source_code": "def test_handle_abort(worker: base_worker.GunicornWebWorker) -> None:\n    with mock.patch(\"aiohttp.worker.sys\") as m_sys:\n        worker.handle_abort(0, None)\n        assert not worker.alive\n        assert worker.exit_code == 1\n        m_sys.exit.assert_called_with(1)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "worker"
      ],
      "imports": [
        "asyncio",
        "os",
        "socket",
        "ssl",
        "typing.TYPE_CHECKING",
        "typing.Callable",
        "typing.Dict",
        "typing.Optional",
        "unittest.mock",
        "pytest",
        "_pytest.fixtures.SubRequest",
        "aiohttp.web",
        "aiohttp.worker",
        "uvloop"
      ],
      "fixtures": [],
      "assertions": [
        "assert not worker.alive",
        "assert worker.exit_code == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.patch('aiohttp.worker.sys')"
      ],
      "methods_under_test": []
    },
    {
      "name": "test__wait_next_notify",
      "module": "test_worker",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_worker.py",
      "line_number": 140,
      "end_line_number": 146,
      "source_code": "def test__wait_next_notify(worker: base_worker.GunicornWebWorker) -> None:\n    worker.loop = mloop = mock.create_autospec(asyncio.AbstractEventLoop)\n    with mock.patch.object(worker, \"_notify_waiter_done\", autospec=True):\n        fut = worker._wait_next_notify()\n\n        assert worker._notify_waiter == fut\n        mloop.call_later.assert_called_with(1.0, worker._notify_waiter_done, fut)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "worker"
      ],
      "imports": [
        "asyncio",
        "os",
        "socket",
        "ssl",
        "typing.TYPE_CHECKING",
        "typing.Callable",
        "typing.Dict",
        "typing.Optional",
        "unittest.mock",
        "pytest",
        "_pytest.fixtures.SubRequest",
        "aiohttp.web",
        "aiohttp.worker",
        "uvloop"
      ],
      "fixtures": [],
      "assertions": [
        "assert worker._notify_waiter == fut"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test__notify_waiter_done",
      "module": "test_worker",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_worker.py",
      "line_number": 149,
      "end_line_number": 159,
      "source_code": "def test__notify_waiter_done(worker: base_worker.GunicornWebWorker) -> None:\n    worker._notify_waiter = None\n    worker._notify_waiter_done()\n    assert worker._notify_waiter is None\n\n    waiter = worker._notify_waiter = mock.Mock()\n    worker._notify_waiter.done.return_value = False\n    worker._notify_waiter_done()\n\n    assert worker._notify_waiter is None\n    waiter.set_result.assert_called_with(True)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "worker"
      ],
      "imports": [
        "asyncio",
        "os",
        "socket",
        "ssl",
        "typing.TYPE_CHECKING",
        "typing.Callable",
        "typing.Dict",
        "typing.Optional",
        "unittest.mock",
        "pytest",
        "_pytest.fixtures.SubRequest",
        "aiohttp.web",
        "aiohttp.worker",
        "uvloop"
      ],
      "fixtures": [],
      "assertions": [
        "assert worker._notify_waiter is None",
        "assert worker._notify_waiter is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test__notify_waiter_done_explicit_waiter",
      "module": "test_worker",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_worker.py",
      "line_number": 162,
      "end_line_number": 175,
      "source_code": "def test__notify_waiter_done_explicit_waiter(\n    worker: base_worker.GunicornWebWorker,\n) -> None:\n    worker._notify_waiter = None\n    assert worker._notify_waiter is None\n\n    waiter = worker._notify_waiter = mock.Mock()\n    waiter.done.return_value = False\n    waiter2 = worker._notify_waiter = mock.Mock()\n    worker._notify_waiter_done(waiter)\n\n    assert worker._notify_waiter is waiter2\n    waiter.set_result.assert_called_with(True)\n    assert not waiter2.set_result.called",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "worker"
      ],
      "imports": [
        "asyncio",
        "os",
        "socket",
        "ssl",
        "typing.TYPE_CHECKING",
        "typing.Callable",
        "typing.Dict",
        "typing.Optional",
        "unittest.mock",
        "pytest",
        "_pytest.fixtures.SubRequest",
        "aiohttp.web",
        "aiohttp.worker",
        "uvloop"
      ],
      "fixtures": [],
      "assertions": [
        "assert worker._notify_waiter is None",
        "assert worker._notify_waiter is waiter2",
        "assert not waiter2.set_result.called"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_init_signals",
      "module": "test_worker",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_worker.py",
      "line_number": 178,
      "end_line_number": 181,
      "source_code": "def test_init_signals(worker: base_worker.GunicornWebWorker) -> None:\n    worker.loop = mock.Mock()\n    worker.init_signals()\n    assert worker.loop.add_signal_handler.called",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "worker"
      ],
      "imports": [
        "asyncio",
        "os",
        "socket",
        "ssl",
        "typing.TYPE_CHECKING",
        "typing.Callable",
        "typing.Dict",
        "typing.Optional",
        "unittest.mock",
        "pytest",
        "_pytest.fixtures.SubRequest",
        "aiohttp.web",
        "aiohttp.worker",
        "uvloop"
      ],
      "fixtures": [],
      "assertions": [
        "assert worker.loop.add_signal_handler.called"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test__get_valid_log_format_ok",
      "module": "test_worker",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_worker.py",
      "line_number": 194,
      "end_line_number": 197,
      "source_code": "def test__get_valid_log_format_ok(\n    worker: base_worker.GunicornWebWorker, source: str, result: str\n) -> None:\n    assert result == worker._get_valid_log_format(source)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('source,result', [(ACCEPTABLE_LOG_FORMAT, ACCEPTABLE_LOG_FORMAT), (AsyncioWorker.DEFAULT_GUNICORN_LOG_FORMAT, AsyncioWorker.DEFAULT_AIOHTTP_LOG_FORMAT)])"
      ],
      "arguments": [
        "worker",
        "source",
        "result"
      ],
      "imports": [
        "asyncio",
        "os",
        "socket",
        "ssl",
        "typing.TYPE_CHECKING",
        "typing.Callable",
        "typing.Dict",
        "typing.Optional",
        "unittest.mock",
        "pytest",
        "_pytest.fixtures.SubRequest",
        "aiohttp.web",
        "aiohttp.worker",
        "uvloop"
      ],
      "fixtures": [],
      "assertions": [
        "assert result == worker._get_valid_log_format(source)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test__get_valid_log_format_exc",
      "module": "test_worker",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_worker.py",
      "line_number": 200,
      "end_line_number": 203,
      "source_code": "def test__get_valid_log_format_exc(worker: base_worker.GunicornWebWorker) -> None:\n    with pytest.raises(ValueError) as exc:\n        worker._get_valid_log_format(WRONG_LOG_FORMAT)\n    assert \"%(name)s\" in str(exc.value)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "worker"
      ],
      "imports": [
        "asyncio",
        "os",
        "socket",
        "ssl",
        "typing.TYPE_CHECKING",
        "typing.Callable",
        "typing.Dict",
        "typing.Optional",
        "unittest.mock",
        "pytest",
        "_pytest.fixtures.SubRequest",
        "aiohttp.web",
        "aiohttp.worker",
        "uvloop"
      ],
      "fixtures": [],
      "assertions": [
        "assert '%(name)s' in str(exc.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test__create_ssl_context_without_certs_and_ciphers",
      "module": "test_worker",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_worker.py",
      "line_number": 258,
      "end_line_number": 269,
      "source_code": "def test__create_ssl_context_without_certs_and_ciphers(\n    worker: base_worker.GunicornWebWorker,\n    tls_certificate_pem_path: str,\n) -> None:\n    worker.cfg.ssl_version = ssl.PROTOCOL_TLS_CLIENT\n    worker.cfg.cert_reqs = ssl.CERT_OPTIONAL\n    worker.cfg.certfile = tls_certificate_pem_path\n    worker.cfg.keyfile = tls_certificate_pem_path\n    worker.cfg.ca_certs = None\n    worker.cfg.ciphers = None\n    ctx = worker._create_ssl_context(worker.cfg)\n    assert isinstance(ctx, ssl.SSLContext)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "worker",
        "tls_certificate_pem_path"
      ],
      "imports": [
        "asyncio",
        "os",
        "socket",
        "ssl",
        "typing.TYPE_CHECKING",
        "typing.Callable",
        "typing.Dict",
        "typing.Optional",
        "unittest.mock",
        "pytest",
        "_pytest.fixtures.SubRequest",
        "aiohttp.web",
        "aiohttp.worker",
        "uvloop"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(ctx, ssl.SSLContext)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test__create_ssl_context_with_ciphers",
      "module": "test_worker",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_worker.py",
      "line_number": 272,
      "end_line_number": 283,
      "source_code": "def test__create_ssl_context_with_ciphers(\n    worker: base_worker.GunicornWebWorker,\n    tls_certificate_pem_path: str,\n) -> None:\n    worker.cfg.ssl_version = ssl.PROTOCOL_TLS_CLIENT\n    worker.cfg.cert_reqs = ssl.CERT_OPTIONAL\n    worker.cfg.certfile = tls_certificate_pem_path\n    worker.cfg.keyfile = tls_certificate_pem_path\n    worker.cfg.ca_certs = None\n    worker.cfg.ciphers = \"3DES PSK\"\n    ctx = worker._create_ssl_context(worker.cfg)\n    assert isinstance(ctx, ssl.SSLContext)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "worker",
        "tls_certificate_pem_path"
      ],
      "imports": [
        "asyncio",
        "os",
        "socket",
        "ssl",
        "typing.TYPE_CHECKING",
        "typing.Callable",
        "typing.Dict",
        "typing.Optional",
        "unittest.mock",
        "pytest",
        "_pytest.fixtures.SubRequest",
        "aiohttp.web",
        "aiohttp.worker",
        "uvloop"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(ctx, ssl.SSLContext)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test__create_ssl_context_with_ca_certs",
      "module": "test_worker",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_worker.py",
      "line_number": 286,
      "end_line_number": 298,
      "source_code": "def test__create_ssl_context_with_ca_certs(\n    worker: base_worker.GunicornWebWorker,\n    tls_ca_certificate_pem_path: str,\n    tls_certificate_pem_path: str,\n) -> None:\n    worker.cfg.ssl_version = ssl.PROTOCOL_TLS_CLIENT\n    worker.cfg.cert_reqs = ssl.CERT_OPTIONAL\n    worker.cfg.certfile = tls_certificate_pem_path\n    worker.cfg.keyfile = tls_certificate_pem_path\n    worker.cfg.ca_certs = tls_ca_certificate_pem_path\n    worker.cfg.ciphers = None\n    ctx = worker._create_ssl_context(worker.cfg)\n    assert isinstance(ctx, ssl.SSLContext)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "worker",
        "tls_ca_certificate_pem_path",
        "tls_certificate_pem_path"
      ],
      "imports": [
        "asyncio",
        "os",
        "socket",
        "ssl",
        "typing.TYPE_CHECKING",
        "typing.Callable",
        "typing.Dict",
        "typing.Optional",
        "unittest.mock",
        "pytest",
        "_pytest.fixtures.SubRequest",
        "aiohttp.web",
        "aiohttp.worker",
        "uvloop"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(ctx, ssl.SSLContext)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_using_gzip_if_header_present_and_file_available",
      "module": "test_web_sendfile",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_sendfile.py",
      "line_number": 13,
      "end_line_number": 39,
      "source_code": "def test_using_gzip_if_header_present_and_file_available(\n    loop: asyncio.AbstractEventLoop,\n) -> None:\n    request = make_mocked_request(\n        \"GET\",\n        \"http://python.org/logo.png\",\n        # Header uses some uppercase to ensure case-insensitive treatment\n        headers={hdrs.ACCEPT_ENCODING: \"GZip\"},\n    )\n\n    gz_filepath = mock.create_autospec(Path, spec_set=True)\n    gz_filepath.lstat.return_value.st_size = 1024\n    gz_filepath.lstat.return_value.st_mtime_ns = 1603733507222449291\n    gz_filepath.lstat.return_value.st_mode = MOCK_MODE\n\n    filepath = mock.create_autospec(Path, spec_set=True)\n    filepath.name = \"logo.png\"\n    filepath.with_suffix.return_value = gz_filepath\n\n    file_sender = FileResponse(filepath)\n    file_sender._path = filepath\n    file_sender._sendfile = make_mocked_coro(None)  # type: ignore[method-assign]\n\n    loop.run_until_complete(file_sender.prepare(request))\n\n    assert not filepath.open.called\n    assert gz_filepath.open.called",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop"
      ],
      "imports": [
        "asyncio",
        "pathlib.Path",
        "stat.S_IFREG",
        "stat.S_IRUSR",
        "stat.S_IWUSR",
        "unittest.mock",
        "aiohttp.hdrs",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_fileresponse.FileResponse"
      ],
      "fixtures": [],
      "assertions": [
        "assert not filepath.open.called",
        "assert gz_filepath.open.called"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "file_sender.prepare",
          "body": "def prepare(data: bytes) -> bytes:\n    return data"
        }
      ]
    },
    {
      "name": "test_gzip_if_header_not_present_and_file_available",
      "module": "test_web_sendfile",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_sendfile.py",
      "line_number": 42,
      "end_line_number": 66,
      "source_code": "def test_gzip_if_header_not_present_and_file_available(\n    loop: asyncio.AbstractEventLoop,\n) -> None:\n    request = make_mocked_request(\"GET\", \"http://python.org/logo.png\", headers={})\n\n    gz_filepath = mock.create_autospec(Path, spec_set=True)\n    gz_filepath.lstat.return_value.st_size = 1024\n    gz_filepath.lstat.return_value.st_mtime_ns = 1603733507222449291\n    gz_filepath.lstat.return_value.st_mode = MOCK_MODE\n\n    filepath = mock.create_autospec(Path, spec_set=True)\n    filepath.name = \"logo.png\"\n    filepath.with_suffix.return_value = gz_filepath\n    filepath.stat.return_value.st_size = 1024\n    filepath.stat.return_value.st_mtime_ns = 1603733507222449291\n    filepath.stat.return_value.st_mode = MOCK_MODE\n\n    file_sender = FileResponse(filepath)\n    file_sender._path = filepath\n    file_sender._sendfile = make_mocked_coro(None)  # type: ignore[method-assign]\n\n    loop.run_until_complete(file_sender.prepare(request))\n\n    assert filepath.open.called\n    assert not gz_filepath.open.called",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop"
      ],
      "imports": [
        "asyncio",
        "pathlib.Path",
        "stat.S_IFREG",
        "stat.S_IRUSR",
        "stat.S_IWUSR",
        "unittest.mock",
        "aiohttp.hdrs",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_fileresponse.FileResponse"
      ],
      "fixtures": [],
      "assertions": [
        "assert filepath.open.called",
        "assert not gz_filepath.open.called"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "file_sender.prepare",
          "body": "def prepare(data: bytes) -> bytes:\n    return data"
        }
      ]
    },
    {
      "name": "test_gzip_if_header_not_present_and_file_not_available",
      "module": "test_web_sendfile",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_sendfile.py",
      "line_number": 69,
      "end_line_number": 91,
      "source_code": "def test_gzip_if_header_not_present_and_file_not_available(\n    loop: asyncio.AbstractEventLoop,\n) -> None:\n    request = make_mocked_request(\"GET\", \"http://python.org/logo.png\", headers={})\n\n    gz_filepath = mock.create_autospec(Path, spec_set=True)\n    gz_filepath.stat.side_effect = OSError(2, \"No such file or directory\")\n\n    filepath = mock.create_autospec(Path, spec_set=True)\n    filepath.name = \"logo.png\"\n    filepath.with_suffix.return_value = gz_filepath\n    filepath.stat.return_value.st_size = 1024\n    filepath.stat.return_value.st_mtime_ns = 1603733507222449291\n    filepath.stat.return_value.st_mode = MOCK_MODE\n\n    file_sender = FileResponse(filepath)\n    file_sender._path = filepath\n    file_sender._sendfile = make_mocked_coro(None)  # type: ignore[method-assign]\n\n    loop.run_until_complete(file_sender.prepare(request))\n\n    assert filepath.open.called\n    assert not gz_filepath.open.called",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop"
      ],
      "imports": [
        "asyncio",
        "pathlib.Path",
        "stat.S_IFREG",
        "stat.S_IRUSR",
        "stat.S_IWUSR",
        "unittest.mock",
        "aiohttp.hdrs",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_fileresponse.FileResponse"
      ],
      "fixtures": [],
      "assertions": [
        "assert filepath.open.called",
        "assert not gz_filepath.open.called"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "file_sender.prepare",
          "body": "def prepare(data: bytes) -> bytes:\n    return data"
        }
      ]
    },
    {
      "name": "test_gzip_if_header_present_and_file_not_available",
      "module": "test_web_sendfile",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_sendfile.py",
      "line_number": 94,
      "end_line_number": 118,
      "source_code": "def test_gzip_if_header_present_and_file_not_available(\n    loop: asyncio.AbstractEventLoop,\n) -> None:\n    request = make_mocked_request(\n        \"GET\", \"http://python.org/logo.png\", headers={hdrs.ACCEPT_ENCODING: \"gzip\"}\n    )\n\n    gz_filepath = mock.create_autospec(Path, spec_set=True)\n    gz_filepath.lstat.side_effect = OSError(2, \"No such file or directory\")\n\n    filepath = mock.create_autospec(Path, spec_set=True)\n    filepath.name = \"logo.png\"\n    filepath.with_suffix.return_value = gz_filepath\n    filepath.stat.return_value.st_size = 1024\n    filepath.stat.return_value.st_mtime_ns = 1603733507222449291\n    filepath.stat.return_value.st_mode = MOCK_MODE\n\n    file_sender = FileResponse(filepath)\n    file_sender._path = filepath\n    file_sender._sendfile = make_mocked_coro(None)  # type: ignore[method-assign]\n\n    loop.run_until_complete(file_sender.prepare(request))\n\n    assert filepath.open.called\n    assert not gz_filepath.open.called",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop"
      ],
      "imports": [
        "asyncio",
        "pathlib.Path",
        "stat.S_IFREG",
        "stat.S_IRUSR",
        "stat.S_IWUSR",
        "unittest.mock",
        "aiohttp.hdrs",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_fileresponse.FileResponse"
      ],
      "fixtures": [],
      "assertions": [
        "assert filepath.open.called",
        "assert not gz_filepath.open.called"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "file_sender.prepare",
          "body": "def prepare(data: bytes) -> bytes:\n    return data"
        }
      ]
    },
    {
      "name": "test_status_controlled_by_user",
      "module": "test_web_sendfile",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_sendfile.py",
      "line_number": 121,
      "end_line_number": 136,
      "source_code": "def test_status_controlled_by_user(loop: asyncio.AbstractEventLoop) -> None:\n    request = make_mocked_request(\"GET\", \"http://python.org/logo.png\", headers={})\n\n    filepath = mock.create_autospec(Path, spec_set=True)\n    filepath.name = \"logo.png\"\n    filepath.stat.return_value.st_size = 1024\n    filepath.stat.return_value.st_mtime_ns = 1603733507222449291\n    filepath.stat.return_value.st_mode = MOCK_MODE\n\n    file_sender = FileResponse(filepath, status=203)\n    file_sender._path = filepath\n    file_sender._sendfile = make_mocked_coro(None)  # type: ignore[method-assign]\n\n    loop.run_until_complete(file_sender.prepare(request))\n\n    assert file_sender._status == 203",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop"
      ],
      "imports": [
        "asyncio",
        "pathlib.Path",
        "stat.S_IFREG",
        "stat.S_IRUSR",
        "stat.S_IWUSR",
        "unittest.mock",
        "aiohttp.hdrs",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.web_fileresponse.FileResponse"
      ],
      "fixtures": [],
      "assertions": [
        "assert file_sender._status == 203"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "file_sender.prepare",
          "body": "def prepare(data: bytes) -> bytes:\n    return data"
        }
      ]
    },
    {
      "name": "test_feed_data_remembers_exception",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 107,
      "end_line_number": 115,
      "source_code": "def test_feed_data_remembers_exception(parser: WebSocketReader) -> None:\n    \"\"\"Verify that feed_data remembers an exception was already raised internally.\"\"\"\n    error, data = parser.feed_data(struct.pack(\"!BB\", 0b01100000, 0b00000000))\n    assert error is True\n    assert data == b\"\"\n\n    error, data = parser.feed_data(b\"\")\n    assert error is True\n    assert data == b\"\"",
      "docstring": "Verify that feed_data remembers an exception was already raised internally.",
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert error is True",
        "assert data == b''",
        "assert error is True",
        "assert data == b''"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_parse_frame",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 118,
      "end_line_number": 123,
      "source_code": "def test_parse_frame(parser: WebSocketReader) -> None:\n    parser.parse_frame(struct.pack(\"!BB\", 0b00000001, 0b00000001))\n    res = parser.parse_frame(b\"1\")\n    fin, opcode, payload, compress = res[0]\n\n    assert (0, 1, b\"1\", False) == (fin, opcode, payload, not not compress)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert (0, 1, b'1', False) == (fin, opcode, payload, not not compress)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_parse_frame_length0",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 126,
      "end_line_number": 131,
      "source_code": "def test_parse_frame_length0(parser: WebSocketReader) -> None:\n    fin, opcode, payload, compress = parser.parse_frame(\n        struct.pack(\"!BB\", 0b00000001, 0b00000000)\n    )[0]\n\n    assert (0, 1, b\"\", False) == (fin, opcode, payload, not not compress)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert (0, 1, b'', False) == (fin, opcode, payload, not not compress)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_parse_frame_length2",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 134,
      "end_line_number": 140,
      "source_code": "def test_parse_frame_length2(parser: WebSocketReader) -> None:\n    parser.parse_frame(struct.pack(\"!BB\", 0b00000001, 126))\n    parser.parse_frame(struct.pack(\"!H\", 4))\n    res = parser.parse_frame(b\"1234\")\n    fin, opcode, payload, compress = res[0]\n\n    assert (0, 1, b\"1234\", False) == (fin, opcode, payload, not not compress)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert (0, 1, b'1234', False) == (fin, opcode, payload, not not compress)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_parse_frame_length2_multi_byte",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 143,
      "end_line_number": 151,
      "source_code": "def test_parse_frame_length2_multi_byte(parser: WebSocketReader) -> None:\n    \"\"\"Ensure a multi-byte length is parsed correctly.\"\"\"\n    expected_payload = b\"1\" * 32768\n    parser.parse_frame(struct.pack(\"!BB\", 0b00000001, 126))\n    parser.parse_frame(struct.pack(\"!H\", 32768))\n    res = parser.parse_frame(b\"1\" * 32768)\n    fin, opcode, payload, compress = res[0]\n\n    assert (0, 1, expected_payload, False) == (fin, opcode, payload, not not compress)",
      "docstring": "Ensure a multi-byte length is parsed correctly.",
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert (0, 1, expected_payload, False) == (fin, opcode, payload, not not compress)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_parse_frame_length4",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 154,
      "end_line_number": 159,
      "source_code": "def test_parse_frame_length4(parser: WebSocketReader) -> None:\n    parser.parse_frame(struct.pack(\"!BB\", 0b00000001, 127))\n    parser.parse_frame(struct.pack(\"!Q\", 4))\n    fin, opcode, payload, compress = parser.parse_frame(b\"1234\")[0]\n\n    assert (0, 1, b\"1234\", False) == (fin, opcode, payload, not not compress)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert (0, 1, b'1234', False) == (fin, opcode, payload, not not compress)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_parse_frame_mask",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 162,
      "end_line_number": 167,
      "source_code": "def test_parse_frame_mask(parser: WebSocketReader) -> None:\n    parser.parse_frame(struct.pack(\"!BB\", 0b00000001, 0b10000001))\n    parser.parse_frame(b\"0001\")\n    fin, opcode, payload, compress = parser.parse_frame(b\"1\")[0]\n\n    assert (0, 1, b\"\\x01\", False) == (fin, opcode, payload, not not compress)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert (0, 1, b'\\x01', False) == (fin, opcode, payload, not not compress)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_parse_frame_header_reversed_bits",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 170,
      "end_line_number": 174,
      "source_code": "def test_parse_frame_header_reversed_bits(\n    out: aiohttp.DataQueue[WSMessage], parser: WebSocketReader\n) -> None:\n    with pytest.raises(WebSocketError):\n        parser.parse_frame(struct.pack(\"!BB\", 0b01100000, 0b00000000))",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "out",
        "parser"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_parse_frame_header_control_frame",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 177,
      "end_line_number": 181,
      "source_code": "def test_parse_frame_header_control_frame(\n    out: aiohttp.DataQueue[WSMessage], parser: WebSocketReader\n) -> None:\n    with pytest.raises(WebSocketError):\n        parser.parse_frame(struct.pack(\"!BB\", 0b00001000, 0b00000000))",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "out",
        "parser"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_parse_frame_header_new_data_err",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 185,
      "end_line_number": 189,
      "source_code": "def test_parse_frame_header_new_data_err(\n    out: aiohttp.DataQueue[WSMessage], parser: WebSocketReader\n) -> None:\n    with pytest.raises(WebSocketError):\n        parser.parse_frame(struct.pack(\"!BB\", 0b000000000, 0b00000000))",
      "docstring": null,
      "decorators": [
        "pytest.mark.xfail()"
      ],
      "arguments": [
        "out",
        "parser"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_parse_frame_header_payload_size",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 192,
      "end_line_number": 196,
      "source_code": "def test_parse_frame_header_payload_size(\n    out: aiohttp.DataQueue[WSMessage], parser: WebSocketReader\n) -> None:\n    with pytest.raises(WebSocketError):\n        parser.parse_frame(struct.pack(\"!BB\", 0b10001000, 0b01111110))",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "out",
        "parser"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ping_frame",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 206,
      "end_line_number": 216,
      "source_code": "def test_ping_frame(\n    out: aiohttp.DataQueue[WSMessage],\n    parser: WebSocketReader,\n    data: Union[bytes, bytearray, memoryview],\n) -> None:\n    with mock.patch.object(parser, \"parse_frame\", autospec=True) as m:\n        m.return_value = [(1, WSMsgType.PING, b\"data\", False)]\n\n        parser.feed_data(data)\n        res = out._buffer[0]\n        assert res == WSMessagePing(data=b\"data\", extra=\"\")",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize(argnames='data', argvalues=[b'', bytearray(b''), memoryview(b'')], ids=['bytes', 'bytearray', 'memoryview'])"
      ],
      "arguments": [
        "out",
        "parser",
        "data"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert res == WSMessagePing(data=b'data', extra='')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_pong_frame",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 219,
      "end_line_number": 225,
      "source_code": "def test_pong_frame(out: aiohttp.DataQueue[WSMessage], parser: WebSocketReader) -> None:\n    with mock.patch.object(parser, \"parse_frame\", autospec=True) as m:\n        m.return_value = [(1, WSMsgType.PONG, b\"data\", False)]\n\n        parser.feed_data(b\"\")\n        res = out._buffer[0]\n        assert res == WSMessagePong(data=b\"data\", extra=\"\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "out",
        "parser"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert res == WSMessagePong(data=b'data', extra='')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_close_frame",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 228,
      "end_line_number": 236,
      "source_code": "def test_close_frame(\n    out: aiohttp.DataQueue[WSMessage], parser: WebSocketReader\n) -> None:\n    with mock.patch.object(parser, \"parse_frame\", autospec=True) as m:\n        m.return_value = [(1, WSMsgType.CLOSE, b\"\", False)]\n\n        parser.feed_data(b\"\")\n        res = out._buffer[0]\n        assert res == WSMessageClose(data=0, extra=\"\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "out",
        "parser"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert res == WSMessageClose(data=0, extra='')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_close_frame_info",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 239,
      "end_line_number": 247,
      "source_code": "def test_close_frame_info(\n    out: aiohttp.DataQueue[WSMessage], parser: WebSocketReader\n) -> None:\n    with mock.patch.object(parser, \"parse_frame\", autospec=True) as m:\n        m.return_value = [(1, WSMsgType.CLOSE, b\"0112345\", False)]\n\n        parser.feed_data(b\"\")\n        res = out._buffer[0]\n        assert res == WSMessageClose(data=12337, extra=\"12345\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "out",
        "parser"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert res == WSMessageClose(data=12337, extra='12345')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_close_frame_invalid",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 250,
      "end_line_number": 259,
      "source_code": "def test_close_frame_invalid(\n    out: aiohttp.DataQueue[WSMessage], parser: WebSocketReader\n) -> None:\n    with mock.patch.object(parser, \"parse_frame\", autospec=True) as m:\n        m.return_value = [(1, WSMsgType.CLOSE, b\"1\", False)]\n        parser.feed_data(b\"\")\n\n        exc = out.exception()\n        assert isinstance(exc, WebSocketError)\n        assert exc.code == WSCloseCode.PROTOCOL_ERROR",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "out",
        "parser"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(exc, WebSocketError)",
        "assert exc.code == WSCloseCode.PROTOCOL_ERROR"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_close_frame_invalid_2",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 262,
      "end_line_number": 270,
      "source_code": "def test_close_frame_invalid_2(\n    out: aiohttp.DataQueue[WSMessage], parser: WebSocketReader\n) -> None:\n    data = build_close_frame(code=1)\n\n    with pytest.raises(WebSocketError) as ctx:\n        parser._feed_data(data)\n\n    assert ctx.value.code == WSCloseCode.PROTOCOL_ERROR",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "out",
        "parser"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert ctx.value.code == WSCloseCode.PROTOCOL_ERROR"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "build_close_frame",
          "body": "def build_close_frame(code: int=1000, message: bytes=b'', noheader: bool=False) -> bytes:\n    return build_frame(PACK_CLOSE_CODE(code) + message, opcode=WSMsgType.CLOSE, noheader=noheader)"
        }
      ]
    },
    {
      "name": "test_close_frame_unicode_err",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 273,
      "end_line_number": 279,
      "source_code": "def test_close_frame_unicode_err(parser: WebSocketReader) -> None:\n    data = build_close_frame(code=1000, message=b\"\\xf4\\x90\\x80\\x80\")\n\n    with pytest.raises(WebSocketError) as ctx:\n        parser._feed_data(data)\n\n    assert ctx.value.code == WSCloseCode.INVALID_TEXT",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert ctx.value.code == WSCloseCode.INVALID_TEXT"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "build_close_frame",
          "body": "def build_close_frame(code: int=1000, message: bytes=b'', noheader: bool=False) -> bytes:\n    return build_frame(PACK_CLOSE_CODE(code) + message, opcode=WSMsgType.CLOSE, noheader=noheader)"
        }
      ]
    },
    {
      "name": "test_unknown_frame",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 282,
      "end_line_number": 289,
      "source_code": "def test_unknown_frame(\n    out: aiohttp.DataQueue[WSMessage], parser: WebSocketReader\n) -> None:\n    with mock.patch.object(parser, \"parse_frame\", autospec=True) as m:\n        m.return_value = [(1, WSMsgType.CONTINUATION, b\"\", False)]\n\n        parser.feed_data(b\"\")\n        assert isinstance(out.exception(), WebSocketError)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "out",
        "parser"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(out.exception(), WebSocketError)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_simple_text",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 292,
      "end_line_number": 298,
      "source_code": "def test_simple_text(\n    out: aiohttp.DataQueue[WSMessage], parser: WebSocketReader\n) -> None:\n    data = build_frame(b\"text\", WSMsgType.TEXT)\n    parser._feed_data(data)\n    res = out._buffer[0]\n    assert res == WSMessageText(data=\"text\", extra=\"\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "out",
        "parser"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert res == WSMessageText(data='text', extra='')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "build_frame",
          "body": "def build_frame(message: bytes, opcode: int, use_mask: bool=False, noheader: bool=False, is_fin: bool=True, compress: bool=False) -> bytes:\n    if compress:\n        compressobj = zlib.compressobj(wbits=-9)\n        message = compressobj.compress(message)\n        message = message + compressobj.flush(zlib.Z_SYNC_FLUSH)\n        if message.endswith(WS_DEFLATE_TRAILING):\n            message = message[:-4]\n    msg_length = len(message)\n    if use_mask:\n        mask_bit = 128\n    else:\n        mask_bit = 0\n    if is_fin:\n        header_first_byte = 128 | opcode\n    else:\n        header_first_byte = opcode\n    if compress:\n        header_first_byte |= 64\n    if msg_length < 126:\n        header = PACK_LEN1(header_first_byte, msg_length | mask_bit)\n    elif msg_length < 1 << 16:\n        header = PACK_LEN2(header_first_byte, 126 | mask_bit, msg_length)\n    else:\n        header = PACK_LEN3(header_first_byte, 127 | mask_bit, msg_length)\n    if use_mask:\n        maski = random.randrange(0, 4294967295)\n        mask = maski.to_bytes(4, 'big')\n        message = bytearray(message)\n        websocket_mask(mask, message)\n        if noheader:\n            return message\n        else:\n            return header + mask + message\n    elif noheader:\n        return message\n    else:\n        return header + message"
        }
      ]
    },
    {
      "name": "test_simple_text_unicode_err",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 301,
      "end_line_number": 307,
      "source_code": "def test_simple_text_unicode_err(parser: WebSocketReader) -> None:\n    data = build_frame(b\"\\xf4\\x90\\x80\\x80\", WSMsgType.TEXT)\n\n    with pytest.raises(WebSocketError) as ctx:\n        parser._feed_data(data)\n\n    assert ctx.value.code == WSCloseCode.INVALID_TEXT",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert ctx.value.code == WSCloseCode.INVALID_TEXT"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "build_frame",
          "body": "def build_frame(message: bytes, opcode: int, use_mask: bool=False, noheader: bool=False, is_fin: bool=True, compress: bool=False) -> bytes:\n    if compress:\n        compressobj = zlib.compressobj(wbits=-9)\n        message = compressobj.compress(message)\n        message = message + compressobj.flush(zlib.Z_SYNC_FLUSH)\n        if message.endswith(WS_DEFLATE_TRAILING):\n            message = message[:-4]\n    msg_length = len(message)\n    if use_mask:\n        mask_bit = 128\n    else:\n        mask_bit = 0\n    if is_fin:\n        header_first_byte = 128 | opcode\n    else:\n        header_first_byte = opcode\n    if compress:\n        header_first_byte |= 64\n    if msg_length < 126:\n        header = PACK_LEN1(header_first_byte, msg_length | mask_bit)\n    elif msg_length < 1 << 16:\n        header = PACK_LEN2(header_first_byte, 126 | mask_bit, msg_length)\n    else:\n        header = PACK_LEN3(header_first_byte, 127 | mask_bit, msg_length)\n    if use_mask:\n        maski = random.randrange(0, 4294967295)\n        mask = maski.to_bytes(4, 'big')\n        message = bytearray(message)\n        websocket_mask(mask, message)\n        if noheader:\n            return message\n        else:\n            return header + mask + message\n    elif noheader:\n        return message\n    else:\n        return header + message"
        }
      ]
    },
    {
      "name": "test_simple_binary",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 310,
      "end_line_number": 318,
      "source_code": "def test_simple_binary(\n    out: aiohttp.DataQueue[WSMessage], parser: WebSocketReader\n) -> None:\n    with mock.patch.object(parser, \"parse_frame\", autospec=True) as m:\n        m.return_value = [(1, WSMsgType.BINARY, b\"binary\", False)]\n\n        parser.feed_data(b\"\")\n        res = out._buffer[0]\n        assert res == WSMessageBinary(data=b\"binary\", extra=\"\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "out",
        "parser"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert res == WSMessageBinary(data=b'binary', extra='')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_fragmentation_header",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 321,
      "end_line_number": 329,
      "source_code": "def test_fragmentation_header(\n    out: aiohttp.DataQueue[WSMessage], parser: WebSocketReader\n) -> None:\n    data = build_frame(b\"a\", WSMsgType.TEXT)\n    parser._feed_data(data[:1])\n    parser._feed_data(data[1:])\n\n    res = out._buffer[0]\n    assert res == WSMessageText(data=\"a\", extra=\"\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "out",
        "parser"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert res == WSMessageText(data='a', extra='')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "build_frame",
          "body": "def build_frame(message: bytes, opcode: int, use_mask: bool=False, noheader: bool=False, is_fin: bool=True, compress: bool=False) -> bytes:\n    if compress:\n        compressobj = zlib.compressobj(wbits=-9)\n        message = compressobj.compress(message)\n        message = message + compressobj.flush(zlib.Z_SYNC_FLUSH)\n        if message.endswith(WS_DEFLATE_TRAILING):\n            message = message[:-4]\n    msg_length = len(message)\n    if use_mask:\n        mask_bit = 128\n    else:\n        mask_bit = 0\n    if is_fin:\n        header_first_byte = 128 | opcode\n    else:\n        header_first_byte = opcode\n    if compress:\n        header_first_byte |= 64\n    if msg_length < 126:\n        header = PACK_LEN1(header_first_byte, msg_length | mask_bit)\n    elif msg_length < 1 << 16:\n        header = PACK_LEN2(header_first_byte, 126 | mask_bit, msg_length)\n    else:\n        header = PACK_LEN3(header_first_byte, 127 | mask_bit, msg_length)\n    if use_mask:\n        maski = random.randrange(0, 4294967295)\n        mask = maski.to_bytes(4, 'big')\n        message = bytearray(message)\n        websocket_mask(mask, message)\n        if noheader:\n            return message\n        else:\n            return header + mask + message\n    elif noheader:\n        return message\n    else:\n        return header + message"
        }
      ]
    },
    {
      "name": "test_continuation",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 332,
      "end_line_number": 342,
      "source_code": "def test_continuation(\n    out: aiohttp.DataQueue[WSMessage], parser: WebSocketReader\n) -> None:\n    data1 = build_frame(b\"line1\", WSMsgType.TEXT, is_fin=False)\n    parser._feed_data(data1)\n\n    data2 = build_frame(b\"line2\", WSMsgType.CONTINUATION)\n    parser._feed_data(data2)\n\n    res = out._buffer[0]\n    assert res == WSMessageText(data=\"line1line2\", extra=\"\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "out",
        "parser"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert res == WSMessageText(data='line1line2', extra='')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "build_frame",
          "body": "def build_frame(message: bytes, opcode: int, use_mask: bool=False, noheader: bool=False, is_fin: bool=True, compress: bool=False) -> bytes:\n    if compress:\n        compressobj = zlib.compressobj(wbits=-9)\n        message = compressobj.compress(message)\n        message = message + compressobj.flush(zlib.Z_SYNC_FLUSH)\n        if message.endswith(WS_DEFLATE_TRAILING):\n            message = message[:-4]\n    msg_length = len(message)\n    if use_mask:\n        mask_bit = 128\n    else:\n        mask_bit = 0\n    if is_fin:\n        header_first_byte = 128 | opcode\n    else:\n        header_first_byte = opcode\n    if compress:\n        header_first_byte |= 64\n    if msg_length < 126:\n        header = PACK_LEN1(header_first_byte, msg_length | mask_bit)\n    elif msg_length < 1 << 16:\n        header = PACK_LEN2(header_first_byte, 126 | mask_bit, msg_length)\n    else:\n        header = PACK_LEN3(header_first_byte, 127 | mask_bit, msg_length)\n    if use_mask:\n        maski = random.randrange(0, 4294967295)\n        mask = maski.to_bytes(4, 'big')\n        message = bytearray(message)\n        websocket_mask(mask, message)\n        if noheader:\n            return message\n        else:\n            return header + mask + message\n    elif noheader:\n        return message\n    else:\n        return header + message"
        },
        {
          "name": "build_frame",
          "body": "def build_frame(message: bytes, opcode: int, use_mask: bool=False, noheader: bool=False, is_fin: bool=True, compress: bool=False) -> bytes:\n    if compress:\n        compressobj = zlib.compressobj(wbits=-9)\n        message = compressobj.compress(message)\n        message = message + compressobj.flush(zlib.Z_SYNC_FLUSH)\n        if message.endswith(WS_DEFLATE_TRAILING):\n            message = message[:-4]\n    msg_length = len(message)\n    if use_mask:\n        mask_bit = 128\n    else:\n        mask_bit = 0\n    if is_fin:\n        header_first_byte = 128 | opcode\n    else:\n        header_first_byte = opcode\n    if compress:\n        header_first_byte |= 64\n    if msg_length < 126:\n        header = PACK_LEN1(header_first_byte, msg_length | mask_bit)\n    elif msg_length < 1 << 16:\n        header = PACK_LEN2(header_first_byte, 126 | mask_bit, msg_length)\n    else:\n        header = PACK_LEN3(header_first_byte, 127 | mask_bit, msg_length)\n    if use_mask:\n        maski = random.randrange(0, 4294967295)\n        mask = maski.to_bytes(4, 'big')\n        message = bytearray(message)\n        websocket_mask(mask, message)\n        if noheader:\n            return message\n        else:\n            return header + mask + message\n    elif noheader:\n        return message\n    else:\n        return header + message"
        }
      ]
    },
    {
      "name": "test_continuation_with_ping",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 345,
      "end_line_number": 367,
      "source_code": "def test_continuation_with_ping(\n    out: aiohttp.DataQueue[WSMessage], parser: WebSocketReader\n) -> None:\n    with mock.patch.object(parser, \"parse_frame\", autospec=True) as m:\n        m.return_value = [\n            (0, WSMsgType.TEXT, b\"line1\", False),\n            (0, WSMsgType.PING, b\"\", False),\n            (1, WSMsgType.CONTINUATION, b\"line2\", False),\n        ]\n\n        data1 = build_frame(b\"line1\", WSMsgType.TEXT, is_fin=False)\n        parser._feed_data(data1)\n\n        data2 = build_frame(b\"\", WSMsgType.PING)\n        parser._feed_data(data2)\n\n        data3 = build_frame(b\"line2\", WSMsgType.CONTINUATION)\n        parser._feed_data(data3)\n\n        res = out._buffer[0]\n        assert res == WSMessagePing(data=b\"\", extra=\"\")\n        res = out._buffer[1]\n        assert res == WSMessageText(data=\"line1line2\", extra=\"\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "out",
        "parser"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert res == WSMessagePing(data=b'', extra='')",
        "assert res == WSMessageText(data='line1line2', extra='')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "build_frame",
          "body": "def build_frame(message: bytes, opcode: int, use_mask: bool=False, noheader: bool=False, is_fin: bool=True, compress: bool=False) -> bytes:\n    if compress:\n        compressobj = zlib.compressobj(wbits=-9)\n        message = compressobj.compress(message)\n        message = message + compressobj.flush(zlib.Z_SYNC_FLUSH)\n        if message.endswith(WS_DEFLATE_TRAILING):\n            message = message[:-4]\n    msg_length = len(message)\n    if use_mask:\n        mask_bit = 128\n    else:\n        mask_bit = 0\n    if is_fin:\n        header_first_byte = 128 | opcode\n    else:\n        header_first_byte = opcode\n    if compress:\n        header_first_byte |= 64\n    if msg_length < 126:\n        header = PACK_LEN1(header_first_byte, msg_length | mask_bit)\n    elif msg_length < 1 << 16:\n        header = PACK_LEN2(header_first_byte, 126 | mask_bit, msg_length)\n    else:\n        header = PACK_LEN3(header_first_byte, 127 | mask_bit, msg_length)\n    if use_mask:\n        maski = random.randrange(0, 4294967295)\n        mask = maski.to_bytes(4, 'big')\n        message = bytearray(message)\n        websocket_mask(mask, message)\n        if noheader:\n            return message\n        else:\n            return header + mask + message\n    elif noheader:\n        return message\n    else:\n        return header + message"
        },
        {
          "name": "build_frame",
          "body": "def build_frame(message: bytes, opcode: int, use_mask: bool=False, noheader: bool=False, is_fin: bool=True, compress: bool=False) -> bytes:\n    if compress:\n        compressobj = zlib.compressobj(wbits=-9)\n        message = compressobj.compress(message)\n        message = message + compressobj.flush(zlib.Z_SYNC_FLUSH)\n        if message.endswith(WS_DEFLATE_TRAILING):\n            message = message[:-4]\n    msg_length = len(message)\n    if use_mask:\n        mask_bit = 128\n    else:\n        mask_bit = 0\n    if is_fin:\n        header_first_byte = 128 | opcode\n    else:\n        header_first_byte = opcode\n    if compress:\n        header_first_byte |= 64\n    if msg_length < 126:\n        header = PACK_LEN1(header_first_byte, msg_length | mask_bit)\n    elif msg_length < 1 << 16:\n        header = PACK_LEN2(header_first_byte, 126 | mask_bit, msg_length)\n    else:\n        header = PACK_LEN3(header_first_byte, 127 | mask_bit, msg_length)\n    if use_mask:\n        maski = random.randrange(0, 4294967295)\n        mask = maski.to_bytes(4, 'big')\n        message = bytearray(message)\n        websocket_mask(mask, message)\n        if noheader:\n            return message\n        else:\n            return header + mask + message\n    elif noheader:\n        return message\n    else:\n        return header + message"
        },
        {
          "name": "build_frame",
          "body": "def build_frame(message: bytes, opcode: int, use_mask: bool=False, noheader: bool=False, is_fin: bool=True, compress: bool=False) -> bytes:\n    if compress:\n        compressobj = zlib.compressobj(wbits=-9)\n        message = compressobj.compress(message)\n        message = message + compressobj.flush(zlib.Z_SYNC_FLUSH)\n        if message.endswith(WS_DEFLATE_TRAILING):\n            message = message[:-4]\n    msg_length = len(message)\n    if use_mask:\n        mask_bit = 128\n    else:\n        mask_bit = 0\n    if is_fin:\n        header_first_byte = 128 | opcode\n    else:\n        header_first_byte = opcode\n    if compress:\n        header_first_byte |= 64\n    if msg_length < 126:\n        header = PACK_LEN1(header_first_byte, msg_length | mask_bit)\n    elif msg_length < 1 << 16:\n        header = PACK_LEN2(header_first_byte, 126 | mask_bit, msg_length)\n    else:\n        header = PACK_LEN3(header_first_byte, 127 | mask_bit, msg_length)\n    if use_mask:\n        maski = random.randrange(0, 4294967295)\n        mask = maski.to_bytes(4, 'big')\n        message = bytearray(message)\n        websocket_mask(mask, message)\n        if noheader:\n            return message\n        else:\n            return header + mask + message\n    elif noheader:\n        return message\n    else:\n        return header + message"
        }
      ]
    },
    {
      "name": "test_continuation_err",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 370,
      "end_line_number": 380,
      "source_code": "def test_continuation_err(\n    out: aiohttp.DataQueue[WSMessage], parser: WebSocketReader\n) -> None:\n    with mock.patch.object(parser, \"parse_frame\", autospec=True) as m:\n        m.return_value = [\n            (0, WSMsgType.TEXT, b\"line1\", False),\n            (1, WSMsgType.TEXT, b\"line2\", False),\n        ]\n\n        with pytest.raises(WebSocketError):\n            parser._feed_data(b\"\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "out",
        "parser"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_continuation_with_close",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 383,
      "end_line_number": 402,
      "source_code": "def test_continuation_with_close(\n    out: aiohttp.DataQueue[WSMessage], parser: WebSocketReader\n) -> None:\n    with mock.patch.object(parser, \"parse_frame\", autospec=True) as m:\n        m.return_value = [\n            (0, WSMsgType.TEXT, b\"line1\", False),\n            (\n                0,\n                WSMsgType.CLOSE,\n                build_close_frame(1002, b\"test\", noheader=True),\n                False,\n            ),\n            (1, WSMsgType.CONTINUATION, b\"line2\", False),\n        ]\n\n        parser.feed_data(b\"\")\n        res = out._buffer[0]\n        assert res == WSMessageClose(data=1002, extra=\"test\")\n        res = out._buffer[1]\n        assert res == WSMessageText(data=\"line1line2\", extra=\"\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "out",
        "parser"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert res == WSMessageClose(data=1002, extra='test')",
        "assert res == WSMessageText(data='line1line2', extra='')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "build_close_frame",
          "body": "def build_close_frame(code: int=1000, message: bytes=b'', noheader: bool=False) -> bytes:\n    return build_frame(PACK_CLOSE_CODE(code) + message, opcode=WSMsgType.CLOSE, noheader=noheader)"
        }
      ]
    },
    {
      "name": "test_continuation_with_close_unicode_err",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 405,
      "end_line_number": 423,
      "source_code": "def test_continuation_with_close_unicode_err(\n    out: aiohttp.DataQueue[WSMessage], parser: WebSocketReader\n) -> None:\n    with mock.patch.object(parser, \"parse_frame\", autospec=True) as m:\n        m.return_value = [\n            (0, WSMsgType.TEXT, b\"line1\", False),\n            (\n                0,\n                WSMsgType.CLOSE,\n                build_close_frame(1000, b\"\\xf4\\x90\\x80\\x80\", noheader=True),\n                False,\n            ),\n            (1, WSMsgType.CONTINUATION, b\"line2\", False),\n        ]\n\n        with pytest.raises(WebSocketError) as ctx:\n            parser._feed_data(b\"\")\n\n        assert ctx.value.code == WSCloseCode.INVALID_TEXT",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "out",
        "parser"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert ctx.value.code == WSCloseCode.INVALID_TEXT"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "build_close_frame",
          "body": "def build_close_frame(code: int=1000, message: bytes=b'', noheader: bool=False) -> bytes:\n    return build_frame(PACK_CLOSE_CODE(code) + message, opcode=WSMsgType.CLOSE, noheader=noheader)"
        }
      ]
    },
    {
      "name": "test_continuation_with_close_bad_code",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 426,
      "end_line_number": 439,
      "source_code": "def test_continuation_with_close_bad_code(\n    out: aiohttp.DataQueue[WSMessage], parser: WebSocketReader\n) -> None:\n    with mock.patch.object(parser, \"parse_frame\", autospec=True) as m:\n        m.return_value = [\n            (0, WSMsgType.TEXT, b\"line1\", False),\n            (0, WSMsgType.CLOSE, build_close_frame(1, b\"test\", noheader=True), False),\n            (1, WSMsgType.CONTINUATION, b\"line2\", False),\n        ]\n\n        with pytest.raises(WebSocketError) as ctx:\n            parser._feed_data(b\"\")\n\n        assert ctx.value.code == WSCloseCode.PROTOCOL_ERROR",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "out",
        "parser"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert ctx.value.code == WSCloseCode.PROTOCOL_ERROR"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "build_close_frame",
          "body": "def build_close_frame(code: int=1000, message: bytes=b'', noheader: bool=False) -> bytes:\n    return build_frame(PACK_CLOSE_CODE(code) + message, opcode=WSMsgType.CLOSE, noheader=noheader)"
        }
      ]
    },
    {
      "name": "test_continuation_with_close_bad_payload",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 442,
      "end_line_number": 455,
      "source_code": "def test_continuation_with_close_bad_payload(\n    out: aiohttp.DataQueue[WSMessage], parser: WebSocketReader\n) -> None:\n    with mock.patch.object(parser, \"parse_frame\", autospec=True) as m:\n        m.return_value = [\n            (0, WSMsgType.TEXT, b\"line1\", False),\n            (0, WSMsgType.CLOSE, b\"1\", False),\n            (1, WSMsgType.CONTINUATION, b\"line2\", False),\n        ]\n\n        with pytest.raises(WebSocketError) as ctx:\n            parser._feed_data(b\"\")\n\n        assert ctx.value.code, WSCloseCode.PROTOCOL_ERROR",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "out",
        "parser"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert ctx.value.code, WSCloseCode.PROTOCOL_ERROR"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_continuation_with_close_empty",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 458,
      "end_line_number": 472,
      "source_code": "def test_continuation_with_close_empty(\n    out: aiohttp.DataQueue[WSMessage], parser: WebSocketReader\n) -> None:\n    with mock.patch.object(parser, \"parse_frame\", autospec=True) as m:\n        m.return_value = [\n            (0, WSMsgType.TEXT, b\"line1\", False),\n            (0, WSMsgType.CLOSE, b\"\", False),\n            (1, WSMsgType.CONTINUATION, b\"line2\", False),\n        ]\n\n        parser.feed_data(b\"\")\n        res = out._buffer[0]\n        assert res == WSMessageClose(data=0, extra=\"\")\n        res = out._buffer[1]\n        assert res == WSMessageText(data=\"line1line2\", extra=\"\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "out",
        "parser"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert res == WSMessageClose(data=0, extra='')",
        "assert res == WSMessageText(data='line1line2', extra='')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_websocket_mask_python",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 482,
      "end_line_number": 485,
      "source_code": "def test_websocket_mask_python() -> None:\n    message = bytearray(websocket_mask_data)\n    _websocket_helpers._websocket_mask_python(websocket_mask_mask, message)\n    assert message == websocket_mask_masked",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert message == websocket_mask_masked"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_websocket_mask_cython",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 491,
      "end_line_number": 497,
      "source_code": "def test_websocket_mask_cython() -> None:\n    message = bytearray(websocket_mask_data)\n    _websocket_helpers._websocket_mask_cython(websocket_mask_mask, message)  # type: ignore[attr-defined]\n    assert message == websocket_mask_masked\n    assert (\n        _websocket_helpers.websocket_mask is _websocket_helpers._websocket_mask_cython  # type: ignore[attr-defined]\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(not hasattr(_websocket_helpers, '_websocket_mask_cython'), reason='Requires Cython')"
      ],
      "arguments": [],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert message == websocket_mask_masked",
        "assert _websocket_helpers.websocket_mask is _websocket_helpers._websocket_mask_cython"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_websocket_mask_python_empty",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 500,
      "end_line_number": 503,
      "source_code": "def test_websocket_mask_python_empty() -> None:\n    message = bytearray()\n    _websocket_helpers._websocket_mask_python(websocket_mask_mask, message)\n    assert message == bytearray()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert message == bytearray()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_websocket_mask_cython_empty",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 509,
      "end_line_number": 512,
      "source_code": "def test_websocket_mask_cython_empty() -> None:\n    message = bytearray()\n    _websocket_helpers._websocket_mask_cython(websocket_mask_mask, message)  # type: ignore[attr-defined]\n    assert message == bytearray()",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(not hasattr(_websocket_helpers, '_websocket_mask_cython'), reason='Requires Cython')"
      ],
      "arguments": [],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert message == bytearray()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_parse_compress_frame_single",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 515,
      "end_line_number": 520,
      "source_code": "def test_parse_compress_frame_single(parser: WebSocketReader) -> None:\n    parser.parse_frame(struct.pack(\"!BB\", 0b11000001, 0b00000001))\n    res = parser.parse_frame(b\"1\")\n    fin, opcode, payload, compress = res[0]\n\n    assert (1, 1, b\"1\", True) == (fin, opcode, payload, not not compress)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert (1, 1, b'1', True) == (fin, opcode, payload, not not compress)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_parse_compress_frame_multi",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 523,
      "end_line_number": 540,
      "source_code": "def test_parse_compress_frame_multi(parser: WebSocketReader) -> None:\n    parser.parse_frame(struct.pack(\"!BB\", 0b01000001, 126))\n    parser.parse_frame(struct.pack(\"!H\", 4))\n    res = parser.parse_frame(b\"1234\")\n    fin, opcode, payload, compress = res[0]\n    assert (0, 1, b\"1234\", True) == (fin, opcode, payload, not not compress)\n\n    parser.parse_frame(struct.pack(\"!BB\", 0b10000001, 126))\n    parser.parse_frame(struct.pack(\"!H\", 4))\n    res = parser.parse_frame(b\"1234\")\n    fin, opcode, payload, compress = res[0]\n    assert (1, 1, b\"1234\", True) == (fin, opcode, payload, not not compress)\n\n    parser.parse_frame(struct.pack(\"!BB\", 0b10000001, 126))\n    parser.parse_frame(struct.pack(\"!H\", 4))\n    res = parser.parse_frame(b\"1234\")\n    fin, opcode, payload, compress = res[0]\n    assert (1, 1, b\"1234\", False) == (fin, opcode, payload, not not compress)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert (0, 1, b'1234', True) == (fin, opcode, payload, not not compress)",
        "assert (1, 1, b'1234', True) == (fin, opcode, payload, not not compress)",
        "assert (1, 1, b'1234', False) == (fin, opcode, payload, not not compress)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_parse_compress_error_frame",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 543,
      "end_line_number": 551,
      "source_code": "def test_parse_compress_error_frame(parser: WebSocketReader) -> None:\n    parser.parse_frame(struct.pack(\"!BB\", 0b01000001, 0b00000001))\n    parser.parse_frame(b\"1\")\n\n    with pytest.raises(WebSocketError) as ctx:\n        parser.parse_frame(struct.pack(\"!BB\", 0b11000001, 0b00000001))\n        parser.parse_frame(b\"1\")\n\n    assert ctx.value.code == WSCloseCode.PROTOCOL_ERROR",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert ctx.value.code == WSCloseCode.PROTOCOL_ERROR"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_parse_no_compress_frame_single",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 554,
      "end_line_number": 560,
      "source_code": "def test_parse_no_compress_frame_single(out: aiohttp.DataQueue[WSMessage]) -> None:\n    parser_no_compress = WebSocketReader(out, 0, compress=False)\n    with pytest.raises(WebSocketError) as ctx:\n        parser_no_compress.parse_frame(struct.pack(\"!BB\", 0b11000001, 0b00000001))\n        parser_no_compress.parse_frame(b\"1\")\n\n    assert ctx.value.code == WSCloseCode.PROTOCOL_ERROR",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "out"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert ctx.value.code == WSCloseCode.PROTOCOL_ERROR"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_msg_too_large",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 563,
      "end_line_number": 568,
      "source_code": "def test_msg_too_large(out: aiohttp.DataQueue[WSMessage]) -> None:\n    parser = WebSocketReader(out, 256, compress=False)\n    data = build_frame(b\"text\" * 256, WSMsgType.TEXT)\n    with pytest.raises(WebSocketError) as ctx:\n        parser._feed_data(data)\n    assert ctx.value.code == WSCloseCode.MESSAGE_TOO_BIG",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "out"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert ctx.value.code == WSCloseCode.MESSAGE_TOO_BIG"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "build_frame",
          "body": "def build_frame(message: bytes, opcode: int, use_mask: bool=False, noheader: bool=False, is_fin: bool=True, compress: bool=False) -> bytes:\n    if compress:\n        compressobj = zlib.compressobj(wbits=-9)\n        message = compressobj.compress(message)\n        message = message + compressobj.flush(zlib.Z_SYNC_FLUSH)\n        if message.endswith(WS_DEFLATE_TRAILING):\n            message = message[:-4]\n    msg_length = len(message)\n    if use_mask:\n        mask_bit = 128\n    else:\n        mask_bit = 0\n    if is_fin:\n        header_first_byte = 128 | opcode\n    else:\n        header_first_byte = opcode\n    if compress:\n        header_first_byte |= 64\n    if msg_length < 126:\n        header = PACK_LEN1(header_first_byte, msg_length | mask_bit)\n    elif msg_length < 1 << 16:\n        header = PACK_LEN2(header_first_byte, 126 | mask_bit, msg_length)\n    else:\n        header = PACK_LEN3(header_first_byte, 127 | mask_bit, msg_length)\n    if use_mask:\n        maski = random.randrange(0, 4294967295)\n        mask = maski.to_bytes(4, 'big')\n        message = bytearray(message)\n        websocket_mask(mask, message)\n        if noheader:\n            return message\n        else:\n            return header + mask + message\n    elif noheader:\n        return message\n    else:\n        return header + message"
        }
      ]
    },
    {
      "name": "test_msg_too_large_not_fin",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 571,
      "end_line_number": 576,
      "source_code": "def test_msg_too_large_not_fin(out: aiohttp.DataQueue[WSMessage]) -> None:\n    parser = WebSocketReader(out, 256, compress=False)\n    data = build_frame(b\"text\" * 256, WSMsgType.TEXT, is_fin=False)\n    with pytest.raises(WebSocketError) as ctx:\n        parser._feed_data(data)\n    assert ctx.value.code == WSCloseCode.MESSAGE_TOO_BIG",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "out"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert ctx.value.code == WSCloseCode.MESSAGE_TOO_BIG"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "build_frame",
          "body": "def build_frame(message: bytes, opcode: int, use_mask: bool=False, noheader: bool=False, is_fin: bool=True, compress: bool=False) -> bytes:\n    if compress:\n        compressobj = zlib.compressobj(wbits=-9)\n        message = compressobj.compress(message)\n        message = message + compressobj.flush(zlib.Z_SYNC_FLUSH)\n        if message.endswith(WS_DEFLATE_TRAILING):\n            message = message[:-4]\n    msg_length = len(message)\n    if use_mask:\n        mask_bit = 128\n    else:\n        mask_bit = 0\n    if is_fin:\n        header_first_byte = 128 | opcode\n    else:\n        header_first_byte = opcode\n    if compress:\n        header_first_byte |= 64\n    if msg_length < 126:\n        header = PACK_LEN1(header_first_byte, msg_length | mask_bit)\n    elif msg_length < 1 << 16:\n        header = PACK_LEN2(header_first_byte, 126 | mask_bit, msg_length)\n    else:\n        header = PACK_LEN3(header_first_byte, 127 | mask_bit, msg_length)\n    if use_mask:\n        maski = random.randrange(0, 4294967295)\n        mask = maski.to_bytes(4, 'big')\n        message = bytearray(message)\n        websocket_mask(mask, message)\n        if noheader:\n            return message\n        else:\n            return header + mask + message\n    elif noheader:\n        return message\n    else:\n        return header + message"
        }
      ]
    },
    {
      "name": "test_compressed_msg_too_large",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 579,
      "end_line_number": 584,
      "source_code": "def test_compressed_msg_too_large(out: aiohttp.DataQueue[WSMessage]) -> None:\n    parser = WebSocketReader(out, 256, compress=True)\n    data = build_frame(b\"aaa\" * 256, WSMsgType.TEXT, compress=True)\n    with pytest.raises(WebSocketError) as ctx:\n        parser._feed_data(data)\n    assert ctx.value.code == WSCloseCode.MESSAGE_TOO_BIG",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "out"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert ctx.value.code == WSCloseCode.MESSAGE_TOO_BIG"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "build_frame",
          "body": "def build_frame(message: bytes, opcode: int, use_mask: bool=False, noheader: bool=False, is_fin: bool=True, compress: bool=False) -> bytes:\n    if compress:\n        compressobj = zlib.compressobj(wbits=-9)\n        message = compressobj.compress(message)\n        message = message + compressobj.flush(zlib.Z_SYNC_FLUSH)\n        if message.endswith(WS_DEFLATE_TRAILING):\n            message = message[:-4]\n    msg_length = len(message)\n    if use_mask:\n        mask_bit = 128\n    else:\n        mask_bit = 0\n    if is_fin:\n        header_first_byte = 128 | opcode\n    else:\n        header_first_byte = opcode\n    if compress:\n        header_first_byte |= 64\n    if msg_length < 126:\n        header = PACK_LEN1(header_first_byte, msg_length | mask_bit)\n    elif msg_length < 1 << 16:\n        header = PACK_LEN2(header_first_byte, 126 | mask_bit, msg_length)\n    else:\n        header = PACK_LEN3(header_first_byte, 127 | mask_bit, msg_length)\n    if use_mask:\n        maski = random.randrange(0, 4294967295)\n        mask = maski.to_bytes(4, 'big')\n        message = bytearray(message)\n        websocket_mask(mask, message)\n        if noheader:\n            return message\n        else:\n            return header + mask + message\n    elif noheader:\n        return message\n    else:\n        return header + message"
        }
      ]
    },
    {
      "name": "test_ctor",
      "module": "test_websocket_parser",
      "class_name": "TestWebSocketError",
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 588,
      "end_line_number": 591,
      "source_code": "def test_ctor(self) -> None:\n        err = WebSocketError(WSCloseCode.PROTOCOL_ERROR, \"Something invalid\")\n        assert err.code == WSCloseCode.PROTOCOL_ERROR\n        assert str(err) == \"Something invalid\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert err.code == WSCloseCode.PROTOCOL_ERROR",
        "assert str(err) == 'Something invalid'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_pickle",
      "module": "test_websocket_parser",
      "class_name": "TestWebSocketError",
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 593,
      "end_line_number": 601,
      "source_code": "def test_pickle(self) -> None:\n        err = WebSocketError(WSCloseCode.PROTOCOL_ERROR, \"Something invalid\")\n        err.foo = \"bar\"  # type: ignore[attr-defined]\n        for proto in range(pickle.HIGHEST_PROTOCOL + 1):\n            pickled = pickle.dumps(err, proto)\n            err2 = pickle.loads(pickled)\n            assert err2.code == WSCloseCode.PROTOCOL_ERROR\n            assert str(err2) == \"Something invalid\"\n            assert err2.foo == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert err2.code == WSCloseCode.PROTOCOL_ERROR",
        "assert str(err2) == 'Something invalid'",
        "assert err2.foo == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 588,
      "end_line_number": 591,
      "source_code": "def test_ctor(self) -> None:\n        err = WebSocketError(WSCloseCode.PROTOCOL_ERROR, \"Something invalid\")\n        assert err.code == WSCloseCode.PROTOCOL_ERROR\n        assert str(err) == \"Something invalid\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert err.code == WSCloseCode.PROTOCOL_ERROR",
        "assert str(err) == 'Something invalid'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_pickle",
      "module": "test_websocket_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_websocket_parser.py",
      "line_number": 593,
      "end_line_number": 601,
      "source_code": "def test_pickle(self) -> None:\n        err = WebSocketError(WSCloseCode.PROTOCOL_ERROR, \"Something invalid\")\n        err.foo = \"bar\"  # type: ignore[attr-defined]\n        for proto in range(pickle.HIGHEST_PROTOCOL + 1):\n            pickled = pickle.dumps(err, proto)\n            err2 = pickle.loads(pickled)\n            assert err2.code == WSCloseCode.PROTOCOL_ERROR\n            assert str(err2) == \"Something invalid\"\n            assert err2.foo == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "pickle",
        "random",
        "struct",
        "zlib",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp._websocket.helpers",
        "aiohttp._websocket.helpers.PACK_CLOSE_CODE",
        "aiohttp._websocket.helpers.PACK_LEN1",
        "aiohttp._websocket.helpers.PACK_LEN2",
        "aiohttp._websocket.helpers.PACK_LEN3",
        "aiohttp._websocket.helpers.websocket_mask",
        "aiohttp._websocket.models.WS_DEFLATE_TRAILING",
        "aiohttp.http.WebSocketError",
        "aiohttp.http.WSCloseCode",
        "aiohttp.http.WSMessage",
        "aiohttp.http.WSMsgType",
        "aiohttp.http_websocket.WebSocketReader",
        "aiohttp.http_websocket.WSMessageBinary",
        "aiohttp.http_websocket.WSMessageClose",
        "aiohttp.http_websocket.WSMessagePing",
        "aiohttp.http_websocket.WSMessagePong",
        "aiohttp.http_websocket.WSMessageText"
      ],
      "fixtures": [],
      "assertions": [
        "assert err2.code == WSCloseCode.PROTOCOL_ERROR",
        "assert str(err2) == 'Something invalid'",
        "assert err2.foo == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_aio_dns_is_default",
      "module": "test_resolver",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_resolver.py",
      "line_number": 385,
      "end_line_number": 386,
      "source_code": "def test_aio_dns_is_default() -> None:\n    assert DefaultResolver is AsyncResolver",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(not getaddrinfo, reason='aiodns >=3.2.0 required')"
      ],
      "arguments": [],
      "imports": [
        "asyncio",
        "ipaddress",
        "socket",
        "ipaddress.ip_address",
        "typing.Any",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Collection",
        "typing.Iterable",
        "typing.List",
        "typing.NamedTuple",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock.Mock",
        "unittest.mock.create_autospec",
        "unittest.mock.patch",
        "pytest",
        "aiohttp.resolver._NAME_SOCKET_FLAGS",
        "aiohttp.resolver.AsyncResolver",
        "aiohttp.resolver.DefaultResolver",
        "aiohttp.resolver.ThreadedResolver",
        "aiodns"
      ],
      "fixtures": [],
      "assertions": [
        "assert DefaultResolver is AsyncResolver"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_threaded_resolver_is_default",
      "module": "test_resolver",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_resolver.py",
      "line_number": 390,
      "end_line_number": 391,
      "source_code": "def test_threaded_resolver_is_default() -> None:\n    assert DefaultResolver is ThreadedResolver",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(getaddrinfo, reason='aiodns <3.2.0 required')"
      ],
      "arguments": [],
      "imports": [
        "asyncio",
        "ipaddress",
        "socket",
        "ipaddress.ip_address",
        "typing.Any",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Collection",
        "typing.Iterable",
        "typing.List",
        "typing.NamedTuple",
        "typing.Tuple",
        "typing.Union",
        "unittest.mock.Mock",
        "unittest.mock.create_autospec",
        "unittest.mock.patch",
        "pytest",
        "aiohttp.resolver._NAME_SOCKET_FLAGS",
        "aiohttp.resolver.AsyncResolver",
        "aiohttp.resolver.DefaultResolver",
        "aiohttp.resolver.ThreadedResolver",
        "aiodns"
      ],
      "fixtures": [],
      "assertions": [
        "assert DefaultResolver is ThreadedResolver"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_non_app",
      "module": "test_web_runner",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_runner.py",
      "line_number": 112,
      "end_line_number": 114,
      "source_code": "def test_non_app() -> None:\n    with pytest.raises(TypeError):\n        web.AppRunner(object())",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "platform",
        "signal",
        "typing.Any",
        "typing.Iterator",
        "typing.NoReturn",
        "typing.Protocol",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp.web",
        "aiohttp.abc.AbstractAccessLogger",
        "aiohttp.test_utils.get_unused_port_socket",
        "aiohttp.web_log.AccessLogger"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_app_handler_args",
      "module": "test_web_runner",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_runner.py",
      "line_number": 117,
      "end_line_number": 120,
      "source_code": "def test_app_handler_args() -> None:\n    app = web.Application(handler_args={\"test\": True})\n    runner = web.AppRunner(app)\n    assert runner._kwargs == {\"access_log_class\": AccessLogger, \"test\": True}",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "platform",
        "signal",
        "typing.Any",
        "typing.Iterator",
        "typing.NoReturn",
        "typing.Protocol",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp.web",
        "aiohttp.abc.AbstractAccessLogger",
        "aiohttp.test_utils.get_unused_port_socket",
        "aiohttp.web_log.AccessLogger"
      ],
      "fixtures": [],
      "assertions": [
        "assert runner._kwargs == {'access_log_class': AccessLogger, 'test': True}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_run_after_asyncio_run",
      "module": "test_web_runner",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_runner.py",
      "line_number": 262,
      "end_line_number": 284,
      "source_code": "def test_run_after_asyncio_run() -> None:\n    called = False\n\n    async def nothing() -> None:\n        pass\n\n    def spy() -> None:\n        nonlocal called\n        called = True\n\n    async def shutdown() -> NoReturn:\n        spy()\n        raise web.GracefulExit()\n\n    # asyncio.run() creates a new loop and closes it.\n    asyncio.run(nothing())\n\n    app = web.Application()\n    # create_task() will delay the function until app is run.\n    app.on_startup.append(lambda a: asyncio.create_task(shutdown()))\n\n    web.run_app(app)\n    assert called, \"run_app() should work after asyncio.run().\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "platform",
        "signal",
        "typing.Any",
        "typing.Iterator",
        "typing.NoReturn",
        "typing.Protocol",
        "typing.Union",
        "unittest.mock",
        "pytest",
        "aiohttp.web",
        "aiohttp.abc.AbstractAccessLogger",
        "aiohttp.test_utils.get_unused_port_socket",
        "aiohttp.web_log.AccessLogger"
      ],
      "fixtures": [],
      "assertions": [
        "assert called, 'run_app() should work after asyncio.run().'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "web.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        },
        {
          "name": "spy",
          "body": "def spy() -> None:\n    nonlocal called\n    called = True"
        }
      ]
    },
    {
      "name": "test_default_status",
      "module": "test_client_exceptions",
      "class_name": "TestClientResponseError",
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 19,
      "end_line_number": 21,
      "source_code": "def test_default_status(self) -> None:\n        err = client.ClientResponseError(history=(), request_info=self.request_info)\n        assert err.status == 0",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert err.status == 0"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_status",
      "module": "test_client_exceptions",
      "class_name": "TestClientResponseError",
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 23,
      "end_line_number": 27,
      "source_code": "def test_status(self) -> None:\n        err = client.ClientResponseError(\n            status=400, history=(), request_info=self.request_info\n        )\n        assert err.status == 400",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert err.status == 400"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_pickle",
      "module": "test_client_exceptions",
      "class_name": "TestClientResponseError",
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 30,
      "end_line_number": 58,
      "source_code": "def test_pickle(self) -> None:\n        err = client.ClientResponseError(request_info=self.request_info, history=())\n        for proto in range(pickle.HIGHEST_PROTOCOL + 1):\n            pickled = pickle.dumps(err, proto)\n            err2 = pickle.loads(pickled)\n            assert err2.request_info == self.request_info\n            assert err2.history == ()\n            assert err2.status == 0\n            assert err2.message == \"\"\n            assert err2.headers is None\n\n        err = client.ClientResponseError(\n            request_info=self.request_info,\n            history=(),\n            status=400,\n            message=\"Something wrong\",\n            headers=CIMultiDict(foo=\"bar\"),\n        )\n        err.foo = \"bar\"  # type: ignore[attr-defined]\n        for proto in range(pickle.HIGHEST_PROTOCOL + 1):\n            pickled = pickle.dumps(err, proto)\n            err2 = pickle.loads(pickled)\n            assert err2.request_info == self.request_info\n            assert err2.history == ()\n            assert err2.status == 400\n            assert err2.message == \"Something wrong\"\n            # Use headers.get() to verify static type is correct.\n            assert err2.headers.get(\"foo\") == \"bar\"\n            assert err2.foo == \"bar\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.xfail(reason='CIMultiDictProxy is not pickleable')"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert err2.request_info == self.request_info",
        "assert err2.history == ()",
        "assert err2.status == 0",
        "assert err2.message == ''",
        "assert err2.headers is None",
        "assert err2.request_info == self.request_info",
        "assert err2.history == ()",
        "assert err2.status == 400",
        "assert err2.message == 'Something wrong'",
        "assert err2.headers.get('foo') == 'bar'",
        "assert err2.foo == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_repr",
      "module": "test_client_exceptions",
      "class_name": "TestClientResponseError",
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 60,
      "end_line_number": 74,
      "source_code": "def test_repr(self) -> None:\n        err = client.ClientResponseError(request_info=self.request_info, history=())\n        assert repr(err) == (f\"ClientResponseError({self.request_info!r}, ())\")\n\n        err = client.ClientResponseError(\n            request_info=self.request_info,\n            history=(),\n            status=400,\n            message=\"Something wrong\",\n            headers=CIMultiDict(),\n        )\n        assert repr(err) == (\n            \"ClientResponseError(%r, (), status=400, \"\n            \"message='Something wrong', headers=<CIMultiDict()>)\" % (self.request_info,)\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(err) == f'ClientResponseError({self.request_info!r}, ())'",
        "assert repr(err) == \"ClientResponseError(%r, (), status=400, message='Something wrong', headers=<CIMultiDict()>)\" % (self.request_info,)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_str",
      "module": "test_client_exceptions",
      "class_name": "TestClientResponseError",
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 76,
      "end_line_number": 84,
      "source_code": "def test_str(self) -> None:\n        err = client.ClientResponseError(\n            request_info=self.request_info,\n            history=(),\n            status=400,\n            message=\"Something wrong\",\n            headers=CIMultiDict(),\n        )\n        assert str(err) == (\"400, message='Something wrong', url='http://example.com'\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(err) == \"400, message='Something wrong', url='http://example.com'\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor",
      "module": "test_client_exceptions",
      "class_name": "TestClientConnectorError",
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 98,
      "end_line_number": 109,
      "source_code": "def test_ctor(self) -> None:\n        err = client.ClientConnectorError(\n            connection_key=self.connection_key,\n            os_error=OSError(errno.ENOENT, \"No such file\"),\n        )\n        assert err.errno == errno.ENOENT\n        assert err.strerror == \"No such file\"\n        assert err.os_error.errno == errno.ENOENT\n        assert err.os_error.strerror == \"No such file\"\n        assert err.host == \"example.com\"\n        assert err.port == 8080\n        assert err.ssl is True",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert err.errno == errno.ENOENT",
        "assert err.strerror == 'No such file'",
        "assert err.os_error.errno == errno.ENOENT",
        "assert err.os_error.strerror == 'No such file'",
        "assert err.host == 'example.com'",
        "assert err.port == 8080",
        "assert err.ssl is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_pickle",
      "module": "test_client_exceptions",
      "class_name": "TestClientConnectorError",
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 111,
      "end_line_number": 127,
      "source_code": "def test_pickle(self) -> None:\n        err = client.ClientConnectorError(\n            connection_key=self.connection_key,\n            os_error=OSError(errno.ENOENT, \"No such file\"),\n        )\n        err.foo = \"bar\"  # type: ignore[attr-defined]\n        for proto in range(pickle.HIGHEST_PROTOCOL + 1):\n            pickled = pickle.dumps(err, proto)\n            err2 = pickle.loads(pickled)\n            assert err2.errno == errno.ENOENT\n            assert err2.strerror == \"No such file\"\n            assert err2.os_error.errno == errno.ENOENT\n            assert err2.os_error.strerror == \"No such file\"\n            assert err2.host == \"example.com\"\n            assert err2.port == 8080\n            assert err2.ssl is True\n            assert err2.foo == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert err2.errno == errno.ENOENT",
        "assert err2.strerror == 'No such file'",
        "assert err2.os_error.errno == errno.ENOENT",
        "assert err2.os_error.strerror == 'No such file'",
        "assert err2.host == 'example.com'",
        "assert err2.port == 8080",
        "assert err2.ssl is True",
        "assert err2.foo == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_repr",
      "module": "test_client_exceptions",
      "class_name": "TestClientConnectorError",
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 129,
      "end_line_number": 136,
      "source_code": "def test_repr(self) -> None:\n        os_error = OSError(errno.ENOENT, \"No such file\")\n        err = client.ClientConnectorError(\n            connection_key=self.connection_key, os_error=os_error\n        )\n        assert repr(err) == (\n            f\"ClientConnectorError({self.connection_key!r}, {os_error!r})\"\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(err) == f'ClientConnectorError({self.connection_key!r}, {os_error!r})'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_str",
      "module": "test_client_exceptions",
      "class_name": "TestClientConnectorError",
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 138,
      "end_line_number": 145,
      "source_code": "def test_str(self) -> None:\n        err = client.ClientConnectorError(\n            connection_key=self.connection_key,\n            os_error=OSError(errno.ENOENT, \"No such file\"),\n        )\n        assert str(err) == (\n            \"Cannot connect to host example.com:8080 ssl:default [No such file]\"\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(err) == 'Cannot connect to host example.com:8080 ssl:default [No such file]'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor",
      "module": "test_client_exceptions",
      "class_name": "TestClientConnectorCertificateError",
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 159,
      "end_line_number": 167,
      "source_code": "def test_ctor(self) -> None:\n        certificate_error = Exception(\"Bad certificate\")\n        err = client.ClientConnectorCertificateError(\n            connection_key=self.connection_key, certificate_error=certificate_error\n        )\n        assert err.certificate_error == certificate_error\n        assert err.host == \"example.com\"\n        assert err.port == 8080\n        assert err.ssl is False",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert err.certificate_error == certificate_error",
        "assert err.host == 'example.com'",
        "assert err.port == 8080",
        "assert err.ssl is False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_pickle",
      "module": "test_client_exceptions",
      "class_name": "TestClientConnectorCertificateError",
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 169,
      "end_line_number": 182,
      "source_code": "def test_pickle(self) -> None:\n        certificate_error = Exception(\"Bad certificate\")\n        err = client.ClientConnectorCertificateError(\n            connection_key=self.connection_key, certificate_error=certificate_error\n        )\n        err.foo = \"bar\"\n        for proto in range(pickle.HIGHEST_PROTOCOL + 1):\n            pickled = pickle.dumps(err, proto)\n            err2 = pickle.loads(pickled)\n            assert err2.certificate_error.args == (\"Bad certificate\",)\n            assert err2.host == \"example.com\"\n            assert err2.port == 8080\n            assert err2.ssl is False\n            assert err2.foo == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert err2.certificate_error.args == ('Bad certificate',)",
        "assert err2.host == 'example.com'",
        "assert err2.port == 8080",
        "assert err2.ssl is False",
        "assert err2.foo == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_repr",
      "module": "test_client_exceptions",
      "class_name": "TestClientConnectorCertificateError",
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 184,
      "end_line_number": 192,
      "source_code": "def test_repr(self) -> None:\n        certificate_error = Exception(\"Bad certificate\")\n        err = client.ClientConnectorCertificateError(\n            connection_key=self.connection_key, certificate_error=certificate_error\n        )\n        assert repr(err) == (\n            \"ClientConnectorCertificateError(%r, %r)\"\n            % (self.connection_key, certificate_error)\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(err) == 'ClientConnectorCertificateError(%r, %r)' % (self.connection_key, certificate_error)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_str",
      "module": "test_client_exceptions",
      "class_name": "TestClientConnectorCertificateError",
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 194,
      "end_line_number": 202,
      "source_code": "def test_str(self) -> None:\n        certificate_error = Exception(\"Bad certificate\")\n        err = client.ClientConnectorCertificateError(\n            connection_key=self.connection_key, certificate_error=certificate_error\n        )\n        assert str(err) == (\n            \"Cannot connect to host example.com:8080 ssl:False\"\n            \" [Exception: ('Bad certificate',)]\"\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(err) == \"Cannot connect to host example.com:8080 ssl:False [Exception: ('Bad certificate',)]\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor",
      "module": "test_client_exceptions",
      "class_name": "TestServerDisconnectedError",
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 206,
      "end_line_number": 211,
      "source_code": "def test_ctor(self) -> None:\n        err = client.ServerDisconnectedError()\n        assert err.message == \"Server disconnected\"\n\n        err = client.ServerDisconnectedError(message=\"No connection\")\n        assert err.message == \"No connection\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert err.message == 'Server disconnected'",
        "assert err.message == 'No connection'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_pickle",
      "module": "test_client_exceptions",
      "class_name": "TestServerDisconnectedError",
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 213,
      "end_line_number": 220,
      "source_code": "def test_pickle(self) -> None:\n        err = client.ServerDisconnectedError(message=\"No connection\")\n        err.foo = \"bar\"  # type: ignore[attr-defined]\n        for proto in range(pickle.HIGHEST_PROTOCOL + 1):\n            pickled = pickle.dumps(err, proto)\n            err2 = pickle.loads(pickled)\n            assert err2.message == \"No connection\"\n            assert err2.foo == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert err2.message == 'No connection'",
        "assert err2.foo == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_repr",
      "module": "test_client_exceptions",
      "class_name": "TestServerDisconnectedError",
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 222,
      "end_line_number": 227,
      "source_code": "def test_repr(self) -> None:\n        err = client.ServerDisconnectedError()\n        assert repr(err) == (\"ServerDisconnectedError('Server disconnected')\")\n\n        err = client.ServerDisconnectedError(message=\"No connection\")\n        assert repr(err) == \"ServerDisconnectedError('No connection')\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(err) == \"ServerDisconnectedError('Server disconnected')\"",
        "assert repr(err) == \"ServerDisconnectedError('No connection')\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_str",
      "module": "test_client_exceptions",
      "class_name": "TestServerDisconnectedError",
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 229,
      "end_line_number": 234,
      "source_code": "def test_str(self) -> None:\n        err = client.ServerDisconnectedError()\n        assert str(err) == \"Server disconnected\"\n\n        err = client.ServerDisconnectedError(message=\"No connection\")\n        assert str(err) == \"No connection\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(err) == 'Server disconnected'",
        "assert str(err) == 'No connection'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor",
      "module": "test_client_exceptions",
      "class_name": "TestServerFingerprintMismatch",
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 238,
      "end_line_number": 245,
      "source_code": "def test_ctor(self) -> None:\n        err = client.ServerFingerprintMismatch(\n            expected=b\"exp\", got=b\"got\", host=\"example.com\", port=8080\n        )\n        assert err.expected == b\"exp\"\n        assert err.got == b\"got\"\n        assert err.host == \"example.com\"\n        assert err.port == 8080",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert err.expected == b'exp'",
        "assert err.got == b'got'",
        "assert err.host == 'example.com'",
        "assert err.port == 8080"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_pickle",
      "module": "test_client_exceptions",
      "class_name": "TestServerFingerprintMismatch",
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 247,
      "end_line_number": 259,
      "source_code": "def test_pickle(self) -> None:\n        err = client.ServerFingerprintMismatch(\n            expected=b\"exp\", got=b\"got\", host=\"example.com\", port=8080\n        )\n        err.foo = \"bar\"  # type: ignore[attr-defined]\n        for proto in range(pickle.HIGHEST_PROTOCOL + 1):\n            pickled = pickle.dumps(err, proto)\n            err2 = pickle.loads(pickled)\n            assert err2.expected == b\"exp\"\n            assert err2.got == b\"got\"\n            assert err2.host == \"example.com\"\n            assert err2.port == 8080\n            assert err2.foo == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert err2.expected == b'exp'",
        "assert err2.got == b'got'",
        "assert err2.host == 'example.com'",
        "assert err2.port == 8080",
        "assert err2.foo == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_repr",
      "module": "test_client_exceptions",
      "class_name": "TestServerFingerprintMismatch",
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 261,
      "end_line_number": 266,
      "source_code": "def test_repr(self) -> None:\n        err = client.ServerFingerprintMismatch(b\"exp\", b\"got\", \"example.com\", 8080)\n        assert repr(err) == (\n            \"<ServerFingerprintMismatch expected=b'exp' \"\n            \"got=b'got' host='example.com' port=8080>\"\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(err) == \"<ServerFingerprintMismatch expected=b'exp' got=b'got' host='example.com' port=8080>\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor",
      "module": "test_client_exceptions",
      "class_name": "TestInvalidURL",
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 270,
      "end_line_number": 273,
      "source_code": "def test_ctor(self) -> None:\n        err = client.InvalidURL(url=\":wrong:url:\", description=\":description:\")\n        assert err.url == \":wrong:url:\"\n        assert err.description == \":description:\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert err.url == ':wrong:url:'",
        "assert err.description == ':description:'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_pickle",
      "module": "test_client_exceptions",
      "class_name": "TestInvalidURL",
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 275,
      "end_line_number": 282,
      "source_code": "def test_pickle(self) -> None:\n        err = client.InvalidURL(url=\":wrong:url:\")\n        err.foo = \"bar\"  # type: ignore[attr-defined]\n        for proto in range(pickle.HIGHEST_PROTOCOL + 1):\n            pickled = pickle.dumps(err, proto)\n            err2 = pickle.loads(pickled)\n            assert err2.url == \":wrong:url:\"\n            assert err2.foo == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert err2.url == ':wrong:url:'",
        "assert err2.foo == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_repr_no_description",
      "module": "test_client_exceptions",
      "class_name": "TestInvalidURL",
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 284,
      "end_line_number": 287,
      "source_code": "def test_repr_no_description(self) -> None:\n        err = client.InvalidURL(url=\":wrong:url:\")\n        assert err.args == (\":wrong:url:\",)\n        assert repr(err) == \"<InvalidURL :wrong:url:>\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert err.args == (':wrong:url:',)",
        "assert repr(err) == '<InvalidURL :wrong:url:>'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_repr_yarl_URL",
      "module": "test_client_exceptions",
      "class_name": "TestInvalidURL",
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 289,
      "end_line_number": 291,
      "source_code": "def test_repr_yarl_URL(self) -> None:\n        err = client.InvalidURL(url=URL(\":wrong:url:\"))\n        assert repr(err) == \"<InvalidURL :wrong:url:>\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(err) == '<InvalidURL :wrong:url:>'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_repr_with_description",
      "module": "test_client_exceptions",
      "class_name": "TestInvalidURL",
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 293,
      "end_line_number": 295,
      "source_code": "def test_repr_with_description(self) -> None:\n        err = client.InvalidURL(url=\":wrong:url:\", description=\":description:\")\n        assert repr(err) == \"<InvalidURL :wrong:url: - :description:>\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(err) == '<InvalidURL :wrong:url: - :description:>'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_str_no_description",
      "module": "test_client_exceptions",
      "class_name": "TestInvalidURL",
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 297,
      "end_line_number": 299,
      "source_code": "def test_str_no_description(self) -> None:\n        err = client.InvalidURL(url=\":wrong:url:\")\n        assert str(err) == \":wrong:url:\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(err) == ':wrong:url:'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_none_description",
      "module": "test_client_exceptions",
      "class_name": "TestInvalidURL",
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 301,
      "end_line_number": 303,
      "source_code": "def test_none_description(self) -> None:\n        err = client.InvalidURL(\":wrong:url:\")\n        assert err.description is None",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert err.description is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_str_with_description",
      "module": "test_client_exceptions",
      "class_name": "TestInvalidURL",
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 305,
      "end_line_number": 307,
      "source_code": "def test_str_with_description(self) -> None:\n        err = client.InvalidURL(url=\":wrong:url:\", description=\":description:\")\n        assert str(err) == \":wrong:url: - :description:\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(err) == ':wrong:url: - :description:'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_default_status",
      "module": "test_client_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 19,
      "end_line_number": 21,
      "source_code": "def test_default_status(self) -> None:\n        err = client.ClientResponseError(history=(), request_info=self.request_info)\n        assert err.status == 0",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert err.status == 0"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_status",
      "module": "test_client_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 23,
      "end_line_number": 27,
      "source_code": "def test_status(self) -> None:\n        err = client.ClientResponseError(\n            status=400, history=(), request_info=self.request_info\n        )\n        assert err.status == 400",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert err.status == 400"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_pickle",
      "module": "test_client_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 30,
      "end_line_number": 58,
      "source_code": "def test_pickle(self) -> None:\n        err = client.ClientResponseError(request_info=self.request_info, history=())\n        for proto in range(pickle.HIGHEST_PROTOCOL + 1):\n            pickled = pickle.dumps(err, proto)\n            err2 = pickle.loads(pickled)\n            assert err2.request_info == self.request_info\n            assert err2.history == ()\n            assert err2.status == 0\n            assert err2.message == \"\"\n            assert err2.headers is None\n\n        err = client.ClientResponseError(\n            request_info=self.request_info,\n            history=(),\n            status=400,\n            message=\"Something wrong\",\n            headers=CIMultiDict(foo=\"bar\"),\n        )\n        err.foo = \"bar\"  # type: ignore[attr-defined]\n        for proto in range(pickle.HIGHEST_PROTOCOL + 1):\n            pickled = pickle.dumps(err, proto)\n            err2 = pickle.loads(pickled)\n            assert err2.request_info == self.request_info\n            assert err2.history == ()\n            assert err2.status == 400\n            assert err2.message == \"Something wrong\"\n            # Use headers.get() to verify static type is correct.\n            assert err2.headers.get(\"foo\") == \"bar\"\n            assert err2.foo == \"bar\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.xfail(reason='CIMultiDictProxy is not pickleable')"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert err2.request_info == self.request_info",
        "assert err2.history == ()",
        "assert err2.status == 0",
        "assert err2.message == ''",
        "assert err2.headers is None",
        "assert err2.request_info == self.request_info",
        "assert err2.history == ()",
        "assert err2.status == 400",
        "assert err2.message == 'Something wrong'",
        "assert err2.headers.get('foo') == 'bar'",
        "assert err2.foo == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_repr",
      "module": "test_client_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 60,
      "end_line_number": 74,
      "source_code": "def test_repr(self) -> None:\n        err = client.ClientResponseError(request_info=self.request_info, history=())\n        assert repr(err) == (f\"ClientResponseError({self.request_info!r}, ())\")\n\n        err = client.ClientResponseError(\n            request_info=self.request_info,\n            history=(),\n            status=400,\n            message=\"Something wrong\",\n            headers=CIMultiDict(),\n        )\n        assert repr(err) == (\n            \"ClientResponseError(%r, (), status=400, \"\n            \"message='Something wrong', headers=<CIMultiDict()>)\" % (self.request_info,)\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(err) == f'ClientResponseError({self.request_info!r}, ())'",
        "assert repr(err) == \"ClientResponseError(%r, (), status=400, message='Something wrong', headers=<CIMultiDict()>)\" % (self.request_info,)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_str",
      "module": "test_client_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 76,
      "end_line_number": 84,
      "source_code": "def test_str(self) -> None:\n        err = client.ClientResponseError(\n            request_info=self.request_info,\n            history=(),\n            status=400,\n            message=\"Something wrong\",\n            headers=CIMultiDict(),\n        )\n        assert str(err) == (\"400, message='Something wrong', url='http://example.com'\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(err) == \"400, message='Something wrong', url='http://example.com'\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor",
      "module": "test_client_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 98,
      "end_line_number": 109,
      "source_code": "def test_ctor(self) -> None:\n        err = client.ClientConnectorError(\n            connection_key=self.connection_key,\n            os_error=OSError(errno.ENOENT, \"No such file\"),\n        )\n        assert err.errno == errno.ENOENT\n        assert err.strerror == \"No such file\"\n        assert err.os_error.errno == errno.ENOENT\n        assert err.os_error.strerror == \"No such file\"\n        assert err.host == \"example.com\"\n        assert err.port == 8080\n        assert err.ssl is True",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert err.errno == errno.ENOENT",
        "assert err.strerror == 'No such file'",
        "assert err.os_error.errno == errno.ENOENT",
        "assert err.os_error.strerror == 'No such file'",
        "assert err.host == 'example.com'",
        "assert err.port == 8080",
        "assert err.ssl is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_pickle",
      "module": "test_client_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 111,
      "end_line_number": 127,
      "source_code": "def test_pickle(self) -> None:\n        err = client.ClientConnectorError(\n            connection_key=self.connection_key,\n            os_error=OSError(errno.ENOENT, \"No such file\"),\n        )\n        err.foo = \"bar\"  # type: ignore[attr-defined]\n        for proto in range(pickle.HIGHEST_PROTOCOL + 1):\n            pickled = pickle.dumps(err, proto)\n            err2 = pickle.loads(pickled)\n            assert err2.errno == errno.ENOENT\n            assert err2.strerror == \"No such file\"\n            assert err2.os_error.errno == errno.ENOENT\n            assert err2.os_error.strerror == \"No such file\"\n            assert err2.host == \"example.com\"\n            assert err2.port == 8080\n            assert err2.ssl is True\n            assert err2.foo == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert err2.errno == errno.ENOENT",
        "assert err2.strerror == 'No such file'",
        "assert err2.os_error.errno == errno.ENOENT",
        "assert err2.os_error.strerror == 'No such file'",
        "assert err2.host == 'example.com'",
        "assert err2.port == 8080",
        "assert err2.ssl is True",
        "assert err2.foo == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_repr",
      "module": "test_client_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 129,
      "end_line_number": 136,
      "source_code": "def test_repr(self) -> None:\n        os_error = OSError(errno.ENOENT, \"No such file\")\n        err = client.ClientConnectorError(\n            connection_key=self.connection_key, os_error=os_error\n        )\n        assert repr(err) == (\n            f\"ClientConnectorError({self.connection_key!r}, {os_error!r})\"\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(err) == f'ClientConnectorError({self.connection_key!r}, {os_error!r})'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_str",
      "module": "test_client_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 138,
      "end_line_number": 145,
      "source_code": "def test_str(self) -> None:\n        err = client.ClientConnectorError(\n            connection_key=self.connection_key,\n            os_error=OSError(errno.ENOENT, \"No such file\"),\n        )\n        assert str(err) == (\n            \"Cannot connect to host example.com:8080 ssl:default [No such file]\"\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(err) == 'Cannot connect to host example.com:8080 ssl:default [No such file]'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor",
      "module": "test_client_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 159,
      "end_line_number": 167,
      "source_code": "def test_ctor(self) -> None:\n        certificate_error = Exception(\"Bad certificate\")\n        err = client.ClientConnectorCertificateError(\n            connection_key=self.connection_key, certificate_error=certificate_error\n        )\n        assert err.certificate_error == certificate_error\n        assert err.host == \"example.com\"\n        assert err.port == 8080\n        assert err.ssl is False",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert err.certificate_error == certificate_error",
        "assert err.host == 'example.com'",
        "assert err.port == 8080",
        "assert err.ssl is False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_pickle",
      "module": "test_client_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 169,
      "end_line_number": 182,
      "source_code": "def test_pickle(self) -> None:\n        certificate_error = Exception(\"Bad certificate\")\n        err = client.ClientConnectorCertificateError(\n            connection_key=self.connection_key, certificate_error=certificate_error\n        )\n        err.foo = \"bar\"\n        for proto in range(pickle.HIGHEST_PROTOCOL + 1):\n            pickled = pickle.dumps(err, proto)\n            err2 = pickle.loads(pickled)\n            assert err2.certificate_error.args == (\"Bad certificate\",)\n            assert err2.host == \"example.com\"\n            assert err2.port == 8080\n            assert err2.ssl is False\n            assert err2.foo == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert err2.certificate_error.args == ('Bad certificate',)",
        "assert err2.host == 'example.com'",
        "assert err2.port == 8080",
        "assert err2.ssl is False",
        "assert err2.foo == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_repr",
      "module": "test_client_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 184,
      "end_line_number": 192,
      "source_code": "def test_repr(self) -> None:\n        certificate_error = Exception(\"Bad certificate\")\n        err = client.ClientConnectorCertificateError(\n            connection_key=self.connection_key, certificate_error=certificate_error\n        )\n        assert repr(err) == (\n            \"ClientConnectorCertificateError(%r, %r)\"\n            % (self.connection_key, certificate_error)\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(err) == 'ClientConnectorCertificateError(%r, %r)' % (self.connection_key, certificate_error)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_str",
      "module": "test_client_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 194,
      "end_line_number": 202,
      "source_code": "def test_str(self) -> None:\n        certificate_error = Exception(\"Bad certificate\")\n        err = client.ClientConnectorCertificateError(\n            connection_key=self.connection_key, certificate_error=certificate_error\n        )\n        assert str(err) == (\n            \"Cannot connect to host example.com:8080 ssl:False\"\n            \" [Exception: ('Bad certificate',)]\"\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(err) == \"Cannot connect to host example.com:8080 ssl:False [Exception: ('Bad certificate',)]\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor",
      "module": "test_client_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 206,
      "end_line_number": 211,
      "source_code": "def test_ctor(self) -> None:\n        err = client.ServerDisconnectedError()\n        assert err.message == \"Server disconnected\"\n\n        err = client.ServerDisconnectedError(message=\"No connection\")\n        assert err.message == \"No connection\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert err.message == 'Server disconnected'",
        "assert err.message == 'No connection'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_pickle",
      "module": "test_client_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 213,
      "end_line_number": 220,
      "source_code": "def test_pickle(self) -> None:\n        err = client.ServerDisconnectedError(message=\"No connection\")\n        err.foo = \"bar\"  # type: ignore[attr-defined]\n        for proto in range(pickle.HIGHEST_PROTOCOL + 1):\n            pickled = pickle.dumps(err, proto)\n            err2 = pickle.loads(pickled)\n            assert err2.message == \"No connection\"\n            assert err2.foo == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert err2.message == 'No connection'",
        "assert err2.foo == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_repr",
      "module": "test_client_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 222,
      "end_line_number": 227,
      "source_code": "def test_repr(self) -> None:\n        err = client.ServerDisconnectedError()\n        assert repr(err) == (\"ServerDisconnectedError('Server disconnected')\")\n\n        err = client.ServerDisconnectedError(message=\"No connection\")\n        assert repr(err) == \"ServerDisconnectedError('No connection')\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(err) == \"ServerDisconnectedError('Server disconnected')\"",
        "assert repr(err) == \"ServerDisconnectedError('No connection')\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_str",
      "module": "test_client_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 229,
      "end_line_number": 234,
      "source_code": "def test_str(self) -> None:\n        err = client.ServerDisconnectedError()\n        assert str(err) == \"Server disconnected\"\n\n        err = client.ServerDisconnectedError(message=\"No connection\")\n        assert str(err) == \"No connection\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(err) == 'Server disconnected'",
        "assert str(err) == 'No connection'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor",
      "module": "test_client_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 238,
      "end_line_number": 245,
      "source_code": "def test_ctor(self) -> None:\n        err = client.ServerFingerprintMismatch(\n            expected=b\"exp\", got=b\"got\", host=\"example.com\", port=8080\n        )\n        assert err.expected == b\"exp\"\n        assert err.got == b\"got\"\n        assert err.host == \"example.com\"\n        assert err.port == 8080",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert err.expected == b'exp'",
        "assert err.got == b'got'",
        "assert err.host == 'example.com'",
        "assert err.port == 8080"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_pickle",
      "module": "test_client_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 247,
      "end_line_number": 259,
      "source_code": "def test_pickle(self) -> None:\n        err = client.ServerFingerprintMismatch(\n            expected=b\"exp\", got=b\"got\", host=\"example.com\", port=8080\n        )\n        err.foo = \"bar\"  # type: ignore[attr-defined]\n        for proto in range(pickle.HIGHEST_PROTOCOL + 1):\n            pickled = pickle.dumps(err, proto)\n            err2 = pickle.loads(pickled)\n            assert err2.expected == b\"exp\"\n            assert err2.got == b\"got\"\n            assert err2.host == \"example.com\"\n            assert err2.port == 8080\n            assert err2.foo == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert err2.expected == b'exp'",
        "assert err2.got == b'got'",
        "assert err2.host == 'example.com'",
        "assert err2.port == 8080",
        "assert err2.foo == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_repr",
      "module": "test_client_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 261,
      "end_line_number": 266,
      "source_code": "def test_repr(self) -> None:\n        err = client.ServerFingerprintMismatch(b\"exp\", b\"got\", \"example.com\", 8080)\n        assert repr(err) == (\n            \"<ServerFingerprintMismatch expected=b'exp' \"\n            \"got=b'got' host='example.com' port=8080>\"\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(err) == \"<ServerFingerprintMismatch expected=b'exp' got=b'got' host='example.com' port=8080>\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor",
      "module": "test_client_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 270,
      "end_line_number": 273,
      "source_code": "def test_ctor(self) -> None:\n        err = client.InvalidURL(url=\":wrong:url:\", description=\":description:\")\n        assert err.url == \":wrong:url:\"\n        assert err.description == \":description:\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert err.url == ':wrong:url:'",
        "assert err.description == ':description:'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_pickle",
      "module": "test_client_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 275,
      "end_line_number": 282,
      "source_code": "def test_pickle(self) -> None:\n        err = client.InvalidURL(url=\":wrong:url:\")\n        err.foo = \"bar\"  # type: ignore[attr-defined]\n        for proto in range(pickle.HIGHEST_PROTOCOL + 1):\n            pickled = pickle.dumps(err, proto)\n            err2 = pickle.loads(pickled)\n            assert err2.url == \":wrong:url:\"\n            assert err2.foo == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert err2.url == ':wrong:url:'",
        "assert err2.foo == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_repr_no_description",
      "module": "test_client_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 284,
      "end_line_number": 287,
      "source_code": "def test_repr_no_description(self) -> None:\n        err = client.InvalidURL(url=\":wrong:url:\")\n        assert err.args == (\":wrong:url:\",)\n        assert repr(err) == \"<InvalidURL :wrong:url:>\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert err.args == (':wrong:url:',)",
        "assert repr(err) == '<InvalidURL :wrong:url:>'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_repr_yarl_URL",
      "module": "test_client_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 289,
      "end_line_number": 291,
      "source_code": "def test_repr_yarl_URL(self) -> None:\n        err = client.InvalidURL(url=URL(\":wrong:url:\"))\n        assert repr(err) == \"<InvalidURL :wrong:url:>\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(err) == '<InvalidURL :wrong:url:>'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_repr_with_description",
      "module": "test_client_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 293,
      "end_line_number": 295,
      "source_code": "def test_repr_with_description(self) -> None:\n        err = client.InvalidURL(url=\":wrong:url:\", description=\":description:\")\n        assert repr(err) == \"<InvalidURL :wrong:url: - :description:>\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(err) == '<InvalidURL :wrong:url: - :description:>'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_str_no_description",
      "module": "test_client_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 297,
      "end_line_number": 299,
      "source_code": "def test_str_no_description(self) -> None:\n        err = client.InvalidURL(url=\":wrong:url:\")\n        assert str(err) == \":wrong:url:\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(err) == ':wrong:url:'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_none_description",
      "module": "test_client_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 301,
      "end_line_number": 303,
      "source_code": "def test_none_description(self) -> None:\n        err = client.InvalidURL(\":wrong:url:\")\n        assert err.description is None",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert err.description is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_str_with_description",
      "module": "test_client_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_exceptions.py",
      "line_number": 305,
      "end_line_number": 307,
      "source_code": "def test_str_with_description(self) -> None:\n        err = client.InvalidURL(url=\":wrong:url:\", description=\":description:\")\n        assert str(err) == \":wrong:url: - :description:\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "errno",
        "pickle",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "yarl.URL",
        "aiohttp.client",
        "aiohttp.client_reqrep"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(err) == ':wrong:url: - :description:'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_method1",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 92,
      "end_line_number": 94,
      "source_code": "def test_method1(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://python.org/\")\n    assert req.method == \"GET\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.method == 'GET'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_method2",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 97,
      "end_line_number": 99,
      "source_code": "def test_method2(make_request: _RequestMaker) -> None:\n    req = make_request(\"head\", \"http://python.org/\")\n    assert req.method == \"HEAD\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.method == 'HEAD'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_method3",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 102,
      "end_line_number": 104,
      "source_code": "def test_method3(make_request: _RequestMaker) -> None:\n    req = make_request(\"HEAD\", \"http://python.org/\")\n    assert req.method == \"HEAD\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.method == 'HEAD'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_method_invalid",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 107,
      "end_line_number": 109,
      "source_code": "def test_method_invalid(make_request: _RequestMaker) -> None:\n    with pytest.raises(ValueError, match=\"Method cannot contain non-token characters\"):\n        make_request(\"METHOD WITH\\nWHITESPACES\", \"http://python.org/\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_version_1_0",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 112,
      "end_line_number": 114,
      "source_code": "def test_version_1_0(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://python.org/\", version=\"1.0\")\n    assert req.version == (1, 0)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.version == (1, 0)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_version_default",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 117,
      "end_line_number": 119,
      "source_code": "def test_version_default(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://python.org/\")\n    assert req.version == (1, 1)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.version == (1, 1)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_request_info",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 122,
      "end_line_number": 126,
      "source_code": "def test_request_info(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://python.org/\")\n    url = URL(\"http://python.org/\")\n    h = CIMultiDictProxy(req.headers)\n    assert req.request_info == aiohttp.RequestInfo(url, \"GET\", h, url)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.request_info == aiohttp.RequestInfo(url, 'GET', h, url)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_request_info_with_fragment",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 129,
      "end_line_number": 137,
      "source_code": "def test_request_info_with_fragment(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://python.org/#urlfragment\")\n    h = CIMultiDictProxy(req.headers)\n    assert req.request_info == aiohttp.RequestInfo(\n        URL(\"http://python.org/\"),\n        \"GET\",\n        h,\n        URL(\"http://python.org/#urlfragment\"),\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.request_info == aiohttp.RequestInfo(URL('http://python.org/'), 'GET', h, URL('http://python.org/#urlfragment'))"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_version_err",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 140,
      "end_line_number": 142,
      "source_code": "def test_version_err(make_request: _RequestMaker) -> None:\n    with pytest.raises(ValueError):\n        make_request(\"get\", \"http://python.org/\", version=\"1.c\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_keep_alive",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 145,
      "end_line_number": 166,
      "source_code": "def test_keep_alive(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://python.org/\", version=(0, 9))\n    assert not req.keep_alive()\n\n    req = make_request(\"get\", \"http://python.org/\", version=(1, 0))\n    assert not req.keep_alive()\n\n    req = make_request(\n        \"get\",\n        \"http://python.org/\",\n        version=(1, 0),\n        headers={\"connection\": \"keep-alive\"},\n    )\n    assert req.keep_alive()\n\n    req = make_request(\"get\", \"http://python.org/\", version=(1, 1))\n    assert req.keep_alive()\n\n    req = make_request(\n        \"get\", \"http://python.org/\", version=(1, 1), headers={\"connection\": \"close\"}\n    )\n    assert not req.keep_alive()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert not req.keep_alive()",
        "assert not req.keep_alive()",
        "assert req.keep_alive()",
        "assert req.keep_alive()",
        "assert not req.keep_alive()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        },
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        },
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        },
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        },
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_host_port_default_http",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 169,
      "end_line_number": 173,
      "source_code": "def test_host_port_default_http(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://python.org/\")\n    assert req.host == \"python.org\"\n    assert req.port == 80\n    assert not req.is_ssl()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.host == 'python.org'",
        "assert req.port == 80",
        "assert not req.is_ssl()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_host_port_default_https",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 176,
      "end_line_number": 180,
      "source_code": "def test_host_port_default_https(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"https://python.org/\")\n    assert req.host == \"python.org\"\n    assert req.port == 443\n    assert req.is_ssl()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.host == 'python.org'",
        "assert req.port == 443",
        "assert req.is_ssl()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_host_port_nondefault_http",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 183,
      "end_line_number": 187,
      "source_code": "def test_host_port_nondefault_http(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://python.org:960/\")\n    assert req.host == \"python.org\"\n    assert req.port == 960\n    assert not req.is_ssl()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.host == 'python.org'",
        "assert req.port == 960",
        "assert not req.is_ssl()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_host_port_nondefault_https",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 190,
      "end_line_number": 194,
      "source_code": "def test_host_port_nondefault_https(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"https://python.org:960/\")\n    assert req.host == \"python.org\"\n    assert req.port == 960\n    assert req.is_ssl()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.host == 'python.org'",
        "assert req.port == 960",
        "assert req.is_ssl()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_host_port_default_ws",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 197,
      "end_line_number": 201,
      "source_code": "def test_host_port_default_ws(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"ws://python.org/\")\n    assert req.host == \"python.org\"\n    assert req.port == 80\n    assert not req.is_ssl()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.host == 'python.org'",
        "assert req.port == 80",
        "assert not req.is_ssl()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_host_port_default_wss",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 204,
      "end_line_number": 208,
      "source_code": "def test_host_port_default_wss(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"wss://python.org/\")\n    assert req.host == \"python.org\"\n    assert req.port == 443\n    assert req.is_ssl()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.host == 'python.org'",
        "assert req.port == 443",
        "assert req.is_ssl()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_host_port_nondefault_ws",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 211,
      "end_line_number": 215,
      "source_code": "def test_host_port_nondefault_ws(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"ws://python.org:960/\")\n    assert req.host == \"python.org\"\n    assert req.port == 960\n    assert not req.is_ssl()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.host == 'python.org'",
        "assert req.port == 960",
        "assert not req.is_ssl()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_host_port_nondefault_wss",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 218,
      "end_line_number": 222,
      "source_code": "def test_host_port_nondefault_wss(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"wss://python.org:960/\")\n    assert req.host == \"python.org\"\n    assert req.port == 960\n    assert req.is_ssl()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.host == 'python.org'",
        "assert req.port == 960",
        "assert req.is_ssl()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_host_port_none_port",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 225,
      "end_line_number": 227,
      "source_code": "def test_host_port_none_port(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"unix://localhost/path\")\n    assert req.headers[\"Host\"] == \"localhost\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.headers['Host'] == 'localhost'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_host_port_err",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 230,
      "end_line_number": 232,
      "source_code": "def test_host_port_err(make_request: _RequestMaker) -> None:\n    with pytest.raises(ValueError):\n        make_request(\"get\", \"http://python.org:123e/\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_hostname_err",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 235,
      "end_line_number": 237,
      "source_code": "def test_hostname_err(make_request: _RequestMaker) -> None:\n    with pytest.raises(ValueError):\n        make_request(\"get\", \"http://:8080/\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_host_header_host_first",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 240,
      "end_line_number": 242,
      "source_code": "def test_host_header_host_first(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://python.org/\")\n    assert list(req.headers)[0] == \"Host\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert list(req.headers)[0] == 'Host'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_host_header_host_without_port",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 245,
      "end_line_number": 247,
      "source_code": "def test_host_header_host_without_port(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://python.org/\")\n    assert req.headers[\"HOST\"] == \"python.org\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.headers['HOST'] == 'python.org'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_host_header_host_with_default_port",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 250,
      "end_line_number": 252,
      "source_code": "def test_host_header_host_with_default_port(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://python.org:80/\")\n    assert req.headers[\"HOST\"] == \"python.org\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.headers['HOST'] == 'python.org'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_host_header_host_with_nondefault_port",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 255,
      "end_line_number": 257,
      "source_code": "def test_host_header_host_with_nondefault_port(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://python.org:99/\")\n    assert req.headers[\"HOST\"] == \"python.org:99\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.headers['HOST'] == 'python.org:99'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_host_header_host_idna_encode",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 260,
      "end_line_number": 262,
      "source_code": "def test_host_header_host_idna_encode(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://xn--9caa.com\")\n    assert req.headers[\"HOST\"] == \"xn--9caa.com\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.headers['HOST'] == 'xn--9caa.com'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_host_header_host_unicode",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 265,
      "end_line_number": 267,
      "source_code": "def test_host_header_host_unicode(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://\u00e9\u00e9.com\")\n    assert req.headers[\"HOST\"] == \"xn--9caa.com\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.headers['HOST'] == 'xn--9caa.com'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_host_header_explicit_host",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 270,
      "end_line_number": 272,
      "source_code": "def test_host_header_explicit_host(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://python.org/\", headers={\"host\": \"example.com\"})\n    assert req.headers[\"HOST\"] == \"example.com\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.headers['HOST'] == 'example.com'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_host_header_explicit_host_with_port",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 275,
      "end_line_number": 277,
      "source_code": "def test_host_header_explicit_host_with_port(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://python.org/\", headers={\"host\": \"example.com:99\"})\n    assert req.headers[\"HOST\"] == \"example.com:99\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.headers['HOST'] == 'example.com:99'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_host_header_ipv4",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 280,
      "end_line_number": 282,
      "source_code": "def test_host_header_ipv4(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://127.0.0.2\")\n    assert req.headers[\"HOST\"] == \"127.0.0.2\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.headers['HOST'] == '127.0.0.2'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_host_header_ipv6",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 285,
      "end_line_number": 287,
      "source_code": "def test_host_header_ipv6(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://[::2]\")\n    assert req.headers[\"HOST\"] == \"[::2]\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.headers['HOST'] == '[::2]'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_host_header_ipv4_with_port",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 290,
      "end_line_number": 292,
      "source_code": "def test_host_header_ipv4_with_port(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://127.0.0.2:99\")\n    assert req.headers[\"HOST\"] == \"127.0.0.2:99\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.headers['HOST'] == '127.0.0.2:99'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_host_header_ipv6_with_port",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 295,
      "end_line_number": 297,
      "source_code": "def test_host_header_ipv6_with_port(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://[::2]:99\")\n    assert req.headers[\"HOST\"] == \"[::2]:99\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.headers['HOST'] == '[::2]:99'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_host_header_fqdn",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 330,
      "end_line_number": 334,
      "source_code": "def test_host_header_fqdn(\n    make_request: _RequestMaker, url: str, headers: Dict[str, str], expected: str\n) -> None:\n    req = make_request(\"get\", url, headers=headers)\n    assert req.headers[\"HOST\"] == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize(('url', 'headers', 'expected'), (pytest.param('http://localhost.', None, 'localhost', id='dot only at the end'), pytest.param('http://python.org.', None, 'python.org', id='single dot'), pytest.param('http://python.org.:99', None, 'python.org:99', id='single dot with port'), pytest.param('http://python.org...:99', None, 'python.org:99', id='multiple dots with port'), pytest.param('http://python.org.:99', {'host': 'example.com.:99'}, 'example.com.:99', id='explicit host header'), pytest.param('https://python.org.', None, 'python.org', id='https'), pytest.param('https://...', None, '', id='only dots'), pytest.param('http://pr\u00edklad.example.org.:99', None, 'xn--prklad-4va.example.org:99', id='single dot with port idna')))"
      ],
      "arguments": [
        "make_request",
        "url",
        "headers",
        "expected"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.headers['HOST'] == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_default_headers_useragent",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 337,
      "end_line_number": 341,
      "source_code": "def test_default_headers_useragent(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://python.org/\")\n\n    assert \"SERVER\" not in req.headers\n    assert \"USER-AGENT\" in req.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'SERVER' not in req.headers",
        "assert 'USER-AGENT' in req.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_default_headers_useragent_custom",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 344,
      "end_line_number": 350,
      "source_code": "def test_default_headers_useragent_custom(make_request: _RequestMaker) -> None:\n    req = make_request(\n        \"get\", \"http://python.org/\", headers={\"user-agent\": \"my custom agent\"}\n    )\n\n    assert \"USER-Agent\" in req.headers\n    assert \"my custom agent\" == req.headers[\"User-Agent\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'USER-Agent' in req.headers",
        "assert 'my custom agent' == req.headers['User-Agent']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_skip_default_useragent_header",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 353,
      "end_line_number": 358,
      "source_code": "def test_skip_default_useragent_header(make_request: _RequestMaker) -> None:\n    req = make_request(\n        \"get\", \"http://python.org/\", skip_auto_headers={istr(\"user-agent\")}\n    )\n\n    assert \"User-Agent\" not in req.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'User-Agent' not in req.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_headers",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 361,
      "end_line_number": 368,
      "source_code": "def test_headers(make_request: _RequestMaker) -> None:\n    req = make_request(\n        \"post\", \"http://python.org/\", headers={\"Content-Type\": \"text/plain\"}\n    )\n\n    assert \"CONTENT-TYPE\" in req.headers\n    assert req.headers[\"CONTENT-TYPE\"] == \"text/plain\"\n    assert req.headers[\"ACCEPT-ENCODING\"] == \"gzip, deflate, br\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'CONTENT-TYPE' in req.headers",
        "assert req.headers['CONTENT-TYPE'] == 'text/plain'",
        "assert req.headers['ACCEPT-ENCODING'] == 'gzip, deflate, br'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_headers_list",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 371,
      "end_line_number": 376,
      "source_code": "def test_headers_list(make_request: _RequestMaker) -> None:\n    req = make_request(\n        \"post\", \"http://python.org/\", headers=[(\"Content-Type\", \"text/plain\")]\n    )\n    assert \"CONTENT-TYPE\" in req.headers\n    assert req.headers[\"CONTENT-TYPE\"] == \"text/plain\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'CONTENT-TYPE' in req.headers",
        "assert req.headers['CONTENT-TYPE'] == 'text/plain'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_headers_default",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 379,
      "end_line_number": 383,
      "source_code": "def test_headers_default(make_request: _RequestMaker) -> None:\n    req = make_request(\n        \"get\", \"http://python.org/\", headers={\"ACCEPT-ENCODING\": \"deflate\"}\n    )\n    assert req.headers[\"ACCEPT-ENCODING\"] == \"deflate\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.headers['ACCEPT-ENCODING'] == 'deflate'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_invalid_url",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 386,
      "end_line_number": 388,
      "source_code": "def test_invalid_url(make_request: _RequestMaker) -> None:\n    with pytest.raises(aiohttp.InvalidURL):\n        make_request(\"get\", \"hiwpefhipowhefopw\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_no_path",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 391,
      "end_line_number": 393,
      "source_code": "def test_no_path(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://python.org\")\n    assert \"/\" == req.url.path",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert '/' == req.url.path"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_ipv6_default_http_port",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 396,
      "end_line_number": 400,
      "source_code": "def test_ipv6_default_http_port(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://[2001:db8::1]/\")\n    assert req.host == \"2001:db8::1\"\n    assert req.port == 80\n    assert not req.is_ssl()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.host == '2001:db8::1'",
        "assert req.port == 80",
        "assert not req.is_ssl()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_ipv6_default_https_port",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 403,
      "end_line_number": 407,
      "source_code": "def test_ipv6_default_https_port(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"https://[2001:db8::1]/\")\n    assert req.host == \"2001:db8::1\"\n    assert req.port == 443\n    assert req.is_ssl()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.host == '2001:db8::1'",
        "assert req.port == 443",
        "assert req.is_ssl()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_ipv6_nondefault_http_port",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 410,
      "end_line_number": 414,
      "source_code": "def test_ipv6_nondefault_http_port(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://[2001:db8::1]:960/\")\n    assert req.host == \"2001:db8::1\"\n    assert req.port == 960\n    assert not req.is_ssl()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.host == '2001:db8::1'",
        "assert req.port == 960",
        "assert not req.is_ssl()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_ipv6_nondefault_https_port",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 417,
      "end_line_number": 421,
      "source_code": "def test_ipv6_nondefault_https_port(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"https://[2001:db8::1]:960/\")\n    assert req.host == \"2001:db8::1\"\n    assert req.port == 960\n    assert req.is_ssl()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.host == '2001:db8::1'",
        "assert req.port == 960",
        "assert req.is_ssl()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_basic_auth",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 424,
      "end_line_number": 429,
      "source_code": "def test_basic_auth(make_request: _RequestMaker) -> None:\n    req = make_request(\n        \"get\", \"http://python.org\", auth=aiohttp.BasicAuth(\"nkim\", \"1234\")\n    )\n    assert \"AUTHORIZATION\" in req.headers\n    assert \"Basic bmtpbToxMjM0\" == req.headers[\"AUTHORIZATION\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'AUTHORIZATION' in req.headers",
        "assert 'Basic bmtpbToxMjM0' == req.headers['AUTHORIZATION']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_basic_auth_utf8",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 432,
      "end_line_number": 437,
      "source_code": "def test_basic_auth_utf8(make_request: _RequestMaker) -> None:\n    req = make_request(\n        \"get\", \"http://python.org\", auth=aiohttp.BasicAuth(\"nkim\", \"\u0441\u0435\u043a\u0440\u0435\u0442\", \"utf-8\")\n    )\n    assert \"AUTHORIZATION\" in req.headers\n    assert \"Basic bmtpbTrRgdC10LrRgNC10YI=\" == req.headers[\"AUTHORIZATION\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'AUTHORIZATION' in req.headers",
        "assert 'Basic bmtpbTrRgdC10LrRgNC10YI=' == req.headers['AUTHORIZATION']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_basic_auth_tuple_forbidden",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 440,
      "end_line_number": 442,
      "source_code": "def test_basic_auth_tuple_forbidden(make_request: _RequestMaker) -> None:\n    with pytest.raises(TypeError):\n        make_request(\"get\", \"http://python.org\", auth=(\"nkim\", \"1234\"))",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_basic_auth_from_url",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 445,
      "end_line_number": 449,
      "source_code": "def test_basic_auth_from_url(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://nkim:1234@python.org\")\n    assert \"AUTHORIZATION\" in req.headers\n    assert \"Basic bmtpbToxMjM0\" == req.headers[\"AUTHORIZATION\"]\n    assert \"python.org\" == req.host",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'AUTHORIZATION' in req.headers",
        "assert 'Basic bmtpbToxMjM0' == req.headers['AUTHORIZATION']",
        "assert 'python.org' == req.host"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_basic_auth_no_user_from_url",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 452,
      "end_line_number": 456,
      "source_code": "def test_basic_auth_no_user_from_url(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://:1234@python.org\")\n    assert \"AUTHORIZATION\" in req.headers\n    assert \"Basic OjEyMzQ=\" == req.headers[\"AUTHORIZATION\"]\n    assert \"python.org\" == req.host",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'AUTHORIZATION' in req.headers",
        "assert 'Basic OjEyMzQ=' == req.headers['AUTHORIZATION']",
        "assert 'python.org' == req.host"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_basic_auth_from_url_overridden",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 459,
      "end_line_number": 465,
      "source_code": "def test_basic_auth_from_url_overridden(make_request: _RequestMaker) -> None:\n    req = make_request(\n        \"get\", \"http://garbage@python.org\", auth=aiohttp.BasicAuth(\"nkim\", \"1234\")\n    )\n    assert \"AUTHORIZATION\" in req.headers\n    assert \"Basic bmtpbToxMjM0\" == req.headers[\"AUTHORIZATION\"]\n    assert \"python.org\" == req.host",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'AUTHORIZATION' in req.headers",
        "assert 'Basic bmtpbToxMjM0' == req.headers['AUTHORIZATION']",
        "assert 'python.org' == req.host"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_path_is_not_double_encoded1",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 468,
      "end_line_number": 470,
      "source_code": "def test_path_is_not_double_encoded1(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://0.0.0.0/get/test case\")\n    assert req.url.raw_path == \"/get/test%20case\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.url.raw_path == '/get/test%20case'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_path_is_not_double_encoded2",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 473,
      "end_line_number": 475,
      "source_code": "def test_path_is_not_double_encoded2(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://0.0.0.0/get/test%2fcase\")\n    assert req.url.raw_path == \"/get/test%2Fcase\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.url.raw_path == '/get/test%2Fcase'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_path_is_not_double_encoded3",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 478,
      "end_line_number": 480,
      "source_code": "def test_path_is_not_double_encoded3(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://0.0.0.0/get/test%20case\")\n    assert req.url.raw_path == \"/get/test%20case\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.url.raw_path == '/get/test%20case'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_path_safe_chars_preserved",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 483,
      "end_line_number": 485,
      "source_code": "def test_path_safe_chars_preserved(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://0.0.0.0/get/:=+/%2B/\")\n    assert req.url.path == \"/get/:=+/+/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.url.path == '/get/:=+/+/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_params_are_added_before_fragment1",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 488,
      "end_line_number": 490,
      "source_code": "def test_params_are_added_before_fragment1(make_request: _RequestMaker) -> None:\n    req = make_request(\"GET\", \"http://example.com/path#fragment\", params={\"a\": \"b\"})\n    assert str(req.url) == \"http://example.com/path?a=b\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(req.url) == 'http://example.com/path?a=b'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_params_are_added_before_fragment2",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 493,
      "end_line_number": 497,
      "source_code": "def test_params_are_added_before_fragment2(make_request: _RequestMaker) -> None:\n    req = make_request(\n        \"GET\", \"http://example.com/path?key=value#fragment\", params={\"a\": \"b\"}\n    )\n    assert str(req.url) == \"http://example.com/path?key=value&a=b\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(req.url) == 'http://example.com/path?key=value&a=b'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_path_not_contain_fragment1",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 500,
      "end_line_number": 502,
      "source_code": "def test_path_not_contain_fragment1(make_request: _RequestMaker) -> None:\n    req = make_request(\"GET\", \"http://example.com/path#fragment\")\n    assert req.url.path == \"/path\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.url.path == '/path'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_path_not_contain_fragment2",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 505,
      "end_line_number": 507,
      "source_code": "def test_path_not_contain_fragment2(make_request: _RequestMaker) -> None:\n    req = make_request(\"GET\", \"http://example.com/path?key=value#fragment\")\n    assert str(req.url) == \"http://example.com/path?key=value\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(req.url) == 'http://example.com/path?key=value'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_cookies",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 510,
      "end_line_number": 514,
      "source_code": "def test_cookies(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://test.com/path\", cookies={\"cookie1\": \"val1\"})\n\n    assert \"COOKIE\" in req.headers\n    assert \"cookie1=val1\" == req.headers[\"COOKIE\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'COOKIE' in req.headers",
        "assert 'cookie1=val1' == req.headers['COOKIE']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_cookies_is_quoted_with_special_characters",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 517,
      "end_line_number": 521,
      "source_code": "def test_cookies_is_quoted_with_special_characters(make_request: _RequestMaker) -> None:\n    req = make_request(\"get\", \"http://test.com/path\", cookies={\"cookie1\": \"val/one\"})\n\n    assert \"COOKIE\" in req.headers\n    assert 'cookie1=\"val/one\"' == req.headers[\"COOKIE\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'COOKIE' in req.headers",
        "assert 'cookie1=\"val/one\"' == req.headers['COOKIE']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_cookies_merge_with_headers",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 524,
      "end_line_number": 532,
      "source_code": "def test_cookies_merge_with_headers(make_request: _RequestMaker) -> None:\n    req = make_request(\n        \"get\",\n        \"http://test.com/path\",\n        headers={\"cookie\": \"cookie1=val1\"},\n        cookies={\"cookie2\": \"val2\"},\n    )\n\n    assert \"cookie1=val1; cookie2=val2\" == req.headers[\"COOKIE\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'cookie1=val1; cookie2=val2' == req.headers['COOKIE']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_query_multivalued_param",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 535,
      "end_line_number": 541,
      "source_code": "def test_query_multivalued_param(make_request: _RequestMaker) -> None:\n    for meth in ClientRequest.ALL_METHODS:\n        req = make_request(\n            meth, \"http://python.org\", params=((\"test\", \"foo\"), (\"test\", \"baz\"))\n        )\n\n        assert str(req.url) == \"http://python.org/?test=foo&test=baz\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(req.url) == 'http://python.org/?test=foo&test=baz'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_query_str_param",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 544,
      "end_line_number": 547,
      "source_code": "def test_query_str_param(make_request: _RequestMaker) -> None:\n    for meth in ClientRequest.ALL_METHODS:\n        req = make_request(meth, \"http://python.org\", params=\"test=foo\")\n        assert str(req.url) == \"http://python.org/?test=foo\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(req.url) == 'http://python.org/?test=foo'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_query_bytes_param_raises",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 550,
      "end_line_number": 553,
      "source_code": "def test_query_bytes_param_raises(make_request: _RequestMaker) -> None:\n    for meth in ClientRequest.ALL_METHODS:\n        with pytest.raises(TypeError):\n            make_request(meth, \"http://python.org\", params=b\"test=foo\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_query_str_param_is_not_encoded",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 556,
      "end_line_number": 559,
      "source_code": "def test_query_str_param_is_not_encoded(make_request: _RequestMaker) -> None:\n    for meth in ClientRequest.ALL_METHODS:\n        req = make_request(meth, \"http://python.org\", params=\"test=f+oo\")\n        assert str(req.url) == \"http://python.org/?test=f+oo\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(req.url) == 'http://python.org/?test=f+oo'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_params_update_path_and_url",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 562,
      "end_line_number": 566,
      "source_code": "def test_params_update_path_and_url(make_request: _RequestMaker) -> None:\n    req = make_request(\n        \"get\", \"http://python.org\", params=((\"test\", \"foo\"), (\"test\", \"baz\"))\n    )\n    assert str(req.url) == \"http://python.org/?test=foo&test=baz\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(req.url) == 'http://python.org/?test=foo&test=baz'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_params_empty_path_and_url",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 569,
      "end_line_number": 573,
      "source_code": "def test_params_empty_path_and_url(make_request: _RequestMaker) -> None:\n    req_empty = make_request(\"get\", \"http://python.org\", params={})\n    assert str(req_empty.url) == \"http://python.org\"\n    req_none = make_request(\"get\", \"http://python.org\")\n    assert str(req_none.url) == \"http://python.org\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(req_empty.url) == 'http://python.org'",
        "assert str(req_none.url) == 'http://python.org'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        },
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_gen_netloc_all",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 576,
      "end_line_number": 586,
      "source_code": "def test_gen_netloc_all(make_request: _RequestMaker) -> None:\n    req = make_request(\n        \"get\",\n        \"https://aiohttp:pwpwpw@\"\n        + \"12345678901234567890123456789\"\n        + \"012345678901234567890:8080\",\n    )\n    assert (\n        req.headers[\"HOST\"]\n        == \"12345678901234567890123456789\" + \"012345678901234567890:8080\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.headers['HOST'] == '12345678901234567890123456789' + '012345678901234567890:8080'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_gen_netloc_no_port",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 589,
      "end_line_number": 598,
      "source_code": "def test_gen_netloc_no_port(make_request: _RequestMaker) -> None:\n    req = make_request(\n        \"get\",\n        \"https://aiohttp:pwpwpw@\"\n        + \"12345678901234567890123456789\"\n        + \"012345678901234567890/\",\n    )\n    assert (\n        req.headers[\"HOST\"] == \"12345678901234567890123456789\" + \"012345678901234567890\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.headers['HOST'] == '12345678901234567890123456789' + '012345678901234567890'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_cookie_coded_value_preserved",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 601,
      "end_line_number": 606,
      "source_code": "def test_cookie_coded_value_preserved(loop: asyncio.AbstractEventLoop) -> None:\n    \"\"\"Verify the coded value of a cookie is preserved.\"\"\"\n    # https://github.com/aio-libs/aiohttp/pull/1453\n    req = ClientRequest(\"get\", URL(\"http://python.org\"), loop=loop)\n    req.update_cookies(cookies=SimpleCookie('ip-cookie=\"second\"; Domain=127.0.0.1;'))\n    assert req.headers[\"COOKIE\"] == 'ip-cookie=\"second\"'",
      "docstring": "Verify the coded value of a cookie is preserved.",
      "decorators": [],
      "arguments": [
        "loop"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.headers['COOKIE'] == 'ip-cookie=\"second\"'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_terminate_with_closed_loop",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 1289,
      "end_line_number": 1322,
      "source_code": "def test_terminate_with_closed_loop(\n    loop: asyncio.AbstractEventLoop, conn: mock.Mock\n) -> None:\n    req = resp = writer = None\n\n    async def go() -> None:\n        nonlocal req, resp, writer\n        req = ClientRequest(\"get\", URL(\"http://python.org\"), loop=loop)\n\n        async def _mock_write_bytes(*args: object, **kwargs: object) -> None:\n            # Ensure the task is scheduled\n            await asyncio.sleep(0)\n\n        with mock.patch.object(req, \"write_bytes\", _mock_write_bytes):\n            resp = await req.send(conn)\n\n        assert req._writer is not None\n        writer = WriterMock()\n        writer.done = mock.Mock(return_value=False)\n        req._writer = writer\n        resp._writer = writer\n\n        await asyncio.sleep(0.05)\n\n    loop.run_until_complete(go())\n\n    loop.close()\n    assert req is not None\n    req.terminate()\n    assert req._writer is None\n    assert writer is not None\n    assert not writer.cancel.called\n    assert resp is not None\n    resp.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop",
        "conn"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req is not None",
        "assert req._writer is None",
        "assert writer is not None",
        "assert not writer.cancel.called",
        "assert resp is not None",
        "assert req._writer is not None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock(return_value=False)"
      ],
      "methods_under_test": [
        {
          "name": "loop.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "resp.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "go",
          "body": "def go() -> List[web.AbstractRoute]:\n    route1 = router.add_route('GET', '/plain', make_handler())\n    route2 = router.add_route('GET', '/variable/{name}', make_handler())\n    resource = router.add_static('/static', pathlib.Path(aiohttp.__file__).parent)\n    return [route1, route2] + list(resource)"
        }
      ]
    },
    {
      "name": "test_terminate_without_writer",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 1325,
      "end_line_number": 1330,
      "source_code": "def test_terminate_without_writer(loop: asyncio.AbstractEventLoop) -> None:\n    req = ClientRequest(\"get\", URL(\"http://python.org\"), loop=loop)\n    assert req._writer is None\n\n    req.terminate()\n    assert req._writer is None",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req._writer is None",
        "assert req._writer is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_bad_fingerprint",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 1391,
      "end_line_number": 1393,
      "source_code": "def test_bad_fingerprint(loop: asyncio.AbstractEventLoop) -> None:\n    with pytest.raises(ValueError):\n        Fingerprint(b\"invalid\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_insecure_fingerprint_md5",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 1396,
      "end_line_number": 1398,
      "source_code": "def test_insecure_fingerprint_md5(loop: asyncio.AbstractEventLoop) -> None:\n    with pytest.raises(ValueError):\n        Fingerprint(hashlib.md5(b\"foo\").digest())",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_insecure_fingerprint_sha1",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 1401,
      "end_line_number": 1403,
      "source_code": "def test_insecure_fingerprint_sha1(loop: asyncio.AbstractEventLoop) -> None:\n    with pytest.raises(ValueError):\n        Fingerprint(hashlib.sha1(b\"foo\").digest())",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_loose_cookies_types",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 1406,
      "end_line_number": 1424,
      "source_code": "def test_loose_cookies_types(loop: asyncio.AbstractEventLoop) -> None:\n    req = ClientRequest(\"get\", URL(\"http://python.org\"), loop=loop)\n    morsel: \"Morsel[str]\" = Morsel()\n    morsel.set(key=\"string\", val=\"Another string\", coded_val=\"really\")\n\n    accepted_types: List[LooseCookies] = [\n        [(\"str\", BaseCookie())],\n        [(\"str\", morsel)],\n        [\n            (\"str\", \"str\"),\n        ],\n        {\"str\": BaseCookie()},\n        {\"str\": morsel},\n        {\"str\": \"str\"},\n        SimpleCookie(),\n    ]\n\n    for loose_cookies_type in accepted_types:\n        req.update_cookies(cookies=loose_cookies_type)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_gen_default_accept_encoding",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 1434,
      "end_line_number": 1436,
      "source_code": "def test_gen_default_accept_encoding(has_brotli: bool, expected: str) -> None:\n    with mock.patch(\"aiohttp.client_reqrep.HAS_BROTLI\", has_brotli):\n        assert _gen_default_accept_encoding() == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('has_brotli,expected', [(False, 'gzip, deflate'), (True, 'gzip, deflate, br')])"
      ],
      "arguments": [
        "has_brotli",
        "expected"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert _gen_default_accept_encoding() == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.patch('aiohttp.client_reqrep.HAS_BROTLI', has_brotli)"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_basicauth_from_netrc_present",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 1450,
      "end_line_number": 1456,
      "source_code": "def test_basicauth_from_netrc_present(\n    make_request: _RequestMaker,\n    expected_auth: helpers.BasicAuth,\n) -> None:\n    \"\"\"Test appropriate Authorization header is sent when netrc is not empty.\"\"\"\n    req = make_request(\"get\", \"http://example.com\", trust_env=True)\n    assert req.headers[hdrs.AUTHORIZATION] == expected_auth.encode()",
      "docstring": "Test appropriate Authorization header is sent when netrc is not empty.",
      "decorators": [
        "pytest.mark.parametrize(('netrc_contents', 'expected_auth'), [('machine example.com login username password pass\\n', helpers.BasicAuth('username', 'pass'))], indirect=('netrc_contents',))",
        "pytest.mark.usefixtures('netrc_contents')"
      ],
      "arguments": [
        "make_request",
        "expected_auth"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert req.headers[hdrs.AUTHORIZATION] == expected_auth.encode()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_basicauth_from_netrc_present_untrusted_env",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 1465,
      "end_line_number": 1470,
      "source_code": "def test_basicauth_from_netrc_present_untrusted_env(\n    make_request: _RequestMaker,\n) -> None:\n    \"\"\"Test no authorization header is sent via netrc if trust_env is False\"\"\"\n    req = make_request(\"get\", \"http://example.com\", trust_env=False)\n    assert hdrs.AUTHORIZATION not in req.headers",
      "docstring": "Test no authorization header is sent via netrc if trust_env is False",
      "decorators": [
        "pytest.mark.parametrize('netrc_contents', ('machine example.com login username password pass\\n',), indirect=('netrc_contents',))",
        "pytest.mark.usefixtures('netrc_contents')"
      ],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert hdrs.AUTHORIZATION not in req.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_basicauth_from_empty_netrc",
      "module": "test_client_request",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_request.py",
      "line_number": 1479,
      "end_line_number": 1484,
      "source_code": "def test_basicauth_from_empty_netrc(\n    make_request: _RequestMaker,\n) -> None:\n    \"\"\"Test that no Authorization header is sent when netrc is empty\"\"\"\n    req = make_request(\"get\", \"http://example.com\", trust_env=True)\n    assert hdrs.AUTHORIZATION not in req.headers",
      "docstring": "Test that no Authorization header is sent when netrc is empty",
      "decorators": [
        "pytest.mark.parametrize('netrc_contents', ('',), indirect=('netrc_contents',))",
        "pytest.mark.usefixtures('netrc_contents')"
      ],
      "arguments": [
        "make_request"
      ],
      "imports": [
        "asyncio",
        "hashlib",
        "io",
        "pathlib",
        "sys",
        "zlib",
        "http.cookies.BaseCookie",
        "http.cookies.Morsel",
        "http.cookies.SimpleCookie",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Protocol",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "multidict.istr",
        "yarl.URL",
        "aiohttp",
        "aiohttp.BaseConnector",
        "aiohttp.hdrs",
        "aiohttp.helpers",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.client_exceptions.ClientConnectionError",
        "aiohttp.client_reqrep.ClientRequest",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.Fingerprint",
        "aiohttp.client_reqrep._gen_default_accept_encoding",
        "aiohttp.connector.Connection",
        "aiohttp.http.HttpVersion",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.LooseCookies"
      ],
      "fixtures": [],
      "assertions": [
        "assert hdrs.AUTHORIZATION not in req.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "@pytest.fixture\ndef make_request(app: web.Application, protocol: web.RequestHandler[web.Request]) -> _RequestMaker:\n\n    def maker(method: str, path: str, headers: Optional[CIMultiDict[str]]=None, protocols: bool=False) -> web.Request:\n        if headers is None:\n            headers = CIMultiDict({'HOST': 'server.example.com', 'UPGRADE': 'websocket', 'CONNECTION': 'Upgrade', 'SEC-WEBSOCKET-KEY': 'dGhlIHNhbXBsZSBub25jZQ==', 'ORIGIN': 'http://example.com', 'SEC-WEBSOCKET-VERSION': '13'})\n        if protocols:\n            headers['SEC-WEBSOCKET-PROTOCOL'] = 'chat, superchat'\n        return make_mocked_request(method, path, headers, app=app, protocol=protocol)\n    return maker"
        }
      ]
    },
    {
      "name": "test_ctor",
      "module": "test_client_connection",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_connection.py",
      "line_number": 33,
      "end_line_number": 41,
      "source_code": "def test_ctor(\n    connector: BaseConnector,\n    key: ConnectionKey,\n    protocol: ResponseHandler,\n    loop: asyncio.AbstractEventLoop,\n) -> None:\n    conn = Connection(connector, key, protocol, loop)\n    assert conn.protocol is protocol\n    conn.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "connector",
        "key",
        "protocol",
        "loop"
      ],
      "imports": [
        "asyncio",
        "gc",
        "typing.Any",
        "unittest.mock",
        "pytest",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector.BaseConnector",
        "aiohttp.connector.Connection"
      ],
      "fixtures": [],
      "assertions": [
        "assert conn.protocol is protocol"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "conn.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_callbacks_on_close",
      "module": "test_client_connection",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_connection.py",
      "line_number": 44,
      "end_line_number": 59,
      "source_code": "def test_callbacks_on_close(\n    connector: BaseConnector,\n    key: ConnectionKey,\n    protocol: ResponseHandler,\n    loop: asyncio.AbstractEventLoop,\n) -> None:\n    conn = Connection(connector, key, protocol, loop)\n    notified = False\n\n    def cb() -> None:\n        nonlocal notified\n        notified = True\n\n    conn.add_callback(cb)\n    conn.close()\n    assert notified",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "connector",
        "key",
        "protocol",
        "loop"
      ],
      "imports": [
        "asyncio",
        "gc",
        "typing.Any",
        "unittest.mock",
        "pytest",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector.BaseConnector",
        "aiohttp.connector.Connection"
      ],
      "fixtures": [],
      "assertions": [
        "assert notified"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "conn.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_callbacks_on_release",
      "module": "test_client_connection",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_connection.py",
      "line_number": 62,
      "end_line_number": 77,
      "source_code": "def test_callbacks_on_release(\n    connector: BaseConnector,\n    key: ConnectionKey,\n    protocol: ResponseHandler,\n    loop: asyncio.AbstractEventLoop,\n) -> None:\n    conn = Connection(connector, key, protocol, loop)\n    notified = False\n\n    def cb() -> None:\n        nonlocal notified\n        notified = True\n\n    conn.add_callback(cb)\n    conn.release()\n    assert notified",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "connector",
        "key",
        "protocol",
        "loop"
      ],
      "imports": [
        "asyncio",
        "gc",
        "typing.Any",
        "unittest.mock",
        "pytest",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector.BaseConnector",
        "aiohttp.connector.Connection"
      ],
      "fixtures": [],
      "assertions": [
        "assert notified"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_callbacks_exception",
      "module": "test_client_connection",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_connection.py",
      "line_number": 80,
      "end_line_number": 99,
      "source_code": "def test_callbacks_exception(\n    connector: BaseConnector,\n    key: ConnectionKey,\n    protocol: ResponseHandler,\n    loop: asyncio.AbstractEventLoop,\n) -> None:\n    conn = Connection(connector, key, protocol, loop)\n    notified = False\n\n    def cb1() -> None:\n        raise Exception\n\n    def cb2() -> None:\n        nonlocal notified\n        notified = True\n\n    conn.add_callback(cb1)\n    conn.add_callback(cb2)\n    conn.close()\n    assert notified",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "connector",
        "key",
        "protocol",
        "loop"
      ],
      "imports": [
        "asyncio",
        "gc",
        "typing.Any",
        "unittest.mock",
        "pytest",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector.BaseConnector",
        "aiohttp.connector.Connection"
      ],
      "fixtures": [],
      "assertions": [
        "assert notified"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "conn.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_del",
      "module": "test_client_connection",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_connection.py",
      "line_number": 102,
      "end_line_number": 123,
      "source_code": "def test_del(\n    connector: BaseConnector,\n    key: ConnectionKey,\n    protocol: ResponseHandler,\n    loop: mock.Mock,\n) -> None:\n    loop.is_closed.return_value = False\n    conn = Connection(connector, key, protocol, loop)\n    exc_handler = mock.Mock()\n    loop.set_exception_handler(exc_handler)\n\n    with pytest.warns(ResourceWarning):\n        del conn\n        gc.collect()\n\n    connector._release.assert_called_with(key, protocol, should_close=True)  # type: ignore[attr-defined]\n    msg = {\n        \"client_connection\": mock.ANY,  # conn was deleted\n        \"message\": \"Unclosed connection\",\n    }\n    msg[\"source_traceback\"] = mock.ANY\n    loop.call_exception_handler.assert_called_with(msg)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "connector",
        "key",
        "protocol",
        "loop"
      ],
      "imports": [
        "asyncio",
        "gc",
        "typing.Any",
        "unittest.mock",
        "pytest",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector.BaseConnector",
        "aiohttp.connector.Connection"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_close",
      "module": "test_client_connection",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_connection.py",
      "line_number": 126,
      "end_line_number": 137,
      "source_code": "def test_close(\n    connector: BaseConnector,\n    key: ConnectionKey,\n    protocol: ResponseHandler,\n    loop: asyncio.AbstractEventLoop,\n) -> None:\n    conn = Connection(connector, key, protocol, loop)\n    assert not conn.closed\n    conn.close()\n    assert conn._protocol is None\n    connector._release.assert_called_with(key, protocol, should_close=True)  # type: ignore[attr-defined]\n    assert conn.closed",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "connector",
        "key",
        "protocol",
        "loop"
      ],
      "imports": [
        "asyncio",
        "gc",
        "typing.Any",
        "unittest.mock",
        "pytest",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector.BaseConnector",
        "aiohttp.connector.Connection"
      ],
      "fixtures": [],
      "assertions": [
        "assert not conn.closed",
        "assert conn._protocol is None",
        "assert conn.closed"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "conn.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_release",
      "module": "test_client_connection",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_connection.py",
      "line_number": 140,
      "end_line_number": 153,
      "source_code": "def test_release(\n    connector: BaseConnector,\n    key: ConnectionKey,\n    protocol: ResponseHandler,\n    loop: asyncio.AbstractEventLoop,\n) -> None:\n    conn = Connection(connector, key, protocol, loop)\n    assert not conn.closed\n    conn.release()\n    assert protocol.transport is not None\n    assert not protocol.transport.close.called  # type: ignore[attr-defined]\n    assert conn._protocol is None\n    connector._release.assert_called_with(key, protocol, should_close=False)  # type: ignore[attr-defined]\n    assert conn.closed",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "connector",
        "key",
        "protocol",
        "loop"
      ],
      "imports": [
        "asyncio",
        "gc",
        "typing.Any",
        "unittest.mock",
        "pytest",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector.BaseConnector",
        "aiohttp.connector.Connection"
      ],
      "fixtures": [],
      "assertions": [
        "assert not conn.closed",
        "assert protocol.transport is not None",
        "assert not protocol.transport.close.called",
        "assert conn._protocol is None",
        "assert conn.closed"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_release_proto_should_close",
      "module": "test_client_connection",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_connection.py",
      "line_number": 156,
      "end_line_number": 170,
      "source_code": "def test_release_proto_should_close(\n    connector: BaseConnector,\n    key: ConnectionKey,\n    protocol: ResponseHandler,\n    loop: asyncio.AbstractEventLoop,\n) -> None:\n    protocol.should_close = True  # type: ignore[misc]\n    conn = Connection(connector, key, protocol, loop)\n    assert not conn.closed\n    conn.release()\n    assert protocol.transport is not None\n    assert not protocol.transport.close.called  # type: ignore[attr-defined]\n    assert conn._protocol is None\n    connector._release.assert_called_with(key, protocol, should_close=True)  # type: ignore[attr-defined]\n    assert conn.closed",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "connector",
        "key",
        "protocol",
        "loop"
      ],
      "imports": [
        "asyncio",
        "gc",
        "typing.Any",
        "unittest.mock",
        "pytest",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector.BaseConnector",
        "aiohttp.connector.Connection"
      ],
      "fixtures": [],
      "assertions": [
        "assert not conn.closed",
        "assert protocol.transport is not None",
        "assert not protocol.transport.close.called",
        "assert conn._protocol is None",
        "assert conn.closed"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_release_released",
      "module": "test_client_connection",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_connection.py",
      "line_number": 173,
      "end_line_number": 186,
      "source_code": "def test_release_released(\n    connector: BaseConnector,\n    key: ConnectionKey,\n    protocol: ResponseHandler,\n    loop: asyncio.AbstractEventLoop,\n) -> None:\n    conn = Connection(connector, key, protocol, loop)\n    conn.release()\n    connector._release.reset_mock()  # type: ignore[attr-defined]\n    conn.release()\n    assert protocol.transport is not None\n    assert not protocol.transport.close.called  # type: ignore[attr-defined]\n    assert conn._protocol is None\n    assert not connector._release.called",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "connector",
        "key",
        "protocol",
        "loop"
      ],
      "imports": [
        "asyncio",
        "gc",
        "typing.Any",
        "unittest.mock",
        "pytest",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector.BaseConnector",
        "aiohttp.connector.Connection"
      ],
      "fixtures": [],
      "assertions": [
        "assert protocol.transport is not None",
        "assert not protocol.transport.close.called",
        "assert conn._protocol is None",
        "assert not connector._release.called"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_system_route",
      "module": "test_web_urldispatcher",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_urldispatcher.py",
      "line_number": 644,
      "end_line_number": 652,
      "source_code": "def test_system_route() -> None:\n    route = SystemRoute(web.HTTPCreated(reason=\"test\"))\n    with pytest.raises(RuntimeError):\n        route.url_for()\n    assert route.name is None\n    assert route.resource is None\n    assert \"<SystemRoute 201: test>\" == repr(route)\n    assert 201 == route.status\n    assert \"test\" == route.reason",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "functools",
        "os",
        "pathlib",
        "socket",
        "sys",
        "stat.S_IFIFO",
        "stat.S_IMODE",
        "typing.Any",
        "typing.Generator",
        "typing.NoReturn",
        "typing.Optional",
        "pytest",
        "yarl",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.web_urldispatcher.Resource",
        "aiohttp.web_urldispatcher.SystemRoute"
      ],
      "fixtures": [],
      "assertions": [
        "assert route.name is None",
        "assert route.resource is None",
        "assert '<SystemRoute 201: test>' == repr(route)",
        "assert 201 == route.status",
        "assert 'test' == route.reason"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_reuse_last_added_resource",
      "module": "test_web_urldispatcher",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_urldispatcher.py",
      "line_number": 691,
      "end_line_number": 702,
      "source_code": "def test_reuse_last_added_resource(path: str) -> None:\n    # Test that adding a route with the same name and path of the last added\n    # resource doesn't create a new resource.\n    app = web.Application()\n\n    async def handler(request: web.Request) -> web.Response:\n        return web.Response()  # pragma: no cover\n\n    app.router.add_get(path, handler, name=\"a\")\n    app.router.add_post(path, handler, name=\"a\")\n\n    assert len(app.router.resources()) == 1",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('path', ('/a', '/{a}', '/{a:.*}'))"
      ],
      "arguments": [
        "path"
      ],
      "imports": [
        "asyncio",
        "functools",
        "os",
        "pathlib",
        "socket",
        "sys",
        "stat.S_IFIFO",
        "stat.S_IMODE",
        "typing.Any",
        "typing.Generator",
        "typing.NoReturn",
        "typing.Optional",
        "pytest",
        "yarl",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.web_urldispatcher.Resource",
        "aiohttp.web_urldispatcher.SystemRoute"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(app.router.resources()) == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_resource_raw_match",
      "module": "test_web_urldispatcher",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_urldispatcher.py",
      "line_number": 705,
      "end_line_number": 720,
      "source_code": "def test_resource_raw_match() -> None:\n    app = web.Application()\n\n    async def handler(request: web.Request) -> web.Response:\n        return web.Response()  # pragma: no cover\n\n    route = app.router.add_get(\"/a\", handler, name=\"a\")\n    assert route.resource is not None\n    assert route.resource.raw_match(\"/a\")\n\n    route = app.router.add_get(\"/{b}\", handler, name=\"b\")\n    assert route.resource is not None\n    assert route.resource.raw_match(\"/{b}\")\n\n    resource = app.router.add_static(\"/static\", \".\")\n    assert not resource.raw_match(\"/static\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "functools",
        "os",
        "pathlib",
        "socket",
        "sys",
        "stat.S_IFIFO",
        "stat.S_IMODE",
        "typing.Any",
        "typing.Generator",
        "typing.NoReturn",
        "typing.Optional",
        "pytest",
        "yarl",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.web_urldispatcher.Resource",
        "aiohttp.web_urldispatcher.SystemRoute"
      ],
      "fixtures": [],
      "assertions": [
        "assert route.resource is not None",
        "assert route.resource.raw_match('/a')",
        "assert route.resource is not None",
        "assert route.resource.raw_match('/{b}')",
        "assert not resource.raw_match('/static')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_default_loop",
      "module": "test_loop",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_loop.py",
      "line_number": 39,
      "end_line_number": 40,
      "source_code": "def test_default_loop(loop: asyncio.AbstractEventLoop) -> None:\n    assert asyncio.get_event_loop_policy().get_event_loop() is loop",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop"
      ],
      "imports": [
        "asyncio",
        "platform",
        "threading",
        "pytest",
        "aiohttp.web",
        "aiohttp.test_utils.AioHTTPTestCase",
        "aiohttp.test_utils.loop_context"
      ],
      "fixtures": [],
      "assertions": [
        "assert asyncio.get_event_loop_policy().get_event_loop() is loop"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_setup_loop_non_main_thread",
      "module": "test_loop",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_loop.py",
      "line_number": 43,
      "end_line_number": 60,
      "source_code": "def test_setup_loop_non_main_thread() -> None:\n    child_exc = None\n\n    def target() -> None:\n        try:\n            with loop_context() as loop:\n                assert asyncio.get_event_loop_policy().get_event_loop() is loop\n                loop.run_until_complete(test_subprocess_co(loop))\n        except Exception as exc:\n            nonlocal child_exc\n            child_exc = exc\n\n    # Ensures setup_test_loop can be called by pytest-xdist in non-main thread.\n    t = threading.Thread(target=target)\n    t.start()\n    t.join()\n\n    assert child_exc is None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "platform",
        "threading",
        "pytest",
        "aiohttp.web",
        "aiohttp.test_utils.AioHTTPTestCase",
        "aiohttp.test_utils.loop_context"
      ],
      "fixtures": [],
      "assertions": [
        "assert child_exc is None",
        "assert asyncio.get_event_loop_policy().get_event_loop() is loop"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_feed_pause",
      "module": "test_flowcontrol_streams",
      "class_name": "TestFlowControlDataQueue",
      "file_path": "__internal__/data/aiohttp/tests/test_flowcontrol_streams.py",
      "line_number": 120,
      "end_line_number": 124,
      "source_code": "def test_feed_pause(self, buffer: streams.FlowControlDataQueue[str]) -> None:\n        buffer._protocol._reading_paused = False\n        buffer.feed_data(\"x\" * 100)\n\n        assert buffer._protocol.pause_reading.called",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "buffer"
      ],
      "imports": [
        "asyncio",
        "unittest.mock",
        "pytest",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert buffer._protocol.pause_reading.called"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_feed_pause",
      "module": "test_flowcontrol_streams",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_flowcontrol_streams.py",
      "line_number": 120,
      "end_line_number": 124,
      "source_code": "def test_feed_pause(self, buffer: streams.FlowControlDataQueue[str]) -> None:\n        buffer._protocol._reading_paused = False\n        buffer.feed_data(\"x\" * 100)\n\n        assert buffer._protocol.pause_reading.called",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "buffer"
      ],
      "imports": [
        "asyncio",
        "unittest.mock",
        "pytest",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert buffer._protocol.pause_reading.called"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_register_type",
      "module": "test_payload",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_payload.py",
      "line_number": 27,
      "end_line_number": 33,
      "source_code": "def test_register_type(registry: payload.PayloadRegistry) -> None:\n    class TestProvider:\n        pass\n\n    payload.register_payload(Payload, TestProvider)\n    p = payload.get_payload(TestProvider())\n    assert isinstance(p, Payload)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "registry"
      ],
      "imports": [
        "array",
        "io.StringIO",
        "typing.AsyncIterator",
        "typing.Iterator",
        "pytest",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(p, Payload)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_register_unsupported_order",
      "module": "test_payload",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_payload.py",
      "line_number": 36,
      "end_line_number": 43,
      "source_code": "def test_register_unsupported_order(registry: payload.PayloadRegistry) -> None:\n    class TestProvider:\n        pass\n\n    with pytest.raises(ValueError):\n        payload.register_payload(\n            Payload, TestProvider, order=object()  # type: ignore[arg-type]\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "registry"
      ],
      "imports": [
        "array",
        "io.StringIO",
        "typing.AsyncIterator",
        "typing.Iterator",
        "pytest",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_payload_ctor",
      "module": "test_payload",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_payload.py",
      "line_number": 46,
      "end_line_number": 52,
      "source_code": "def test_payload_ctor() -> None:\n    p = Payload(\"test\", encoding=\"utf-8\", filename=\"test.txt\")\n    assert p._value == \"test\"\n    assert p._encoding == \"utf-8\"\n    assert p.size is None\n    assert p.filename == \"test.txt\"\n    assert p.content_type == \"text/plain\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "array",
        "io.StringIO",
        "typing.AsyncIterator",
        "typing.Iterator",
        "pytest",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter"
      ],
      "fixtures": [],
      "assertions": [
        "assert p._value == 'test'",
        "assert p._encoding == 'utf-8'",
        "assert p.size is None",
        "assert p.filename == 'test.txt'",
        "assert p.content_type == 'text/plain'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_payload_content_type",
      "module": "test_payload",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_payload.py",
      "line_number": 55,
      "end_line_number": 57,
      "source_code": "def test_payload_content_type() -> None:\n    p = Payload(\"test\", headers={\"content-type\": \"application/json\"})\n    assert p.content_type == \"application/json\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "array",
        "io.StringIO",
        "typing.AsyncIterator",
        "typing.Iterator",
        "pytest",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter"
      ],
      "fixtures": [],
      "assertions": [
        "assert p.content_type == 'application/json'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_bytes_payload_default_content_type",
      "module": "test_payload",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_payload.py",
      "line_number": 60,
      "end_line_number": 62,
      "source_code": "def test_bytes_payload_default_content_type() -> None:\n    p = payload.BytesPayload(b\"data\")\n    assert p.content_type == \"application/octet-stream\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "array",
        "io.StringIO",
        "typing.AsyncIterator",
        "typing.Iterator",
        "pytest",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter"
      ],
      "fixtures": [],
      "assertions": [
        "assert p.content_type == 'application/octet-stream'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_bytes_payload_explicit_content_type",
      "module": "test_payload",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_payload.py",
      "line_number": 65,
      "end_line_number": 67,
      "source_code": "def test_bytes_payload_explicit_content_type() -> None:\n    p = payload.BytesPayload(b\"data\", content_type=\"application/custom\")\n    assert p.content_type == \"application/custom\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "array",
        "io.StringIO",
        "typing.AsyncIterator",
        "typing.Iterator",
        "pytest",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter"
      ],
      "fixtures": [],
      "assertions": [
        "assert p.content_type == 'application/custom'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_bytes_payload_bad_type",
      "module": "test_payload",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_payload.py",
      "line_number": 70,
      "end_line_number": 72,
      "source_code": "def test_bytes_payload_bad_type() -> None:\n    with pytest.raises(TypeError):\n        payload.BytesPayload(object())",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "array",
        "io.StringIO",
        "typing.AsyncIterator",
        "typing.Iterator",
        "pytest",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_bytes_payload_memoryview_correct_size",
      "module": "test_payload",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_payload.py",
      "line_number": 75,
      "end_line_number": 78,
      "source_code": "def test_bytes_payload_memoryview_correct_size() -> None:\n    mv = memoryview(array.array(\"H\", [1, 2, 3]))\n    p = payload.BytesPayload(mv)\n    assert p.size == 6",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "array",
        "io.StringIO",
        "typing.AsyncIterator",
        "typing.Iterator",
        "pytest",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter"
      ],
      "fixtures": [],
      "assertions": [
        "assert p.size == 6"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_string_payload",
      "module": "test_payload",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_payload.py",
      "line_number": 81,
      "end_line_number": 92,
      "source_code": "def test_string_payload() -> None:\n    p = payload.StringPayload(\"test\")\n    assert p.encoding == \"utf-8\"\n    assert p.content_type == \"text/plain; charset=utf-8\"\n\n    p = payload.StringPayload(\"test\", encoding=\"koi8-r\")\n    assert p.encoding == \"koi8-r\"\n    assert p.content_type == \"text/plain; charset=koi8-r\"\n\n    p = payload.StringPayload(\"test\", content_type=\"text/plain; charset=koi8-r\")\n    assert p.encoding == \"koi8-r\"\n    assert p.content_type == \"text/plain; charset=koi8-r\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "array",
        "io.StringIO",
        "typing.AsyncIterator",
        "typing.Iterator",
        "pytest",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter"
      ],
      "fixtures": [],
      "assertions": [
        "assert p.encoding == 'utf-8'",
        "assert p.content_type == 'text/plain; charset=utf-8'",
        "assert p.encoding == 'koi8-r'",
        "assert p.content_type == 'text/plain; charset=koi8-r'",
        "assert p.encoding == 'koi8-r'",
        "assert p.content_type == 'text/plain; charset=koi8-r'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_string_io_payload",
      "module": "test_payload",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_payload.py",
      "line_number": 95,
      "end_line_number": 100,
      "source_code": "def test_string_io_payload() -> None:\n    s = StringIO(\"\u0171\" * 5000)\n    p = payload.StringIOPayload(s)\n    assert p.encoding == \"utf-8\"\n    assert p.content_type == \"text/plain; charset=utf-8\"\n    assert p.size == 10000",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "array",
        "io.StringIO",
        "typing.AsyncIterator",
        "typing.Iterator",
        "pytest",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter"
      ],
      "fixtures": [],
      "assertions": [
        "assert p.encoding == 'utf-8'",
        "assert p.content_type == 'text/plain; charset=utf-8'",
        "assert p.size == 10000"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_async_iterable_payload_default_content_type",
      "module": "test_payload",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_payload.py",
      "line_number": 103,
      "end_line_number": 109,
      "source_code": "def test_async_iterable_payload_default_content_type() -> None:\n    async def gen() -> AsyncIterator[bytes]:\n        return\n        yield b\"abc\"  # type: ignore[unreachable]  # pragma: no cover\n\n    p = payload.AsyncIterablePayload(gen())\n    assert p.content_type == \"application/octet-stream\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "array",
        "io.StringIO",
        "typing.AsyncIterator",
        "typing.Iterator",
        "pytest",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter"
      ],
      "fixtures": [],
      "assertions": [
        "assert p.content_type == 'application/octet-stream'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_async_iterable_payload_explicit_content_type",
      "module": "test_payload",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_payload.py",
      "line_number": 112,
      "end_line_number": 118,
      "source_code": "def test_async_iterable_payload_explicit_content_type() -> None:\n    async def gen() -> AsyncIterator[bytes]:\n        return\n        yield b\"abc\"  # type: ignore[unreachable]  # pragma: no cover\n\n    p = payload.AsyncIterablePayload(gen(), content_type=\"application/custom\")\n    assert p.content_type == \"application/custom\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "array",
        "io.StringIO",
        "typing.AsyncIterator",
        "typing.Iterator",
        "pytest",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter"
      ],
      "fixtures": [],
      "assertions": [
        "assert p.content_type == 'application/custom'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_async_iterable_payload_not_async_iterable",
      "module": "test_payload",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_payload.py",
      "line_number": 121,
      "end_line_number": 123,
      "source_code": "def test_async_iterable_payload_not_async_iterable() -> None:\n    with pytest.raises(TypeError):\n        payload.AsyncIterablePayload(object())",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "array",
        "io.StringIO",
        "typing.AsyncIterator",
        "typing.Iterator",
        "pytest",
        "aiohttp.payload",
        "aiohttp.abc.AbstractStreamWriter"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_run_app_http",
      "module": "test_run_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 109,
      "end_line_number": 122,
      "source_code": "def test_run_app_http(patched_loop: asyncio.AbstractEventLoop) -> None:\n    app = web.Application()\n    startup_handler = make_mocked_coro()\n    app.on_startup.append(startup_handler)\n    cleanup_handler = make_mocked_coro()\n    app.on_cleanup.append(cleanup_handler)\n\n    web.run_app(app, print=stopper(patched_loop), loop=patched_loop)\n\n    patched_loop.create_server.assert_called_with(  # type: ignore[attr-defined]\n        mock.ANY, None, 8080, ssl=None, backlog=128, reuse_address=None, reuse_port=None\n    )\n    startup_handler.assert_called_once_with(app)\n    cleanup_handler.assert_called_once_with(app)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "patched_loop"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "web.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        },
        {
          "name": "stopper",
          "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f"
        }
      ]
    },
    {
      "name": "test_run_app_close_loop",
      "module": "test_run_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 125,
      "end_line_number": 132,
      "source_code": "def test_run_app_close_loop(patched_loop: asyncio.AbstractEventLoop) -> None:\n    app = web.Application()\n    web.run_app(app, print=stopper(patched_loop), loop=patched_loop)\n\n    patched_loop.create_server.assert_called_with(  # type: ignore[attr-defined]\n        mock.ANY, None, 8080, ssl=None, backlog=128, reuse_address=None, reuse_port=None\n    )\n    assert patched_loop.is_closed()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "patched_loop"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert patched_loop.is_closed()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "web.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        },
        {
          "name": "stopper",
          "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f"
        }
      ]
    },
    {
      "name": "test_run_app_mixed_bindings",
      "module": "test_run_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 445,
      "end_line_number": 455,
      "source_code": "def test_run_app_mixed_bindings(\n    run_app_kwargs: Dict[str, Any],\n    expected_server_calls: List[mock._Call],\n    expected_unix_server_calls: List[mock._Call],\n    patched_loop: asyncio.AbstractEventLoop,\n) -> None:\n    app = web.Application()\n    web.run_app(app, print=stopper(patched_loop), **run_app_kwargs, loop=patched_loop)\n\n    assert patched_loop.create_unix_server.mock_calls == expected_unix_server_calls  # type: ignore[attr-defined]\n    assert patched_loop.create_server.mock_calls == expected_server_calls",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('run_app_kwargs, expected_server_calls, expected_unix_server_calls', mixed_bindings_test_params, ids=mixed_bindings_test_ids)"
      ],
      "arguments": [
        "run_app_kwargs",
        "expected_server_calls",
        "expected_unix_server_calls",
        "patched_loop"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert patched_loop.create_unix_server.mock_calls == expected_unix_server_calls",
        "assert patched_loop.create_server.mock_calls == expected_server_calls"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "web.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        },
        {
          "name": "stopper",
          "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f"
        }
      ]
    },
    {
      "name": "test_run_app_https",
      "module": "test_run_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 458,
      "end_line_number": 474,
      "source_code": "def test_run_app_https(patched_loop: asyncio.AbstractEventLoop) -> None:\n    app = web.Application()\n\n    ssl_context = ssl.create_default_context()\n    web.run_app(\n        app, ssl_context=ssl_context, print=stopper(patched_loop), loop=patched_loop\n    )\n\n    patched_loop.create_server.assert_called_with(  # type: ignore[attr-defined]\n        mock.ANY,\n        None,\n        8443,\n        ssl=ssl_context,\n        backlog=128,\n        reuse_address=None,\n        reuse_port=None,\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "patched_loop"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "web.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        },
        {
          "name": "stopper",
          "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f"
        }
      ]
    },
    {
      "name": "test_run_app_nondefault_host_port",
      "module": "test_run_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 477,
      "end_line_number": 490,
      "source_code": "def test_run_app_nondefault_host_port(\n    patched_loop: asyncio.AbstractEventLoop, aiohttp_unused_port: Callable[[], int]\n) -> None:\n    port = aiohttp_unused_port()\n    host = \"127.0.0.1\"\n\n    app = web.Application()\n    web.run_app(\n        app, host=host, port=port, print=stopper(patched_loop), loop=patched_loop\n    )\n\n    patched_loop.create_server.assert_called_with(  # type: ignore[attr-defined]\n        mock.ANY, host, port, ssl=None, backlog=128, reuse_address=None, reuse_port=None\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "patched_loop",
        "aiohttp_unused_port"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "web.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        },
        {
          "name": "stopper",
          "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f"
        }
      ]
    },
    {
      "name": "test_run_app_multiple_hosts",
      "module": "test_run_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 493,
      "end_line_number": 511,
      "source_code": "def test_run_app_multiple_hosts(patched_loop: asyncio.AbstractEventLoop) -> None:\n    hosts = (\"127.0.0.1\", \"127.0.0.2\")\n\n    app = web.Application()\n    web.run_app(app, host=hosts, print=stopper(patched_loop), loop=patched_loop)\n\n    calls = map(\n        lambda h: mock.call(\n            mock.ANY,\n            h,\n            8080,\n            ssl=None,\n            backlog=128,\n            reuse_address=None,\n            reuse_port=None,\n        ),\n        hosts,\n    )\n    patched_loop.create_server.assert_has_calls(calls)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "patched_loop"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "web.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        },
        {
          "name": "stopper",
          "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f"
        }
      ]
    },
    {
      "name": "test_run_app_custom_backlog",
      "module": "test_run_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 514,
      "end_line_number": 520,
      "source_code": "def test_run_app_custom_backlog(patched_loop: asyncio.AbstractEventLoop) -> None:\n    app = web.Application()\n    web.run_app(app, backlog=10, print=stopper(patched_loop), loop=patched_loop)\n\n    patched_loop.create_server.assert_called_with(  # type: ignore[attr-defined]\n        mock.ANY, None, 8080, ssl=None, backlog=10, reuse_address=None, reuse_port=None\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "patched_loop"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "web.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        },
        {
          "name": "stopper",
          "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f"
        }
      ]
    },
    {
      "name": "test_run_app_custom_backlog_unix",
      "module": "test_run_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 523,
      "end_line_number": 535,
      "source_code": "def test_run_app_custom_backlog_unix(patched_loop: asyncio.AbstractEventLoop) -> None:\n    app = web.Application()\n    web.run_app(\n        app,\n        path=\"/tmp/tmpsock.sock\",\n        backlog=10,\n        print=stopper(patched_loop),\n        loop=patched_loop,\n    )\n\n    patched_loop.create_unix_server.assert_called_with(  # type: ignore[attr-defined]\n        mock.ANY, \"/tmp/tmpsock.sock\", ssl=None, backlog=10\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "patched_loop"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "web.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        },
        {
          "name": "stopper",
          "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f"
        }
      ]
    },
    {
      "name": "test_run_app_http_unix_socket",
      "module": "test_run_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 539,
      "end_line_number": 550,
      "source_code": "def test_run_app_http_unix_socket(\n    patched_loop: asyncio.AbstractEventLoop, unix_sockname: str\n) -> None:\n    app = web.Application()\n\n    printer = mock.Mock(wraps=stopper(patched_loop))\n    web.run_app(app, path=unix_sockname, print=printer, loop=patched_loop)\n\n    patched_loop.create_unix_server.assert_called_with(  # type: ignore[attr-defined]\n        mock.ANY, unix_sockname, ssl=None, backlog=128\n    )\n    assert f\"http://unix:{unix_sockname}:\" in printer.call_args[0][0]",
      "docstring": null,
      "decorators": [
        "skip_if_no_unix_socks"
      ],
      "arguments": [
        "patched_loop",
        "unix_sockname"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert f'http://unix:{unix_sockname}:' in printer.call_args[0][0]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock(wraps=stopper(patched_loop))"
      ],
      "methods_under_test": [
        {
          "name": "web.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        },
        {
          "name": "stopper",
          "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f"
        }
      ]
    },
    {
      "name": "test_run_app_https_unix_socket",
      "module": "test_run_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 554,
      "end_line_number": 572,
      "source_code": "def test_run_app_https_unix_socket(\n    patched_loop: asyncio.AbstractEventLoop, unix_sockname: str\n) -> None:\n    app = web.Application()\n\n    ssl_context = ssl.create_default_context()\n    printer = mock.Mock(wraps=stopper(patched_loop))\n    web.run_app(\n        app,\n        path=unix_sockname,\n        ssl_context=ssl_context,\n        print=printer,\n        loop=patched_loop,\n    )\n\n    patched_loop.create_unix_server.assert_called_with(  # type: ignore[attr-defined]\n        mock.ANY, unix_sockname, ssl=ssl_context, backlog=128\n    )\n    assert f\"https://unix:{unix_sockname}:\" in printer.call_args[0][0]",
      "docstring": null,
      "decorators": [
        "skip_if_no_unix_socks"
      ],
      "arguments": [
        "patched_loop",
        "unix_sockname"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert f'https://unix:{unix_sockname}:' in printer.call_args[0][0]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock(wraps=stopper(patched_loop))"
      ],
      "methods_under_test": [
        {
          "name": "web.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        },
        {
          "name": "stopper",
          "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f"
        }
      ]
    },
    {
      "name": "test_run_app_abstract_linux_socket",
      "module": "test_run_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 577,
      "end_line_number": 589,
      "source_code": "def test_run_app_abstract_linux_socket(patched_loop: asyncio.AbstractEventLoop) -> None:\n    sock_path = b\"\\x00\" + uuid4().hex.encode(\"ascii\")\n    app = web.Application()\n    web.run_app(\n        app,\n        path=sock_path.decode(\"ascii\", \"ignore\"),\n        print=stopper(patched_loop),\n        loop=patched_loop,\n    )\n\n    patched_loop.create_unix_server.assert_called_with(  # type: ignore[attr-defined]\n        mock.ANY, sock_path.decode(\"ascii\"), ssl=None, backlog=128\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(not hasattr(socket, 'AF_UNIX'), reason='requires UNIX sockets')",
        "skip_if_no_abstract_paths"
      ],
      "arguments": [
        "patched_loop"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "web.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        },
        {
          "name": "sock_path.decode",
          "body": "def decode(self, encoding: str='utf-8', errors: str='strict') -> str:\n    assert False"
        },
        {
          "name": "sock_path.decode",
          "body": "def decode(self, encoding: str='utf-8', errors: str='strict') -> str:\n    assert False"
        },
        {
          "name": "stopper",
          "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f"
        }
      ]
    },
    {
      "name": "test_run_app_preexisting_inet_socket",
      "module": "test_run_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 592,
      "end_line_number": 608,
      "source_code": "def test_run_app_preexisting_inet_socket(\n    patched_loop: asyncio.AbstractEventLoop, mocker: MockerFixture\n) -> None:\n    app = web.Application()\n\n    sock = socket.socket()\n    with contextlib.closing(sock):\n        sock.bind((\"127.0.0.1\", 0))\n        _, port = sock.getsockname()\n\n        printer = mock.Mock(wraps=stopper(patched_loop))\n        web.run_app(app, sock=sock, print=printer, loop=patched_loop)\n\n        patched_loop.create_server.assert_called_with(  # type: ignore[attr-defined]\n            mock.ANY, sock=sock, backlog=128, ssl=None\n        )\n        assert f\"http://127.0.0.1:{port}\" in printer.call_args[0][0]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "patched_loop",
        "mocker"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert f'http://127.0.0.1:{port}' in printer.call_args[0][0]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock(wraps=stopper(patched_loop))"
      ],
      "methods_under_test": [
        {
          "name": "web.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        },
        {
          "name": "stopper",
          "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f"
        }
      ]
    },
    {
      "name": "test_run_app_preexisting_inet6_socket",
      "module": "test_run_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 612,
      "end_line_number": 628,
      "source_code": "def test_run_app_preexisting_inet6_socket(\n    patched_loop: asyncio.AbstractEventLoop,\n) -> None:\n    app = web.Application()\n\n    sock = socket.socket(socket.AF_INET6)\n    with contextlib.closing(sock):\n        sock.bind((\"::1\", 0))\n        port = sock.getsockname()[1]\n\n        printer = mock.Mock(wraps=stopper(patched_loop))\n        web.run_app(app, sock=sock, print=printer, loop=patched_loop)\n\n        patched_loop.create_server.assert_called_with(  # type: ignore[attr-defined]\n            mock.ANY, sock=sock, backlog=128, ssl=None\n        )\n        assert f\"http://[::1]:{port}\" in printer.call_args[0][0]",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(not HAS_IPV6, reason='IPv6 is not available')"
      ],
      "arguments": [
        "patched_loop"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert f'http://[::1]:{port}' in printer.call_args[0][0]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock(wraps=stopper(patched_loop))"
      ],
      "methods_under_test": [
        {
          "name": "web.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        },
        {
          "name": "stopper",
          "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f"
        }
      ]
    },
    {
      "name": "test_run_app_preexisting_unix_socket",
      "module": "test_run_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 632,
      "end_line_number": 649,
      "source_code": "def test_run_app_preexisting_unix_socket(\n    patched_loop: asyncio.AbstractEventLoop, mocker: MockerFixture\n) -> None:\n    app = web.Application()\n\n    sock_path = \"/tmp/test_preexisting_sock1\"\n    sock = socket.socket(socket.AF_UNIX)\n    with contextlib.closing(sock):\n        sock.bind(sock_path)\n        os.unlink(sock_path)\n\n        printer = mock.Mock(wraps=stopper(patched_loop))\n        web.run_app(app, sock=sock, print=printer, loop=patched_loop)\n\n        patched_loop.create_server.assert_called_with(  # type: ignore[attr-defined]\n            mock.ANY, sock=sock, backlog=128, ssl=None\n        )\n        assert f\"http://unix:{sock_path}:\" in printer.call_args[0][0]",
      "docstring": null,
      "decorators": [
        "skip_if_no_unix_socks"
      ],
      "arguments": [
        "patched_loop",
        "mocker"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert f'http://unix:{sock_path}:' in printer.call_args[0][0]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock(wraps=stopper(patched_loop))"
      ],
      "methods_under_test": [
        {
          "name": "web.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        },
        {
          "name": "stopper",
          "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f"
        }
      ]
    },
    {
      "name": "test_run_app_multiple_preexisting_sockets",
      "module": "test_run_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 652,
      "end_line_number": 675,
      "source_code": "def test_run_app_multiple_preexisting_sockets(\n    patched_loop: asyncio.AbstractEventLoop,\n) -> None:\n    app = web.Application()\n\n    sock1 = socket.socket()\n    sock2 = socket.socket()\n    with contextlib.closing(sock1), contextlib.closing(sock2):\n        sock1.bind((\"localhost\", 0))\n        _, port1 = sock1.getsockname()\n        sock2.bind((\"localhost\", 0))\n        _, port2 = sock2.getsockname()\n\n        printer = mock.Mock(wraps=stopper(patched_loop))\n        web.run_app(app, sock=(sock1, sock2), print=printer, loop=patched_loop)\n\n        patched_loop.create_server.assert_has_calls(  # type: ignore[attr-defined]\n            [\n                mock.call(mock.ANY, sock=sock1, backlog=128, ssl=None),\n                mock.call(mock.ANY, sock=sock2, backlog=128, ssl=None),\n            ]\n        )\n        assert f\"http://127.0.0.1:{port1}\" in printer.call_args[0][0]\n        assert f\"http://127.0.0.1:{port2}\" in printer.call_args[0][0]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "patched_loop"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert f'http://127.0.0.1:{port1}' in printer.call_args[0][0]",
        "assert f'http://127.0.0.1:{port2}' in printer.call_args[0][0]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock(wraps=stopper(patched_loop))"
      ],
      "methods_under_test": [
        {
          "name": "web.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        },
        {
          "name": "stopper",
          "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f"
        }
      ]
    },
    {
      "name": "test_sigint",
      "module": "test_run_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 686,
      "end_line_number": 697,
      "source_code": "def test_sigint() -> None:\n    skip_if_on_windows()\n\n    with subprocess.Popen(\n        [sys.executable, \"-u\", \"-c\", _script_test_signal],\n        stdout=subprocess.PIPE,\n    ) as proc:\n        for line in proc.stdout:  # type: ignore[union-attr]\n            if line.startswith(b\"======== Running on\"):\n                break\n        proc.send_signal(signal.SIGINT)\n        assert proc.wait() == 0",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert proc.wait() == 0"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "skip_if_on_windows",
          "body": "def skip_if_on_windows() -> None:\n    if platform.system() == 'Windows':\n        pytest.skip('the test is not valid for Windows')"
        }
      ]
    },
    {
      "name": "test_sigterm",
      "module": "test_run_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 700,
      "end_line_number": 711,
      "source_code": "def test_sigterm() -> None:\n    skip_if_on_windows()\n\n    with subprocess.Popen(\n        [sys.executable, \"-u\", \"-c\", _script_test_signal],\n        stdout=subprocess.PIPE,\n    ) as proc:\n        for line in proc.stdout:  # type: ignore[union-attr]\n            if line.startswith(b\"======== Running on\"):\n                break\n        proc.terminate()\n        assert proc.wait() == 0",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert proc.wait() == 0"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "skip_if_on_windows",
          "body": "def skip_if_on_windows() -> None:\n    if platform.system() == 'Windows':\n        pytest.skip('the test is not valid for Windows')"
        }
      ]
    },
    {
      "name": "test_startup_cleanup_signals_even_on_failure",
      "module": "test_run_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 714,
      "end_line_number": 729,
      "source_code": "def test_startup_cleanup_signals_even_on_failure(\n    patched_loop: asyncio.AbstractEventLoop,\n) -> None:\n    patched_loop.create_server.side_effect = RuntimeError()  # type: ignore[attr-defined]\n\n    app = web.Application()\n    startup_handler = make_mocked_coro()\n    app.on_startup.append(startup_handler)\n    cleanup_handler = make_mocked_coro()\n    app.on_cleanup.append(cleanup_handler)\n\n    with pytest.raises(RuntimeError):\n        web.run_app(app, print=stopper(patched_loop), loop=patched_loop)\n\n    startup_handler.assert_called_once_with(app)\n    cleanup_handler.assert_called_once_with(app)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "patched_loop"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "web.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        },
        {
          "name": "stopper",
          "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f"
        }
      ]
    },
    {
      "name": "test_run_app_coro",
      "module": "test_run_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 732,
      "end_line_number": 752,
      "source_code": "def test_run_app_coro(patched_loop: asyncio.AbstractEventLoop) -> None:\n    startup_handler = cleanup_handler = None\n\n    async def make_app() -> web.Application:\n        nonlocal startup_handler, cleanup_handler\n        app = web.Application()\n        startup_handler = make_mocked_coro()\n        app.on_startup.append(startup_handler)\n        cleanup_handler = make_mocked_coro()\n        app.on_cleanup.append(cleanup_handler)\n        return app\n\n    web.run_app(make_app(), print=stopper(patched_loop), loop=patched_loop)\n\n    patched_loop.create_server.assert_called_with(  # type: ignore[attr-defined]\n        mock.ANY, None, 8080, ssl=None, backlog=128, reuse_address=None, reuse_port=None\n    )\n    assert startup_handler is not None\n    assert cleanup_handler is not None\n    startup_handler.assert_called_once_with(mock.ANY)\n    cleanup_handler.assert_called_once_with(mock.ANY)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "patched_loop"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert startup_handler is not None",
        "assert cleanup_handler is not None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "web.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        },
        {
          "name": "stopper",
          "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f"
        }
      ]
    },
    {
      "name": "test_run_app_default_logger",
      "module": "test_run_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 755,
      "end_line_number": 777,
      "source_code": "def test_run_app_default_logger(\n    monkeypatch: pytest.MonkeyPatch, patched_loop: asyncio.AbstractEventLoop\n) -> None:\n    logger = access_logger\n    attrs = {\n        \"hasHandlers.return_value\": False,\n        \"level\": logging.NOTSET,\n        \"name\": \"aiohttp.access\",\n    }\n    mock_logger = mock.create_autospec(logger, name=\"mock_access_logger\")\n    mock_logger.configure_mock(**attrs)\n\n    app = web.Application()\n    web.run_app(\n        app,\n        debug=True,\n        print=stopper(patched_loop),\n        access_log=mock_logger,\n        loop=patched_loop,\n    )\n    mock_logger.setLevel.assert_any_call(logging.DEBUG)\n    mock_logger.hasHandlers.assert_called_with()\n    assert isinstance(mock_logger.addHandler.call_args[0][0], logging.StreamHandler)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch",
        "patched_loop"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(mock_logger.addHandler.call_args[0][0], logging.StreamHandler)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "web.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        },
        {
          "name": "stopper",
          "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f"
        }
      ]
    },
    {
      "name": "test_run_app_default_logger_setup_requires_debug",
      "module": "test_run_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 780,
      "end_line_number": 802,
      "source_code": "def test_run_app_default_logger_setup_requires_debug(\n    patched_loop: asyncio.AbstractEventLoop,\n) -> None:\n    logger = access_logger\n    attrs = {\n        \"hasHandlers.return_value\": False,\n        \"level\": logging.NOTSET,\n        \"name\": \"aiohttp.access\",\n    }\n    mock_logger = mock.create_autospec(logger, name=\"mock_access_logger\")\n    mock_logger.configure_mock(**attrs)\n\n    app = web.Application()\n    web.run_app(\n        app,\n        debug=False,\n        print=stopper(patched_loop),\n        access_log=mock_logger,\n        loop=patched_loop,\n    )\n    mock_logger.setLevel.assert_not_called()\n    mock_logger.hasHandlers.assert_not_called()\n    mock_logger.addHandler.assert_not_called()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "patched_loop"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "web.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        },
        {
          "name": "stopper",
          "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f"
        }
      ]
    },
    {
      "name": "test_run_app_default_logger_setup_requires_default_logger",
      "module": "test_run_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 805,
      "end_line_number": 827,
      "source_code": "def test_run_app_default_logger_setup_requires_default_logger(\n    patched_loop: asyncio.AbstractEventLoop,\n) -> None:\n    logger = access_logger\n    attrs = {\n        \"hasHandlers.return_value\": False,\n        \"level\": logging.NOTSET,\n        \"name\": None,\n    }\n    mock_logger = mock.create_autospec(logger, name=\"mock_access_logger\")\n    mock_logger.configure_mock(**attrs)\n\n    app = web.Application()\n    web.run_app(\n        app,\n        debug=True,\n        print=stopper(patched_loop),\n        access_log=mock_logger,\n        loop=patched_loop,\n    )\n    mock_logger.setLevel.assert_not_called()\n    mock_logger.hasHandlers.assert_not_called()\n    mock_logger.addHandler.assert_not_called()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "patched_loop"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "web.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        },
        {
          "name": "stopper",
          "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f"
        }
      ]
    },
    {
      "name": "test_run_app_default_logger_setup_only_if_unconfigured",
      "module": "test_run_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 830,
      "end_line_number": 852,
      "source_code": "def test_run_app_default_logger_setup_only_if_unconfigured(\n    patched_loop: asyncio.AbstractEventLoop,\n) -> None:\n    logger = access_logger\n    attrs = {\n        \"hasHandlers.return_value\": True,\n        \"level\": None,\n        \"name\": \"aiohttp.access\",\n    }\n    mock_logger = mock.create_autospec(logger, name=\"mock_access_logger\")\n    mock_logger.configure_mock(**attrs)\n\n    app = web.Application()\n    web.run_app(\n        app,\n        debug=True,\n        print=stopper(patched_loop),\n        access_log=mock_logger,\n        loop=patched_loop,\n    )\n    mock_logger.setLevel.assert_not_called()\n    mock_logger.hasHandlers.assert_called_with()\n    mock_logger.addHandler.assert_not_called()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "patched_loop"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "web.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        },
        {
          "name": "stopper",
          "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f"
        }
      ]
    },
    {
      "name": "test_run_app_cancels_all_pending_tasks",
      "module": "test_run_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 855,
      "end_line_number": 870,
      "source_code": "def test_run_app_cancels_all_pending_tasks(\n    patched_loop: asyncio.AbstractEventLoop,\n) -> None:\n    app = web.Application()\n    task = None\n\n    async def on_startup(app: web.Application) -> None:\n        nonlocal task\n        loop = asyncio.get_event_loop()\n        task = loop.create_task(asyncio.sleep(1000))\n\n    app.on_startup.append(on_startup)\n\n    web.run_app(app, print=stopper(patched_loop), loop=patched_loop)\n    assert task is not None\n    assert task.cancelled()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "patched_loop"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert task is not None",
        "assert task.cancelled()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "web.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        },
        {
          "name": "stopper",
          "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f"
        }
      ]
    },
    {
      "name": "test_run_app_cancels_done_tasks",
      "module": "test_run_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 873,
      "end_line_number": 889,
      "source_code": "def test_run_app_cancels_done_tasks(patched_loop: asyncio.AbstractEventLoop) -> None:\n    app = web.Application()\n    task = None\n\n    async def coro() -> int:\n        return 123\n\n    async def on_startup(app: web.Application) -> None:\n        nonlocal task\n        loop = asyncio.get_event_loop()\n        task = loop.create_task(coro())\n\n    app.on_startup.append(on_startup)\n\n    web.run_app(app, print=stopper(patched_loop), loop=patched_loop)\n    assert task is not None\n    assert task.done()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "patched_loop"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert task is not None",
        "assert task.done()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "web.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        },
        {
          "name": "task.done",
          "body": "def done(self) -> bool:\n    return True"
        },
        {
          "name": "stopper",
          "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f"
        }
      ]
    },
    {
      "name": "test_run_app_cancels_failed_tasks",
      "module": "test_run_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 892,
      "end_line_number": 923,
      "source_code": "def test_run_app_cancels_failed_tasks(patched_loop: asyncio.AbstractEventLoop) -> None:\n    app = web.Application()\n    task = None\n\n    exc = RuntimeError(\"FAIL\")\n\n    async def fail() -> None:\n        try:\n            await asyncio.sleep(1000)\n        except asyncio.CancelledError:\n            raise exc\n\n    async def on_startup(app: web.Application) -> None:\n        nonlocal task\n        loop = asyncio.get_event_loop()\n        task = loop.create_task(fail())\n        await asyncio.sleep(0.01)\n\n    app.on_startup.append(on_startup)\n\n    exc_handler = mock.Mock()\n    patched_loop.set_exception_handler(exc_handler)\n    web.run_app(app, print=stopper(patched_loop), loop=patched_loop)\n    assert task is not None\n    assert task.done()\n\n    msg = {\n        \"message\": \"unhandled exception during asyncio.run() shutdown\",\n        \"exception\": exc,\n        \"task\": task,\n    }\n    exc_handler.assert_called_with(patched_loop, msg)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "patched_loop"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert task is not None",
        "assert task.done()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": [
        {
          "name": "web.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        },
        {
          "name": "task.done",
          "body": "def done(self) -> bool:\n    return True"
        },
        {
          "name": "stopper",
          "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f"
        }
      ]
    },
    {
      "name": "test_run_app_keepalive_timeout",
      "module": "test_run_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 926,
      "end_line_number": 947,
      "source_code": "def test_run_app_keepalive_timeout(\n    patched_loop: asyncio.AbstractEventLoop,\n    mocker: MockerFixture,\n    monkeypatch: pytest.MonkeyPatch,\n) -> None:\n    new_timeout = 1234\n    base_runner_init_orig = BaseRunner.__init__\n\n    def base_runner_init_spy(\n        self: BaseRunner[web.Request], *args: Any, **kwargs: Any\n    ) -> None:\n        assert kwargs[\"keepalive_timeout\"] == new_timeout\n        base_runner_init_orig(self, *args, **kwargs)\n\n    app = web.Application()\n    monkeypatch.setattr(BaseRunner, \"__init__\", base_runner_init_spy)\n    web.run_app(\n        app,\n        keepalive_timeout=new_timeout,\n        print=stopper(patched_loop),\n        loop=patched_loop,\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "patched_loop",
        "mocker",
        "monkeypatch"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert kwargs['keepalive_timeout'] == new_timeout"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "web.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        },
        {
          "name": "stopper",
          "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f"
        }
      ]
    },
    {
      "name": "test_run_app_context_vars",
      "module": "test_run_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 950,
      "end_line_number": 979,
      "source_code": "def test_run_app_context_vars(patched_loop: asyncio.AbstractEventLoop) -> None:\n    from contextvars import ContextVar\n\n    count = 0\n    VAR = ContextVar(\"VAR\", default=\"default\")\n\n    async def on_startup(app: web.Application) -> None:\n        nonlocal count\n        assert \"init\" == VAR.get()\n        VAR.set(\"on_startup\")\n        count += 1\n\n    async def on_cleanup(app: web.Application) -> None:\n        nonlocal count\n        assert \"on_startup\" == VAR.get()\n        count += 1\n\n    async def init() -> web.Application:\n        nonlocal count\n        assert \"default\" == VAR.get()\n        VAR.set(\"init\")\n        app = web.Application()\n\n        app.on_startup.append(on_startup)\n        app.on_cleanup.append(on_cleanup)\n        count += 1\n        return app\n\n    web.run_app(init(), print=stopper(patched_loop), loop=patched_loop)\n    assert count == 3",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "patched_loop"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert count == 3",
        "assert 'init' == VAR.get()",
        "assert 'on_startup' == VAR.get()",
        "assert 'default' == VAR.get()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "web.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        },
        {
          "name": "stopper",
          "body": "def stopper(loop: asyncio.AbstractEventLoop) -> Callable[[], None]:\n\n    def raiser() -> NoReturn:\n        raise KeyboardInterrupt\n\n    def f(*args: object) -> None:\n        loop.call_soon(raiser)\n    return f"
        }
      ]
    },
    {
      "name": "test_run_app_raises_exception",
      "module": "test_run_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 982,
      "end_line_number": 996,
      "source_code": "def test_run_app_raises_exception(patched_loop: asyncio.AbstractEventLoop) -> None:\n    async def context(app: web.Application) -> AsyncIterator[None]:\n        raise RuntimeError(\"foo\")\n        yield  # type: ignore[unreachable]  # pragma: no cover\n\n    app = web.Application()\n    app.cleanup_ctx.append(context)\n\n    with mock.patch.object(\n        patched_loop, \"call_exception_handler\", autospec=True, spec_set=True\n    ) as m:\n        with pytest.raises(RuntimeError, match=\"foo\"):\n            web.run_app(app, loop=patched_loop)\n\n    assert not m.called",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "patched_loop"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert not m.called"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "web.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        }
      ]
    },
    {
      "name": "test_shutdown_wait_for_handler",
      "module": "test_run_app",
      "class_name": "TestShutdown",
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 1077,
      "end_line_number": 1093,
      "source_code": "def test_shutdown_wait_for_handler(\n        self, aiohttp_unused_port: Callable[[], int]\n    ) -> None:\n        port = aiohttp_unused_port()\n        finished = False\n\n        async def task() -> None:\n            nonlocal finished\n            await asyncio.sleep(2)\n            finished = True\n\n        t, connection_count = self.run_app(port, 3, task)\n\n        assert finished is True\n        assert t.done()\n        assert not t.cancelled()\n        assert connection_count == 0",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "aiohttp_unused_port"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert finished is True",
        "assert t.done()",
        "assert not t.cancelled()",
        "assert connection_count == 0"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        },
        {
          "name": "t.done",
          "body": "def done(self) -> bool:\n    return True"
        }
      ]
    },
    {
      "name": "test_shutdown_timeout_handler",
      "module": "test_run_app",
      "class_name": "TestShutdown",
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 1095,
      "end_line_number": 1111,
      "source_code": "def test_shutdown_timeout_handler(\n        self, aiohttp_unused_port: Callable[[], int]\n    ) -> None:\n        port = aiohttp_unused_port()\n        finished = False\n\n        async def task() -> None:\n            nonlocal finished\n            await asyncio.sleep(2)\n            finished = True\n\n        t, connection_count = self.run_app(port, 1, task)\n\n        assert finished is False\n        assert t.done()\n        assert t.cancelled()\n        assert connection_count == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "aiohttp_unused_port"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert finished is False",
        "assert t.done()",
        "assert t.cancelled()",
        "assert connection_count == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        },
        {
          "name": "t.done",
          "body": "def done(self) -> bool:\n    return True"
        }
      ]
    },
    {
      "name": "test_shutdown_timeout_not_reached",
      "module": "test_run_app",
      "class_name": "TestShutdown",
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 1113,
      "end_line_number": 1131,
      "source_code": "def test_shutdown_timeout_not_reached(\n        self, aiohttp_unused_port: Callable[[], int]\n    ) -> None:\n        port = aiohttp_unused_port()\n        finished = False\n\n        async def task() -> None:\n            nonlocal finished\n            await asyncio.sleep(1)\n            finished = True\n\n        start_time = time.time()\n        t, connection_count = self.run_app(port, 15, task)\n\n        assert finished is True\n        assert t.done()\n        assert connection_count == 0\n        # Verify run_app has not waited for timeout.\n        assert time.time() - start_time < 10",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "aiohttp_unused_port"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert finished is True",
        "assert t.done()",
        "assert connection_count == 0",
        "assert time.time() - start_time < 10"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        },
        {
          "name": "t.done",
          "body": "def done(self) -> bool:\n    return True"
        }
      ]
    },
    {
      "name": "test_shutdown_new_conn_rejected",
      "module": "test_run_app",
      "class_name": "TestShutdown",
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 1133,
      "end_line_number": 1158,
      "source_code": "def test_shutdown_new_conn_rejected(\n        self, aiohttp_unused_port: Callable[[], int]\n    ) -> None:\n        port = aiohttp_unused_port()\n        finished = False\n\n        async def task() -> None:\n            nonlocal finished\n            await asyncio.sleep(9)\n            finished = True\n\n        async def test(sess: ClientSession) -> None:\n            # Ensure we are in the middle of shutdown (waiting for task()).\n            await asyncio.sleep(1)\n            with pytest.raises(ClientConnectorError):\n                # Use a new session to try and open a new connection.\n                async with ClientSession() as sess:\n                    async with sess.get(f\"http://localhost:{port}/\"):\n                        pass\n            assert finished is False\n\n        t, connection_count = self.run_app(port, 10, task, test)\n\n        assert finished is True\n        assert t.done()\n        assert connection_count == 0",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "aiohttp_unused_port"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert finished is True",
        "assert t.done()",
        "assert connection_count == 0",
        "assert finished is False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        },
        {
          "name": "t.done",
          "body": "def done(self) -> bool:\n    return True"
        }
      ]
    },
    {
      "name": "test_shutdown_pending_handler_responds",
      "module": "test_run_app",
      "class_name": "TestShutdown",
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 1160,
      "end_line_number": 1204,
      "source_code": "def test_shutdown_pending_handler_responds(\n        self, aiohttp_unused_port: Callable[[], int]\n    ) -> None:\n        port = aiohttp_unused_port()\n        finished = False\n        t = None\n\n        async def test() -> None:\n            async def test_resp(sess: ClientSession) -> None:\n                async with sess.get(f\"http://localhost:{port}/\") as resp:\n                    assert await resp.text() == \"FOO\"\n\n            await asyncio.sleep(1)\n            async with ClientSession() as sess:\n                t = asyncio.create_task(test_resp(sess))\n                await asyncio.sleep(1)\n                # Handler is in-progress while we trigger server shutdown.\n                async with sess.get(f\"http://localhost:{port}/stop\"):\n                    pass\n\n                assert finished is False\n                # Handler should still complete and produce a response.\n                await t\n\n        async def run_test(app: web.Application) -> AsyncIterator[None]:\n            nonlocal t\n            t = asyncio.create_task(test())\n            yield\n            await t\n\n        async def handler(request: web.Request) -> web.Response:\n            nonlocal finished\n            await asyncio.sleep(3)\n            finished = True\n            return web.Response(text=\"FOO\")\n\n        app = web.Application()\n        app.cleanup_ctx.append(run_test)\n        app.router.add_get(\"/\", handler)\n        app.router.add_get(\"/stop\", self.stop)\n\n        web.run_app(app, port=port, shutdown_timeout=5)\n        assert t is not None\n        assert t.exception() is None\n        assert finished is True",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "aiohttp_unused_port"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert t is not None",
        "assert t.exception() is None",
        "assert finished is True",
        "assert finished is False",
        "assert await resp.text() == 'FOO'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "web.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        }
      ]
    },
    {
      "name": "test_shutdown_close_idle_keepalive",
      "module": "test_run_app",
      "class_name": "TestShutdown",
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 1206,
      "end_line_number": 1237,
      "source_code": "def test_shutdown_close_idle_keepalive(\n        self, aiohttp_unused_port: Callable[[], int]\n    ) -> None:\n        port = aiohttp_unused_port()\n        t = None\n\n        async def test() -> None:\n            await asyncio.sleep(1)\n            async with ClientSession() as sess:\n                async with sess.get(f\"http://localhost:{port}/stop\"):\n                    pass\n\n                # Hold on to keep-alive connection.\n                await asyncio.sleep(5)\n\n        async def run_test(app: web.Application) -> AsyncIterator[None]:\n            nonlocal t\n            t = asyncio.create_task(test())\n            yield\n            t.cancel()\n            with contextlib.suppress(asyncio.CancelledError):\n                await t\n\n        app = web.Application()\n        app.cleanup_ctx.append(run_test)\n        app.router.add_get(\"/stop\", self.stop)\n\n        web.run_app(app, port=port, shutdown_timeout=10)\n        # If connection closed, then test() will be cancelled in cleanup_ctx.\n        # If not, then shutdown_timeout will allow it to sleep until complete.\n        assert t is not None\n        assert t.cancelled()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "aiohttp_unused_port"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert t is not None",
        "assert t.cancelled()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "web.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        }
      ]
    },
    {
      "name": "test_shutdown_close_websockets",
      "module": "test_run_app",
      "class_name": "TestShutdown",
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 1239,
      "end_line_number": 1292,
      "source_code": "def test_shutdown_close_websockets(\n        self, aiohttp_unused_port: Callable[[], int]\n    ) -> None:\n        port = aiohttp_unused_port()\n        WS = web.AppKey(\"ws\", Set[web.WebSocketResponse])\n        client_finished = server_finished = False\n        t = None\n\n        async def ws_handler(request: web.Request) -> web.WebSocketResponse:\n            ws = web.WebSocketResponse()\n            await ws.prepare(request)\n            request.app[WS].add(ws)\n            async for msg in ws:\n                pass\n            nonlocal server_finished\n            server_finished = True\n            return ws\n\n        async def close_websockets(app: web.Application) -> None:\n            for ws in app[WS]:\n                await ws.close(code=WSCloseCode.GOING_AWAY)\n\n        async def test() -> None:\n            await asyncio.sleep(1)\n            async with ClientSession() as sess:\n                async with sess.ws_connect(f\"http://localhost:{port}/ws\") as ws:\n                    async with sess.get(f\"http://localhost:{port}/stop\"):\n                        pass\n\n                    async for msg in ws:\n                        pass\n                    nonlocal client_finished\n                    client_finished = True\n\n        async def run_test(app: web.Application) -> AsyncIterator[None]:\n            nonlocal t\n            t = asyncio.create_task(test())\n            yield\n            t.cancel()\n            with contextlib.suppress(asyncio.CancelledError):\n                await t\n\n        app = web.Application()\n        app[WS] = set()\n        app.on_shutdown.append(close_websockets)\n        app.cleanup_ctx.append(run_test)\n        app.router.add_get(\"/ws\", ws_handler)\n        app.router.add_get(\"/stop\", self.stop)\n\n        start = time.time()\n        web.run_app(app, port=port, shutdown_timeout=10)\n        assert time.time() - start < 5\n        assert client_finished\n        assert server_finished",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "aiohttp_unused_port"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert time.time() - start < 5",
        "assert client_finished",
        "assert server_finished"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "web.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        },
        {
          "name": "ws.prepare",
          "body": "def prepare(data: bytes) -> bytes:\n    return data"
        },
        {
          "name": "ws.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_shutdown_handler_cancellation_suppressed",
      "module": "test_run_app",
      "class_name": "TestShutdown",
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 1294,
      "end_line_number": 1344,
      "source_code": "def test_shutdown_handler_cancellation_suppressed(\n        self, aiohttp_unused_port: Callable[[], int]\n    ) -> None:\n        port = aiohttp_unused_port()\n        actions = []\n        t = None\n\n        async def test() -> None:\n            async def test_resp(sess: ClientSession) -> None:\n                t = ClientTimeout(total=0.4)\n                with pytest.raises(asyncio.TimeoutError):\n                    async with sess.get(f\"http://localhost:{port}/\", timeout=t) as resp:\n                        assert await resp.text() == \"FOO\"\n                actions.append(\"CANCELLED\")\n\n            async with ClientSession() as sess:\n                t = asyncio.create_task(test_resp(sess))\n                await asyncio.sleep(0.5)\n                # Handler is in-progress while we trigger server shutdown.\n                actions.append(\"PRESTOP\")\n                async with sess.get(f\"http://localhost:{port}/stop\"):\n                    pass\n\n                actions.append(\"STOPPING\")\n                # Handler should still complete and produce a response.\n                await t\n\n        async def run_test(app: web.Application) -> AsyncIterator[None]:\n            nonlocal t\n            t = asyncio.create_task(test())\n            yield\n            await t\n\n        async def handler(request: web.Request) -> web.Response:\n            try:\n                await asyncio.sleep(5)\n            except asyncio.CancelledError:\n                actions.append(\"SUPPRESSED\")\n                await asyncio.sleep(2)\n                actions.append(\"DONE\")\n            return web.Response(text=\"FOO\")\n\n        app = web.Application()\n        app.cleanup_ctx.append(run_test)\n        app.router.add_get(\"/\", handler)\n        app.router.add_get(\"/stop\", self.stop)\n\n        web.run_app(app, port=port, shutdown_timeout=2, handler_cancellation=True)\n        assert t is not None\n        assert t.exception() is None\n        assert actions == [\"CANCELLED\", \"SUPPRESSED\", \"PRESTOP\", \"STOPPING\", \"DONE\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "aiohttp_unused_port"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert t is not None",
        "assert t.exception() is None",
        "assert actions == ['CANCELLED', 'SUPPRESSED', 'PRESTOP', 'STOPPING', 'DONE']",
        "assert await resp.text() == 'FOO'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "web.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        }
      ]
    },
    {
      "name": "test_shutdown_wait_for_handler",
      "module": "test_run_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 1077,
      "end_line_number": 1093,
      "source_code": "def test_shutdown_wait_for_handler(\n        self, aiohttp_unused_port: Callable[[], int]\n    ) -> None:\n        port = aiohttp_unused_port()\n        finished = False\n\n        async def task() -> None:\n            nonlocal finished\n            await asyncio.sleep(2)\n            finished = True\n\n        t, connection_count = self.run_app(port, 3, task)\n\n        assert finished is True\n        assert t.done()\n        assert not t.cancelled()\n        assert connection_count == 0",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "aiohttp_unused_port"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert finished is True",
        "assert t.done()",
        "assert not t.cancelled()",
        "assert connection_count == 0"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        },
        {
          "name": "t.done",
          "body": "def done(self) -> bool:\n    return True"
        }
      ]
    },
    {
      "name": "test_shutdown_timeout_handler",
      "module": "test_run_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 1095,
      "end_line_number": 1111,
      "source_code": "def test_shutdown_timeout_handler(\n        self, aiohttp_unused_port: Callable[[], int]\n    ) -> None:\n        port = aiohttp_unused_port()\n        finished = False\n\n        async def task() -> None:\n            nonlocal finished\n            await asyncio.sleep(2)\n            finished = True\n\n        t, connection_count = self.run_app(port, 1, task)\n\n        assert finished is False\n        assert t.done()\n        assert t.cancelled()\n        assert connection_count == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "aiohttp_unused_port"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert finished is False",
        "assert t.done()",
        "assert t.cancelled()",
        "assert connection_count == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        },
        {
          "name": "t.done",
          "body": "def done(self) -> bool:\n    return True"
        }
      ]
    },
    {
      "name": "test_shutdown_timeout_not_reached",
      "module": "test_run_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 1113,
      "end_line_number": 1131,
      "source_code": "def test_shutdown_timeout_not_reached(\n        self, aiohttp_unused_port: Callable[[], int]\n    ) -> None:\n        port = aiohttp_unused_port()\n        finished = False\n\n        async def task() -> None:\n            nonlocal finished\n            await asyncio.sleep(1)\n            finished = True\n\n        start_time = time.time()\n        t, connection_count = self.run_app(port, 15, task)\n\n        assert finished is True\n        assert t.done()\n        assert connection_count == 0\n        # Verify run_app has not waited for timeout.\n        assert time.time() - start_time < 10",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "aiohttp_unused_port"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert finished is True",
        "assert t.done()",
        "assert connection_count == 0",
        "assert time.time() - start_time < 10"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        },
        {
          "name": "t.done",
          "body": "def done(self) -> bool:\n    return True"
        }
      ]
    },
    {
      "name": "test_shutdown_new_conn_rejected",
      "module": "test_run_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 1133,
      "end_line_number": 1158,
      "source_code": "def test_shutdown_new_conn_rejected(\n        self, aiohttp_unused_port: Callable[[], int]\n    ) -> None:\n        port = aiohttp_unused_port()\n        finished = False\n\n        async def task() -> None:\n            nonlocal finished\n            await asyncio.sleep(9)\n            finished = True\n\n        async def test(sess: ClientSession) -> None:\n            # Ensure we are in the middle of shutdown (waiting for task()).\n            await asyncio.sleep(1)\n            with pytest.raises(ClientConnectorError):\n                # Use a new session to try and open a new connection.\n                async with ClientSession() as sess:\n                    async with sess.get(f\"http://localhost:{port}/\"):\n                        pass\n            assert finished is False\n\n        t, connection_count = self.run_app(port, 10, task, test)\n\n        assert finished is True\n        assert t.done()\n        assert connection_count == 0",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "aiohttp_unused_port"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert finished is True",
        "assert t.done()",
        "assert connection_count == 0",
        "assert finished is False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        },
        {
          "name": "t.done",
          "body": "def done(self) -> bool:\n    return True"
        }
      ]
    },
    {
      "name": "test_shutdown_pending_handler_responds",
      "module": "test_run_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 1160,
      "end_line_number": 1204,
      "source_code": "def test_shutdown_pending_handler_responds(\n        self, aiohttp_unused_port: Callable[[], int]\n    ) -> None:\n        port = aiohttp_unused_port()\n        finished = False\n        t = None\n\n        async def test() -> None:\n            async def test_resp(sess: ClientSession) -> None:\n                async with sess.get(f\"http://localhost:{port}/\") as resp:\n                    assert await resp.text() == \"FOO\"\n\n            await asyncio.sleep(1)\n            async with ClientSession() as sess:\n                t = asyncio.create_task(test_resp(sess))\n                await asyncio.sleep(1)\n                # Handler is in-progress while we trigger server shutdown.\n                async with sess.get(f\"http://localhost:{port}/stop\"):\n                    pass\n\n                assert finished is False\n                # Handler should still complete and produce a response.\n                await t\n\n        async def run_test(app: web.Application) -> AsyncIterator[None]:\n            nonlocal t\n            t = asyncio.create_task(test())\n            yield\n            await t\n\n        async def handler(request: web.Request) -> web.Response:\n            nonlocal finished\n            await asyncio.sleep(3)\n            finished = True\n            return web.Response(text=\"FOO\")\n\n        app = web.Application()\n        app.cleanup_ctx.append(run_test)\n        app.router.add_get(\"/\", handler)\n        app.router.add_get(\"/stop\", self.stop)\n\n        web.run_app(app, port=port, shutdown_timeout=5)\n        assert t is not None\n        assert t.exception() is None\n        assert finished is True",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "aiohttp_unused_port"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert t is not None",
        "assert t.exception() is None",
        "assert finished is True",
        "assert finished is False",
        "assert await resp.text() == 'FOO'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "web.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        }
      ]
    },
    {
      "name": "test_shutdown_close_idle_keepalive",
      "module": "test_run_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 1206,
      "end_line_number": 1237,
      "source_code": "def test_shutdown_close_idle_keepalive(\n        self, aiohttp_unused_port: Callable[[], int]\n    ) -> None:\n        port = aiohttp_unused_port()\n        t = None\n\n        async def test() -> None:\n            await asyncio.sleep(1)\n            async with ClientSession() as sess:\n                async with sess.get(f\"http://localhost:{port}/stop\"):\n                    pass\n\n                # Hold on to keep-alive connection.\n                await asyncio.sleep(5)\n\n        async def run_test(app: web.Application) -> AsyncIterator[None]:\n            nonlocal t\n            t = asyncio.create_task(test())\n            yield\n            t.cancel()\n            with contextlib.suppress(asyncio.CancelledError):\n                await t\n\n        app = web.Application()\n        app.cleanup_ctx.append(run_test)\n        app.router.add_get(\"/stop\", self.stop)\n\n        web.run_app(app, port=port, shutdown_timeout=10)\n        # If connection closed, then test() will be cancelled in cleanup_ctx.\n        # If not, then shutdown_timeout will allow it to sleep until complete.\n        assert t is not None\n        assert t.cancelled()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "aiohttp_unused_port"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert t is not None",
        "assert t.cancelled()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "web.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        }
      ]
    },
    {
      "name": "test_shutdown_close_websockets",
      "module": "test_run_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 1239,
      "end_line_number": 1292,
      "source_code": "def test_shutdown_close_websockets(\n        self, aiohttp_unused_port: Callable[[], int]\n    ) -> None:\n        port = aiohttp_unused_port()\n        WS = web.AppKey(\"ws\", Set[web.WebSocketResponse])\n        client_finished = server_finished = False\n        t = None\n\n        async def ws_handler(request: web.Request) -> web.WebSocketResponse:\n            ws = web.WebSocketResponse()\n            await ws.prepare(request)\n            request.app[WS].add(ws)\n            async for msg in ws:\n                pass\n            nonlocal server_finished\n            server_finished = True\n            return ws\n\n        async def close_websockets(app: web.Application) -> None:\n            for ws in app[WS]:\n                await ws.close(code=WSCloseCode.GOING_AWAY)\n\n        async def test() -> None:\n            await asyncio.sleep(1)\n            async with ClientSession() as sess:\n                async with sess.ws_connect(f\"http://localhost:{port}/ws\") as ws:\n                    async with sess.get(f\"http://localhost:{port}/stop\"):\n                        pass\n\n                    async for msg in ws:\n                        pass\n                    nonlocal client_finished\n                    client_finished = True\n\n        async def run_test(app: web.Application) -> AsyncIterator[None]:\n            nonlocal t\n            t = asyncio.create_task(test())\n            yield\n            t.cancel()\n            with contextlib.suppress(asyncio.CancelledError):\n                await t\n\n        app = web.Application()\n        app[WS] = set()\n        app.on_shutdown.append(close_websockets)\n        app.cleanup_ctx.append(run_test)\n        app.router.add_get(\"/ws\", ws_handler)\n        app.router.add_get(\"/stop\", self.stop)\n\n        start = time.time()\n        web.run_app(app, port=port, shutdown_timeout=10)\n        assert time.time() - start < 5\n        assert client_finished\n        assert server_finished",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "aiohttp_unused_port"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert time.time() - start < 5",
        "assert client_finished",
        "assert server_finished"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "web.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        },
        {
          "name": "ws.prepare",
          "body": "def prepare(data: bytes) -> bytes:\n    return data"
        },
        {
          "name": "ws.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_shutdown_handler_cancellation_suppressed",
      "module": "test_run_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
      "line_number": 1294,
      "end_line_number": 1344,
      "source_code": "def test_shutdown_handler_cancellation_suppressed(\n        self, aiohttp_unused_port: Callable[[], int]\n    ) -> None:\n        port = aiohttp_unused_port()\n        actions = []\n        t = None\n\n        async def test() -> None:\n            async def test_resp(sess: ClientSession) -> None:\n                t = ClientTimeout(total=0.4)\n                with pytest.raises(asyncio.TimeoutError):\n                    async with sess.get(f\"http://localhost:{port}/\", timeout=t) as resp:\n                        assert await resp.text() == \"FOO\"\n                actions.append(\"CANCELLED\")\n\n            async with ClientSession() as sess:\n                t = asyncio.create_task(test_resp(sess))\n                await asyncio.sleep(0.5)\n                # Handler is in-progress while we trigger server shutdown.\n                actions.append(\"PRESTOP\")\n                async with sess.get(f\"http://localhost:{port}/stop\"):\n                    pass\n\n                actions.append(\"STOPPING\")\n                # Handler should still complete and produce a response.\n                await t\n\n        async def run_test(app: web.Application) -> AsyncIterator[None]:\n            nonlocal t\n            t = asyncio.create_task(test())\n            yield\n            await t\n\n        async def handler(request: web.Request) -> web.Response:\n            try:\n                await asyncio.sleep(5)\n            except asyncio.CancelledError:\n                actions.append(\"SUPPRESSED\")\n                await asyncio.sleep(2)\n                actions.append(\"DONE\")\n            return web.Response(text=\"FOO\")\n\n        app = web.Application()\n        app.cleanup_ctx.append(run_test)\n        app.router.add_get(\"/\", handler)\n        app.router.add_get(\"/stop\", self.stop)\n\n        web.run_app(app, port=port, shutdown_timeout=2, handler_cancellation=True)\n        assert t is not None\n        assert t.exception() is None\n        assert actions == [\"CANCELLED\", \"SUPPRESSED\", \"PRESTOP\", \"STOPPING\", \"DONE\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "aiohttp_unused_port"
      ],
      "imports": [
        "asyncio",
        "contextlib",
        "logging",
        "os",
        "platform",
        "signal",
        "socket",
        "ssl",
        "subprocess",
        "sys",
        "time",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "unittest.mock",
        "uuid.uuid4",
        "pytest",
        "pytest_mock.MockerFixture",
        "aiohttp.ClientConnectorError",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.WSCloseCode",
        "aiohttp.web",
        "aiohttp.log.access_logger",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.web_protocol.RequestHandler",
        "aiohttp.web_runner.BaseRunner",
        "contextvars.ContextVar"
      ],
      "fixtures": [],
      "assertions": [
        "assert t is not None",
        "assert t.exception() is None",
        "assert actions == ['CANCELLED', 'SUPPRESSED', 'PRESTOP', 'STOPPING', 'DONE']",
        "assert await resp.text() == 'FOO'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "web.run_app",
          "body": "def run_app(self, port: int, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://localhost:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://localhost:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, port=port, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)"
        }
      ]
    },
    {
      "name": "test_aiohttp_plugin",
      "module": "test_pytest_plugin",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_pytest_plugin.py",
      "line_number": 19,
      "end_line_number": 124,
      "source_code": "def test_aiohttp_plugin(testdir: pytest.Testdir) -> None:\n    testdir.makepyfile(\n        \"\"\"\\\nimport pytest\nfrom unittest import mock\n\nfrom aiohttp import web\n\nvalue = web.AppKey('value', str)\n\n\nasync def hello(request):\n    return web.Response(body=b'Hello, world')\n\n\nasync def create_app():\n    app = web.Application()\n    app.router.add_route('GET', '/', hello)\n    return app\n\n\nasync def test_hello(aiohttp_client) -> None:\n    client = await aiohttp_client(await create_app())\n    resp = await client.get('/')\n    assert resp.status == 200\n    text = await resp.text()\n    assert 'Hello, world' in text\n\n\nasync def test_hello_from_app(aiohttp_client) -> None:\n    app = web.Application()\n    app.router.add_get('/', hello)\n    client = await aiohttp_client(app)\n    resp = await client.get('/')\n    assert resp.status == 200\n    text = await resp.text()\n    assert 'Hello, world' in text\n\n\nasync def test_hello_with_loop(aiohttp_client) -> None:\n    client = await aiohttp_client(await create_app())\n    resp = await client.get('/')\n    assert resp.status == 200\n    text = await resp.text()\n    assert 'Hello, world' in text\n\n\nasync def test_noop() -> None:\n    pass\n\n\nasync def previous(request):\n    if request.method == 'POST':\n        with pytest.deprecated_call():  # FIXME: this isn't actually called\n            request.app[value] = (await request.post())['value']\n        return web.Response(body=b'thanks for the data')\n    else:\n        v = request.app.get(value, 'unknown')\n        return web.Response(body='value: {}'.format(v).encode())\n\n\ndef create_stateful_app():\n    app = web.Application()\n    app.router.add_route('*', '/', previous)\n    return app\n\n\n@pytest.fixture\ndef cli(loop, aiohttp_client):\n    return loop.run_until_complete(aiohttp_client(create_stateful_app()))\n\n\ndef test_noncoro() -> None:\n    assert True\n\n\nasync def test_failed_to_create_client(aiohttp_client) -> None:\n\n    def make_app():\n        raise RuntimeError()\n\n    with pytest.raises(RuntimeError):\n        await aiohttp_client(make_app())\n\n\nasync def test_custom_port_aiohttp_client(aiohttp_client, aiohttp_unused_port):\n    port = aiohttp_unused_port()\n    client = await aiohttp_client(await create_app(),\n                                  server_kwargs={'port': port})\n    assert client.port == port\n    resp = await client.get('/')\n    assert resp.status == 200\n    text = await resp.text()\n    assert 'Hello, world' in text\n\n\nasync def test_custom_port_test_server(aiohttp_server, aiohttp_unused_port):\n    app = await create_app()\n    port = aiohttp_unused_port()\n    server = await aiohttp_server(app, port=port)\n    assert server.port == port\n\"\"\"\n    )\n    testdir.makeconftest(CONFTEST)\n    result = testdir.runpytest(\"-p\", \"no:sugar\", \"--aiohttp-loop=pyloop\")\n    result.assert_outcomes(passed=8)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "testdir"
      ],
      "imports": [
        "os",
        "platform",
        "warnings",
        "pytest",
        "aiohttp.pytest_plugin"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_warning_checks",
      "module": "test_pytest_plugin",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_pytest_plugin.py",
      "line_number": 127,
      "end_line_number": 152,
      "source_code": "def test_warning_checks(testdir: pytest.Testdir) -> None:\n    testdir.makepyfile(\n        \"\"\"\\\n\nasync def foobar():\n    return 123\n\nasync def test_good() -> None:\n    v = await foobar()\n    assert v == 123\n\nasync def test_bad() -> None:\n    foobar()\n\"\"\"\n    )\n    testdir.makeconftest(CONFTEST)\n    result = testdir.runpytest(\n        \"-p\", \"no:sugar\", \"-s\", \"-W\", \"default\", \"--aiohttp-loop=pyloop\"\n    )\n    expected_outcomes = (\n        {\"failed\": 0, \"passed\": 2}\n        if IS_PYPY and bool(os.environ.get(\"PYTHONASYNCIODEBUG\"))\n        else {\"failed\": 1, \"passed\": 1}\n    )\n    # Under PyPy \"coroutine 'foobar' was never awaited\" does not happen.\n    result.assert_outcomes(**expected_outcomes)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "testdir"
      ],
      "imports": [
        "os",
        "platform",
        "warnings",
        "pytest",
        "aiohttp.pytest_plugin"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_aiohttp_plugin_async_fixture",
      "module": "test_pytest_plugin",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_pytest_plugin.py",
      "line_number": 155,
      "end_line_number": 216,
      "source_code": "def test_aiohttp_plugin_async_fixture(\n    testdir: pytest.Testdir, capsys: pytest.CaptureFixture[str]\n) -> None:\n    testdir.makepyfile(\n        \"\"\"\\\nimport pytest\n\nfrom aiohttp import web\n\n\nasync def hello(request):\n    return web.Response(body=b'Hello, world')\n\n\ndef create_app():\n    app = web.Application()\n    app.router.add_route('GET', '/', hello)\n    return app\n\n\n@pytest.fixture\nasync def cli(aiohttp_client, loop):\n    client = await aiohttp_client(create_app())\n    return client\n\n\n@pytest.fixture\nasync def foo():\n    return 42\n\n\n@pytest.fixture\nasync def bar(request):\n    # request should be accessible in async fixtures if needed\n    return request.function\n\n\nasync def test_hello(cli, loop) -> None:\n    resp = await cli.get('/')\n    assert resp.status == 200\n\n\ndef test_foo(loop, foo) -> None:\n    assert foo == 42\n\n\ndef test_foo_without_loop(foo) -> None:\n    # will raise an error because there is no loop\n    pass\n\n\ndef test_bar(loop, bar) -> None:\n    assert bar is test_bar\n\"\"\"\n    )\n    testdir.makeconftest(CONFTEST)\n    result = testdir.runpytest(\"-p\", \"no:sugar\", \"--aiohttp-loop=pyloop\")\n    result.assert_outcomes(passed=3, errors=1)\n    result.stdout.fnmatch_lines(\n        \"*Asynchronous fixtures must depend on the 'loop' fixture \"\n        \"or be used in tests depending from it.\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "testdir",
        "capsys"
      ],
      "imports": [
        "os",
        "platform",
        "warnings",
        "pytest",
        "aiohttp.pytest_plugin"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_aiohttp_plugin_async_gen_fixture",
      "module": "test_pytest_plugin",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_pytest_plugin.py",
      "line_number": 219,
      "end_line_number": 258,
      "source_code": "def test_aiohttp_plugin_async_gen_fixture(testdir: pytest.Testdir) -> None:\n    testdir.makepyfile(\n        \"\"\"\\\nimport pytest\nfrom unittest import mock\n\nfrom aiohttp import web\n\n\ncanary = mock.Mock()\n\n\nasync def hello(request):\n    return web.Response(body=b'Hello, world')\n\n\ndef create_app():\n    app = web.Application()\n    app.router.add_route('GET', '/', hello)\n    return app\n\n\n@pytest.fixture\nasync def cli(aiohttp_client, loop):\n    yield await aiohttp_client(create_app())\n    canary()\n\n\nasync def test_hello(cli) -> None:\n    resp = await cli.get('/')\n    assert resp.status == 200\n\n\ndef test_finalized() -> None:\n    assert canary.called is True\n\"\"\"\n    )\n    testdir.makeconftest(CONFTEST)\n    result = testdir.runpytest(\"-p\", \"no:sugar\", \"--aiohttp-loop=pyloop\")\n    result.assert_outcomes(passed=2)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "testdir"
      ],
      "imports": [
        "os",
        "platform",
        "warnings",
        "pytest",
        "aiohttp.pytest_plugin"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_warnings_propagated",
      "module": "test_pytest_plugin",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_pytest_plugin.py",
      "line_number": 261,
      "end_line_number": 267,
      "source_code": "def test_warnings_propagated(recwarn: pytest.WarningsRecorder) -> None:\n    with pytest_plugin._runtime_warning_context():\n        warnings.warn(\"test warning is propagated\")\n    assert len(recwarn) == 1\n    message = recwarn[0].message\n    assert isinstance(message, UserWarning)\n    assert message.args == (\"test warning is propagated\",)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "recwarn"
      ],
      "imports": [
        "os",
        "platform",
        "warnings",
        "pytest",
        "aiohttp.pytest_plugin"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(recwarn) == 1",
        "assert isinstance(message, UserWarning)",
        "assert message.args == ('test warning is propagated',)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_aiohttp_client_cls_fixture_custom_client_used",
      "module": "test_pytest_plugin",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_pytest_plugin.py",
      "line_number": 270,
      "end_line_number": 295,
      "source_code": "def test_aiohttp_client_cls_fixture_custom_client_used(testdir: pytest.Testdir) -> None:\n    testdir.makepyfile(\n        \"\"\"\nimport pytest\nfrom aiohttp.web import Application\nfrom aiohttp.test_utils import TestClient\n\n\nclass CustomClient(TestClient):\n    pass\n\n\n@pytest.fixture\ndef aiohttp_client_cls():\n    return CustomClient\n\n\nasync def test_hello(aiohttp_client) -> None:\n    client = await aiohttp_client(Application())\n    assert isinstance(client, CustomClient)\n\n\"\"\"\n    )\n    testdir.makeconftest(CONFTEST)\n    result = testdir.runpytest()\n    result.assert_outcomes(passed=1)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "testdir"
      ],
      "imports": [
        "os",
        "platform",
        "warnings",
        "pytest",
        "aiohttp.pytest_plugin"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_aiohttp_client_cls_fixture_factory",
      "module": "test_pytest_plugin",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_pytest_plugin.py",
      "line_number": 298,
      "end_line_number": 347,
      "source_code": "def test_aiohttp_client_cls_fixture_factory(testdir: pytest.Testdir) -> None:\n    testdir.makeconftest(\n        CONFTEST\n        + \"\"\"\n\ndef pytest_configure(config):\n    config.addinivalue_line(\"markers\", \"rest: RESTful API tests\")\n    config.addinivalue_line(\"markers\", \"graphql: GraphQL API tests\")\n\n\"\"\"\n    )\n    testdir.makepyfile(\n        \"\"\"\nimport pytest\nfrom aiohttp.web import Application\nfrom aiohttp.test_utils import TestClient\n\n\nclass RESTfulClient(TestClient):\n    pass\n\n\nclass GraphQLClient(TestClient):\n    pass\n\n\n@pytest.fixture\ndef aiohttp_client_cls(request):\n    if request.node.get_closest_marker('rest') is not None:\n        return RESTfulClient\n    elif request.node.get_closest_marker('graphql') is not None:\n        return GraphQLClient\n    return TestClient\n\n\n@pytest.mark.rest\nasync def test_rest(aiohttp_client) -> None:\n    client = await aiohttp_client(Application())\n    assert isinstance(client, RESTfulClient)\n\n\n@pytest.mark.graphql\nasync def test_graphql(aiohttp_client) -> None:\n    client = await aiohttp_client(Application())\n    assert isinstance(client, GraphQLClient)\n\n\"\"\"\n    )\n    result = testdir.runpytest()\n    result.assert_outcomes(passed=2)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "testdir"
      ],
      "imports": [
        "os",
        "platform",
        "warnings",
        "pytest",
        "aiohttp.pytest_plugin"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_stream_response_ctor",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 68,
      "end_line_number": 77,
      "source_code": "def test_stream_response_ctor() -> None:\n    resp = web.StreamResponse()\n    assert 200 == resp.status\n    assert resp.keep_alive is None\n\n    assert resp.task is None\n\n    req = mock.Mock()\n    resp._req = req\n    assert resp.task is req.task",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert 200 == resp.status",
        "assert resp.keep_alive is None",
        "assert resp.task is None",
        "assert resp.task is req.task"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_stream_response_hashable",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 80,
      "end_line_number": 82,
      "source_code": "def test_stream_response_hashable() -> None:\n    # should not raise exception\n    hash(web.StreamResponse())",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_stream_response_eq",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 85,
      "end_line_number": 90,
      "source_code": "def test_stream_response_eq() -> None:\n    resp1 = web.StreamResponse()\n    resp2 = web.StreamResponse()\n\n    assert resp1 == resp1\n    assert not resp1 == resp2",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp1 == resp1",
        "assert not resp1 == resp2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_stream_response_is_mutable_mapping",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 93,
      "end_line_number": 97,
      "source_code": "def test_stream_response_is_mutable_mapping() -> None:\n    resp = web.StreamResponse()\n    assert isinstance(resp, collections.abc.MutableMapping)\n    resp[\"key\"] = \"value\"\n    assert \"value\" == resp[\"key\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(resp, collections.abc.MutableMapping)",
        "assert 'value' == resp['key']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_stream_response_delitem",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 100,
      "end_line_number": 104,
      "source_code": "def test_stream_response_delitem() -> None:\n    resp = web.StreamResponse()\n    resp[\"key\"] = \"value\"\n    del resp[\"key\"]\n    assert \"key\" not in resp",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'key' not in resp"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_stream_response_len",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 107,
      "end_line_number": 111,
      "source_code": "def test_stream_response_len() -> None:\n    resp = web.StreamResponse()\n    assert len(resp) == 0\n    resp[\"key\"] = \"value\"\n    assert len(resp) == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(resp) == 0",
        "assert len(resp) == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_request_iter",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 114,
      "end_line_number": 118,
      "source_code": "def test_request_iter() -> None:\n    resp = web.StreamResponse()\n    resp[\"key\"] = \"value\"\n    resp[\"key2\"] = \"value2\"\n    assert set(resp) == {\"key\", \"key2\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert set(resp) == {'key', 'key2'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_content_length",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 121,
      "end_line_number": 123,
      "source_code": "def test_content_length() -> None:\n    resp = web.StreamResponse()\n    assert resp.content_length is None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.content_length is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_content_length_setter",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 126,
      "end_line_number": 130,
      "source_code": "def test_content_length_setter() -> None:\n    resp = web.StreamResponse()\n\n    resp.content_length = 234\n    assert 234 == resp.content_length",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert 234 == resp.content_length"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_content_length_setter_with_enable_chunked_encoding",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 133,
      "end_line_number": 138,
      "source_code": "def test_content_length_setter_with_enable_chunked_encoding() -> None:\n    resp = web.StreamResponse()\n\n    resp.enable_chunked_encoding()\n    with pytest.raises(RuntimeError):\n        resp.content_length = 234",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_drop_content_length_header_on_setting_len_to_None",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 141,
      "end_line_number": 147,
      "source_code": "def test_drop_content_length_header_on_setting_len_to_None() -> None:\n    resp = web.StreamResponse()\n\n    resp.content_length = 1\n    assert \"1\" == resp.headers[\"Content-Length\"]\n    resp.content_length = None\n    assert \"Content-Length\" not in resp.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert '1' == resp.headers['Content-Length']",
        "assert 'Content-Length' not in resp.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_set_content_length_to_None_on_non_set",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 150,
      "end_line_number": 156,
      "source_code": "def test_set_content_length_to_None_on_non_set() -> None:\n    resp = web.StreamResponse()\n\n    resp.content_length = None\n    assert \"Content-Length\" not in resp.headers\n    resp.content_length = None\n    assert \"Content-Length\" not in resp.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'Content-Length' not in resp.headers",
        "assert 'Content-Length' not in resp.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_setting_content_type",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 159,
      "end_line_number": 163,
      "source_code": "def test_setting_content_type() -> None:\n    resp = web.StreamResponse()\n\n    resp.content_type = \"text/html\"\n    assert \"text/html\" == resp.headers[\"content-type\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'text/html' == resp.headers['content-type']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_setting_charset",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 166,
      "end_line_number": 171,
      "source_code": "def test_setting_charset() -> None:\n    resp = web.StreamResponse()\n\n    resp.content_type = \"text/html\"\n    resp.charset = \"koi8-r\"\n    assert \"text/html; charset=koi8-r\" == resp.headers[\"content-type\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'text/html; charset=koi8-r' == resp.headers['content-type']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_default_charset",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 174,
      "end_line_number": 177,
      "source_code": "def test_default_charset() -> None:\n    resp = web.StreamResponse()\n\n    assert resp.charset is None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.charset is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_reset_charset",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 180,
      "end_line_number": 185,
      "source_code": "def test_reset_charset() -> None:\n    resp = web.StreamResponse()\n\n    resp.content_type = \"text/html\"\n    resp.charset = None\n    assert resp.charset is None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.charset is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_reset_charset_after_setting",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 188,
      "end_line_number": 194,
      "source_code": "def test_reset_charset_after_setting() -> None:\n    resp = web.StreamResponse()\n\n    resp.content_type = \"text/html\"\n    resp.charset = \"koi8-r\"\n    resp.charset = None\n    assert resp.charset is None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.charset is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_charset_without_content_type",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 197,
      "end_line_number": 201,
      "source_code": "def test_charset_without_content_type() -> None:\n    resp = web.StreamResponse()\n\n    with pytest.raises(RuntimeError):\n        resp.charset = \"koi8-r\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_last_modified_initial",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 204,
      "end_line_number": 206,
      "source_code": "def test_last_modified_initial() -> None:\n    resp = web.StreamResponse()\n    assert resp.last_modified is None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.last_modified is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_last_modified_string",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 209,
      "end_line_number": 214,
      "source_code": "def test_last_modified_string() -> None:\n    resp = web.StreamResponse()\n\n    dt = datetime.datetime(1990, 1, 2, 3, 4, 5, 0, datetime.timezone.utc)\n    resp.last_modified = \"Mon, 2 Jan 1990 03:04:05 GMT\"  # type: ignore[assignment]\n    assert resp.last_modified == dt",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.last_modified == dt"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_last_modified_timestamp",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 217,
      "end_line_number": 226,
      "source_code": "def test_last_modified_timestamp() -> None:\n    resp = web.StreamResponse()\n\n    dt = datetime.datetime(1970, 1, 1, 0, 0, 0, 0, datetime.timezone.utc)\n\n    resp.last_modified = 0  # type: ignore[assignment]\n    assert resp.last_modified == dt\n\n    resp.last_modified = 0.0  # type: ignore[assignment]\n    assert resp.last_modified == dt",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.last_modified == dt",
        "assert resp.last_modified == dt"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_last_modified_datetime",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 229,
      "end_line_number": 234,
      "source_code": "def test_last_modified_datetime() -> None:\n    resp = web.StreamResponse()\n\n    dt = datetime.datetime(2001, 2, 3, 4, 5, 6, 0, datetime.timezone.utc)\n    resp.last_modified = dt\n    assert resp.last_modified == dt",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.last_modified == dt"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_last_modified_reset",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 237,
      "end_line_number": 242,
      "source_code": "def test_last_modified_reset() -> None:\n    resp = web.StreamResponse()\n\n    resp.last_modified = 0  # type: ignore[assignment]\n    resp.last_modified = None\n    assert resp.last_modified is None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.last_modified is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_last_modified_string_invalid",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 253,
      "end_line_number": 255,
      "source_code": "def test_last_modified_string_invalid(header_val: str) -> None:\n    resp = web.StreamResponse(headers={\"Last-Modified\": header_val})\n    assert resp.last_modified is None",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('header_val', ('xxyyzz', 'Tue, 08 Oct 4446413 00:56:40 GMT', 'Tue, 08 Oct 2000 00:56:80 GMT'))"
      ],
      "arguments": [
        "header_val"
      ],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.last_modified is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_etag_initial",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 258,
      "end_line_number": 260,
      "source_code": "def test_etag_initial() -> None:\n    resp = web.StreamResponse()\n    assert resp.etag is None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.etag is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_etag_string",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 263,
      "end_line_number": 268,
      "source_code": "def test_etag_string() -> None:\n    resp = web.StreamResponse()\n    value = \"0123-kotik\"\n    resp.etag = value  # type: ignore[assignment]\n    assert resp.etag == ETag(value=value)\n    assert resp.headers[hdrs.ETAG] == f'\"{value}\"'",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.etag == ETag(value=value)",
        "assert resp.headers[hdrs.ETAG] == f'\"{value}\"'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_etag_class",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 278,
      "end_line_number": 282,
      "source_code": "def test_etag_class(etag: ETag, expected_header: str) -> None:\n    resp = web.StreamResponse()\n    resp.etag = etag\n    assert resp.etag == etag\n    assert resp.headers[hdrs.ETAG] == expected_header",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize(('etag', 'expected_header'), ((ETag(value='0123-weak-kotik', is_weak=True), 'W/\"0123-weak-kotik\"'), (ETag(value='0123-strong-kotik', is_weak=False), '\"0123-strong-kotik\"')))"
      ],
      "arguments": [
        "etag",
        "expected_header"
      ],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.etag == etag",
        "assert resp.headers[hdrs.ETAG] == expected_header"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_etag_any",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 285,
      "end_line_number": 289,
      "source_code": "def test_etag_any() -> None:\n    resp = web.StreamResponse()\n    resp.etag = \"*\"  # type: ignore[assignment]\n    assert resp.etag == ETag(value=\"*\")\n    assert resp.headers[hdrs.ETAG] == \"*\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.etag == ETag(value='*')",
        "assert resp.headers[hdrs.ETAG] == '*'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_etag_invalid_value_set",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 301,
      "end_line_number": 304,
      "source_code": "def test_etag_invalid_value_set(invalid_value: Union[str, ETag]) -> None:\n    resp = web.StreamResponse()\n    with pytest.raises(ValueError, match=\"is not a valid etag\"):\n        resp.etag = invalid_value",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('invalid_value', ('\"invalid\"', '\u043f\u043e\u0432\u0438\u043d\u0435\u043d \u0431\u0443\u0442\u0438 ascii', ETag(value='\"invalid\"', is_weak=True), ETag(value='bad \u00a9\u00ae')))"
      ],
      "arguments": [
        "invalid_value"
      ],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_etag_invalid_value_get",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 314,
      "end_line_number": 317,
      "source_code": "def test_etag_invalid_value_get(header: str) -> None:\n    resp = web.StreamResponse()\n    resp.headers[\"ETag\"] = header\n    assert resp.etag is None",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('header', ('forgotten quotes', '\"\u2200 x \u2209 ascii\"'))"
      ],
      "arguments": [
        "header"
      ],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.etag is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_etag_invalid_value_class",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 321,
      "end_line_number": 324,
      "source_code": "def test_etag_invalid_value_class(invalid: Union[int, ETag]) -> None:\n    resp = web.StreamResponse()\n    with pytest.raises(ValueError, match=\"Unsupported etag type\"):\n        resp.etag = invalid",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('invalid', (123, ETag(value=123, is_weak=True)))"
      ],
      "arguments": [
        "invalid"
      ],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_etag_reset",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 327,
      "end_line_number": 331,
      "source_code": "def test_etag_reset() -> None:\n    resp = web.StreamResponse()\n    resp.etag = \"*\"  # type: ignore[assignment]\n    resp.etag = None\n    assert resp.etag is None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.etag is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_enable_chunked_encoding_with_content_length",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 366,
      "end_line_number": 371,
      "source_code": "def test_enable_chunked_encoding_with_content_length() -> None:\n    resp = web.StreamResponse()\n\n    resp.content_length = 234\n    with pytest.raises(RuntimeError):\n        resp.enable_chunked_encoding()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_force_close",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 778,
      "end_line_number": 783,
      "source_code": "def test_force_close() -> None:\n    resp = web.StreamResponse()\n\n    assert resp.keep_alive is None\n    resp.force_close()\n    assert resp.keep_alive is False",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.keep_alive is None",
        "assert resp.keep_alive is False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_set_status_with_reason",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 786,
      "end_line_number": 791,
      "source_code": "def test_set_status_with_reason() -> None:\n    resp = web.StreamResponse()\n\n    resp.set_status(200, \"Everything is fine!\")\n    assert 200 == resp.status\n    assert \"Everything is fine!\" == resp.reason",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert 200 == resp.status",
        "assert 'Everything is fine!' == resp.reason"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_set_status_with_empty_reason",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 794,
      "end_line_number": 799,
      "source_code": "def test_set_status_with_empty_reason() -> None:\n    resp = web.StreamResponse()\n\n    resp.set_status(200, \"\")\n    assert resp.status == 200\n    assert resp.reason == \"\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status == 200",
        "assert resp.reason == ''"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test___repr___not_prepared",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 819,
      "end_line_number": 821,
      "source_code": "def test___repr___not_prepared() -> None:\n    resp = web.StreamResponse(reason=\"foo\")\n    assert \"<StreamResponse foo not prepared>\" == repr(resp)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert '<StreamResponse foo not prepared>' == repr(resp)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_response_ctor",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 873,
      "end_line_number": 880,
      "source_code": "def test_response_ctor() -> None:\n    resp = web.Response()\n\n    assert 200 == resp.status\n    assert \"OK\" == resp.reason\n    assert resp.body is None\n    assert resp.content_length == 0\n    assert \"CONTENT-LENGTH\" not in resp.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert 200 == resp.status",
        "assert 'OK' == resp.reason",
        "assert resp.body is None",
        "assert resp.content_length == 0",
        "assert 'CONTENT-LENGTH' not in resp.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor_content_type",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 896,
      "end_line_number": 902,
      "source_code": "def test_ctor_content_type() -> None:\n    resp = web.Response(content_type=\"application/json\")\n\n    assert 200 == resp.status\n    assert \"OK\" == resp.reason\n    assert 0 == resp.content_length\n    assert CIMultiDict([(\"CONTENT-TYPE\", \"application/json\")]) == resp.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert 200 == resp.status",
        "assert 'OK' == resp.reason",
        "assert 0 == resp.content_length",
        "assert CIMultiDict([('CONTENT-TYPE', 'application/json')]) == resp.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor_text_body_combined",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 905,
      "end_line_number": 907,
      "source_code": "def test_ctor_text_body_combined() -> None:\n    with pytest.raises(ValueError):\n        web.Response(body=b\"123\", text=\"test text\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor_charset",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 927,
      "end_line_number": 931,
      "source_code": "def test_ctor_charset() -> None:\n    resp = web.Response(text=\"\u0442\u0435\u043a\u0441\u0442\", charset=\"koi8-r\")\n\n    assert \"\u0442\u0435\u043a\u0441\u0442\".encode(\"koi8-r\") == resp.body\n    assert \"koi8-r\" == resp.charset",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert '\u0442\u0435\u043a\u0441\u0442'.encode('koi8-r') == resp.body",
        "assert 'koi8-r' == resp.charset"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor_charset_default_utf8",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 934,
      "end_line_number": 937,
      "source_code": "def test_ctor_charset_default_utf8() -> None:\n    resp = web.Response(text=\"test test\", charset=None)\n\n    assert \"utf-8\" == resp.charset",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'utf-8' == resp.charset"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor_charset_in_content_type",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 940,
      "end_line_number": 942,
      "source_code": "def test_ctor_charset_in_content_type() -> None:\n    with pytest.raises(ValueError):\n        web.Response(text=\"test test\", content_type=\"text/plain; charset=utf-8\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor_charset_without_text",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 945,
      "end_line_number": 948,
      "source_code": "def test_ctor_charset_without_text() -> None:\n    resp = web.Response(content_type=\"text/plain\", charset=\"koi8-r\")\n\n    assert \"koi8-r\" == resp.charset",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'koi8-r' == resp.charset"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor_content_type_with_extra",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 951,
      "end_line_number": 955,
      "source_code": "def test_ctor_content_type_with_extra() -> None:\n    resp = web.Response(text=\"test test\", content_type=\"text/plain; version=0.0.4\")\n\n    assert resp.content_type == \"text/plain\"\n    assert resp.headers[\"content-type\"] == \"text/plain; version=0.0.4; charset=utf-8\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.content_type == 'text/plain'",
        "assert resp.headers['content-type'] == 'text/plain; version=0.0.4; charset=utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor_both_content_type_param_and_header_with_text",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 958,
      "end_line_number": 964,
      "source_code": "def test_ctor_both_content_type_param_and_header_with_text() -> None:\n    with pytest.raises(ValueError):\n        web.Response(\n            headers={\"Content-Type\": \"application/json\"},\n            content_type=\"text/html\",\n            text=\"text\",\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor_both_charset_param_and_header_with_text",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 967,
      "end_line_number": 971,
      "source_code": "def test_ctor_both_charset_param_and_header_with_text() -> None:\n    with pytest.raises(ValueError):\n        web.Response(\n            headers={\"Content-Type\": \"application/json\"}, charset=\"koi8-r\", text=\"text\"\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor_both_content_type_param_and_header",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 974,
      "end_line_number": 978,
      "source_code": "def test_ctor_both_content_type_param_and_header() -> None:\n    with pytest.raises(ValueError):\n        web.Response(\n            headers={\"Content-Type\": \"application/json\"}, content_type=\"text/html\"\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ctor_both_charset_param_and_header",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 981,
      "end_line_number": 983,
      "source_code": "def test_ctor_both_charset_param_and_header() -> None:\n    with pytest.raises(ValueError):\n        web.Response(headers={\"Content-Type\": \"application/json\"}, charset=\"koi8-r\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_assign_nonstr_text",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 1001,
      "end_line_number": 1007,
      "source_code": "def test_assign_nonstr_text() -> None:\n    resp = web.Response(text=\"test\")\n\n    with pytest.raises(AssertionError):\n        resp.text = b\"123\"  # type: ignore[assignment]\n    assert b\"test\" == resp.body\n    assert 4 == resp.content_length",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert b'test' == resp.body",
        "assert 4 == resp.content_length"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_payload_body_get_text",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 1043,
      "end_line_number": 1049,
      "source_code": "def test_payload_body_get_text(payload: object, expected: Optional[str]) -> None:\n    resp = web.Response(body=payload)\n    if expected is None:\n        with pytest.raises(TypeError):\n            resp.text\n    else:\n        assert resp.text == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('payload,expected', (('test', 'test'), (CustomIO(), 'test'), (io.StringIO('test'), 'test'), (io.TextIOWrapper(io.BytesIO(b'test')), 'test'), (io.BytesIO(b'test'), 'test'), (io.BufferedReader(io.BytesIO(b'test')), 'test'), (async_iter(), None), (BodyPartReader(b'x', CIMultiDictProxy(CIMultiDict()), mock.Mock()), None), (mpwriter, '--x\\nContent-Type: text/plain; charset=utf-8\\r\\nContent-Length: 4\\r\\n\\r\\ntest')))"
      ],
      "arguments": [
        "payload",
        "expected"
      ],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.text == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_response_set_content_length",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 1052,
      "end_line_number": 1055,
      "source_code": "def test_response_set_content_length() -> None:\n    resp = web.Response()\n    with pytest.raises(RuntimeError):\n        resp.content_length = 1",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_set_text_with_content_type",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 1136,
      "end_line_number": 1143,
      "source_code": "def test_set_text_with_content_type() -> None:\n    resp = web.Response()\n    resp.content_type = \"text/html\"\n    resp.text = \"text\"\n\n    assert \"text\" == resp.text\n    assert b\"text\" == resp.body\n    assert \"text/html\" == resp.content_type",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'text' == resp.text",
        "assert b'text' == resp.body",
        "assert 'text/html' == resp.content_type"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_set_text_with_charset",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 1146,
      "end_line_number": 1154,
      "source_code": "def test_set_text_with_charset() -> None:\n    resp = web.Response()\n    resp.content_type = \"text/plain\"\n    resp.charset = \"KOI8-R\"\n    resp.text = \"\u0442\u0435\u043a\u0441\u0442\"\n\n    assert \"\u0442\u0435\u043a\u0441\u0442\" == resp.text\n    assert \"\u0442\u0435\u043a\u0441\u0442\".encode(\"koi8-r\") == resp.body\n    assert \"koi8-r\" == resp.charset",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert '\u0442\u0435\u043a\u0441\u0442' == resp.text",
        "assert '\u0442\u0435\u043a\u0441\u0442'.encode('koi8-r') == resp.body",
        "assert 'koi8-r' == resp.charset"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_default_content_type_in_stream_response",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 1157,
      "end_line_number": 1159,
      "source_code": "def test_default_content_type_in_stream_response() -> None:\n    resp = web.StreamResponse()\n    assert resp.content_type == \"application/octet-stream\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.content_type == 'application/octet-stream'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_default_content_type_in_response",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 1162,
      "end_line_number": 1164,
      "source_code": "def test_default_content_type_in_response() -> None:\n    resp = web.Response()\n    assert resp.content_type == \"application/octet-stream\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.content_type == 'application/octet-stream'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_content_type_with_set_text",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 1167,
      "end_line_number": 1169,
      "source_code": "def test_content_type_with_set_text() -> None:\n    resp = web.Response(text=\"text\")\n    assert resp.content_type == \"text/plain\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.content_type == 'text/plain'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_content_type_with_set_body",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 1172,
      "end_line_number": 1174,
      "source_code": "def test_content_type_with_set_body() -> None:\n    resp = web.Response(body=b\"body\")\n    assert resp.content_type == \"application/octet-stream\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.content_type == 'application/octet-stream'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_prepared_when_not_started",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 1177,
      "end_line_number": 1179,
      "source_code": "def test_prepared_when_not_started() -> None:\n    resp = web.StreamResponse()\n    assert not resp.prepared",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert not resp.prepared"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_nonstr_text_in_ctor",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 1209,
      "end_line_number": 1211,
      "source_code": "def test_nonstr_text_in_ctor() -> None:\n    with pytest.raises(TypeError):\n        web.Response(text=b\"data\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_text_in_ctor_with_content_type",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 1214,
      "end_line_number": 1217,
      "source_code": "def test_text_in_ctor_with_content_type() -> None:\n    resp = web.Response(text=\"data\", content_type=\"text/html\")\n    assert \"data\" == resp.text\n    assert \"text/html\" == resp.content_type",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'data' == resp.text",
        "assert 'text/html' == resp.content_type"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_text_in_ctor_with_content_type_header",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 1220,
      "end_line_number": 1226,
      "source_code": "def test_text_in_ctor_with_content_type_header() -> None:\n    resp = web.Response(\n        text=\"\u0442\u0435\u043a\u0441\u0442\", headers={\"Content-Type\": \"text/html; charset=koi8-r\"}\n    )\n    assert \"\u0442\u0435\u043a\u0441\u0442\".encode(\"koi8-r\") == resp.body\n    assert \"text/html\" == resp.content_type\n    assert \"koi8-r\" == resp.charset",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert '\u0442\u0435\u043a\u0441\u0442'.encode('koi8-r') == resp.body",
        "assert 'text/html' == resp.content_type",
        "assert 'koi8-r' == resp.charset"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_text_in_ctor_with_content_type_header_multidict",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 1229,
      "end_line_number": 1234,
      "source_code": "def test_text_in_ctor_with_content_type_header_multidict() -> None:\n    headers = CIMultiDict({\"Content-Type\": \"text/html; charset=koi8-r\"})\n    resp = web.Response(text=\"\u0442\u0435\u043a\u0441\u0442\", headers=headers)\n    assert \"\u0442\u0435\u043a\u0441\u0442\".encode(\"koi8-r\") == resp.body\n    assert \"text/html\" == resp.content_type\n    assert \"koi8-r\" == resp.charset",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert '\u0442\u0435\u043a\u0441\u0442'.encode('koi8-r') == resp.body",
        "assert 'text/html' == resp.content_type",
        "assert 'koi8-r' == resp.charset"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_body_in_ctor_with_content_type_header_multidict",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 1237,
      "end_line_number": 1242,
      "source_code": "def test_body_in_ctor_with_content_type_header_multidict() -> None:\n    headers = CIMultiDict({\"Content-Type\": \"text/html; charset=koi8-r\"})\n    resp = web.Response(body=\"\u0442\u0435\u043a\u0441\u0442\".encode(\"koi8-r\"), headers=headers)\n    assert \"\u0442\u0435\u043a\u0441\u0442\".encode(\"koi8-r\") == resp.body\n    assert \"text/html\" == resp.content_type\n    assert \"koi8-r\" == resp.charset",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert '\u0442\u0435\u043a\u0441\u0442'.encode('koi8-r') == resp.body",
        "assert 'text/html' == resp.content_type",
        "assert 'koi8-r' == resp.charset"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_text_with_empty_payload",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 1245,
      "end_line_number": 1248,
      "source_code": "def test_text_with_empty_payload() -> None:\n    resp = web.Response(status=200)\n    assert resp.body is None\n    assert resp.text is None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.body is None",
        "assert resp.text is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_response_with_content_length_header_without_body",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 1251,
      "end_line_number": 1253,
      "source_code": "def test_response_with_content_length_header_without_body() -> None:\n    resp = web.Response(headers={\"Content-Length\": \"123\"})\n    assert resp.content_length == 123",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.content_length == 123"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_response_with_immutable_headers",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 1256,
      "end_line_number": 1263,
      "source_code": "def test_response_with_immutable_headers() -> None:\n    resp = web.Response(\n        text=\"text\", headers=CIMultiDictProxy(CIMultiDict({\"Header\": \"Value\"}))\n    )\n    assert resp.headers == {\n        \"Header\": \"Value\",\n        \"Content-Type\": \"text/plain; charset=utf-8\",\n    }",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.headers == {'Header': 'Value', 'Content-Type': 'text/plain; charset=utf-8'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_weakref_creation",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 1290,
      "end_line_number": 1292,
      "source_code": "def test_weakref_creation() -> None:\n    resp = web.Response()\n    weakref.ref(resp)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_content_type_is_application_json_by_default",
      "module": "test_web_response",
      "class_name": "TestJSONResponse",
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 1296,
      "end_line_number": 1298,
      "source_code": "def test_content_type_is_application_json_by_default(self) -> None:\n        resp = web.json_response(\"\")\n        assert \"application/json\" == resp.content_type",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'application/json' == resp.content_type"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_passing_text_only",
      "module": "test_web_response",
      "class_name": "TestJSONResponse",
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 1300,
      "end_line_number": 1302,
      "source_code": "def test_passing_text_only(self) -> None:\n        resp = web.json_response(text=json.dumps(\"jaysawn\"))\n        assert resp.text == json.dumps(\"jaysawn\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.text == json.dumps('jaysawn')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_data_and_text_raises_value_error",
      "module": "test_web_response",
      "class_name": "TestJSONResponse",
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 1304,
      "end_line_number": 1308,
      "source_code": "def test_data_and_text_raises_value_error(self) -> None:\n        with pytest.raises(ValueError) as excinfo:\n            web.json_response(data=\"foo\", text=\"bar\")\n        expected_message = \"only one of data, text, or body should be specified\"\n        assert expected_message == excinfo.value.args[0]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert expected_message == excinfo.value.args[0]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_data_and_body_raises_value_error",
      "module": "test_web_response",
      "class_name": "TestJSONResponse",
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 1310,
      "end_line_number": 1314,
      "source_code": "def test_data_and_body_raises_value_error(self) -> None:\n        with pytest.raises(ValueError) as excinfo:\n            web.json_response(data=\"foo\", body=b\"bar\")\n        expected_message = \"only one of data, text, or body should be specified\"\n        assert expected_message == excinfo.value.args[0]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert expected_message == excinfo.value.args[0]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_text_is_json_encoded",
      "module": "test_web_response",
      "class_name": "TestJSONResponse",
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 1316,
      "end_line_number": 1318,
      "source_code": "def test_text_is_json_encoded(self) -> None:\n        resp = web.json_response({\"foo\": 42})\n        assert json.dumps({\"foo\": 42}) == resp.text",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert json.dumps({'foo': 42}) == resp.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_content_type_is_overrideable",
      "module": "test_web_response",
      "class_name": "TestJSONResponse",
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 1320,
      "end_line_number": 1322,
      "source_code": "def test_content_type_is_overrideable(self) -> None:\n        resp = web.json_response({\"foo\": 42}, content_type=\"application/vnd.json+api\")\n        assert \"application/vnd.json+api\" == resp.content_type",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'application/vnd.json+api' == resp.content_type"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_content_type_is_application_json_by_default",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 1296,
      "end_line_number": 1298,
      "source_code": "def test_content_type_is_application_json_by_default(self) -> None:\n        resp = web.json_response(\"\")\n        assert \"application/json\" == resp.content_type",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'application/json' == resp.content_type"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_passing_text_only",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 1300,
      "end_line_number": 1302,
      "source_code": "def test_passing_text_only(self) -> None:\n        resp = web.json_response(text=json.dumps(\"jaysawn\"))\n        assert resp.text == json.dumps(\"jaysawn\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.text == json.dumps('jaysawn')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_data_and_text_raises_value_error",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 1304,
      "end_line_number": 1308,
      "source_code": "def test_data_and_text_raises_value_error(self) -> None:\n        with pytest.raises(ValueError) as excinfo:\n            web.json_response(data=\"foo\", text=\"bar\")\n        expected_message = \"only one of data, text, or body should be specified\"\n        assert expected_message == excinfo.value.args[0]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert expected_message == excinfo.value.args[0]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_data_and_body_raises_value_error",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 1310,
      "end_line_number": 1314,
      "source_code": "def test_data_and_body_raises_value_error(self) -> None:\n        with pytest.raises(ValueError) as excinfo:\n            web.json_response(data=\"foo\", body=b\"bar\")\n        expected_message = \"only one of data, text, or body should be specified\"\n        assert expected_message == excinfo.value.args[0]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert expected_message == excinfo.value.args[0]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_text_is_json_encoded",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 1316,
      "end_line_number": 1318,
      "source_code": "def test_text_is_json_encoded(self) -> None:\n        resp = web.json_response({\"foo\": 42})\n        assert json.dumps({\"foo\": 42}) == resp.text",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert json.dumps({'foo': 42}) == resp.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_content_type_is_overrideable",
      "module": "test_web_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_response.py",
      "line_number": 1320,
      "end_line_number": 1322,
      "source_code": "def test_content_type_is_overrideable(self) -> None:\n        resp = web.json_response({\"foo\": 42}, content_type=\"application/vnd.json+api\")\n        assert \"application/vnd.json+api\" == resp.content_type",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections.abc",
        "datetime",
        "gzip",
        "io",
        "json",
        "re",
        "weakref",
        "zlib",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.AsyncIterator",
        "typing.Optional",
        "typing.Union",
        "unittest.mock",
        "aiosignal",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "aiohttp.HttpVersion",
        "aiohttp.HttpVersion10",
        "aiohttp.HttpVersion11",
        "aiohttp.hdrs",
        "aiohttp.web",
        "aiohttp.abc.AbstractStreamWriter",
        "aiohttp.helpers.ETag",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.http_writer._serialize_headers",
        "aiohttp.multipart.BodyPartReader",
        "aiohttp.multipart.MultipartWriter",
        "aiohttp.payload.BytesPayload",
        "aiohttp.payload.StringPayload",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.LooseHeaders"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'application/vnd.json+api' == resp.content_type"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_c_parser_loaded",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 106,
      "end_line_number": 110,
      "source_code": "def test_c_parser_loaded() -> None:\n    assert \"HttpRequestParserC\" in dir(aiohttp.http_parser)\n    assert \"HttpResponseParserC\" in dir(aiohttp.http_parser)\n    assert \"RawRequestMessageC\" in dir(aiohttp.http_parser)\n    assert \"RawResponseMessageC\" in dir(aiohttp.http_parser)",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(NO_EXTENSIONS, reason='Extensions available but not imported')"
      ],
      "arguments": [],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'HttpRequestParserC' in dir(aiohttp.http_parser)",
        "assert 'HttpResponseParserC' in dir(aiohttp.http_parser)",
        "assert 'RawRequestMessageC' in dir(aiohttp.http_parser)",
        "assert 'RawResponseMessageC' in dir(aiohttp.http_parser)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_parse_headers",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 113,
      "end_line_number": 127,
      "source_code": "def test_parse_headers(parser: HttpRequestParser) -> None:\n    text = b\"\"\"GET /test HTTP/1.1\\r\ntest: a line\\r\ntest2: data\\r\n\\r\n\"\"\"\n    messages, upgrade, tail = parser.feed_data(text)\n    assert len(messages) == 1\n    msg = messages[0][0]\n\n    assert list(msg.headers.items()) == [(\"test\", \"a line\"), (\"test2\", \"data\")]\n    assert msg.raw_headers == ((b\"test\", b\"a line\"), (b\"test2\", b\"data\"))\n    assert not msg.should_close\n    assert msg.compression is None\n    assert not msg.upgrade",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(messages) == 1",
        "assert list(msg.headers.items()) == [('test', 'a line'), ('test2', 'data')]",
        "assert msg.raw_headers == ((b'test', b'a line'), (b'test2', b'data'))",
        "assert not msg.should_close",
        "assert msg.compression is None",
        "assert not msg.upgrade"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_reject_obsolete_line_folding",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 130,
      "end_line_number": 138,
      "source_code": "def test_reject_obsolete_line_folding(parser: HttpRequestParser) -> None:\n    text = b\"\"\"GET /test HTTP/1.1\\r\ntest: line\\r\n Content-Length: 48\\r\ntest2: data\\r\n\\r\n\"\"\"\n    with pytest.raises(http_exceptions.BadHttpMessage):\n        parser.feed_data(text)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_invalid_character",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 142,
      "end_line_number": 162,
      "source_code": "def test_invalid_character(\n    loop: asyncio.AbstractEventLoop,\n    protocol: BaseProtocol,\n    request: pytest.FixtureRequest,\n) -> None:\n    parser = HttpRequestParserC(\n        protocol,\n        loop,\n        2**16,\n        max_line_size=8190,\n        max_field_size=8190,\n    )\n    text = b\"POST / HTTP/1.1\\r\\nHost: localhost:8080\\r\\nSet-Cookie: abc\\x01def\\r\\n\\r\\n\"\n    error_detail = re.escape(\n        r\"\"\":\n\n    b'Set-Cookie: abc\\x01def'\n                     ^\"\"\"\n    )\n    with pytest.raises(http_exceptions.BadHttpMessage, match=error_detail):\n        parser.feed_data(text)",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(NO_EXTENSIONS, reason='Only tests C parser.')"
      ],
      "arguments": [
        "loop",
        "protocol",
        "request"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_invalid_linebreak",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 166,
      "end_line_number": 186,
      "source_code": "def test_invalid_linebreak(\n    loop: asyncio.AbstractEventLoop,\n    protocol: BaseProtocol,\n    request: pytest.FixtureRequest,\n) -> None:\n    parser = HttpRequestParserC(\n        protocol,\n        loop,\n        2**16,\n        max_line_size=8190,\n        max_field_size=8190,\n    )\n    text = b\"GET /world HTTP/1.1\\r\\nHost: 127.0.0.1\\n\\r\\n\"\n    error_detail = re.escape(\n        r\"\"\":\n\n    b'Host: 127.0.0.1\\n'\n                     ^\"\"\"\n    )\n    with pytest.raises(http_exceptions.BadHttpMessage, match=error_detail):\n        parser.feed_data(text)",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(NO_EXTENSIONS, reason='Only tests C parser.')"
      ],
      "arguments": [
        "loop",
        "protocol",
        "request"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_cve_2023_37276",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 189,
      "end_line_number": 192,
      "source_code": "def test_cve_2023_37276(parser: HttpRequestParser) -> None:\n    text = b\"\"\"POST / HTTP/1.1\\r\\nHost: localhost:8080\\r\\nX-Abc: \\rxTransfer-Encoding: chunked\\r\\n\\r\\n\"\"\"\n    with pytest.raises(http_exceptions.BadHttpMessage):\n        parser.feed_data(text)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_bad_header_name",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 199,
      "end_line_number": 209,
      "source_code": "def test_bad_header_name(\n    parser: HttpRequestParser, rfc9110_5_6_2_token_delim: str\n) -> None:\n    text = f\"POST / HTTP/1.1\\r\\nhead{rfc9110_5_6_2_token_delim}er: val\\r\\n\\r\\n\".encode()\n    if rfc9110_5_6_2_token_delim == \":\":\n        # Inserting colon into header just splits name/value earlier.\n        parser.feed_data(text)\n        return\n\n    with pytest.raises(http_exceptions.BadHttpMessage):\n        parser.feed_data(text)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('rfc9110_5_6_2_token_delim', '\"(),/:;<=>?@[\\\\]{}')"
      ],
      "arguments": [
        "parser",
        "rfc9110_5_6_2_token_delim"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_bad_headers",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 227,
      "end_line_number": 230,
      "source_code": "def test_bad_headers(parser: HttpRequestParser, hdr: str) -> None:\n    text = f\"POST / HTTP/1.1\\r\\n{hdr}\\r\\n\\r\\n\".encode()\n    with pytest.raises(http_exceptions.BadHttpMessage):\n        parser.feed_data(text)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('hdr', ('Content-Length: -5', 'Content-Length: +256', 'Content-Length: \u00b9', 'Content-Length: \ud835\udfd9', 'Foo: abc\\rdef', 'Bar: abc\\ndef', 'Baz: abc\\x00def', 'Foo : bar', 'Foo\\t: bar', '\u00ffoo: bar'))"
      ],
      "arguments": [
        "parser",
        "hdr"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_unpaired_surrogate_in_header_py",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 233,
      "end_line_number": 249,
      "source_code": "def test_unpaired_surrogate_in_header_py(\n    loop: asyncio.AbstractEventLoop, protocol: BaseProtocol\n) -> None:\n    parser = HttpRequestParserPy(\n        protocol,\n        loop,\n        2**16,\n        max_line_size=8190,\n        max_field_size=8190,\n    )\n    text = b\"POST / HTTP/1.1\\r\\n\\xff\\r\\n\\r\\n\"\n    message = None\n    try:\n        parser.feed_data(text)\n    except http_exceptions.InvalidHeader as e:\n        message = e.message.encode(\"utf-8\")\n    assert message is not None",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop",
        "protocol"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert message is not None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_content_length_transfer_encoding",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 252,
      "end_line_number": 258,
      "source_code": "def test_content_length_transfer_encoding(parser: HttpRequestParser) -> None:\n    text = (\n        b\"GET / HTTP/1.1\\r\\nHost: a\\r\\nContent-Length: 5\\r\\nTransfer-Encoding: a\\r\\n\\r\\n\"\n        + b\"apple\\r\\n\"\n    )\n    with pytest.raises(http_exceptions.BadHttpMessage):\n        parser.feed_data(text)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_bad_chunked_py",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 261,
      "end_line_number": 277,
      "source_code": "def test_bad_chunked_py(\n    loop: asyncio.AbstractEventLoop, protocol: BaseProtocol\n) -> None:\n    \"\"\"Test that invalid chunked encoding doesn't allow content-length to be used.\"\"\"\n    parser = HttpRequestParserPy(\n        protocol,\n        loop,\n        2**16,\n        max_line_size=8190,\n        max_field_size=8190,\n    )\n    text = (\n        b\"GET / HTTP/1.1\\r\\nHost: a\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n0_2e\\r\\n\\r\\n\"\n        + b\"GET / HTTP/1.1\\r\\nHost: a\\r\\nContent-Length: 5\\r\\n\\r\\n0\\r\\n\\r\\n\"\n    )\n    messages, upgrade, tail = parser.feed_data(text)\n    assert isinstance(messages[0][1].exception(), http_exceptions.TransferEncodingError)",
      "docstring": "Test that invalid chunked encoding doesn't allow content-length to be used.",
      "decorators": [],
      "arguments": [
        "loop",
        "protocol"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(messages[0][1].exception(), http_exceptions.TransferEncodingError)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_bad_chunked_c",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 284,
      "end_line_number": 298,
      "source_code": "def test_bad_chunked_c(loop: asyncio.AbstractEventLoop, protocol: BaseProtocol) -> None:\n    \"\"\"C parser behaves differently. Maybe we should align them later.\"\"\"\n    parser = HttpRequestParserC(\n        protocol,\n        loop,\n        2**16,\n        max_line_size=8190,\n        max_field_size=8190,\n    )\n    text = (\n        b\"GET / HTTP/1.1\\r\\nHost: a\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n0_2e\\r\\n\\r\\n\"\n        + b\"GET / HTTP/1.1\\r\\nHost: a\\r\\nContent-Length: 5\\r\\n\\r\\n0\\r\\n\\r\\n\"\n    )\n    with pytest.raises(http_exceptions.BadHttpMessage):\n        parser.feed_data(text)",
      "docstring": "C parser behaves differently. Maybe we should align them later.",
      "decorators": [
        "pytest.mark.skipif('HttpRequestParserC' not in dir(aiohttp.http_parser), reason='C based HTTP parser not available')"
      ],
      "arguments": [
        "loop",
        "protocol"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_whitespace_before_header",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 301,
      "end_line_number": 304,
      "source_code": "def test_whitespace_before_header(parser: HttpRequestParser) -> None:\n    text = b\"GET / HTTP/1.1\\r\\n\\tContent-Length: 1\\r\\n\\r\\nX\"\n    with pytest.raises(http_exceptions.BadHttpMessage):\n        parser.feed_data(text)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_parse_headers_longline",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 307,
      "end_line_number": 313,
      "source_code": "def test_parse_headers_longline(parser: HttpRequestParser) -> None:\n    invalid_unicode_byte = b\"\\xd9\"\n    header_name = b\"Test\" + invalid_unicode_byte + b\"Header\" + b\"A\" * 8192\n    text = b\"GET /test HTTP/1.1\\r\\n\" + header_name + b\": test\\r\\n\" + b\"\\r\\n\" + b\"\\r\\n\"\n    with pytest.raises((http_exceptions.LineTooLong, http_exceptions.BadHttpMessage)):\n        # FIXME: `LineTooLong` doesn't seem to actually be happening\n        parser.feed_data(text)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_parse_unusual_request_line",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 329,
      "end_line_number": 338,
      "source_code": "def test_parse_unusual_request_line(parser: HttpRequestParser) -> None:\n    text = b\"#smol //a HTTP/1.3\\r\\n\\r\\n\"\n    messages, upgrade, tail = parser.feed_data(text)\n    assert len(messages) == 1\n    msg, _ = messages[0]\n    assert msg.compression is None\n    assert not msg.upgrade\n    assert msg.method == \"#smol\"\n    assert msg.path == \"//a\"\n    assert msg.version == (1, 3)",
      "docstring": null,
      "decorators": [
        "pytest.mark.usefixtures('xfail_c_parser_status')"
      ],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(messages) == 1",
        "assert msg.compression is None",
        "assert not msg.upgrade",
        "assert msg.method == '#smol'",
        "assert msg.path == '//a'",
        "assert msg.version == (1, 3)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_parse",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 341,
      "end_line_number": 350,
      "source_code": "def test_parse(parser: HttpRequestParser) -> None:\n    text = b\"GET /test HTTP/1.1\\r\\n\\r\\n\"\n    messages, upgrade, tail = parser.feed_data(text)\n    assert len(messages) == 1\n    msg, _ = messages[0]\n    assert msg.compression is None\n    assert not msg.upgrade\n    assert msg.method == \"GET\"\n    assert msg.path == \"/test\"\n    assert msg.version == (1, 1)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(messages) == 1",
        "assert msg.compression is None",
        "assert not msg.upgrade",
        "assert msg.method == 'GET'",
        "assert msg.path == '/test'",
        "assert msg.version == (1, 1)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_parse_delayed",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 371,
      "end_line_number": 380,
      "source_code": "def test_parse_delayed(parser: HttpRequestParser) -> None:\n    text = b\"GET /test HTTP/1.1\\r\\n\"\n    messages, upgrade, tail = parser.feed_data(text)\n    assert len(messages) == 0\n    assert not upgrade\n\n    messages, upgrade, tail = parser.feed_data(b\"\\r\\n\")\n    assert len(messages) == 1\n    msg = messages[0][0]\n    assert msg.method == \"GET\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(messages) == 0",
        "assert not upgrade",
        "assert len(messages) == 1",
        "assert msg.method == 'GET'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_headers_multi_feed",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 383,
      "end_line_number": 402,
      "source_code": "def test_headers_multi_feed(parser: HttpRequestParser) -> None:\n    text1 = b\"GET /test HTTP/1.1\\r\\n\"\n    text2 = b\"test: line\"\n    text3 = b\" continue\\r\\n\\r\\n\"\n\n    messages, upgrade, tail = parser.feed_data(text1)\n    assert len(messages) == 0\n\n    messages, upgrade, tail = parser.feed_data(text2)\n    assert len(messages) == 0\n\n    messages, upgrade, tail = parser.feed_data(text3)\n    assert len(messages) == 1\n\n    msg = messages[0][0]\n    assert list(msg.headers.items()) == [(\"test\", \"line continue\")]\n    assert msg.raw_headers == ((b\"test\", b\"line continue\"),)\n    assert not msg.should_close\n    assert msg.compression is None\n    assert not msg.upgrade",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(messages) == 0",
        "assert len(messages) == 0",
        "assert len(messages) == 1",
        "assert list(msg.headers.items()) == [('test', 'line continue')]",
        "assert msg.raw_headers == ((b'test', b'line continue'),)",
        "assert not msg.should_close",
        "assert msg.compression is None",
        "assert not msg.upgrade"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_headers_split_field",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 405,
      "end_line_number": 423,
      "source_code": "def test_headers_split_field(parser: HttpRequestParser) -> None:\n    text1 = b\"GET /test HTTP/1.1\\r\\n\"\n    text2 = b\"t\"\n    text3 = b\"es\"\n    text4 = b\"t: value\\r\\n\\r\\n\"\n\n    messages, upgrade, tail = parser.feed_data(text1)\n    messages, upgrade, tail = parser.feed_data(text2)\n    messages, upgrade, tail = parser.feed_data(text3)\n    assert len(messages) == 0\n    messages, upgrade, tail = parser.feed_data(text4)\n    assert len(messages) == 1\n\n    msg = messages[0][0]\n    assert list(msg.headers.items()) == [(\"test\", \"value\")]\n    assert msg.raw_headers == ((b\"test\", b\"value\"),)\n    assert not msg.should_close\n    assert msg.compression is None\n    assert not msg.upgrade",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(messages) == 0",
        "assert len(messages) == 1",
        "assert list(msg.headers.items()) == [('test', 'value')]",
        "assert msg.raw_headers == ((b'test', b'value'),)",
        "assert not msg.should_close",
        "assert msg.compression is None",
        "assert not msg.upgrade"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_parse_headers_multi",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 426,
      "end_line_number": 446,
      "source_code": "def test_parse_headers_multi(parser: HttpRequestParser) -> None:\n    text = (\n        b\"GET /test HTTP/1.1\\r\\n\"\n        b\"Set-Cookie: c1=cookie1\\r\\n\"\n        b\"Set-Cookie: c2=cookie2\\r\\n\\r\\n\"\n    )\n\n    messages, upgrade, tail = parser.feed_data(text)\n    assert len(messages) == 1\n    msg = messages[0][0]\n\n    assert list(msg.headers.items()) == [\n        (\"Set-Cookie\", \"c1=cookie1\"),\n        (\"Set-Cookie\", \"c2=cookie2\"),\n    ]\n    assert msg.raw_headers == (\n        (b\"Set-Cookie\", b\"c1=cookie1\"),\n        (b\"Set-Cookie\", b\"c2=cookie2\"),\n    )\n    assert not msg.should_close\n    assert msg.compression is None",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(messages) == 1",
        "assert list(msg.headers.items()) == [('Set-Cookie', 'c1=cookie1'), ('Set-Cookie', 'c2=cookie2')]",
        "assert msg.raw_headers == ((b'Set-Cookie', b'c1=cookie1'), (b'Set-Cookie', b'c2=cookie2'))",
        "assert not msg.should_close",
        "assert msg.compression is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_conn_default_1_0",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 449,
      "end_line_number": 453,
      "source_code": "def test_conn_default_1_0(parser: HttpRequestParser) -> None:\n    text = b\"GET /test HTTP/1.0\\r\\n\\r\\n\"\n    messages, upgrade, tail = parser.feed_data(text)\n    msg = messages[0][0]\n    assert msg.should_close",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg.should_close"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_conn_default_1_1",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 456,
      "end_line_number": 460,
      "source_code": "def test_conn_default_1_1(parser: HttpRequestParser) -> None:\n    text = b\"GET /test HTTP/1.1\\r\\n\\r\\n\"\n    messages, upgrade, tail = parser.feed_data(text)\n    msg = messages[0][0]\n    assert not msg.should_close",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert not msg.should_close"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_conn_close",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 463,
      "end_line_number": 467,
      "source_code": "def test_conn_close(parser: HttpRequestParser) -> None:\n    text = b\"GET /test HTTP/1.1\\r\\nconnection: close\\r\\n\\r\\n\"\n    messages, upgrade, tail = parser.feed_data(text)\n    msg = messages[0][0]\n    assert msg.should_close",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg.should_close"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_conn_close_1_0",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 470,
      "end_line_number": 474,
      "source_code": "def test_conn_close_1_0(parser: HttpRequestParser) -> None:\n    text = b\"GET /test HTTP/1.0\\r\\nconnection: close\\r\\n\\r\\n\"\n    messages, upgrade, tail = parser.feed_data(text)\n    msg = messages[0][0]\n    assert msg.should_close",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg.should_close"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_conn_keep_alive_1_0",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 477,
      "end_line_number": 481,
      "source_code": "def test_conn_keep_alive_1_0(parser: HttpRequestParser) -> None:\n    text = b\"GET /test HTTP/1.0\\r\\nconnection: keep-alive\\r\\n\\r\\n\"\n    messages, upgrade, tail = parser.feed_data(text)\n    msg = messages[0][0]\n    assert not msg.should_close",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert not msg.should_close"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_conn_keep_alive_1_1",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 484,
      "end_line_number": 488,
      "source_code": "def test_conn_keep_alive_1_1(parser: HttpRequestParser) -> None:\n    text = b\"GET /test HTTP/1.1\\r\\nconnection: keep-alive\\r\\n\\r\\n\"\n    messages, upgrade, tail = parser.feed_data(text)\n    msg = messages[0][0]\n    assert not msg.should_close",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert not msg.should_close"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_conn_other_1_0",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 491,
      "end_line_number": 495,
      "source_code": "def test_conn_other_1_0(parser: HttpRequestParser) -> None:\n    text = b\"GET /test HTTP/1.0\\r\\nconnection: test\\r\\n\\r\\n\"\n    messages, upgrade, tail = parser.feed_data(text)\n    msg = messages[0][0]\n    assert msg.should_close",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg.should_close"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_conn_other_1_1",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 498,
      "end_line_number": 502,
      "source_code": "def test_conn_other_1_1(parser: HttpRequestParser) -> None:\n    text = b\"GET /test HTTP/1.1\\r\\nconnection: test\\r\\n\\r\\n\"\n    messages, upgrade, tail = parser.feed_data(text)\n    msg = messages[0][0]\n    assert not msg.should_close",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert not msg.should_close"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_request_chunked",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 505,
      "end_line_number": 511,
      "source_code": "def test_request_chunked(parser: HttpRequestParser) -> None:\n    text = b\"GET /test HTTP/1.1\\r\\ntransfer-encoding: chunked\\r\\n\\r\\n\"\n    messages, upgrade, tail = parser.feed_data(text)\n    msg, payload = messages[0]\n    assert msg.chunked\n    assert not upgrade\n    assert isinstance(payload, streams.StreamReader)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg.chunked",
        "assert not upgrade",
        "assert isinstance(payload, streams.StreamReader)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_request_te_chunked_with_content_length",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 514,
      "end_line_number": 524,
      "source_code": "def test_request_te_chunked_with_content_length(parser: HttpRequestParser) -> None:\n    text = (\n        b\"GET /test HTTP/1.1\\r\\n\"\n        b\"content-length: 1234\\r\\n\"\n        b\"transfer-encoding: chunked\\r\\n\\r\\n\"\n    )\n    with pytest.raises(\n        http_exceptions.BadHttpMessage,\n        match=\"Transfer-Encoding can't be present with Content-Length\",\n    ):\n        parser.feed_data(text)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_request_te_chunked123",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 527,
      "end_line_number": 533,
      "source_code": "def test_request_te_chunked123(parser: HttpRequestParser) -> None:\n    text = b\"GET /test HTTP/1.1\\r\\ntransfer-encoding: chunked123\\r\\n\\r\\n\"\n    with pytest.raises(\n        http_exceptions.BadHttpMessage,\n        match=\"Request has invalid `Transfer-Encoding`\",\n    ):\n        parser.feed_data(text)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_request_te_first_chunked",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 543,
      "end_line_number": 550,
      "source_code": "def test_request_te_first_chunked(parser: HttpRequestParser) -> None:\n    text = b\"GET /test HTTP/1.1\\r\\nTransfer-Encoding: chunked, not\\r\\n\\r\\n1\\r\\nT\\r\\n3\\r\\nest\\r\\n0\\r\\n\\r\\n\"\n    # https://www.rfc-editor.org/rfc/rfc9112#section-6.3-2.4.3\n    with pytest.raises(\n        http_exceptions.BadHttpMessage,\n        match=\"nvalid `Transfer-Encoding`\",\n    ):\n        parser.feed_data(text)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_conn_upgrade",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 553,
      "end_line_number": 563,
      "source_code": "def test_conn_upgrade(parser: HttpRequestParser) -> None:\n    text = (\n        b\"GET /test HTTP/1.1\\r\\n\"\n        b\"connection: upgrade\\r\\n\"\n        b\"upgrade: websocket\\r\\n\\r\\n\"\n    )\n    messages, upgrade, tail = parser.feed_data(text)\n    msg = messages[0][0]\n    assert not msg.should_close\n    assert msg.upgrade\n    assert upgrade",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert not msg.should_close",
        "assert msg.upgrade",
        "assert upgrade"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_bad_upgrade",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 566,
      "end_line_number": 572,
      "source_code": "def test_bad_upgrade(parser: HttpRequestParser) -> None:\n    \"\"\"Test not upgraded if missing Upgrade header.\"\"\"\n    text = b\"GET /test HTTP/1.1\\r\\nconnection: upgrade\\r\\n\\r\\n\"\n    messages, upgrade, tail = parser.feed_data(text)\n    msg = messages[0][0]\n    assert not msg.upgrade\n    assert not upgrade",
      "docstring": "Test not upgraded if missing Upgrade header.",
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert not msg.upgrade",
        "assert not upgrade"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_compression_empty",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 575,
      "end_line_number": 579,
      "source_code": "def test_compression_empty(parser: HttpRequestParser) -> None:\n    text = b\"GET /test HTTP/1.1\\r\\ncontent-encoding: \\r\\n\\r\\n\"\n    messages, upgrade, tail = parser.feed_data(text)\n    msg = messages[0][0]\n    assert msg.compression is None",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg.compression is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_compression_deflate",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 582,
      "end_line_number": 586,
      "source_code": "def test_compression_deflate(parser: HttpRequestParser) -> None:\n    text = b\"GET /test HTTP/1.1\\r\\ncontent-encoding: deflate\\r\\n\\r\\n\"\n    messages, upgrade, tail = parser.feed_data(text)\n    msg = messages[0][0]\n    assert msg.compression == \"deflate\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg.compression == 'deflate'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_compression_gzip",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 589,
      "end_line_number": 593,
      "source_code": "def test_compression_gzip(parser: HttpRequestParser) -> None:\n    text = b\"GET /test HTTP/1.1\\r\\ncontent-encoding: gzip\\r\\n\\r\\n\"\n    messages, upgrade, tail = parser.feed_data(text)\n    msg = messages[0][0]\n    assert msg.compression == \"gzip\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg.compression == 'gzip'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_compression_brotli",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 597,
      "end_line_number": 601,
      "source_code": "def test_compression_brotli(parser: HttpRequestParser) -> None:\n    text = b\"GET /test HTTP/1.1\\r\\ncontent-encoding: br\\r\\n\\r\\n\"\n    messages, upgrade, tail = parser.feed_data(text)\n    msg = messages[0][0]\n    assert msg.compression == \"br\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(brotli is None, reason='brotli is not installed')"
      ],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg.compression == 'br'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_compression_unknown",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 604,
      "end_line_number": 608,
      "source_code": "def test_compression_unknown(parser: HttpRequestParser) -> None:\n    text = b\"GET /test HTTP/1.1\\r\\ncontent-encoding: compress\\r\\n\\r\\n\"\n    messages, upgrade, tail = parser.feed_data(text)\n    msg = messages[0][0]\n    assert msg.compression is None",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg.compression is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_url_connect",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 611,
      "end_line_number": 616,
      "source_code": "def test_url_connect(parser: HttpRequestParser) -> None:\n    text = b\"CONNECT www.google.com HTTP/1.1\\r\\ncontent-length: 0\\r\\n\\r\\n\"\n    messages, upgrade, tail = parser.feed_data(text)\n    msg, payload = messages[0]\n    assert upgrade\n    assert msg.url == URL.build(authority=\"www.google.com\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert upgrade",
        "assert msg.url == URL.build(authority='www.google.com')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_headers_connect",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 619,
      "end_line_number": 624,
      "source_code": "def test_headers_connect(parser: HttpRequestParser) -> None:\n    text = b\"CONNECT www.google.com HTTP/1.1\\r\\ncontent-length: 0\\r\\n\\r\\n\"\n    messages, upgrade, tail = parser.feed_data(text)\n    msg, payload = messages[0]\n    assert upgrade\n    assert isinstance(payload, streams.StreamReader)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert upgrade",
        "assert isinstance(payload, streams.StreamReader)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_url_absolute",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 627,
      "end_line_number": 636,
      "source_code": "def test_url_absolute(parser: HttpRequestParser) -> None:\n    text = (\n        b\"GET https://www.google.com/path/to.html HTTP/1.1\\r\\n\"\n        b\"content-length: 0\\r\\n\\r\\n\"\n    )\n    messages, upgrade, tail = parser.feed_data(text)\n    msg, payload = messages[0]\n    assert not upgrade\n    assert msg.method == \"GET\"\n    assert msg.url == URL(\"https://www.google.com/path/to.html\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert not upgrade",
        "assert msg.method == 'GET'",
        "assert msg.url == URL('https://www.google.com/path/to.html')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_headers_old_websocket_key1",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 639,
      "end_line_number": 643,
      "source_code": "def test_headers_old_websocket_key1(parser: HttpRequestParser) -> None:\n    text = b\"GET /test HTTP/1.1\\r\\nSEC-WEBSOCKET-KEY1: line\\r\\n\\r\\n\"\n\n    with pytest.raises(http_exceptions.BadHttpMessage):\n        parser.feed_data(text)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_headers_content_length_err_1",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 646,
      "end_line_number": 650,
      "source_code": "def test_headers_content_length_err_1(parser: HttpRequestParser) -> None:\n    text = b\"GET /test HTTP/1.1\\r\\ncontent-length: line\\r\\n\\r\\n\"\n\n    with pytest.raises(http_exceptions.BadHttpMessage):\n        parser.feed_data(text)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_headers_content_length_err_2",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 653,
      "end_line_number": 657,
      "source_code": "def test_headers_content_length_err_2(parser: HttpRequestParser) -> None:\n    text = b\"GET /test HTTP/1.1\\r\\ncontent-length: -1\\r\\n\\r\\n\"\n\n    with pytest.raises(http_exceptions.BadHttpMessage):\n        parser.feed_data(text)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_invalid_header_spacing",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 676,
      "end_line_number": 686,
      "source_code": "def test_invalid_header_spacing(\n    parser: HttpRequestParser, pad1: bytes, pad2: bytes, hdr: bytes\n) -> None:\n    text = b\"GET /test HTTP/1.1\\r\\n%s%s%s: value\\r\\n\\r\\n\" % (pad1, hdr, pad2)\n    if pad1 == pad2 == b\"\" and hdr != b\"\":\n        # one entry in param matrix is correct: non-empty name, not padded\n        parser.feed_data(text)\n        return\n\n    with pytest.raises(http_exceptions.BadHttpMessage):\n        parser.feed_data(text)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('hdr', [b'', b'foo'], ids=['name-empty', 'with-name'])",
        "pytest.mark.parametrize('pad2', _pad.keys(), ids=['post-' + n for n in _pad.values()])",
        "pytest.mark.parametrize('pad1', _pad.keys(), ids=['pre-' + n for n in _pad.values()])"
      ],
      "arguments": [
        "parser",
        "pad1",
        "pad2",
        "hdr"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_empty_header_name",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 689,
      "end_line_number": 692,
      "source_code": "def test_empty_header_name(parser: HttpRequestParser) -> None:\n    text = b\"GET /test HTTP/1.1\\r\\n:test\\r\\n\\r\\n\"\n    with pytest.raises(http_exceptions.BadHttpMessage):\n        parser.feed_data(text)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_invalid_header",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 695,
      "end_line_number": 698,
      "source_code": "def test_invalid_header(parser: HttpRequestParser) -> None:\n    text = b\"GET /test HTTP/1.1\\r\\ntest line\\r\\n\\r\\n\"\n    with pytest.raises(http_exceptions.BadHttpMessage):\n        parser.feed_data(text)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_invalid_name",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 701,
      "end_line_number": 705,
      "source_code": "def test_invalid_name(parser: HttpRequestParser) -> None:\n    text = b\"GET /test HTTP/1.1\\r\\ntest[]: line\\r\\n\\r\\n\"\n\n    with pytest.raises(http_exceptions.BadHttpMessage):\n        parser.feed_data(text)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_max_header_field_size",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 709,
      "end_line_number": 715,
      "source_code": "def test_max_header_field_size(parser: HttpRequestParser, size: int) -> None:\n    name = b\"t\" * size\n    text = b\"GET /test HTTP/1.1\\r\\n\" + name + b\":data\\r\\n\\r\\n\"\n\n    match = f\"400, message:\\n  Got more than 8190 bytes \\\\({size}\\\\) when reading\"\n    with pytest.raises(http_exceptions.LineTooLong, match=match):\n        parser.feed_data(text)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('size', [40960, 8191])"
      ],
      "arguments": [
        "parser",
        "size"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_max_header_field_size_under_limit",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 718,
      "end_line_number": 733,
      "source_code": "def test_max_header_field_size_under_limit(parser: HttpRequestParser) -> None:\n    name = b\"t\" * 8190\n    text = b\"GET /test HTTP/1.1\\r\\n\" + name + b\":data\\r\\n\\r\\n\"\n\n    messages, upgrade, tail = parser.feed_data(text)\n    msg = messages[0][0]\n    assert msg.method == \"GET\"\n    assert msg.path == \"/test\"\n    assert msg.version == (1, 1)\n    assert msg.headers == CIMultiDict({name.decode(): \"data\"})\n    assert msg.raw_headers == ((name, b\"data\"),)\n    assert not msg.should_close\n    assert msg.compression is None\n    assert not msg.upgrade\n    assert not msg.chunked\n    assert msg.url == URL(\"/test\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg.method == 'GET'",
        "assert msg.path == '/test'",
        "assert msg.version == (1, 1)",
        "assert msg.headers == CIMultiDict({name.decode(): 'data'})",
        "assert msg.raw_headers == ((name, b'data'),)",
        "assert not msg.should_close",
        "assert msg.compression is None",
        "assert not msg.upgrade",
        "assert not msg.chunked",
        "assert msg.url == URL('/test')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "name.decode",
          "body": "def decode(self, encoding: str='utf-8', errors: str='strict') -> str:\n    assert False"
        }
      ]
    },
    {
      "name": "test_max_header_value_size",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 737,
      "end_line_number": 743,
      "source_code": "def test_max_header_value_size(parser: HttpRequestParser, size: int) -> None:\n    name = b\"t\" * size\n    text = b\"GET /test HTTP/1.1\\r\\ndata:\" + name + b\"\\r\\n\\r\\n\"\n\n    match = f\"400, message:\\n  Got more than 8190 bytes \\\\({size}\\\\) when reading\"\n    with pytest.raises(http_exceptions.LineTooLong, match=match):\n        parser.feed_data(text)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('size', [40960, 8191])"
      ],
      "arguments": [
        "parser",
        "size"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_max_header_value_size_under_limit",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 746,
      "end_line_number": 761,
      "source_code": "def test_max_header_value_size_under_limit(parser: HttpRequestParser) -> None:\n    value = b\"A\" * 8190\n    text = b\"GET /test HTTP/1.1\\r\\ndata:\" + value + b\"\\r\\n\\r\\n\"\n\n    messages, upgrade, tail = parser.feed_data(text)\n    msg = messages[0][0]\n    assert msg.method == \"GET\"\n    assert msg.path == \"/test\"\n    assert msg.version == (1, 1)\n    assert msg.headers == CIMultiDict({\"data\": value.decode()})\n    assert msg.raw_headers == ((b\"data\", value),)\n    assert not msg.should_close\n    assert msg.compression is None\n    assert not msg.upgrade\n    assert not msg.chunked\n    assert msg.url == URL(\"/test\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg.method == 'GET'",
        "assert msg.path == '/test'",
        "assert msg.version == (1, 1)",
        "assert msg.headers == CIMultiDict({'data': value.decode()})",
        "assert msg.raw_headers == ((b'data', value),)",
        "assert not msg.should_close",
        "assert msg.compression is None",
        "assert not msg.upgrade",
        "assert not msg.chunked",
        "assert msg.url == URL('/test')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "value.decode",
          "body": "def decode(self, encoding: str='utf-8', errors: str='strict') -> str:\n    assert False"
        }
      ]
    },
    {
      "name": "test_max_header_value_size_continuation",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 765,
      "end_line_number": 773,
      "source_code": "def test_max_header_value_size_continuation(\n    response: HttpResponseParser, size: int\n) -> None:\n    name = b\"T\" * (size - 5)\n    text = b\"HTTP/1.1 200 Ok\\r\\ndata: test\\r\\n \" + name + b\"\\r\\n\\r\\n\"\n\n    match = f\"400, message:\\n  Got more than 8190 bytes \\\\({size}\\\\) when reading\"\n    with pytest.raises(http_exceptions.LineTooLong, match=match):\n        response.feed_data(text)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('size', [40965, 8191])"
      ],
      "arguments": [
        "response",
        "size"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_max_header_value_size_continuation_under_limit",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 776,
      "end_line_number": 792,
      "source_code": "def test_max_header_value_size_continuation_under_limit(\n    response: HttpResponseParser,\n) -> None:\n    value = b\"A\" * 8185\n    text = b\"HTTP/1.1 200 Ok\\r\\ndata: test\\r\\n \" + value + b\"\\r\\n\\r\\n\"\n\n    messages, upgrade, tail = response.feed_data(text)\n    msg = messages[0][0]\n    assert msg.code == 200\n    assert msg.reason == \"Ok\"\n    assert msg.version == (1, 1)\n    assert msg.headers == CIMultiDict({\"data\": \"test \" + value.decode()})\n    assert msg.raw_headers == ((b\"data\", b\"test \" + value),)\n    assert msg.should_close\n    assert msg.compression is None\n    assert not msg.upgrade\n    assert not msg.chunked",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "response"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg.code == 200",
        "assert msg.reason == 'Ok'",
        "assert msg.version == (1, 1)",
        "assert msg.headers == CIMultiDict({'data': 'test ' + value.decode()})",
        "assert msg.raw_headers == ((b'data', b'test ' + value),)",
        "assert msg.should_close",
        "assert msg.compression is None",
        "assert not msg.upgrade",
        "assert not msg.chunked"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "value.decode",
          "body": "def decode(self, encoding: str='utf-8', errors: str='strict') -> str:\n    assert False"
        }
      ]
    },
    {
      "name": "test_http_request_parser",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 795,
      "end_line_number": 809,
      "source_code": "def test_http_request_parser(parser: HttpRequestParser) -> None:\n    text = b\"GET /path HTTP/1.1\\r\\n\\r\\n\"\n    messages, upgrade, tail = parser.feed_data(text)\n    msg = messages[0][0]\n\n    assert msg.method == \"GET\"\n    assert msg.path == \"/path\"\n    assert msg.version == (1, 1)\n    assert msg.headers == CIMultiDict()\n    assert msg.raw_headers == ()\n    assert not msg.should_close\n    assert msg.compression is None\n    assert not msg.upgrade\n    assert not msg.chunked\n    assert msg.url == URL(\"/path\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg.method == 'GET'",
        "assert msg.path == '/path'",
        "assert msg.version == (1, 1)",
        "assert msg.headers == CIMultiDict()",
        "assert msg.raw_headers == ()",
        "assert not msg.should_close",
        "assert msg.compression is None",
        "assert not msg.upgrade",
        "assert not msg.chunked",
        "assert msg.url == URL('/path')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_http_request_bad_status_line",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 812,
      "end_line_number": 817,
      "source_code": "def test_http_request_bad_status_line(parser: HttpRequestParser) -> None:\n    text = b\"getpath \\r\\n\\r\\n\"\n    with pytest.raises(http_exceptions.BadStatusLine) as exc_info:\n        parser.feed_data(text)\n    # Check for accidentally escaped message.\n    assert r\"\\n\" not in exc_info.value.message",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert '\\\\n' not in exc_info.value.message"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_http_request_bad_status_line_number",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 832,
      "end_line_number": 837,
      "source_code": "def test_http_request_bad_status_line_number(\n    parser: HttpRequestParser, nonascii_digit: bytes\n) -> None:\n    text = b\"GET /digit HTTP/1.\" + nonascii_digit + b\"\\r\\n\\r\\n\"\n    with pytest.raises(http_exceptions.BadStatusLine):\n        parser.feed_data(text)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('nonascii_digit', _num.keys(), ids=_num.values())"
      ],
      "arguments": [
        "parser",
        "nonascii_digit"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_http_request_bad_status_line_separator",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 840,
      "end_line_number": 845,
      "source_code": "def test_http_request_bad_status_line_separator(parser: HttpRequestParser) -> None:\n    # single code point, old, multibyte NFKC, multibyte NFKD\n    utf8sep = \"\\N{arabic ligature sallallahou alayhe wasallam}\".encode()\n    text = b\"GET /ligature HTTP/1\" + utf8sep + b\"1\\r\\n\\r\\n\"\n    with pytest.raises(http_exceptions.BadStatusLine):\n        parser.feed_data(text)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_http_request_bad_status_line_whitespace",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 848,
      "end_line_number": 851,
      "source_code": "def test_http_request_bad_status_line_whitespace(parser: HttpRequestParser) -> None:\n    text = b\"GET\\n/path\\fHTTP/1.1\\r\\n\\r\\n\"\n    with pytest.raises(http_exceptions.BadStatusLine):\n        parser.feed_data(text)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_http_request_message_after_close",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 854,
      "end_line_number": 859,
      "source_code": "def test_http_request_message_after_close(parser: HttpRequestParser) -> None:\n    text = b\"GET / HTTP/1.1\\r\\nConnection: close\\r\\n\\r\\nInvalid\\r\\n\\r\\n\"\n    with pytest.raises(\n        http_exceptions.BadHttpMessage, match=\"Data after `Connection: close`\"\n    ):\n        parser.feed_data(text)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_http_request_upgrade",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 862,
      "end_line_number": 874,
      "source_code": "def test_http_request_upgrade(parser: HttpRequestParser) -> None:\n    text = (\n        b\"GET /test HTTP/1.1\\r\\n\"\n        b\"connection: upgrade\\r\\n\"\n        b\"upgrade: websocket\\r\\n\\r\\n\"\n        b\"some raw data\"\n    )\n    messages, upgrade, tail = parser.feed_data(text)\n    msg = messages[0][0]\n    assert not msg.should_close\n    assert msg.upgrade\n    assert upgrade\n    assert tail == b\"some raw data\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert not msg.should_close",
        "assert msg.upgrade",
        "assert upgrade",
        "assert tail == b'some raw data'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_http_request_parser_utf8_request_line",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 910,
      "end_line_number": 932,
      "source_code": "def test_http_request_parser_utf8_request_line(parser: HttpRequestParser) -> None:\n    messages, upgrade, tail = parser.feed_data(\n        # note the truncated unicode sequence\n        b\"GET /P\\xc3\\xbcnktchen\\xa0\\xef\\xb7 HTTP/1.1\\r\\n\" +\n        # for easier grep: ASCII 0xA0 more commonly known as non-breaking space\n        # note the leading and trailing spaces\n        \"sTeP:  \\N{latin small letter sharp s}nek\\t\\N{no-break space}  \"\n        \"\\r\\n\\r\\n\".encode()\n    )\n    msg = messages[0][0]\n\n    assert msg.method == \"GET\"\n    assert msg.path == \"/P\u00fcnktchen\\udca0\\udcef\\udcb7\"\n    assert msg.version == (1, 1)\n    assert msg.headers == CIMultiDict([(\"STEP\", \"\u00dfnek\\t\\xa0\")])\n    assert msg.raw_headers == ((b\"sTeP\", \"\u00dfnek\\t\\xa0\".encode()),)\n    assert not msg.should_close\n    assert msg.compression is None\n    assert not msg.upgrade\n    assert not msg.chunked\n    # python HTTP parser depends on Cython and CPython URL to match\n    # .. but yarl.URL(\"/abs\") is not equal to URL.build(path=\"/abs\"), see #6409\n    assert msg.url == URL.build(path=\"/P\u00fcnktchen\\udca0\\udcef\\udcb7\", encoded=True)",
      "docstring": null,
      "decorators": [
        "pytest.mark.usefixtures('xfail_c_parser_url')"
      ],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg.method == 'GET'",
        "assert msg.path == '/P\u00fcnktchen\\udca0\\udcef\\udcb7'",
        "assert msg.version == (1, 1)",
        "assert msg.headers == CIMultiDict([('STEP', '\u00dfnek\\t\\xa0')])",
        "assert msg.raw_headers == ((b'sTeP', '\u00dfnek\\t\\xa0'.encode()),)",
        "assert not msg.should_close",
        "assert msg.compression is None",
        "assert not msg.upgrade",
        "assert not msg.chunked",
        "assert msg.url == URL.build(path='/P\u00fcnktchen\\udca0\\udcef\\udcb7', encoded=True)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_http_request_parser_utf8",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 935,
      "end_line_number": 949,
      "source_code": "def test_http_request_parser_utf8(parser: HttpRequestParser) -> None:\n    text = \"GET /path HTTP/1.1\\r\\nx-test:\u0442\u0435\u0441\u0442\\r\\n\\r\\n\".encode()\n    messages, upgrade, tail = parser.feed_data(text)\n    msg = messages[0][0]\n\n    assert msg.method == \"GET\"\n    assert msg.path == \"/path\"\n    assert msg.version == (1, 1)\n    assert msg.headers == CIMultiDict([(\"X-TEST\", \"\u0442\u0435\u0441\u0442\")])\n    assert msg.raw_headers == ((b\"x-test\", \"\u0442\u0435\u0441\u0442\".encode()),)\n    assert not msg.should_close\n    assert msg.compression is None\n    assert not msg.upgrade\n    assert not msg.chunked\n    assert msg.url == URL(\"/path\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg.method == 'GET'",
        "assert msg.path == '/path'",
        "assert msg.version == (1, 1)",
        "assert msg.headers == CIMultiDict([('X-TEST', '\u0442\u0435\u0441\u0442')])",
        "assert msg.raw_headers == ((b'x-test', '\u0442\u0435\u0441\u0442'.encode()),)",
        "assert not msg.should_close",
        "assert msg.compression is None",
        "assert not msg.upgrade",
        "assert not msg.chunked",
        "assert msg.url == URL('/path')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_http_request_parser_non_utf8",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 952,
      "end_line_number": 967,
      "source_code": "def test_http_request_parser_non_utf8(parser: HttpRequestParser) -> None:\n    text = \"GET /path HTTP/1.1\\r\\nx-test:\u0442\u0435\u0441\u0442\\r\\n\\r\\n\".encode(\"cp1251\")\n    msg = parser.feed_data(text)[0][0][0]\n\n    assert msg.method == \"GET\"\n    assert msg.path == \"/path\"\n    assert msg.version == (1, 1)\n    assert msg.headers == CIMultiDict(\n        [(\"X-TEST\", \"\u0442\u0435\u0441\u0442\".encode(\"cp1251\").decode(\"utf8\", \"surrogateescape\"))]\n    )\n    assert msg.raw_headers == ((b\"x-test\", \"\u0442\u0435\u0441\u0442\".encode(\"cp1251\")),)\n    assert not msg.should_close\n    assert msg.compression is None\n    assert not msg.upgrade\n    assert not msg.chunked\n    assert msg.url == URL(\"/path\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg.method == 'GET'",
        "assert msg.path == '/path'",
        "assert msg.version == (1, 1)",
        "assert msg.headers == CIMultiDict([('X-TEST', '\u0442\u0435\u0441\u0442'.encode('cp1251').decode('utf8', 'surrogateescape'))])",
        "assert msg.raw_headers == ((b'x-test', '\u0442\u0435\u0441\u0442'.encode('cp1251')),)",
        "assert not msg.should_close",
        "assert msg.compression is None",
        "assert not msg.upgrade",
        "assert not msg.chunked",
        "assert msg.url == URL('/path')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_http_request_parser_two_slashes",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 970,
      "end_line_number": 981,
      "source_code": "def test_http_request_parser_two_slashes(parser: HttpRequestParser) -> None:\n    text = b\"GET //path HTTP/1.1\\r\\n\\r\\n\"\n    msg = parser.feed_data(text)[0][0][0]\n\n    assert msg.method == \"GET\"\n    assert msg.path == \"//path\"\n    assert msg.url.path == \"//path\"\n    assert msg.version == (1, 1)\n    assert not msg.should_close\n    assert msg.compression is None\n    assert not msg.upgrade\n    assert not msg.chunked",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg.method == 'GET'",
        "assert msg.path == '//path'",
        "assert msg.url.path == '//path'",
        "assert msg.version == (1, 1)",
        "assert not msg.should_close",
        "assert msg.compression is None",
        "assert not msg.upgrade",
        "assert not msg.chunked"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_http_request_parser_bad_method",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 988,
      "end_line_number": 992,
      "source_code": "def test_http_request_parser_bad_method(\n    parser: HttpRequestParser, rfc9110_5_6_2_token_delim: bytes\n) -> None:\n    with pytest.raises(http_exceptions.BadStatusLine):\n        parser.feed_data(rfc9110_5_6_2_token_delim + b'ET\" /get HTTP/1.1\\r\\n\\r\\n')",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('rfc9110_5_6_2_token_delim', [bytes([i]) for i in b'\"(),/:;<=>?@[\\\\]{}'])"
      ],
      "arguments": [
        "parser",
        "rfc9110_5_6_2_token_delim"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_http_request_parser_bad_version",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 995,
      "end_line_number": 997,
      "source_code": "def test_http_request_parser_bad_version(parser: HttpRequestParser) -> None:\n    with pytest.raises(http_exceptions.BadHttpMessage):\n        parser.feed_data(b\"GET //get HT/11\\r\\n\\r\\n\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_http_request_parser_bad_version_number",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 1000,
      "end_line_number": 1002,
      "source_code": "def test_http_request_parser_bad_version_number(parser: HttpRequestParser) -> None:\n    with pytest.raises(http_exceptions.BadHttpMessage):\n        parser.feed_data(b\"GET /test HTTP/1.32\\r\\n\\r\\n\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_http_request_parser_bad_ascii_uri",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 1005,
      "end_line_number": 1007,
      "source_code": "def test_http_request_parser_bad_ascii_uri(parser: HttpRequestParser) -> None:\n    with pytest.raises(http_exceptions.InvalidURLError):\n        parser.feed_data(b\"GET ! HTTP/1.1\\r\\n\\r\\n\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_http_request_parser_bad_nonascii_uri",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 1010,
      "end_line_number": 1012,
      "source_code": "def test_http_request_parser_bad_nonascii_uri(parser: HttpRequestParser) -> None:\n    with pytest.raises(http_exceptions.InvalidURLError):\n        parser.feed_data(b\"GET \\xff HTTP/1.1\\r\\n\\r\\n\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_http_request_max_status_line",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 1016,
      "end_line_number": 1020,
      "source_code": "def test_http_request_max_status_line(parser: HttpRequestParser, size: int) -> None:\n    path = b\"t\" * (size - 5)\n    match = f\"400, message:\\n  Got more than 8190 bytes \\\\({size}\\\\) when reading\"\n    with pytest.raises(http_exceptions.LineTooLong, match=match):\n        parser.feed_data(b\"GET /path\" + path + b\" HTTP/1.1\\r\\n\\r\\n\")",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('size', [40965, 8191])"
      ],
      "arguments": [
        "parser",
        "size"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_http_request_max_status_line_under_limit",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 1023,
      "end_line_number": 1039,
      "source_code": "def test_http_request_max_status_line_under_limit(parser: HttpRequestParser) -> None:\n    path = b\"t\" * (8190 - 5)\n    messages, upgraded, tail = parser.feed_data(\n        b\"GET /path\" + path + b\" HTTP/1.1\\r\\n\\r\\n\"\n    )\n    msg = messages[0][0]\n\n    assert msg.method == \"GET\"\n    assert msg.path == \"/path\" + path.decode()\n    assert msg.version == (1, 1)\n    assert msg.headers == CIMultiDict()\n    assert msg.raw_headers == ()\n    assert not msg.should_close\n    assert msg.compression is None\n    assert not msg.upgrade\n    assert not msg.chunked\n    assert msg.url == URL(\"/path\" + path.decode())",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg.method == 'GET'",
        "assert msg.path == '/path' + path.decode()",
        "assert msg.version == (1, 1)",
        "assert msg.headers == CIMultiDict()",
        "assert msg.raw_headers == ()",
        "assert not msg.should_close",
        "assert msg.compression is None",
        "assert not msg.upgrade",
        "assert not msg.chunked",
        "assert msg.url == URL('/path' + path.decode())"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "path.decode",
          "body": "def decode(self, encoding: str='utf-8', errors: str='strict') -> str:\n    assert False"
        },
        {
          "name": "path.decode",
          "body": "def decode(self, encoding: str='utf-8', errors: str='strict') -> str:\n    assert False"
        }
      ]
    },
    {
      "name": "test_http_response_parser_utf8",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 1042,
      "end_line_number": 1055,
      "source_code": "def test_http_response_parser_utf8(response: HttpResponseParser) -> None:\n    text = \"HTTP/1.1 200 Ok\\r\\nx-test:\u0442\u0435\u0441\u0442\\r\\n\\r\\n\".encode()\n\n    messages, upgraded, tail = response.feed_data(text)\n    assert len(messages) == 1\n    msg = messages[0][0]\n\n    assert msg.version == (1, 1)\n    assert msg.code == 200\n    assert msg.reason == \"Ok\"\n    assert msg.headers == CIMultiDict([(\"X-TEST\", \"\u0442\u0435\u0441\u0442\")])\n    assert msg.raw_headers == ((b\"x-test\", \"\u0442\u0435\u0441\u0442\".encode()),)\n    assert not upgraded\n    assert not tail",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "response"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(messages) == 1",
        "assert msg.version == (1, 1)",
        "assert msg.code == 200",
        "assert msg.reason == 'Ok'",
        "assert msg.headers == CIMultiDict([('X-TEST', '\u0442\u0435\u0441\u0442')])",
        "assert msg.raw_headers == ((b'x-test', '\u0442\u0435\u0441\u0442'.encode()),)",
        "assert not upgraded",
        "assert not tail"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_http_response_parser_utf8_without_reason",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 1058,
      "end_line_number": 1071,
      "source_code": "def test_http_response_parser_utf8_without_reason(response: HttpResponseParser) -> None:\n    text = \"HTTP/1.1 200 \\r\\nx-test:\u0442\u0435\u0441\u0442\\r\\n\\r\\n\".encode()\n\n    messages, upgraded, tail = response.feed_data(text)\n    assert len(messages) == 1\n    msg = messages[0][0]\n\n    assert msg.version == (1, 1)\n    assert msg.code == 200\n    assert msg.reason == \"\"\n    assert msg.headers == CIMultiDict([(\"X-TEST\", \"\u0442\u0435\u0441\u0442\")])\n    assert msg.raw_headers == ((b\"x-test\", \"\u0442\u0435\u0441\u0442\".encode()),)\n    assert not upgraded\n    assert not tail",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "response"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(messages) == 1",
        "assert msg.version == (1, 1)",
        "assert msg.code == 200",
        "assert msg.reason == ''",
        "assert msg.headers == CIMultiDict([('X-TEST', '\u0442\u0435\u0441\u0442')])",
        "assert msg.raw_headers == ((b'x-test', '\u0442\u0435\u0441\u0442'.encode()),)",
        "assert not upgraded",
        "assert not tail"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_http_response_parser_obs_line_folding",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 1074,
      "end_line_number": 1087,
      "source_code": "def test_http_response_parser_obs_line_folding(response: HttpResponseParser) -> None:\n    text = b\"HTTP/1.1 200 Ok\\r\\ntest: line\\r\\n continue\\r\\n\\r\\n\"\n\n    messages, upgraded, tail = response.feed_data(text)\n    assert len(messages) == 1\n    msg = messages[0][0]\n\n    assert msg.version == (1, 1)\n    assert msg.code == 200\n    assert msg.reason == \"Ok\"\n    assert msg.headers == CIMultiDict([(\"TEST\", \"line continue\")])\n    assert msg.raw_headers == ((b\"test\", b\"line continue\"),)\n    assert not upgraded\n    assert not tail",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "response"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(messages) == 1",
        "assert msg.version == (1, 1)",
        "assert msg.code == 200",
        "assert msg.reason == 'Ok'",
        "assert msg.headers == CIMultiDict([('TEST', 'line continue')])",
        "assert msg.raw_headers == ((b'test', b'line continue'),)",
        "assert not upgraded",
        "assert not tail"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_http_response_parser_strict_obs_line_folding",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 1091,
      "end_line_number": 1097,
      "source_code": "def test_http_response_parser_strict_obs_line_folding(\n    response: HttpResponseParser,\n) -> None:\n    text = b\"HTTP/1.1 200 Ok\\r\\ntest: line\\r\\n continue\\r\\n\\r\\n\"\n\n    with pytest.raises(http_exceptions.BadHttpMessage):\n        response.feed_data(text)",
      "docstring": null,
      "decorators": [
        "pytest.mark.dev_mode"
      ],
      "arguments": [
        "response"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_http_response_parser_bad_status_line_too_long",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 1101,
      "end_line_number": 1107,
      "source_code": "def test_http_response_parser_bad_status_line_too_long(\n    response: HttpResponseParser, size: int\n) -> None:\n    reason = b\"t\" * (size - 2)\n    match = f\"400, message:\\n  Got more than 8190 bytes \\\\({size}\\\\) when reading\"\n    with pytest.raises(http_exceptions.LineTooLong, match=match):\n        response.feed_data(b\"HTTP/1.1 200 Ok\" + reason + b\"\\r\\n\\r\\n\")",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('size', [40962, 8191])"
      ],
      "arguments": [
        "response",
        "size"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_http_response_parser_status_line_under_limit",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 1110,
      "end_line_number": 1120,
      "source_code": "def test_http_response_parser_status_line_under_limit(\n    response: HttpResponseParser,\n) -> None:\n    reason = b\"O\" * 8190\n    messages, upgraded, tail = response.feed_data(\n        b\"HTTP/1.1 200 \" + reason + b\"\\r\\n\\r\\n\"\n    )\n    msg = messages[0][0]\n    assert msg.version == (1, 1)\n    assert msg.code == 200\n    assert msg.reason == reason.decode()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "response"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg.version == (1, 1)",
        "assert msg.code == 200",
        "assert msg.reason == reason.decode()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "reason.decode",
          "body": "def decode(self, encoding: str='utf-8', errors: str='strict') -> str:\n    assert False"
        }
      ]
    },
    {
      "name": "test_http_response_parser_bad_version",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 1123,
      "end_line_number": 1125,
      "source_code": "def test_http_response_parser_bad_version(response: HttpResponseParser) -> None:\n    with pytest.raises(http_exceptions.BadHttpMessage):\n        response.feed_data(b\"HT/11 200 Ok\\r\\n\\r\\n\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "response"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_http_response_parser_bad_version_number",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 1128,
      "end_line_number": 1130,
      "source_code": "def test_http_response_parser_bad_version_number(response: HttpResponseParser) -> None:\n    with pytest.raises(http_exceptions.BadHttpMessage):\n        response.feed_data(b\"HTTP/12.3 200 Ok\\r\\n\\r\\n\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "response"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_http_response_parser_no_reason",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 1133,
      "end_line_number": 1138,
      "source_code": "def test_http_response_parser_no_reason(response: HttpResponseParser) -> None:\n    msg = response.feed_data(b\"HTTP/1.1 200\\r\\n\\r\\n\")[0][0][0]\n\n    assert msg.version == (1, 1)\n    assert msg.code == 200\n    assert msg.reason == \"\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "response"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg.version == (1, 1)",
        "assert msg.code == 200",
        "assert msg.reason == ''"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_http_response_parser_lenient_headers",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 1141,
      "end_line_number": 1147,
      "source_code": "def test_http_response_parser_lenient_headers(response: HttpResponseParser) -> None:\n    messages, upgrade, tail = response.feed_data(\n        b\"HTTP/1.1 200 test\\r\\nFoo: abc\\x01def\\r\\n\\r\\n\"\n    )\n    msg = messages[0][0]\n\n    assert msg.headers[\"Foo\"] == \"abc\\x01def\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "response"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg.headers['Foo'] == 'abc\\x01def'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_http_response_parser_strict_headers",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 1151,
      "end_line_number": 1155,
      "source_code": "def test_http_response_parser_strict_headers(response: HttpResponseParser) -> None:\n    if isinstance(response, HttpResponseParserPy):\n        pytest.xfail(\"Py parser is lenient. May update py-parser later.\")\n    with pytest.raises(http_exceptions.BadHttpMessage):  # type: ignore[unreachable]\n        response.feed_data(b\"HTTP/1.1 200 test\\r\\nFoo: abc\\x01def\\r\\n\\r\\n\")",
      "docstring": null,
      "decorators": [
        "pytest.mark.dev_mode"
      ],
      "arguments": [
        "response"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_http_response_parser_bad_crlf",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 1158,
      "end_line_number": 1166,
      "source_code": "def test_http_response_parser_bad_crlf(response: HttpResponseParser) -> None:\n    \"\"\"Still a lot of dodgy servers sending bad requests like this.\"\"\"\n    messages, upgrade, tail = response.feed_data(\n        b\"HTTP/1.0 200 OK\\nFoo: abc\\nBar: def\\n\\nBODY\\n\"\n    )\n    msg = messages[0][0]\n\n    assert msg.headers[\"Foo\"] == \"abc\"\n    assert msg.headers[\"Bar\"] == \"def\"",
      "docstring": "Still a lot of dodgy servers sending bad requests like this.",
      "decorators": [],
      "arguments": [
        "response"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg.headers['Foo'] == 'abc'",
        "assert msg.headers['Bar'] == 'def'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_http_response_parser_bad",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 1241,
      "end_line_number": 1243,
      "source_code": "def test_http_response_parser_bad(response: HttpResponseParser) -> None:\n    with pytest.raises(http_exceptions.BadHttpMessage):\n        response.feed_data(b\"HTT/1\\r\\n\\r\\n\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "response"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_http_response_parser_code_under_100",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 1246,
      "end_line_number": 1248,
      "source_code": "def test_http_response_parser_code_under_100(response: HttpResponseParser) -> None:\n    with pytest.raises(http_exceptions.BadStatusLine):\n        response.feed_data(b\"HTTP/1.1 99 test\\r\\n\\r\\n\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "response"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_http_response_parser_code_above_999",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 1251,
      "end_line_number": 1253,
      "source_code": "def test_http_response_parser_code_above_999(response: HttpResponseParser) -> None:\n    with pytest.raises(http_exceptions.BadStatusLine):\n        response.feed_data(b\"HTTP/1.1 9999 test\\r\\n\\r\\n\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "response"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_http_response_parser_code_not_int",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 1256,
      "end_line_number": 1258,
      "source_code": "def test_http_response_parser_code_not_int(response: HttpResponseParser) -> None:\n    with pytest.raises(http_exceptions.BadStatusLine):\n        response.feed_data(b\"HTTP/1.1 ttt test\\r\\n\\r\\n\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "response"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_http_response_parser_code_not_ascii",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 1262,
      "end_line_number": 1266,
      "source_code": "def test_http_response_parser_code_not_ascii(\n    response: HttpResponseParser, nonascii_digit: bytes\n) -> None:\n    with pytest.raises(http_exceptions.BadStatusLine):\n        response.feed_data(b\"HTTP/1.1 20\" + nonascii_digit + b\" test\\r\\n\\r\\n\")",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('nonascii_digit', _num.keys(), ids=_num.values())"
      ],
      "arguments": [
        "response",
        "nonascii_digit"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_http_request_chunked_payload",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 1269,
      "end_line_number": 1281,
      "source_code": "def test_http_request_chunked_payload(parser: HttpRequestParser) -> None:\n    text = b\"GET /test HTTP/1.1\\r\\ntransfer-encoding: chunked\\r\\n\\r\\n\"\n    msg, payload = parser.feed_data(text)[0][0]\n\n    assert msg.chunked\n    assert not payload.is_eof()\n    assert isinstance(payload, streams.StreamReader)\n\n    parser.feed_data(b\"4\\r\\ndata\\r\\n4\\r\\nline\\r\\n0\\r\\n\\r\\n\")\n\n    assert b\"dataline\" == b\"\".join(d for d in payload._buffer)\n    assert [4, 8] == payload._http_chunk_splits\n    assert payload.is_eof()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg.chunked",
        "assert not payload.is_eof()",
        "assert isinstance(payload, streams.StreamReader)",
        "assert b'dataline' == b''.join((d for d in payload._buffer))",
        "assert [4, 8] == payload._http_chunk_splits",
        "assert payload.is_eof()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_http_request_chunked_payload_and_next_message",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 1284,
      "end_line_number": 1305,
      "source_code": "def test_http_request_chunked_payload_and_next_message(\n    parser: HttpRequestParser,\n) -> None:\n    text = b\"GET /test HTTP/1.1\\r\\ntransfer-encoding: chunked\\r\\n\\r\\n\"\n    msg, payload = parser.feed_data(text)[0][0]\n\n    messages, upgraded, tail = parser.feed_data(\n        b\"4\\r\\ndata\\r\\n4\\r\\nline\\r\\n0\\r\\n\\r\\n\"\n        b\"POST /test2 HTTP/1.1\\r\\n\"\n        b\"transfer-encoding: chunked\\r\\n\\r\\n\"\n    )\n\n    assert b\"dataline\" == b\"\".join(d for d in payload._buffer)\n    assert [4, 8] == payload._http_chunk_splits\n    assert payload.is_eof()\n\n    assert len(messages) == 1\n    msg2, payload2 = messages[0]\n\n    assert msg2.method == \"POST\"\n    assert msg2.chunked\n    assert not payload2.is_eof()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert b'dataline' == b''.join((d for d in payload._buffer))",
        "assert [4, 8] == payload._http_chunk_splits",
        "assert payload.is_eof()",
        "assert len(messages) == 1",
        "assert msg2.method == 'POST'",
        "assert msg2.chunked",
        "assert not payload2.is_eof()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_http_request_chunked_payload_chunks",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 1308,
      "end_line_number": 1327,
      "source_code": "def test_http_request_chunked_payload_chunks(parser: HttpRequestParser) -> None:\n    text = b\"GET /test HTTP/1.1\\r\\ntransfer-encoding: chunked\\r\\n\\r\\n\"\n    msg, payload = parser.feed_data(text)[0][0]\n\n    parser.feed_data(b\"4\\r\\ndata\\r\")\n    parser.feed_data(b\"\\n4\")\n    parser.feed_data(b\"\\r\")\n    parser.feed_data(b\"\\n\")\n    parser.feed_data(b\"li\")\n    parser.feed_data(b\"ne\\r\\n0\\r\\n\")\n    parser.feed_data(b\"test: test\\r\\n\")\n\n    assert b\"dataline\" == b\"\".join(d for d in payload._buffer)\n    assert [4, 8] == payload._http_chunk_splits\n    assert not payload.is_eof()\n\n    parser.feed_data(b\"\\r\\n\")\n    assert b\"dataline\" == b\"\".join(d for d in payload._buffer)\n    assert [4, 8] == payload._http_chunk_splits\n    assert payload.is_eof()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert b'dataline' == b''.join((d for d in payload._buffer))",
        "assert [4, 8] == payload._http_chunk_splits",
        "assert not payload.is_eof()",
        "assert b'dataline' == b''.join((d for d in payload._buffer))",
        "assert [4, 8] == payload._http_chunk_splits",
        "assert payload.is_eof()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_parse_chunked_payload_chunk_extension",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 1330,
      "end_line_number": 1338,
      "source_code": "def test_parse_chunked_payload_chunk_extension(parser: HttpRequestParser) -> None:\n    text = b\"GET /test HTTP/1.1\\r\\ntransfer-encoding: chunked\\r\\n\\r\\n\"\n    msg, payload = parser.feed_data(text)[0][0]\n\n    parser.feed_data(b\"4;test\\r\\ndata\\r\\n4\\r\\nline\\r\\n0\\r\\ntest: test\\r\\n\\r\\n\")\n\n    assert b\"dataline\" == b\"\".join(d for d in payload._buffer)\n    assert [4, 8] == payload._http_chunk_splits\n    assert payload.is_eof()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert b'dataline' == b''.join((d for d in payload._buffer))",
        "assert [4, 8] == payload._http_chunk_splits",
        "assert payload.is_eof()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_parse_no_length_or_te_on_post",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 1341,
      "end_line_number": 1350,
      "source_code": "def test_parse_no_length_or_te_on_post(\n    loop: asyncio.AbstractEventLoop,\n    protocol: BaseProtocol,\n    request_cls: Type[HttpRequestParser],\n) -> None:\n    parser = request_cls(protocol, loop, limit=2**16)\n    text = b\"POST /test HTTP/1.1\\r\\n\\r\\n\"\n    msg, payload = parser.feed_data(text)[0][0]\n\n    assert payload.is_eof()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop",
        "protocol",
        "request_cls"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert payload.is_eof()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "request_cls",
          "body": "@pytest.fixture(params=REQUEST_PARSERS, ids=_gen_ids(REQUEST_PARSERS))\ndef request_cls(request: pytest.FixtureRequest) -> Type[HttpRequestParser]:\n    return request.param"
        }
      ]
    },
    {
      "name": "test_parse_payload_response_without_body",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 1353,
      "end_line_number": 1362,
      "source_code": "def test_parse_payload_response_without_body(\n    loop: asyncio.AbstractEventLoop,\n    protocol: BaseProtocol,\n    response_cls: Type[HttpResponseParser],\n) -> None:\n    parser = response_cls(protocol, loop, 2**16, response_with_body=False)\n    text = b\"HTTP/1.1 200 Ok\\r\\ncontent-length: 10\\r\\n\\r\\n\"\n    msg, payload = parser.feed_data(text)[0][0]\n\n    assert payload.is_eof()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop",
        "protocol",
        "response_cls"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert payload.is_eof()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "response_cls",
          "body": "@pytest.fixture(params=RESPONSE_PARSERS, ids=_gen_ids(RESPONSE_PARSERS))\ndef response_cls(request: pytest.FixtureRequest) -> Type[HttpResponseParser]:\n    return request.param"
        }
      ]
    },
    {
      "name": "test_parse_length_payload",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 1365,
      "end_line_number": 1375,
      "source_code": "def test_parse_length_payload(response: HttpResponseParser) -> None:\n    text = b\"HTTP/1.1 200 Ok\\r\\ncontent-length: 4\\r\\n\\r\\n\"\n    msg, payload = response.feed_data(text)[0][0]\n    assert not payload.is_eof()\n\n    response.feed_data(b\"da\")\n    response.feed_data(b\"t\")\n    response.feed_data(b\"aHT\")\n\n    assert payload.is_eof()\n    assert b\"data\" == b\"\".join(d for d in payload._buffer)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "response"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert not payload.is_eof()",
        "assert payload.is_eof()",
        "assert b'data' == b''.join((d for d in payload._buffer))"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_parse_no_length_payload",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 1378,
      "end_line_number": 1381,
      "source_code": "def test_parse_no_length_payload(parser: HttpRequestParser) -> None:\n    text = b\"PUT / HTTP/1.1\\r\\n\\r\\n\"\n    msg, payload = parser.feed_data(text)[0][0]\n    assert payload.is_eof()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert payload.is_eof()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_parse_content_length_payload_multiple",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 1384,
      "end_line_number": 1419,
      "source_code": "def test_parse_content_length_payload_multiple(response: HttpResponseParser) -> None:\n    text = b\"HTTP/1.1 200 OK\\r\\ncontent-length: 5\\r\\n\\r\\nfirst\"\n    msg, payload = response.feed_data(text)[0][0]\n    assert msg.version == HttpVersion(major=1, minor=1)\n    assert msg.code == 200\n    assert msg.reason == \"OK\"\n    assert msg.headers == CIMultiDict(\n        [\n            (\"Content-Length\", \"5\"),\n        ]\n    )\n    assert msg.raw_headers == ((b\"content-length\", b\"5\"),)\n    assert not msg.should_close\n    assert msg.compression is None\n    assert not msg.upgrade\n    assert not msg.chunked\n    assert payload.is_eof()\n    assert b\"first\" == b\"\".join(d for d in payload._buffer)\n\n    text = b\"HTTP/1.1 200 OK\\r\\ncontent-length: 6\\r\\n\\r\\nsecond\"\n    msg, payload = response.feed_data(text)[0][0]\n    assert msg.version == HttpVersion(major=1, minor=1)\n    assert msg.code == 200\n    assert msg.reason == \"OK\"\n    assert msg.headers == CIMultiDict(\n        [\n            (\"Content-Length\", \"6\"),\n        ]\n    )\n    assert msg.raw_headers == ((b\"content-length\", b\"6\"),)\n    assert not msg.should_close\n    assert msg.compression is None\n    assert not msg.upgrade\n    assert not msg.chunked\n    assert payload.is_eof()\n    assert b\"second\" == b\"\".join(d for d in payload._buffer)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "response"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg.version == HttpVersion(major=1, minor=1)",
        "assert msg.code == 200",
        "assert msg.reason == 'OK'",
        "assert msg.headers == CIMultiDict([('Content-Length', '5')])",
        "assert msg.raw_headers == ((b'content-length', b'5'),)",
        "assert not msg.should_close",
        "assert msg.compression is None",
        "assert not msg.upgrade",
        "assert not msg.chunked",
        "assert payload.is_eof()",
        "assert b'first' == b''.join((d for d in payload._buffer))",
        "assert msg.version == HttpVersion(major=1, minor=1)",
        "assert msg.code == 200",
        "assert msg.reason == 'OK'",
        "assert msg.headers == CIMultiDict([('Content-Length', '6')])",
        "assert msg.raw_headers == ((b'content-length', b'6'),)",
        "assert not msg.should_close",
        "assert msg.compression is None",
        "assert not msg.upgrade",
        "assert not msg.chunked",
        "assert payload.is_eof()",
        "assert b'second' == b''.join((d for d in payload._buffer))"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_parse_content_length_than_chunked_payload",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 1422,
      "end_line_number": 1463,
      "source_code": "def test_parse_content_length_than_chunked_payload(\n    response: HttpResponseParser,\n) -> None:\n    text = b\"HTTP/1.1 200 OK\\r\\ncontent-length: 5\\r\\n\\r\\nfirst\"\n    msg, payload = response.feed_data(text)[0][0]\n    assert msg.version == HttpVersion(major=1, minor=1)\n    assert msg.code == 200\n    assert msg.reason == \"OK\"\n    assert msg.headers == CIMultiDict(\n        [\n            (\"Content-Length\", \"5\"),\n        ]\n    )\n    assert msg.raw_headers == ((b\"content-length\", b\"5\"),)\n    assert not msg.should_close\n    assert msg.compression is None\n    assert not msg.upgrade\n    assert not msg.chunked\n    assert payload.is_eof()\n    assert b\"first\" == b\"\".join(d for d in payload._buffer)\n\n    text = (\n        b\"HTTP/1.1 200 OK\\r\\n\"\n        b\"transfer-encoding: chunked\\r\\n\\r\\n\"\n        b\"6\\r\\nsecond\\r\\n0\\r\\n\\r\\n\"\n    )\n    msg, payload = response.feed_data(text)[0][0]\n    assert msg.version == HttpVersion(major=1, minor=1)\n    assert msg.code == 200\n    assert msg.reason == \"OK\"\n    assert msg.headers == CIMultiDict(\n        [\n            (\"Transfer-Encoding\", \"chunked\"),\n        ]\n    )\n    assert msg.raw_headers == ((b\"transfer-encoding\", b\"chunked\"),)\n    assert not msg.should_close\n    assert msg.compression is None\n    assert not msg.upgrade\n    assert msg.chunked\n    assert payload.is_eof()\n    assert b\"second\" == b\"\".join(d for d in payload._buffer)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "response"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg.version == HttpVersion(major=1, minor=1)",
        "assert msg.code == 200",
        "assert msg.reason == 'OK'",
        "assert msg.headers == CIMultiDict([('Content-Length', '5')])",
        "assert msg.raw_headers == ((b'content-length', b'5'),)",
        "assert not msg.should_close",
        "assert msg.compression is None",
        "assert not msg.upgrade",
        "assert not msg.chunked",
        "assert payload.is_eof()",
        "assert b'first' == b''.join((d for d in payload._buffer))",
        "assert msg.version == HttpVersion(major=1, minor=1)",
        "assert msg.code == 200",
        "assert msg.reason == 'OK'",
        "assert msg.headers == CIMultiDict([('Transfer-Encoding', 'chunked')])",
        "assert msg.raw_headers == ((b'transfer-encoding', b'chunked'),)",
        "assert not msg.should_close",
        "assert msg.compression is None",
        "assert not msg.upgrade",
        "assert msg.chunked",
        "assert payload.is_eof()",
        "assert b'second' == b''.join((d for d in payload._buffer))"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_parse_chunked_payload_empty_body_than_another_chunked",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 1467,
      "end_line_number": 1508,
      "source_code": "def test_parse_chunked_payload_empty_body_than_another_chunked(\n    response: HttpResponseParser, code: int\n) -> None:\n    head = f\"HTTP/1.1 {code} OK\\r\\n\".encode()\n    text = head + b\"transfer-encoding: chunked\\r\\n\\r\\n\"\n    msg, payload = response.feed_data(text)[0][0]\n    assert msg.version == HttpVersion(major=1, minor=1)\n    assert msg.code == code\n    assert msg.reason == \"OK\"\n    assert msg.headers == CIMultiDict(\n        [\n            (\"Transfer-Encoding\", \"chunked\"),\n        ]\n    )\n    assert msg.raw_headers == ((b\"transfer-encoding\", b\"chunked\"),)\n    assert not msg.should_close\n    assert msg.compression is None\n    assert not msg.upgrade\n    assert msg.chunked\n    assert payload.is_eof()\n\n    text = (\n        b\"HTTP/1.1 200 OK\\r\\n\"\n        b\"transfer-encoding: chunked\\r\\n\\r\\n\"\n        b\"6\\r\\nsecond\\r\\n0\\r\\n\\r\\n\"\n    )\n    msg, payload = response.feed_data(text)[0][0]\n    assert msg.version == HttpVersion(major=1, minor=1)\n    assert msg.code == 200\n    assert msg.reason == \"OK\"\n    assert msg.headers == CIMultiDict(\n        [\n            (\"Transfer-Encoding\", \"chunked\"),\n        ]\n    )\n    assert msg.raw_headers == ((b\"transfer-encoding\", b\"chunked\"),)\n    assert not msg.should_close\n    assert msg.compression is None\n    assert not msg.upgrade\n    assert msg.chunked\n    assert payload.is_eof()\n    assert b\"second\" == b\"\".join(d for d in payload._buffer)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('code', (204, 304, 101, 102))"
      ],
      "arguments": [
        "response",
        "code"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg.version == HttpVersion(major=1, minor=1)",
        "assert msg.code == code",
        "assert msg.reason == 'OK'",
        "assert msg.headers == CIMultiDict([('Transfer-Encoding', 'chunked')])",
        "assert msg.raw_headers == ((b'transfer-encoding', b'chunked'),)",
        "assert not msg.should_close",
        "assert msg.compression is None",
        "assert not msg.upgrade",
        "assert msg.chunked",
        "assert payload.is_eof()",
        "assert msg.version == HttpVersion(major=1, minor=1)",
        "assert msg.code == 200",
        "assert msg.reason == 'OK'",
        "assert msg.headers == CIMultiDict([('Transfer-Encoding', 'chunked')])",
        "assert msg.raw_headers == ((b'transfer-encoding', b'chunked'),)",
        "assert not msg.should_close",
        "assert msg.compression is None",
        "assert not msg.upgrade",
        "assert msg.chunked",
        "assert payload.is_eof()",
        "assert b'second' == b''.join((d for d in payload._buffer))"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_partial_url",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 1534,
      "end_line_number": 1545,
      "source_code": "def test_partial_url(parser: HttpRequestParser) -> None:\n    messages, upgrade, tail = parser.feed_data(b\"GET /te\")\n    assert len(messages) == 0\n    messages, upgrade, tail = parser.feed_data(b\"st HTTP/1.1\\r\\n\\r\\n\")\n    assert len(messages) == 1\n\n    msg, payload = messages[0]\n\n    assert msg.method == \"GET\"\n    assert msg.path == \"/test\"\n    assert msg.version == (1, 1)\n    assert payload.is_eof()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(messages) == 0",
        "assert len(messages) == 1",
        "assert msg.method == 'GET'",
        "assert msg.path == '/test'",
        "assert msg.version == (1, 1)",
        "assert payload.is_eof()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_parse_uri_percent_encoded",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 1559,
      "end_line_number": 1570,
      "source_code": "def test_parse_uri_percent_encoded(\n    parser: HttpRequestParser, uri: str, path: str, query: Dict[str, str], fragment: str\n) -> None:\n    text = (f\"GET {uri} HTTP/1.1\\r\\n\\r\\n\").encode()\n    messages, upgrade, tail = parser.feed_data(text)\n    msg = messages[0][0]\n\n    assert msg.path == uri\n    assert msg.url == URL(uri)\n    assert msg.url.path == path\n    assert msg.url.query == query\n    assert msg.url.fragment == fragment",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize(('uri', 'path', 'query', 'fragment'), [('/path%23frag', '/path#frag', {}, ''), ('/path%2523frag', '/path%23frag', {}, ''), ('/path?key=value%23frag', '/path', {'key': 'value#frag'}, ''), ('/path?key=value%2523frag', '/path', {'key': 'value%23frag'}, ''), ('/path#frag%20', '/path', {}, 'frag '), ('/path#frag%2520', '/path', {}, 'frag%20')])"
      ],
      "arguments": [
        "parser",
        "uri",
        "path",
        "query",
        "fragment"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg.path == uri",
        "assert msg.url == URL(uri)",
        "assert msg.url.path == path",
        "assert msg.url.query == query",
        "assert msg.url.fragment == fragment"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_parse_uri_utf8",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 1573,
      "end_line_number": 1583,
      "source_code": "def test_parse_uri_utf8(parser: HttpRequestParser) -> None:\n    if not isinstance(parser, HttpRequestParserPy):\n        pytest.xfail(\"Not valid HTTP. Maybe update py-parser to reject later.\")\n    text = (\"GET /\u043f\u0443\u0442\u044c?\u043a\u043b\u044e\u0447=\u0437\u043d\u0430\u0447#\u0444\u0440\u0430\u0433 HTTP/1.1\\r\\n\\r\\n\").encode()\n    messages, upgrade, tail = parser.feed_data(text)\n    msg = messages[0][0]\n\n    assert msg.path == \"/\u043f\u0443\u0442\u044c?\u043a\u043b\u044e\u0447=\u0437\u043d\u0430\u0447#\u0444\u0440\u0430\u0433\"\n    assert msg.url.path == \"/\u043f\u0443\u0442\u044c\"\n    assert msg.url.query == {\"\u043a\u043b\u044e\u0447\": \"\u0437\u043d\u0430\u0447\"}\n    assert msg.url.fragment == \"\u0444\u0440\u0430\u0433\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg.path == '/\u043f\u0443\u0442\u044c?\u043a\u043b\u044e\u0447=\u0437\u043d\u0430\u0447#\u0444\u0440\u0430\u0433'",
        "assert msg.url.path == '/\u043f\u0443\u0442\u044c'",
        "assert msg.url.query == {'\u043a\u043b\u044e\u0447': '\u0437\u043d\u0430\u0447'}",
        "assert msg.url.fragment == '\u0444\u0440\u0430\u0433'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_parse_uri_utf8_percent_encoded",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 1586,
      "end_line_number": 1597,
      "source_code": "def test_parse_uri_utf8_percent_encoded(parser: HttpRequestParser) -> None:\n    text = (\n        \"GET %s HTTP/1.1\\r\\n\\r\\n\" % quote(\"/\u043f\u0443\u0442\u044c?\u043a\u043b\u044e\u0447=\u0437\u043d\u0430\u0447#\u0444\u0440\u0430\u0433\", safe=\"/?=#\")\n    ).encode()\n    messages, upgrade, tail = parser.feed_data(text)\n    msg = messages[0][0]\n\n    assert msg.path == quote(\"/\u043f\u0443\u0442\u044c?\u043a\u043b\u044e\u0447=\u0437\u043d\u0430\u0447#\u0444\u0440\u0430\u0433\", safe=\"/?=#\")\n    assert msg.url == URL(\"/\u043f\u0443\u0442\u044c?\u043a\u043b\u044e\u0447=\u0437\u043d\u0430\u0447#\u0444\u0440\u0430\u0433\")\n    assert msg.url.path == \"/\u043f\u0443\u0442\u044c\"\n    assert msg.url.query == {\"\u043a\u043b\u044e\u0447\": \"\u0437\u043d\u0430\u0447\"}\n    assert msg.url.fragment == \"\u0444\u0440\u0430\u0433\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "parser"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg.path == quote('/\u043f\u0443\u0442\u044c?\u043a\u043b\u044e\u0447=\u0437\u043d\u0430\u0447#\u0444\u0440\u0430\u0433', safe='/?=#')",
        "assert msg.url == URL('/\u043f\u0443\u0442\u044c?\u043a\u043b\u044e\u0447=\u0437\u043d\u0430\u0447#\u0444\u0440\u0430\u0433')",
        "assert msg.url.path == '/\u043f\u0443\u0442\u044c'",
        "assert msg.url.query == {'\u043a\u043b\u044e\u0447': '\u0437\u043d\u0430\u0447'}",
        "assert msg.url.fragment == '\u0444\u0440\u0430\u0433'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_parse_bad_method_for_c_parser_raises",
      "module": "test_http_parser",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_http_parser.py",
      "line_number": 1604,
      "end_line_number": 1617,
      "source_code": "def test_parse_bad_method_for_c_parser_raises(\n    loop: asyncio.AbstractEventLoop, protocol: BaseProtocol\n) -> None:\n    payload = b\"GET1 /test HTTP/1.1\\r\\n\\r\\n\"\n    parser = HttpRequestParserC(\n        protocol,\n        loop,\n        2**16,\n        max_line_size=8190,\n        max_field_size=8190,\n    )\n\n    with pytest.raises(aiohttp.http_exceptions.BadStatusLine):\n        messages, upgrade, tail = parser.feed_data(payload)",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif('HttpRequestParserC' not in dir(aiohttp.http_parser), reason='C based HTTP parser not available')"
      ],
      "arguments": [
        "loop",
        "protocol"
      ],
      "imports": [
        "asyncio",
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Type",
        "unittest.mock",
        "urllib.parse.quote",
        "pytest",
        "multidict.CIMultiDict",
        "yarl.URL",
        "aiohttp",
        "aiohttp.http_exceptions",
        "aiohttp.streams",
        "aiohttp.base_protocol.BaseProtocol",
        "aiohttp.helpers.NO_EXTENSIONS",
        "aiohttp.http_parser.DeflateBuffer",
        "aiohttp.http_parser.HttpParser",
        "aiohttp.http_parser.HttpPayloadParser",
        "aiohttp.http_parser.HttpRequestParser",
        "aiohttp.http_parser.HttpRequestParserPy",
        "aiohttp.http_parser.HttpResponseParser",
        "aiohttp.http_parser.HttpResponseParserPy",
        "aiohttp.http_writer.HttpVersion",
        "aiohttp.http_parser.HttpRequestParserC",
        "aiohttp.http_parser.HttpResponseParserC",
        "brotlicffi",
        "brotli"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_formdata_multipart",
      "module": "test_formdata",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_formdata.py",
      "line_number": 27,
      "end_line_number": 32,
      "source_code": "def test_formdata_multipart(buf: bytearray) -> None:\n    form = FormData(default_to_multipart=False)\n    assert not form.is_multipart\n\n    form.add_field(\"test\", b\"test\", filename=\"test.txt\")\n    assert form.is_multipart",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "buf"
      ],
      "imports": [
        "io",
        "unittest.mock",
        "pytest",
        "aiohttp.FormData",
        "aiohttp.web",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert not form.is_multipart",
        "assert form.is_multipart"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_form_data_is_multipart_param",
      "module": "test_formdata",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_formdata.py",
      "line_number": 35,
      "end_line_number": 40,
      "source_code": "def test_form_data_is_multipart_param(buf: bytearray) -> None:\n    form = FormData(default_to_multipart=True)\n    assert form.is_multipart\n\n    form.add_field(\"test\", \"test\")\n    assert form.is_multipart",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "buf"
      ],
      "imports": [
        "io",
        "unittest.mock",
        "pytest",
        "aiohttp.FormData",
        "aiohttp.web",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert form.is_multipart",
        "assert form.is_multipart"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_invalid_formdata_payload_multipart",
      "module": "test_formdata",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_formdata.py",
      "line_number": 44,
      "end_line_number": 48,
      "source_code": "def test_invalid_formdata_payload_multipart(obj: object) -> None:\n    form = FormData()\n    form.add_field(\"test\", obj, filename=\"test.txt\")\n    with pytest.raises(TypeError, match=\"Can not serialize value\"):\n        form()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('obj', (object(), None))"
      ],
      "arguments": [
        "obj"
      ],
      "imports": [
        "io",
        "unittest.mock",
        "pytest",
        "aiohttp.FormData",
        "aiohttp.web",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_invalid_formdata_payload_urlencoded",
      "module": "test_formdata",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_formdata.py",
      "line_number": 52,
      "end_line_number": 55,
      "source_code": "def test_invalid_formdata_payload_urlencoded(obj: object) -> None:\n    form = FormData({\"test\": obj})\n    with pytest.raises(TypeError, match=\"expected str\"):\n        form()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('obj', (object(), None))"
      ],
      "arguments": [
        "obj"
      ],
      "imports": [
        "io",
        "unittest.mock",
        "pytest",
        "aiohttp.FormData",
        "aiohttp.web",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_invalid_formdata_params",
      "module": "test_formdata",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_formdata.py",
      "line_number": 58,
      "end_line_number": 60,
      "source_code": "def test_invalid_formdata_params() -> None:\n    with pytest.raises(TypeError):\n        FormData(\"asdasf\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "io",
        "unittest.mock",
        "pytest",
        "aiohttp.FormData",
        "aiohttp.web",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_invalid_formdata_params2",
      "module": "test_formdata",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_formdata.py",
      "line_number": 63,
      "end_line_number": 65,
      "source_code": "def test_invalid_formdata_params2() -> None:\n    with pytest.raises(TypeError):\n        FormData(\"as\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "io",
        "unittest.mock",
        "pytest",
        "aiohttp.FormData",
        "aiohttp.web",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_invalid_formdata_content_type",
      "module": "test_formdata",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_formdata.py",
      "line_number": 78,
      "end_line_number": 83,
      "source_code": "def test_invalid_formdata_content_type() -> None:\n    form = FormData()\n    invalid_vals = [0, 0.1, {}, [], b\"foo\"]\n    for invalid_val in invalid_vals:\n        with pytest.raises(TypeError):\n            form.add_field(\"foo\", \"bar\", content_type=invalid_val)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "io",
        "unittest.mock",
        "pytest",
        "aiohttp.FormData",
        "aiohttp.web",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_invalid_formdata_filename",
      "module": "test_formdata",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_formdata.py",
      "line_number": 86,
      "end_line_number": 91,
      "source_code": "def test_invalid_formdata_filename() -> None:\n    form = FormData()\n    invalid_vals = [0, 0.1, {}, [], b\"foo\"]\n    for invalid_val in invalid_vals:\n        with pytest.raises(TypeError):\n            form.add_field(\"foo\", \"bar\", filename=invalid_val)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "io",
        "unittest.mock",
        "pytest",
        "aiohttp.FormData",
        "aiohttp.web",
        "aiohttp.http_writer.StreamWriter",
        "aiohttp.pytest_plugin.AiohttpClient"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_app_call",
      "module": "test_web_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_app.py",
      "line_number": 18,
      "end_line_number": 20,
      "source_code": "def test_app_call() -> None:\n    app = web.Application()\n    assert app is app()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Iterator",
        "typing.NoReturn",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "aiohttp.log",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.Handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert app is app()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app",
          "body": "@pytest.fixture\ndef app(loop: asyncio.AbstractEventLoop) -> web.Application:\n    ret: web.Application = mock.create_autospec(web.Application, spec_set=True)\n    ret.on_response_prepare = aiosignal.Signal(ret)\n    ret.on_response_prepare.freeze()\n    return ret"
        }
      ]
    },
    {
      "name": "test_logging",
      "module": "test_web_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_app.py",
      "line_number": 50,
      "end_line_number": 54,
      "source_code": "def test_logging() -> None:\n    logger = mock.Mock()\n    app = web.Application()\n    app.logger = logger\n    assert app.logger is logger",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Iterator",
        "typing.NoReturn",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "aiohttp.log",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.Handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.logger is logger"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_appkey",
      "module": "test_web_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_app.py",
      "line_number": 104,
      "end_line_number": 111,
      "source_code": "def test_appkey() -> None:\n    key = web.AppKey(\"key\", str)\n    app = web.Application()\n    app[key] = \"value\"\n    assert app[key] == \"value\"\n    assert len(app) == 1\n    del app[key]\n    assert len(app) == 0",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Iterator",
        "typing.NoReturn",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "aiohttp.log",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.Handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert app[key] == 'value'",
        "assert len(app) == 1",
        "assert len(app) == 0"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_appkey_repr_concrete",
      "module": "test_web_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_app.py",
      "line_number": 114,
      "end_line_number": 125,
      "source_code": "def test_appkey_repr_concrete() -> None:\n    key = web.AppKey(\"key\", int)\n    assert repr(key) in (\n        \"<AppKey(__channelexec__.key, type=int)>\",  # pytest-xdist\n        \"<AppKey(__main__.key, type=int)>\",\n    )\n    key2 = web.AppKey(\"key\", web.Request)\n    assert repr(key2) in (\n        # pytest-xdist:\n        \"<AppKey(__channelexec__.key, type=aiohttp.web_request.Request)>\",\n        \"<AppKey(__main__.key, type=aiohttp.web_request.Request)>\",\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Iterator",
        "typing.NoReturn",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "aiohttp.log",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.Handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(key) in ('<AppKey(__channelexec__.key, type=int)>', '<AppKey(__main__.key, type=int)>')",
        "assert repr(key2) in ('<AppKey(__channelexec__.key, type=aiohttp.web_request.Request)>', '<AppKey(__main__.key, type=aiohttp.web_request.Request)>')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_appkey_repr_nonconcrete",
      "module": "test_web_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_app.py",
      "line_number": 128,
      "end_line_number": 134,
      "source_code": "def test_appkey_repr_nonconcrete() -> None:\n    key = web.AppKey(\"key\", Iterator[int])\n    assert repr(key) in (\n        # pytest-xdist:\n        \"<AppKey(__channelexec__.key, type=typing.Iterator[int])>\",\n        \"<AppKey(__main__.key, type=typing.Iterator[int])>\",\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Iterator",
        "typing.NoReturn",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "aiohttp.log",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.Handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(key) in ('<AppKey(__channelexec__.key, type=typing.Iterator[int])>', '<AppKey(__main__.key, type=typing.Iterator[int])>')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_appkey_repr_annotated",
      "module": "test_web_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_app.py",
      "line_number": 137,
      "end_line_number": 143,
      "source_code": "def test_appkey_repr_annotated() -> None:\n    key = web.AppKey[Iterator[int]](\"key\")\n    assert repr(key) in (\n        # pytest-xdist:\n        \"<AppKey(__channelexec__.key, type=typing.Iterator[int])>\",\n        \"<AppKey(__main__.key, type=typing.Iterator[int])>\",\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Iterator",
        "typing.NoReturn",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "aiohttp.log",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.Handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(key) in ('<AppKey(__channelexec__.key, type=typing.Iterator[int])>', '<AppKey(__main__.key, type=typing.Iterator[int])>')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_app_str_keys",
      "module": "test_web_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_app.py",
      "line_number": 146,
      "end_line_number": 154,
      "source_code": "def test_app_str_keys() -> None:\n    app = web.Application()\n    with pytest.warns(\n        UserWarning, match=r\"web_advanced\\.html#application-s-config\"\n    ) as checker:\n        app[\"key\"] = \"value\"\n        # Check that the error is emitted at the call site (stacklevel=2)\n        assert checker[0].filename == __file__\n    assert app[\"key\"] == \"value\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Iterator",
        "typing.NoReturn",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "aiohttp.log",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.Handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert app['key'] == 'value'",
        "assert checker[0].filename == __file__"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_app_get",
      "module": "test_web_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_app.py",
      "line_number": 157,
      "end_line_number": 162,
      "source_code": "def test_app_get() -> None:\n    key = web.AppKey(\"key\", int)\n    app = web.Application()\n    assert app.get(key, \"foo\") == \"foo\"\n    app[key] = 5\n    assert app.get(key, \"foo\") == 5",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Iterator",
        "typing.NoReturn",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "aiohttp.log",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.Handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.get(key, 'foo') == 'foo'",
        "assert app.get(key, 'foo') == 5"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_app_freeze",
      "module": "test_web_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_app.py",
      "line_number": 165,
      "end_line_number": 175,
      "source_code": "def test_app_freeze() -> None:\n    app = web.Application()\n    subapp = mock.Mock()\n    subapp._middlewares = ()\n    app._subapps.append(subapp)\n\n    app.freeze()\n    assert subapp.freeze.called\n\n    app.freeze()\n    assert len(subapp.freeze.call_args_list) == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Iterator",
        "typing.NoReturn",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "aiohttp.log",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.Handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert subapp.freeze.called",
        "assert len(subapp.freeze.call_args_list) == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_equality",
      "module": "test_web_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_app.py",
      "line_number": 178,
      "end_line_number": 183,
      "source_code": "def test_equality() -> None:\n    app1 = web.Application()\n    app2 = web.Application()\n\n    assert app1 == app1\n    assert app1 != app2",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Iterator",
        "typing.NoReturn",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "aiohttp.log",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.Handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert app1 == app1",
        "assert app1 != app2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_app_run_middlewares",
      "module": "test_web_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_app.py",
      "line_number": 186,
      "end_line_number": 206,
      "source_code": "def test_app_run_middlewares() -> None:\n    root = web.Application()\n    sub = web.Application()\n    root.add_subapp(\"/sub\", sub)\n    root.freeze()\n    assert root._run_middlewares is False\n\n    async def middleware(request: web.Request, handler: Handler) -> web.StreamResponse:\n        return await handler(request)  # pragma: no cover\n\n    root = web.Application(middlewares=[middleware])\n    sub = web.Application()\n    root.add_subapp(\"/sub\", sub)\n    root.freeze()\n    assert root._run_middlewares is True\n\n    root = web.Application()\n    sub = web.Application(middlewares=[middleware])\n    root.add_subapp(\"/sub\", sub)\n    root.freeze()\n    assert root._run_middlewares is True",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Iterator",
        "typing.NoReturn",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "aiohttp.log",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.Handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert root._run_middlewares is False",
        "assert root._run_middlewares is True",
        "assert root._run_middlewares is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "handler",
          "body": "def handler(request: web.Request) -> NoReturn:\n    assert False"
        }
      ]
    },
    {
      "name": "test_subapp_pre_frozen_after_adding",
      "module": "test_web_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_app.py",
      "line_number": 209,
      "end_line_number": 215,
      "source_code": "def test_subapp_pre_frozen_after_adding() -> None:\n    app = web.Application()\n    subapp = web.Application()\n\n    app.add_subapp(\"/prefix\", subapp)\n    assert subapp.pre_frozen\n    assert not subapp.frozen",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Iterator",
        "typing.NoReturn",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "aiohttp.log",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.Handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert subapp.pre_frozen",
        "assert not subapp.frozen"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_app_inheritance",
      "module": "test_web_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_app.py",
      "line_number": 218,
      "end_line_number": 222,
      "source_code": "def test_app_inheritance() -> None:\n    with pytest.raises(TypeError):\n\n        class A(web.Application):  # type: ignore[misc]\n            pass",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Iterator",
        "typing.NoReturn",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "aiohttp.log",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.Handler"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_app_custom_attr",
      "module": "test_web_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_app.py",
      "line_number": 225,
      "end_line_number": 228,
      "source_code": "def test_app_custom_attr() -> None:\n    app = web.Application()\n    with pytest.raises(AttributeError):\n        app.custom = None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Iterator",
        "typing.NoReturn",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "aiohttp.log",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.Handler"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_app_iter",
      "module": "test_web_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_app.py",
      "line_number": 534,
      "end_line_number": 542,
      "source_code": "def test_app_iter() -> None:\n    app = web.Application()\n    b = web.AppKey(\"b\", str)\n    c = web.AppKey(\"c\", str)\n    app[\"a\"] = \"0\"\n    app[b] = \"1\"\n    app[c] = \"2\"\n    app[\"d\"] = \"4\"\n    assert sorted(list(app)) == [b, c, \"a\", \"d\"]",
      "docstring": null,
      "decorators": [
        "pytest.mark.filterwarnings('ignore:.*web\\\\.AppKey:UserWarning')"
      ],
      "arguments": [],
      "imports": [
        "asyncio",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Iterator",
        "typing.NoReturn",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "aiohttp.log",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.Handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert sorted(list(app)) == [b, c, 'a', 'd']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_app_forbid_nonslot_attr",
      "module": "test_web_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_app.py",
      "line_number": 545,
      "end_line_number": 550,
      "source_code": "def test_app_forbid_nonslot_attr() -> None:\n    app = web.Application()\n    with pytest.raises(AttributeError):\n        app.unknow_attr  # type: ignore[attr-defined]\n    with pytest.raises(AttributeError):\n        app.unknow_attr = 1",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Iterator",
        "typing.NoReturn",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "aiohttp.log",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.Handler"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_forbid_changing_frozen_app",
      "module": "test_web_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_app.py",
      "line_number": 553,
      "end_line_number": 557,
      "source_code": "def test_forbid_changing_frozen_app() -> None:\n    app = web.Application()\n    app.freeze()\n    with pytest.raises(RuntimeError):\n        app[\"key\"] = \"value\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Iterator",
        "typing.NoReturn",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "aiohttp.log",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.Handler"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_app_boolean",
      "module": "test_web_app",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_app.py",
      "line_number": 560,
      "end_line_number": 562,
      "source_code": "def test_app_boolean() -> None:\n    app = web.Application()\n    assert app",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Iterator",
        "typing.NoReturn",
        "typing.Type",
        "unittest.mock",
        "pytest",
        "aiohttp.log",
        "aiohttp.web",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.typedefs.Handler"
      ],
      "fixtures": [],
      "assertions": [
        "assert app"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_del",
      "module": "test_client_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_response.py",
      "line_number": 60,
      "end_line_number": 85,
      "source_code": "def test_del(session: ClientSession) -> None:\n    loop = mock.Mock()\n    response = ClientResponse(\n        \"get\",\n        URL(\"http://del-cl-resp.org\"),\n        request_info=mock.Mock(),\n        writer=WriterMock(),\n        continue100=None,\n        timer=TimerNoop(),\n        traces=[],\n        loop=loop,\n        session=session,\n    )\n    loop.get_debug = mock.Mock()\n    loop.get_debug.return_value = True\n\n    connection = mock.Mock()\n    response._closed = False\n    response._connection = connection\n    loop.set_exception_handler(lambda loop, ctx: None)\n\n    with pytest.warns(ResourceWarning):\n        del response\n        gc.collect()\n\n    connection.release.assert_called_with()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "session"
      ],
      "imports": [
        "asyncio",
        "gc",
        "sys",
        "json.JSONDecodeError",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientSession",
        "aiohttp.http",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.RequestInfo",
        "aiohttp.connector.Connection",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_close",
      "module": "test_client_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_response.py",
      "line_number": 88,
      "end_line_number": 105,
      "source_code": "def test_close(loop: asyncio.AbstractEventLoop, session: ClientSession) -> None:\n    response = ClientResponse(\n        \"get\",\n        URL(\"http://def-cl-resp.org\"),\n        request_info=mock.Mock(),\n        writer=WriterMock(),\n        continue100=None,\n        timer=TimerNoop(),\n        traces=[],\n        loop=loop,\n        session=session,\n    )\n    response._closed = False\n    response._connection = mock.Mock()\n    response.close()\n    assert response.connection is None\n    response.close()\n    response.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop",
        "session"
      ],
      "imports": [
        "asyncio",
        "gc",
        "sys",
        "json.JSONDecodeError",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientSession",
        "aiohttp.http",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.RequestInfo",
        "aiohttp.connector.Connection",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.connection is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": [
        {
          "name": "response.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "response.close",
          "body": "def close(self) -> None:\n    pass"
        },
        {
          "name": "response.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_wait_for_100_1",
      "module": "test_client_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_response.py",
      "line_number": 108,
      "end_line_number": 123,
      "source_code": "def test_wait_for_100_1(\n    loop: asyncio.AbstractEventLoop, session: ClientSession\n) -> None:\n    response = ClientResponse(\n        \"get\",\n        URL(\"http://python.org\"),\n        continue100=loop.create_future(),\n        request_info=mock.Mock(),\n        writer=WriterMock(),\n        timer=TimerNoop(),\n        traces=[],\n        loop=loop,\n        session=session,\n    )\n    assert response._continue is not None\n    response.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop",
        "session"
      ],
      "imports": [
        "asyncio",
        "gc",
        "sys",
        "json.JSONDecodeError",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientSession",
        "aiohttp.http",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.RequestInfo",
        "aiohttp.connector.Connection",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [
        "assert response._continue is not None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": [
        {
          "name": "response.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_wait_for_100_2",
      "module": "test_client_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_response.py",
      "line_number": 126,
      "end_line_number": 141,
      "source_code": "def test_wait_for_100_2(\n    loop: asyncio.AbstractEventLoop, session: ClientSession\n) -> None:\n    response = ClientResponse(\n        \"get\",\n        URL(\"http://python.org\"),\n        request_info=mock.Mock(),\n        continue100=None,\n        writer=WriterMock(),\n        timer=TimerNoop(),\n        traces=[],\n        loop=loop,\n        session=session,\n    )\n    assert response._continue is None\n    response.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop",
        "session"
      ],
      "imports": [
        "asyncio",
        "gc",
        "sys",
        "json.JSONDecodeError",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientSession",
        "aiohttp.http",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.RequestInfo",
        "aiohttp.connector.Connection",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [
        "assert response._continue is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": [
        {
          "name": "response.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_repr",
      "module": "test_client_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_response.py",
      "line_number": 144,
      "end_line_number": 158,
      "source_code": "def test_repr(loop: asyncio.AbstractEventLoop, session: ClientSession) -> None:\n    response = ClientResponse(\n        \"get\",\n        URL(\"http://def-cl-resp.org\"),\n        request_info=mock.Mock(),\n        writer=WriterMock(),\n        continue100=None,\n        timer=TimerNoop(),\n        traces=[],\n        loop=loop,\n        session=session,\n    )\n    response.status = 200\n    response.reason = \"Ok\"\n    assert \"<ClientResponse(http://def-cl-resp.org) [200 Ok]>\" in repr(response)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop",
        "session"
      ],
      "imports": [
        "asyncio",
        "gc",
        "sys",
        "json.JSONDecodeError",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientSession",
        "aiohttp.http",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.RequestInfo",
        "aiohttp.connector.Connection",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [
        "assert '<ClientResponse(http://def-cl-resp.org) [200 Ok]>' in repr(response)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_repr_non_ascii_url",
      "module": "test_client_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_response.py",
      "line_number": 161,
      "end_line_number": 173,
      "source_code": "def test_repr_non_ascii_url() -> None:\n    response = ClientResponse(\n        \"get\",\n        URL(\"http://fake-host.org/\\u03bb\"),\n        request_info=mock.Mock(),\n        writer=WriterMock(),\n        continue100=None,\n        timer=TimerNoop(),\n        traces=[],\n        loop=mock.Mock(),\n        session=mock.Mock(),\n    )\n    assert \"<ClientResponse(http://fake-host.org/%CE%BB) [None None]>\" in repr(response)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "gc",
        "sys",
        "json.JSONDecodeError",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientSession",
        "aiohttp.http",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.RequestInfo",
        "aiohttp.connector.Connection",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [
        "assert '<ClientResponse(http://fake-host.org/%CE%BB) [None None]>' in repr(response)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_repr_non_ascii_reason",
      "module": "test_client_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_response.py",
      "line_number": 176,
      "end_line_number": 191,
      "source_code": "def test_repr_non_ascii_reason() -> None:\n    response = ClientResponse(\n        \"get\",\n        URL(\"http://fake-host.org/path\"),\n        request_info=mock.Mock(),\n        writer=WriterMock(),\n        continue100=None,\n        timer=TimerNoop(),\n        traces=[],\n        loop=mock.Mock(),\n        session=mock.Mock(),\n    )\n    response.reason = \"\\u03bb\"\n    assert \"<ClientResponse(http://fake-host.org/path) [None \\\\u03bb]>\" in repr(\n        response\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "gc",
        "sys",
        "json.JSONDecodeError",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientSession",
        "aiohttp.http",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.RequestInfo",
        "aiohttp.connector.Connection",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [
        "assert '<ClientResponse(http://fake-host.org/path) [None \\\\u03bb]>' in repr(response)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_get_encoding_unknown",
      "module": "test_client_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_response.py",
      "line_number": 773,
      "end_line_number": 790,
      "source_code": "def test_get_encoding_unknown(\n    loop: asyncio.AbstractEventLoop, session: ClientSession\n) -> None:\n    response = ClientResponse(\n        \"get\",\n        URL(\"http://def-cl-resp.org\"),\n        request_info=mock.Mock(),\n        writer=WriterMock(),\n        continue100=None,\n        timer=TimerNoop(),\n        traces=[],\n        loop=loop,\n        session=session,\n    )\n\n    h = {\"Content-Type\": \"application/json\"}\n    response._headers = CIMultiDictProxy(CIMultiDict(h))\n    assert response.get_encoding() == \"utf-8\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop",
        "session"
      ],
      "imports": [
        "asyncio",
        "gc",
        "sys",
        "json.JSONDecodeError",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientSession",
        "aiohttp.http",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.RequestInfo",
        "aiohttp.connector.Connection",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.get_encoding() == 'utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_raise_for_status_2xx",
      "module": "test_client_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_response.py",
      "line_number": 793,
      "end_line_number": 807,
      "source_code": "def test_raise_for_status_2xx() -> None:\n    response = ClientResponse(\n        \"get\",\n        URL(\"http://def-cl-resp.org\"),\n        request_info=mock.Mock(),\n        writer=WriterMock(),\n        continue100=None,\n        timer=TimerNoop(),\n        traces=[],\n        loop=mock.Mock(),\n        session=mock.Mock(),\n    )\n    response.status = 200\n    response.reason = \"OK\"\n    response.raise_for_status()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "gc",
        "sys",
        "json.JSONDecodeError",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientSession",
        "aiohttp.http",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.RequestInfo",
        "aiohttp.connector.Connection",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_raise_for_status_4xx",
      "module": "test_client_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_response.py",
      "line_number": 810,
      "end_line_number": 828,
      "source_code": "def test_raise_for_status_4xx() -> None:\n    response = ClientResponse(\n        \"get\",\n        URL(\"http://def-cl-resp.org\"),\n        request_info=mock.Mock(),\n        writer=WriterMock(),\n        continue100=None,\n        timer=TimerNoop(),\n        traces=[],\n        loop=mock.Mock(),\n        session=mock.Mock(),\n    )\n    response.status = 409\n    response.reason = \"CONFLICT\"\n    with pytest.raises(aiohttp.ClientResponseError) as cm:\n        response.raise_for_status()\n    assert str(cm.value.status) == \"409\"\n    assert str(cm.value.message) == \"CONFLICT\"\n    assert response.closed",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "gc",
        "sys",
        "json.JSONDecodeError",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientSession",
        "aiohttp.http",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.RequestInfo",
        "aiohttp.connector.Connection",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(cm.value.status) == '409'",
        "assert str(cm.value.message) == 'CONFLICT'",
        "assert response.closed"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_raise_for_status_4xx_without_reason",
      "module": "test_client_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_response.py",
      "line_number": 831,
      "end_line_number": 849,
      "source_code": "def test_raise_for_status_4xx_without_reason() -> None:\n    response = ClientResponse(\n        \"get\",\n        URL(\"http://def-cl-resp.org\"),\n        request_info=mock.Mock(),\n        writer=WriterMock(),\n        continue100=None,\n        timer=TimerNoop(),\n        traces=[],\n        loop=mock.Mock(),\n        session=mock.Mock(),\n    )\n    response.status = 404\n    response.reason = \"\"\n    with pytest.raises(aiohttp.ClientResponseError) as cm:\n        response.raise_for_status()\n    assert str(cm.value.status) == \"404\"\n    assert str(cm.value.message) == \"\"\n    assert response.closed",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "gc",
        "sys",
        "json.JSONDecodeError",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientSession",
        "aiohttp.http",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.RequestInfo",
        "aiohttp.connector.Connection",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(cm.value.status) == '404'",
        "assert str(cm.value.message) == ''",
        "assert response.closed"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_resp_host",
      "module": "test_client_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_response.py",
      "line_number": 852,
      "end_line_number": 864,
      "source_code": "def test_resp_host() -> None:\n    response = ClientResponse(\n        \"get\",\n        URL(\"http://del-cl-resp.org\"),\n        request_info=mock.Mock(),\n        writer=WriterMock(),\n        continue100=None,\n        timer=TimerNoop(),\n        traces=[],\n        loop=mock.Mock(),\n        session=mock.Mock(),\n    )\n    assert \"del-cl-resp.org\" == response.host",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "gc",
        "sys",
        "json.JSONDecodeError",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientSession",
        "aiohttp.http",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.RequestInfo",
        "aiohttp.connector.Connection",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'del-cl-resp.org' == response.host"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_content_type",
      "module": "test_client_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_response.py",
      "line_number": 867,
      "end_line_number": 882,
      "source_code": "def test_content_type() -> None:\n    response = ClientResponse(\n        \"get\",\n        URL(\"http://def-cl-resp.org\"),\n        request_info=mock.Mock(),\n        writer=WriterMock(),\n        continue100=None,\n        timer=TimerNoop(),\n        traces=[],\n        loop=mock.Mock(),\n        session=mock.Mock(),\n    )\n    h = {\"Content-Type\": \"application/json;charset=cp1251\"}\n    response._headers = CIMultiDictProxy(CIMultiDict(h))\n\n    assert \"application/json\" == response.content_type",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "gc",
        "sys",
        "json.JSONDecodeError",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientSession",
        "aiohttp.http",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.RequestInfo",
        "aiohttp.connector.Connection",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'application/json' == response.content_type"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_content_type_no_header",
      "module": "test_client_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_response.py",
      "line_number": 885,
      "end_line_number": 899,
      "source_code": "def test_content_type_no_header() -> None:\n    response = ClientResponse(\n        \"get\",\n        URL(\"http://def-cl-resp.org\"),\n        request_info=mock.Mock(),\n        writer=WriterMock(),\n        continue100=None,\n        timer=TimerNoop(),\n        traces=[],\n        loop=mock.Mock(),\n        session=mock.Mock(),\n    )\n    response._headers = CIMultiDictProxy(CIMultiDict({}))\n\n    assert \"application/octet-stream\" == response.content_type",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "gc",
        "sys",
        "json.JSONDecodeError",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientSession",
        "aiohttp.http",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.RequestInfo",
        "aiohttp.connector.Connection",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'application/octet-stream' == response.content_type"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_charset",
      "module": "test_client_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_response.py",
      "line_number": 902,
      "end_line_number": 917,
      "source_code": "def test_charset() -> None:\n    response = ClientResponse(\n        \"get\",\n        URL(\"http://def-cl-resp.org\"),\n        request_info=mock.Mock(),\n        writer=WriterMock(),\n        continue100=None,\n        timer=TimerNoop(),\n        traces=[],\n        loop=mock.Mock(),\n        session=mock.Mock(),\n    )\n    h = {\"Content-Type\": \"application/json;charset=cp1251\"}\n    response._headers = CIMultiDictProxy(CIMultiDict(h))\n\n    assert \"cp1251\" == response.charset",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "gc",
        "sys",
        "json.JSONDecodeError",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientSession",
        "aiohttp.http",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.RequestInfo",
        "aiohttp.connector.Connection",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'cp1251' == response.charset"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_charset_no_header",
      "module": "test_client_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_response.py",
      "line_number": 920,
      "end_line_number": 934,
      "source_code": "def test_charset_no_header() -> None:\n    response = ClientResponse(\n        \"get\",\n        URL(\"http://def-cl-resp.org\"),\n        request_info=mock.Mock(),\n        writer=WriterMock(),\n        continue100=None,\n        timer=TimerNoop(),\n        traces=[],\n        loop=mock.Mock(),\n        session=mock.Mock(),\n    )\n    response._headers = CIMultiDictProxy(CIMultiDict({}))\n\n    assert response.charset is None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "gc",
        "sys",
        "json.JSONDecodeError",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientSession",
        "aiohttp.http",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.RequestInfo",
        "aiohttp.connector.Connection",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.charset is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_charset_no_charset",
      "module": "test_client_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_response.py",
      "line_number": 937,
      "end_line_number": 952,
      "source_code": "def test_charset_no_charset() -> None:\n    response = ClientResponse(\n        \"get\",\n        URL(\"http://def-cl-resp.org\"),\n        request_info=mock.Mock(),\n        writer=WriterMock(),\n        continue100=None,\n        timer=TimerNoop(),\n        traces=[],\n        loop=mock.Mock(),\n        session=mock.Mock(),\n    )\n    h = {\"Content-Type\": \"application/json\"}\n    response._headers = CIMultiDictProxy(CIMultiDict(h))\n\n    assert response.charset is None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "gc",
        "sys",
        "json.JSONDecodeError",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientSession",
        "aiohttp.http",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.RequestInfo",
        "aiohttp.connector.Connection",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.charset is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_content_disposition_full",
      "module": "test_client_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_response.py",
      "line_number": 955,
      "end_line_number": 975,
      "source_code": "def test_content_disposition_full() -> None:\n    response = ClientResponse(\n        \"get\",\n        URL(\"http://def-cl-resp.org\"),\n        request_info=mock.Mock(),\n        writer=WriterMock(),\n        continue100=None,\n        timer=TimerNoop(),\n        traces=[],\n        loop=mock.Mock(),\n        session=mock.Mock(),\n    )\n    h = {\"Content-Disposition\": 'attachment; filename=\"archive.tar.gz\"; foo=bar'}\n    response._headers = CIMultiDictProxy(CIMultiDict(h))\n\n    assert response.content_disposition is not None\n    assert \"attachment\" == response.content_disposition.type\n    assert \"bar\" == response.content_disposition.parameters[\"foo\"]\n    assert \"archive.tar.gz\" == response.content_disposition.filename\n    with pytest.raises(TypeError):\n        response.content_disposition.parameters[\"foo\"] = \"baz\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "gc",
        "sys",
        "json.JSONDecodeError",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientSession",
        "aiohttp.http",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.RequestInfo",
        "aiohttp.connector.Connection",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.content_disposition is not None",
        "assert 'attachment' == response.content_disposition.type",
        "assert 'bar' == response.content_disposition.parameters['foo']",
        "assert 'archive.tar.gz' == response.content_disposition.filename"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_content_disposition_no_parameters",
      "module": "test_client_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_response.py",
      "line_number": 978,
      "end_line_number": 996,
      "source_code": "def test_content_disposition_no_parameters() -> None:\n    response = ClientResponse(\n        \"get\",\n        URL(\"http://def-cl-resp.org\"),\n        request_info=mock.Mock(),\n        writer=WriterMock(),\n        continue100=None,\n        timer=TimerNoop(),\n        traces=[],\n        loop=mock.Mock(),\n        session=mock.Mock(),\n    )\n    h = {\"Content-Disposition\": \"attachment\"}\n    response._headers = CIMultiDictProxy(CIMultiDict(h))\n\n    assert response.content_disposition is not None\n    assert \"attachment\" == response.content_disposition.type\n    assert response.content_disposition.filename is None\n    assert {} == response.content_disposition.parameters",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "gc",
        "sys",
        "json.JSONDecodeError",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientSession",
        "aiohttp.http",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.RequestInfo",
        "aiohttp.connector.Connection",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.content_disposition is not None",
        "assert 'attachment' == response.content_disposition.type",
        "assert response.content_disposition.filename is None",
        "assert {} == response.content_disposition.parameters"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_content_disposition_no_header",
      "module": "test_client_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_response.py",
      "line_number": 999,
      "end_line_number": 1013,
      "source_code": "def test_content_disposition_no_header() -> None:\n    response = ClientResponse(\n        \"get\",\n        URL(\"http://def-cl-resp.org\"),\n        request_info=mock.Mock(),\n        writer=WriterMock(),\n        continue100=None,\n        timer=TimerNoop(),\n        traces=[],\n        loop=mock.Mock(),\n        session=mock.Mock(),\n    )\n    response._headers = CIMultiDictProxy(CIMultiDict({}))\n\n    assert response.content_disposition is None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "gc",
        "sys",
        "json.JSONDecodeError",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientSession",
        "aiohttp.http",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.RequestInfo",
        "aiohttp.connector.Connection",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.content_disposition is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_response_request_info",
      "module": "test_client_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_response.py",
      "line_number": 1016,
      "end_line_number": 1033,
      "source_code": "def test_response_request_info() -> None:\n    url = URL(\"http://def-cl-resp.org\")\n    h = {\"Content-Type\": \"application/json;charset=cp1251\"}\n    headers = CIMultiDictProxy(CIMultiDict(h))\n    response = ClientResponse(\n        \"get\",\n        url,\n        request_info=RequestInfo(url, \"get\", headers, url),\n        writer=WriterMock(),\n        continue100=None,\n        timer=TimerNoop(),\n        traces=[],\n        loop=mock.Mock(),\n        session=mock.Mock(),\n    )\n    assert url == response.request_info.url\n    assert \"get\" == response.request_info.method\n    assert headers == response.request_info.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "gc",
        "sys",
        "json.JSONDecodeError",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientSession",
        "aiohttp.http",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.RequestInfo",
        "aiohttp.connector.Connection",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [
        "assert url == response.request_info.url",
        "assert 'get' == response.request_info.method",
        "assert headers == response.request_info.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_request_info_in_exception",
      "module": "test_client_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_response.py",
      "line_number": 1036,
      "end_line_number": 1055,
      "source_code": "def test_request_info_in_exception() -> None:\n    url = URL(\"http://def-cl-resp.org\")\n    h = {\"Content-Type\": \"application/json;charset=cp1251\"}\n    headers = CIMultiDictProxy(CIMultiDict(h))\n    response = ClientResponse(\n        \"get\",\n        url,\n        request_info=RequestInfo(url, \"get\", headers, url),\n        writer=WriterMock(),\n        continue100=None,\n        timer=TimerNoop(),\n        traces=[],\n        loop=mock.Mock(),\n        session=mock.Mock(),\n    )\n    response.status = 409\n    response.reason = \"CONFLICT\"\n    with pytest.raises(aiohttp.ClientResponseError) as cm:\n        response.raise_for_status()\n    assert cm.value.request_info == response.request_info",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "gc",
        "sys",
        "json.JSONDecodeError",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientSession",
        "aiohttp.http",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.RequestInfo",
        "aiohttp.connector.Connection",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [
        "assert cm.value.request_info == response.request_info"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_no_redirect_history_in_exception",
      "module": "test_client_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_response.py",
      "line_number": 1058,
      "end_line_number": 1077,
      "source_code": "def test_no_redirect_history_in_exception() -> None:\n    url = URL(\"http://def-cl-resp.org\")\n    h = {\"Content-Type\": \"application/json;charset=cp1251\"}\n    headers = CIMultiDictProxy(CIMultiDict(h))\n    response = ClientResponse(\n        \"get\",\n        url,\n        request_info=RequestInfo(url, \"get\", headers, url),\n        writer=WriterMock(),\n        continue100=None,\n        timer=TimerNoop(),\n        traces=[],\n        loop=mock.Mock(),\n        session=mock.Mock(),\n    )\n    response.status = 409\n    response.reason = \"CONFLICT\"\n    with pytest.raises(aiohttp.ClientResponseError) as cm:\n        response.raise_for_status()\n    assert () == cm.value.history",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "gc",
        "sys",
        "json.JSONDecodeError",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientSession",
        "aiohttp.http",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.RequestInfo",
        "aiohttp.connector.Connection",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [
        "assert () == cm.value.history"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_redirect_history_in_exception",
      "module": "test_client_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_response.py",
      "line_number": 1080,
      "end_line_number": 1120,
      "source_code": "def test_redirect_history_in_exception() -> None:\n    hist_url = URL(\"http://def-cl-resp.org\")\n    u = \"http://def-cl-resp.org/index.htm\"\n    url = URL(u)\n    hist_headers = {\"Content-Type\": \"application/json;charset=cp1251\", \"Location\": u}\n    h = {\"Content-Type\": \"application/json;charset=cp1251\"}\n    headers = CIMultiDictProxy(CIMultiDict(h))\n    response = ClientResponse(\n        \"get\",\n        url,\n        request_info=RequestInfo(url, \"get\", headers, url),\n        writer=WriterMock(),\n        continue100=None,\n        timer=TimerNoop(),\n        traces=[],\n        loop=mock.Mock(),\n        session=mock.Mock(),\n    )\n    response.status = 409\n    response.reason = \"CONFLICT\"\n\n    hist_response = ClientResponse(\n        \"get\",\n        hist_url,\n        request_info=RequestInfo(url, \"get\", headers, url),\n        writer=WriterMock(),\n        continue100=None,\n        timer=TimerNoop(),\n        traces=[],\n        loop=mock.Mock(),\n        session=mock.Mock(),\n    )\n\n    hist_response._headers = CIMultiDictProxy(CIMultiDict(hist_headers))\n    hist_response.status = 301\n    hist_response.reason = \"REDIRECT\"\n\n    response._history = (hist_response,)\n    with pytest.raises(aiohttp.ClientResponseError) as cm:\n        response.raise_for_status()\n    assert (hist_response,) == cm.value.history",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "gc",
        "sys",
        "json.JSONDecodeError",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientSession",
        "aiohttp.http",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.RequestInfo",
        "aiohttp.connector.Connection",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [
        "assert (hist_response,) == cm.value.history"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_response_real_url",
      "module": "test_client_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_response.py",
      "line_number": 1164,
      "end_line_number": 1180,
      "source_code": "def test_response_real_url(\n    loop: asyncio.AbstractEventLoop, session: ClientSession\n) -> None:\n    url = URL(\"http://def-cl-resp.org/#urlfragment\")\n    response = ClientResponse(\n        \"get\",\n        url,\n        request_info=mock.Mock(),\n        writer=WriterMock(),\n        continue100=None,\n        timer=TimerNoop(),\n        traces=[],\n        loop=loop,\n        session=session,\n    )\n    assert response.url == url.with_fragment(None)\n    assert response.real_url == url",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop",
        "session"
      ],
      "imports": [
        "asyncio",
        "gc",
        "sys",
        "json.JSONDecodeError",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientSession",
        "aiohttp.http",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.RequestInfo",
        "aiohttp.connector.Connection",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.url == url.with_fragment(None)",
        "assert response.real_url == url"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_response_links_comma_separated",
      "module": "test_client_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_response.py",
      "line_number": 1183,
      "end_line_number": 1211,
      "source_code": "def test_response_links_comma_separated(\n    loop: asyncio.AbstractEventLoop, session: ClientSession\n) -> None:\n    url = URL(\"http://def-cl-resp.org/\")\n    response = ClientResponse(\n        \"get\",\n        url,\n        request_info=mock.Mock(),\n        writer=WriterMock(),\n        continue100=None,\n        timer=TimerNoop(),\n        traces=[],\n        loop=loop,\n        session=session,\n    )\n    h = (\n        (\n            \"Link\",\n            (\n                \"<http://example.com/page/1.html>; rel=next, \"\n                \"<http://example.com/>; rel=home\"\n            ),\n        ),\n    )\n    response._headers = CIMultiDictProxy(CIMultiDict(h))\n    assert response.links == {\n        \"next\": {\"url\": URL(\"http://example.com/page/1.html\"), \"rel\": \"next\"},\n        \"home\": {\"url\": URL(\"http://example.com/\"), \"rel\": \"home\"},\n    }",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop",
        "session"
      ],
      "imports": [
        "asyncio",
        "gc",
        "sys",
        "json.JSONDecodeError",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientSession",
        "aiohttp.http",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.RequestInfo",
        "aiohttp.connector.Connection",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.links == {'next': {'url': URL('http://example.com/page/1.html'), 'rel': 'next'}, 'home': {'url': URL('http://example.com/'), 'rel': 'home'}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_response_links_multiple_headers",
      "module": "test_client_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_response.py",
      "line_number": 1214,
      "end_line_number": 1237,
      "source_code": "def test_response_links_multiple_headers(\n    loop: asyncio.AbstractEventLoop, session: ClientSession\n) -> None:\n    url = URL(\"http://def-cl-resp.org/\")\n    response = ClientResponse(\n        \"get\",\n        url,\n        request_info=mock.Mock(),\n        writer=WriterMock(),\n        continue100=None,\n        timer=TimerNoop(),\n        traces=[],\n        loop=loop,\n        session=session,\n    )\n    h = (\n        (\"Link\", \"<http://example.com/page/1.html>; rel=next\"),\n        (\"Link\", \"<http://example.com/>; rel=home\"),\n    )\n    response._headers = CIMultiDictProxy(CIMultiDict(h))\n    assert response.links == {\n        \"next\": {\"url\": URL(\"http://example.com/page/1.html\"), \"rel\": \"next\"},\n        \"home\": {\"url\": URL(\"http://example.com/\"), \"rel\": \"home\"},\n    }",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop",
        "session"
      ],
      "imports": [
        "asyncio",
        "gc",
        "sys",
        "json.JSONDecodeError",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientSession",
        "aiohttp.http",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.RequestInfo",
        "aiohttp.connector.Connection",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.links == {'next': {'url': URL('http://example.com/page/1.html'), 'rel': 'next'}, 'home': {'url': URL('http://example.com/'), 'rel': 'home'}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_response_links_no_rel",
      "module": "test_client_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_response.py",
      "line_number": 1240,
      "end_line_number": 1259,
      "source_code": "def test_response_links_no_rel(\n    loop: asyncio.AbstractEventLoop, session: ClientSession\n) -> None:\n    url = URL(\"http://def-cl-resp.org/\")\n    response = ClientResponse(\n        \"get\",\n        url,\n        request_info=mock.Mock(),\n        writer=WriterMock(),\n        continue100=None,\n        timer=TimerNoop(),\n        traces=[],\n        loop=loop,\n        session=session,\n    )\n    h = ((\"Link\", \"<http://example.com/>\"),)\n    response._headers = CIMultiDictProxy(CIMultiDict(h))\n    assert response.links == {\n        \"http://example.com/\": {\"url\": URL(\"http://example.com/\")}\n    }",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop",
        "session"
      ],
      "imports": [
        "asyncio",
        "gc",
        "sys",
        "json.JSONDecodeError",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientSession",
        "aiohttp.http",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.RequestInfo",
        "aiohttp.connector.Connection",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.links == {'http://example.com/': {'url': URL('http://example.com/')}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_response_links_quoted",
      "module": "test_client_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_response.py",
      "line_number": 1262,
      "end_line_number": 1281,
      "source_code": "def test_response_links_quoted(\n    loop: asyncio.AbstractEventLoop, session: ClientSession\n) -> None:\n    url = URL(\"http://def-cl-resp.org/\")\n    response = ClientResponse(\n        \"get\",\n        url,\n        request_info=mock.Mock(),\n        writer=WriterMock(),\n        continue100=None,\n        timer=TimerNoop(),\n        traces=[],\n        loop=loop,\n        session=session,\n    )\n    h = ((\"Link\", '<http://example.com/>; rel=\"home-page\"'),)\n    response._headers = CIMultiDictProxy(CIMultiDict(h))\n    assert response.links == {\n        \"home-page\": {\"url\": URL(\"http://example.com/\"), \"rel\": \"home-page\"}\n    }",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop",
        "session"
      ],
      "imports": [
        "asyncio",
        "gc",
        "sys",
        "json.JSONDecodeError",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientSession",
        "aiohttp.http",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.RequestInfo",
        "aiohttp.connector.Connection",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.links == {'home-page': {'url': URL('http://example.com/'), 'rel': 'home-page'}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_response_links_relative",
      "module": "test_client_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_response.py",
      "line_number": 1284,
      "end_line_number": 1303,
      "source_code": "def test_response_links_relative(\n    loop: asyncio.AbstractEventLoop, session: ClientSession\n) -> None:\n    url = URL(\"http://def-cl-resp.org/\")\n    response = ClientResponse(\n        \"get\",\n        url,\n        request_info=mock.Mock(),\n        writer=WriterMock(),\n        continue100=None,\n        timer=TimerNoop(),\n        traces=[],\n        loop=loop,\n        session=session,\n    )\n    h = ((\"Link\", \"</relative/path>; rel=rel\"),)\n    response._headers = CIMultiDictProxy(CIMultiDict(h))\n    assert response.links == {\n        \"rel\": {\"url\": URL(\"http://def-cl-resp.org/relative/path\"), \"rel\": \"rel\"}\n    }",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop",
        "session"
      ],
      "imports": [
        "asyncio",
        "gc",
        "sys",
        "json.JSONDecodeError",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientSession",
        "aiohttp.http",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.RequestInfo",
        "aiohttp.connector.Connection",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.links == {'rel': {'url': URL('http://def-cl-resp.org/relative/path'), 'rel': 'rel'}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_response_links_empty",
      "module": "test_client_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_response.py",
      "line_number": 1306,
      "end_line_number": 1322,
      "source_code": "def test_response_links_empty(\n    loop: asyncio.AbstractEventLoop, session: ClientSession\n) -> None:\n    url = URL(\"http://def-cl-resp.org/\")\n    response = ClientResponse(\n        \"get\",\n        url,\n        request_info=mock.Mock(),\n        writer=WriterMock(),\n        continue100=None,\n        timer=TimerNoop(),\n        traces=[],\n        loop=loop,\n        session=session,\n    )\n    response._headers = CIMultiDictProxy(CIMultiDict())\n    assert response.links == {}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop",
        "session"
      ],
      "imports": [
        "asyncio",
        "gc",
        "sys",
        "json.JSONDecodeError",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientSession",
        "aiohttp.http",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.RequestInfo",
        "aiohttp.connector.Connection",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.links == {}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_response_not_closed_after_get_ok",
      "module": "test_client_response",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_response.py",
      "line_number": 1325,
      "end_line_number": 1343,
      "source_code": "def test_response_not_closed_after_get_ok(mocker: MockerFixture) -> None:\n    response = ClientResponse(\n        \"get\",\n        URL(\"http://del-cl-resp.org\"),\n        request_info=mock.Mock(),\n        writer=WriterMock(),\n        continue100=None,\n        timer=TimerNoop(),\n        traces=[],\n        loop=mock.Mock(),\n        session=mock.Mock(),\n    )\n    response.status = 400\n    response.reason = \"Bad Request\"\n    response._closed = False\n    spy = mocker.spy(response, \"raise_for_status\")\n    assert not response.ok\n    assert not response.closed\n    assert spy.call_count == 0",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "mocker"
      ],
      "imports": [
        "asyncio",
        "gc",
        "sys",
        "json.JSONDecodeError",
        "unittest.mock",
        "pytest",
        "multidict.CIMultiDict",
        "multidict.CIMultiDictProxy",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientSession",
        "aiohttp.http",
        "aiohttp.client_reqrep.ClientResponse",
        "aiohttp.client_reqrep.RequestInfo",
        "aiohttp.connector.Connection",
        "aiohttp.helpers.TimerNoop",
        "aiohttp.test_utils.make_mocked_coro"
      ],
      "fixtures": [],
      "assertions": [
        "assert not response.ok",
        "assert not response.closed",
        "assert spy.call_count == 0"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": [
        {
          "name": "mocker.spy",
          "body": "def spy() -> None:\n    nonlocal called\n    called = True"
        }
      ]
    },
    {
      "name": "test_access_logger_format",
      "module": "test_web_log",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_log.py",
      "line_number": 28,
      "end_line_number": 33,
      "source_code": "def test_access_logger_format() -> None:\n    log_format = '%T \"%{ETag}o\" %X {X} %%P'\n    mock_logger = mock.Mock()\n    access_logger = AccessLogger(mock_logger, log_format)\n    expected = '%s \"%s\" %%X {X} %%%s'\n    assert expected == access_logger._log_format",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime",
        "logging",
        "platform",
        "sys",
        "contextvars.ContextVar",
        "typing.Dict",
        "typing.NoReturn",
        "typing.Optional",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp.web",
        "aiohttp.abc.AbstractAccessLogger",
        "aiohttp.abc.AbstractAsyncAccessLogger",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpRawServer",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.Handler",
        "aiohttp.web_log.AccessLogger",
        "aiohttp.web_response.Response",
        "typing.Self",
        "typing.Any"
      ],
      "fixtures": [],
      "assertions": [
        "assert expected == access_logger._log_format"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_access_logger_atoms",
      "module": "test_web_log",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_log.py",
      "line_number": 88,
      "end_line_number": 115,
      "source_code": "def test_access_logger_atoms(\n    monkeypatch: pytest.MonkeyPatch,\n    log_format: str,\n    expected: str,\n    extra: Dict[str, object],\n) -> None:\n    class PatchedDatetime(datetime.datetime):\n        @classmethod\n        def now(cls, tz: Optional[datetime.tzinfo] = None) -> Self:\n            return cls(1843, 1, 1, 0, 30, tzinfo=tz)\n\n    monkeypatch.setattr(\"datetime.datetime\", PatchedDatetime)\n    monkeypatch.setattr(\"time.timezone\", -28800)\n    monkeypatch.setattr(\"os.getpid\", lambda: 42)\n    mock_logger = mock.Mock()\n    access_logger = AccessLogger(mock_logger, log_format)\n    request = mock.Mock(\n        headers={\"H1\": \"a\", \"H2\": \"b\"},\n        method=\"GET\",\n        path_qs=\"/path\",\n        version=aiohttp.HttpVersion(1, 1),\n        remote=\"127.0.0.2\",\n    )\n    response = mock.Mock(headers={}, body_length=42, status=200)\n    access_logger.log(request, response, 3.1415926)\n    assert not mock_logger.exception.called, mock_logger.exception.call_args\n\n    mock_logger.info.assert_called_with(expected, extra=extra)",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(IS_PYPY, reason=\"\\n    Because of patching :py:class:`datetime.datetime`, under PyPy it\\n    fails in :py:func:`isinstance` call in\\n    :py:meth:`datetime.datetime.__sub__` (called from\\n    :py:meth:`aiohttp.AccessLogger._format_t`):\\n\\n    *** TypeError: isinstance() arg 2 must be a class, type, or tuple of classes and types\\n\\n    (Pdb) from datetime import datetime\\n    (Pdb) isinstance(now, datetime)\\n    *** TypeError: isinstance() arg 2 must be a class, type, or tuple of classes and types\\n    (Pdb) datetime.__class__\\n    <class 'unittest.mock.MagicMock'>\\n    (Pdb) isinstance(now, datetime.__class__)\\n    False\\n\\n    Ref: https://bitbucket.org/pypy/pypy/issues/1187/call-to-isinstance-in-__sub__-self-other\\n    Ref: https://github.com/celery/celery/issues/811\\n    Ref: https://stackoverflow.com/a/46102240/595220\\n    \")",
        "pytest.mark.parametrize('log_format,expected,extra', [('%t', '[01/Jan/1843:00:29:56 +0800]', {'request_start_time': '[01/Jan/1843:00:29:56 +0800]'}), ('%a %t %P %r %s %b %T %Tf %D \"%{H1}i\" \"%{H2}i\"', '127.0.0.2 [01/Jan/1843:00:29:56 +0800] <42> GET /path HTTP/1.1 200 42 3 3.141593 3141593 \"a\" \"b\"', {'first_request_line': 'GET /path HTTP/1.1', 'process_id': '<42>', 'remote_address': '127.0.0.2', 'request_start_time': '[01/Jan/1843:00:29:56 +0800]', 'request_time': '3', 'request_time_frac': '3.141593', 'request_time_micro': '3141593', 'response_size': 42, 'response_status': 200, 'request_header': {'H1': 'a', 'H2': 'b'}})])"
      ],
      "arguments": [
        "monkeypatch",
        "log_format",
        "expected",
        "extra"
      ],
      "imports": [
        "datetime",
        "logging",
        "platform",
        "sys",
        "contextvars.ContextVar",
        "typing.Dict",
        "typing.NoReturn",
        "typing.Optional",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp.web",
        "aiohttp.abc.AbstractAccessLogger",
        "aiohttp.abc.AbstractAsyncAccessLogger",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpRawServer",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.Handler",
        "aiohttp.web_log.AccessLogger",
        "aiohttp.web_response.Response",
        "typing.Self",
        "typing.Any"
      ],
      "fixtures": [],
      "assertions": [
        "assert not mock_logger.exception.called, mock_logger.exception.call_args"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock(headers={'H1': 'a', 'H2': 'b'}, method='GET', path_qs='/path', version=aiohttp.HttpVersion(1, 1), remote='127.0.0.2')",
        "mock.Mock(headers={}, body_length=42, status=200)"
      ],
      "methods_under_test": [
        {
          "name": "access_logger.log",
          "body": "def log(self, request: web.BaseRequest, response: web.StreamResponse, time: float) -> None:\n    \"\"\"Pass log method.\"\"\""
        }
      ]
    },
    {
      "name": "test_access_logger_dicts",
      "module": "test_web_log",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_log.py",
      "line_number": 118,
      "end_line_number": 134,
      "source_code": "def test_access_logger_dicts() -> None:\n    log_format = \"%{User-Agent}i %{Content-Length}o %{None}i\"\n    mock_logger = mock.Mock()\n    access_logger = AccessLogger(mock_logger, log_format)\n    request = mock.Mock(\n        headers={\"User-Agent\": \"Mock/1.0\"}, version=(1, 1), remote=\"127.0.0.2\"\n    )\n    response = mock.Mock(headers={\"Content-Length\": 123})\n    access_logger.log(request, response, 0.0)\n    assert not mock_logger.error.called\n    expected = \"Mock/1.0 123 -\"\n    extra = {\n        \"request_header\": {\"User-Agent\": \"Mock/1.0\", \"None\": \"-\"},\n        \"response_header\": {\"Content-Length\": 123},\n    }\n\n    mock_logger.info.assert_called_with(expected, extra=extra)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime",
        "logging",
        "platform",
        "sys",
        "contextvars.ContextVar",
        "typing.Dict",
        "typing.NoReturn",
        "typing.Optional",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp.web",
        "aiohttp.abc.AbstractAccessLogger",
        "aiohttp.abc.AbstractAsyncAccessLogger",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpRawServer",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.Handler",
        "aiohttp.web_log.AccessLogger",
        "aiohttp.web_response.Response",
        "typing.Self",
        "typing.Any"
      ],
      "fixtures": [],
      "assertions": [
        "assert not mock_logger.error.called"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock(headers={'User-Agent': 'Mock/1.0'}, version=(1, 1), remote='127.0.0.2')",
        "mock.Mock(headers={'Content-Length': 123})"
      ],
      "methods_under_test": [
        {
          "name": "access_logger.log",
          "body": "def log(self, request: web.BaseRequest, response: web.StreamResponse, time: float) -> None:\n    \"\"\"Pass log method.\"\"\""
        }
      ]
    },
    {
      "name": "test_access_logger_unix_socket",
      "module": "test_web_log",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_log.py",
      "line_number": 137,
      "end_line_number": 146,
      "source_code": "def test_access_logger_unix_socket() -> None:\n    log_format = \"|%a|\"\n    mock_logger = mock.Mock()\n    access_logger = AccessLogger(mock_logger, log_format)\n    request = mock.Mock(headers={\"User-Agent\": \"Mock/1.0\"}, version=(1, 1), remote=\"\")\n    response = mock.Mock()\n    access_logger.log(request, response, 0.0)\n    assert not mock_logger.error.called\n    expected = \"||\"\n    mock_logger.info.assert_called_with(expected, extra={\"remote_address\": \"\"})",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime",
        "logging",
        "platform",
        "sys",
        "contextvars.ContextVar",
        "typing.Dict",
        "typing.NoReturn",
        "typing.Optional",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp.web",
        "aiohttp.abc.AbstractAccessLogger",
        "aiohttp.abc.AbstractAsyncAccessLogger",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpRawServer",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.Handler",
        "aiohttp.web_log.AccessLogger",
        "aiohttp.web_response.Response",
        "typing.Self",
        "typing.Any"
      ],
      "fixtures": [],
      "assertions": [
        "assert not mock_logger.error.called"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock(headers={'User-Agent': 'Mock/1.0'}, version=(1, 1), remote='')",
        "mock.Mock()"
      ],
      "methods_under_test": [
        {
          "name": "access_logger.log",
          "body": "def log(self, request: web.BaseRequest, response: web.StreamResponse, time: float) -> None:\n    \"\"\"Pass log method.\"\"\""
        }
      ]
    },
    {
      "name": "test_logger_no_message",
      "module": "test_web_log",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_log.py",
      "line_number": 149,
      "end_line_number": 158,
      "source_code": "def test_logger_no_message() -> None:\n    mock_logger = mock.Mock()\n    access_logger = AccessLogger(mock_logger, \"%r %{content-type}i\")\n    extra_dict = {\n        \"first_request_line\": \"GET / HTTP/1.1\",\n        \"request_header\": {\"content-type\": \"-\"},\n    }\n\n    access_logger.log(make_mocked_request(\"GET\", \"/\"), web.Response(), 0.0)\n    mock_logger.info.assert_called_with(\"GET / HTTP/1.1 -\", extra=extra_dict)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime",
        "logging",
        "platform",
        "sys",
        "contextvars.ContextVar",
        "typing.Dict",
        "typing.NoReturn",
        "typing.Optional",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp.web",
        "aiohttp.abc.AbstractAccessLogger",
        "aiohttp.abc.AbstractAsyncAccessLogger",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpRawServer",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.Handler",
        "aiohttp.web_log.AccessLogger",
        "aiohttp.web_response.Response",
        "typing.Self",
        "typing.Any"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": [
        {
          "name": "access_logger.log",
          "body": "def log(self, request: web.BaseRequest, response: web.StreamResponse, time: float) -> None:\n    \"\"\"Pass log method.\"\"\""
        }
      ]
    },
    {
      "name": "test_logger_internal_error",
      "module": "test_web_log",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_log.py",
      "line_number": 161,
      "end_line_number": 165,
      "source_code": "def test_logger_internal_error() -> None:\n    mock_logger = mock.Mock()\n    access_logger = AccessLogger(mock_logger, \"%D\")\n    access_logger.log(make_mocked_request(\"GET\", \"/\"), web.Response(), \"invalid\")  # type: ignore[arg-type]\n    mock_logger.exception.assert_called_with(\"Error in logging\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime",
        "logging",
        "platform",
        "sys",
        "contextvars.ContextVar",
        "typing.Dict",
        "typing.NoReturn",
        "typing.Optional",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp.web",
        "aiohttp.abc.AbstractAccessLogger",
        "aiohttp.abc.AbstractAsyncAccessLogger",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpRawServer",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.Handler",
        "aiohttp.web_log.AccessLogger",
        "aiohttp.web_response.Response",
        "typing.Self",
        "typing.Any"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": [
        {
          "name": "access_logger.log",
          "body": "def log(self, request: web.BaseRequest, response: web.StreamResponse, time: float) -> None:\n    \"\"\"Pass log method.\"\"\""
        }
      ]
    },
    {
      "name": "test_logger_no_transport",
      "module": "test_web_log",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_log.py",
      "line_number": 168,
      "end_line_number": 172,
      "source_code": "def test_logger_no_transport() -> None:\n    mock_logger = mock.Mock()\n    access_logger = AccessLogger(mock_logger, \"%a\")\n    access_logger.log(make_mocked_request(\"GET\", \"/\"), web.Response(), 0.0)\n    mock_logger.info.assert_called_with(\"-\", extra={\"remote_address\": \"-\"})",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime",
        "logging",
        "platform",
        "sys",
        "contextvars.ContextVar",
        "typing.Dict",
        "typing.NoReturn",
        "typing.Optional",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp.web",
        "aiohttp.abc.AbstractAccessLogger",
        "aiohttp.abc.AbstractAsyncAccessLogger",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpRawServer",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.Handler",
        "aiohttp.web_log.AccessLogger",
        "aiohttp.web_response.Response",
        "typing.Self",
        "typing.Any"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": [
        {
          "name": "access_logger.log",
          "body": "def log(self, request: web.BaseRequest, response: web.StreamResponse, time: float) -> None:\n    \"\"\"Pass log method.\"\"\""
        }
      ]
    },
    {
      "name": "test_logger_abc",
      "module": "test_web_log",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_log.py",
      "line_number": 175,
      "end_line_number": 199,
      "source_code": "def test_logger_abc() -> None:\n    class Logger(AbstractAccessLogger):\n        def log(\n            self, request: web.BaseRequest, response: web.StreamResponse, time: float\n        ) -> None:\n            1 / 0\n\n    mock_logger = mock.Mock()\n    access_logger: AbstractAccessLogger = Logger(mock_logger, \"\")\n\n    with pytest.raises(ZeroDivisionError):\n        access_logger.log(make_mocked_request(\"GET\", \"/\"), web.Response(), 0.0)\n\n    class Logger2(AbstractAccessLogger):\n        def log(\n            self, request: web.BaseRequest, response: web.StreamResponse, time: float\n        ) -> None:\n            self.logger.info(\n                self.log_format.format(request=request, response=response, time=time)\n            )\n\n    mock_logger = mock.Mock()\n    access_logger = Logger2(mock_logger, \"{request} {response} {time}\")\n    access_logger.log(\"request\", \"response\", 1)  # type: ignore[arg-type]\n    mock_logger.info.assert_called_with(\"request response 1\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime",
        "logging",
        "platform",
        "sys",
        "contextvars.ContextVar",
        "typing.Dict",
        "typing.NoReturn",
        "typing.Optional",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp.web",
        "aiohttp.abc.AbstractAccessLogger",
        "aiohttp.abc.AbstractAsyncAccessLogger",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpRawServer",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.Handler",
        "aiohttp.web_log.AccessLogger",
        "aiohttp.web_response.Response",
        "typing.Self",
        "typing.Any"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": [
        {
          "name": "access_logger.log",
          "body": "def log(self, request: web.BaseRequest, response: web.StreamResponse, time: float) -> None:\n    \"\"\"Pass log method.\"\"\""
        },
        {
          "name": "access_logger.log",
          "body": "def log(self, request: web.BaseRequest, response: web.StreamResponse, time: float) -> None:\n    \"\"\"Pass log method.\"\"\""
        }
      ]
    },
    {
      "name": "test_logger_does_nothing_when_disabled",
      "module": "test_web_log",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_web_log.py",
      "line_number": 278,
      "end_line_number": 286,
      "source_code": "def test_logger_does_nothing_when_disabled(caplog: pytest.LogCaptureFixture) -> None:\n    \"\"\"Test that the logger does nothing when the log level is disabled.\"\"\"\n    mock_logger = logging.getLogger(\"test.aiohttp.log\")\n    mock_logger.setLevel(logging.INFO)\n    access_logger = AccessLogger(mock_logger, \"%b\")\n    access_logger.log(\n        mock.Mock(name=\"mock_request\"), mock.Mock(name=\"mock_response\"), 42\n    )\n    assert \"mock_response\" in caplog.text",
      "docstring": "Test that the logger does nothing when the log level is disabled.",
      "decorators": [],
      "arguments": [
        "caplog"
      ],
      "imports": [
        "datetime",
        "logging",
        "platform",
        "sys",
        "contextvars.ContextVar",
        "typing.Dict",
        "typing.NoReturn",
        "typing.Optional",
        "unittest.mock",
        "pytest",
        "aiohttp",
        "aiohttp.web",
        "aiohttp.abc.AbstractAccessLogger",
        "aiohttp.abc.AbstractAsyncAccessLogger",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpRawServer",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_request",
        "aiohttp.typedefs.Handler",
        "aiohttp.web_log.AccessLogger",
        "aiohttp.web_response.Response",
        "typing.Self",
        "typing.Any"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'mock_response' in caplog.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock(name='mock_request')",
        "mock.Mock(name='mock_response')"
      ],
      "methods_under_test": [
        {
          "name": "access_logger.log",
          "body": "def log(self, request: web.BaseRequest, response: web.StreamResponse, time: float) -> None:\n    \"\"\"Pass log method.\"\"\""
        }
      ]
    },
    {
      "name": "test_connection_del",
      "module": "test_connector",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_connector.py",
      "line_number": 130,
      "end_line_number": 148,
      "source_code": "def test_connection_del(loop: asyncio.AbstractEventLoop) -> None:\n    connector = mock.Mock()\n    key = mock.Mock()\n    protocol = mock.Mock()\n    loop.set_debug(False)\n    conn = Connection(connector, key, protocol, loop=loop)\n    exc_handler = mock.Mock()\n    loop.set_exception_handler(exc_handler)\n\n    with pytest.warns(ResourceWarning):\n        del conn\n        gc.collect()\n\n    connector._release.assert_called_with(key, protocol, should_close=True)\n    msg = {\n        \"message\": mock.ANY,\n        \"client_connection\": mock.ANY,\n    }\n    exc_handler.assert_called_with(loop, msg)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop"
      ],
      "imports": [
        "asyncio",
        "gc",
        "hashlib",
        "platform",
        "socket",
        "ssl",
        "sys",
        "uuid",
        "collections.deque",
        "concurrent.futures",
        "contextlib.closing",
        "contextlib.suppress",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Literal",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "aiohappyeyeballs.AddrInfoType",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientRequest",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.connector",
        "aiohttp.web",
        "aiohttp.abc.ResolveResult",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector._SSL_CONTEXT_UNVERIFIED",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.connector.Connection",
        "aiohttp.connector.TCPConnector",
        "aiohttp.connector._DNSCacheTable",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.unused_port",
        "aiohttp.tracing.Trace"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_connection_del_loop_debug",
      "module": "test_connector",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_connector.py",
      "line_number": 151,
      "end_line_number": 169,
      "source_code": "def test_connection_del_loop_debug(loop: asyncio.AbstractEventLoop) -> None:\n    connector = mock.Mock()\n    key = mock.Mock()\n    protocol = mock.Mock()\n    loop.set_debug(True)\n    conn = Connection(connector, key, protocol, loop=loop)\n    exc_handler = mock.Mock()\n    loop.set_exception_handler(exc_handler)\n\n    with pytest.warns(ResourceWarning):\n        del conn\n        gc.collect()\n\n    msg = {\n        \"message\": mock.ANY,\n        \"client_connection\": mock.ANY,\n        \"source_traceback\": mock.ANY,\n    }\n    exc_handler.assert_called_with(loop, msg)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop"
      ],
      "imports": [
        "asyncio",
        "gc",
        "hashlib",
        "platform",
        "socket",
        "ssl",
        "sys",
        "uuid",
        "collections.deque",
        "concurrent.futures",
        "contextlib.closing",
        "contextlib.suppress",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Literal",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "aiohappyeyeballs.AddrInfoType",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientRequest",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.connector",
        "aiohttp.web",
        "aiohttp.abc.ResolveResult",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector._SSL_CONTEXT_UNVERIFIED",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.connector.Connection",
        "aiohttp.connector.TCPConnector",
        "aiohttp.connector._DNSCacheTable",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.unused_port",
        "aiohttp.tracing.Trace"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_connection_del_loop_closed",
      "module": "test_connector",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_connector.py",
      "line_number": 172,
      "end_line_number": 187,
      "source_code": "def test_connection_del_loop_closed(loop: asyncio.AbstractEventLoop) -> None:\n    connector = mock.Mock()\n    key = mock.Mock()\n    protocol = mock.Mock()\n    loop.set_debug(True)\n    conn = Connection(connector, key, protocol, loop=loop)\n    exc_handler = mock.Mock()\n    loop.set_exception_handler(exc_handler)\n    loop.close()\n\n    with pytest.warns(ResourceWarning):\n        del conn\n        gc.collect()\n\n    assert not connector._release.called\n    assert not exc_handler.called",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loop"
      ],
      "imports": [
        "asyncio",
        "gc",
        "hashlib",
        "platform",
        "socket",
        "ssl",
        "sys",
        "uuid",
        "collections.deque",
        "concurrent.futures",
        "contextlib.closing",
        "contextlib.suppress",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Literal",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "aiohappyeyeballs.AddrInfoType",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientRequest",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.connector",
        "aiohttp.web",
        "aiohttp.abc.ResolveResult",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector._SSL_CONTEXT_UNVERIFIED",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.connector.Connection",
        "aiohttp.connector.TCPConnector",
        "aiohttp.connector._DNSCacheTable",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.unused_port",
        "aiohttp.tracing.Trace"
      ],
      "fixtures": [],
      "assertions": [
        "assert not connector._release.called",
        "assert not exc_handler.called"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()",
        "mock.Mock()"
      ],
      "methods_under_test": [
        {
          "name": "loop.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_del_with_closed_loop",
      "module": "test_connector",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_connector.py",
      "line_number": 246,
      "end_line_number": 267,
      "source_code": "def test_del_with_closed_loop(\n    loop: asyncio.AbstractEventLoop, key: ConnectionKey\n) -> None:\n    async def make_conn() -> aiohttp.BaseConnector:\n        return aiohttp.BaseConnector()\n\n    conn = loop.run_until_complete(make_conn())\n    transp = create_mocked_conn(loop)\n    conn._conns[key] = [(transp, 123)]\n\n    conns_impl = conn._conns\n    exc_handler = mock.Mock()\n    loop.set_exception_handler(exc_handler)\n    loop.close()\n\n    with pytest.warns(ResourceWarning):\n        del conn\n        gc.collect()\n\n    assert not conns_impl\n    assert not transp.close.called\n    assert exc_handler.called",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(sys.implementation.name != 'cpython', reason='CPython GC is required for the test')"
      ],
      "arguments": [
        "loop",
        "key"
      ],
      "imports": [
        "asyncio",
        "gc",
        "hashlib",
        "platform",
        "socket",
        "ssl",
        "sys",
        "uuid",
        "collections.deque",
        "concurrent.futures",
        "contextlib.closing",
        "contextlib.suppress",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Literal",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "aiohappyeyeballs.AddrInfoType",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientRequest",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.connector",
        "aiohttp.web",
        "aiohttp.abc.ResolveResult",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector._SSL_CONTEXT_UNVERIFIED",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.connector.Connection",
        "aiohttp.connector.TCPConnector",
        "aiohttp.connector._DNSCacheTable",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.unused_port",
        "aiohttp.tracing.Trace"
      ],
      "fixtures": [],
      "assertions": [
        "assert not conns_impl",
        "assert not transp.close.called",
        "assert exc_handler.called"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": [
        {
          "name": "create_mocked_conn",
          "body": "@pytest.fixture\ndef create_mocked_conn(loop: asyncio.AbstractEventLoop) -> Iterator[Callable[[], ResponseHandler]]:\n\n    def _proto_factory() -> Any:\n        proto = mock.create_autospec(ResponseHandler, instance=True)\n        proto.closed = loop.create_future()\n        proto.closed.set_result(None)\n        return proto\n    yield _proto_factory"
        },
        {
          "name": "loop.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_next_addrs_basic",
      "module": "test_connector",
      "class_name": "TestDNSCacheTable",
      "file_path": "__internal__/data/aiohttp/tests/test_connector.py",
      "line_number": 3164,
      "end_line_number": 3173,
      "source_code": "def test_next_addrs_basic(self, dns_cache_table: _DNSCacheTable) -> None:\n        dns_cache_table.add(self.host1, [self.result1])\n        dns_cache_table.add(self.host2, [self.result2])\n\n        addrs = dns_cache_table.next_addrs(self.host1)\n        assert addrs == [self.result1]\n        addrs = dns_cache_table.next_addrs(self.host2)\n        assert addrs == [self.result2]\n        with pytest.raises(KeyError):\n            dns_cache_table.next_addrs((\"no-such-host\", 80))",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "dns_cache_table"
      ],
      "imports": [
        "asyncio",
        "gc",
        "hashlib",
        "platform",
        "socket",
        "ssl",
        "sys",
        "uuid",
        "collections.deque",
        "concurrent.futures",
        "contextlib.closing",
        "contextlib.suppress",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Literal",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "aiohappyeyeballs.AddrInfoType",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientRequest",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.connector",
        "aiohttp.web",
        "aiohttp.abc.ResolveResult",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector._SSL_CONTEXT_UNVERIFIED",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.connector.Connection",
        "aiohttp.connector.TCPConnector",
        "aiohttp.connector._DNSCacheTable",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.unused_port",
        "aiohttp.tracing.Trace"
      ],
      "fixtures": [],
      "assertions": [
        "assert addrs == [self.result1]",
        "assert addrs == [self.result2]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_remove",
      "module": "test_connector",
      "class_name": "TestDNSCacheTable",
      "file_path": "__internal__/data/aiohttp/tests/test_connector.py",
      "line_number": 3175,
      "end_line_number": 3179,
      "source_code": "def test_remove(self, dns_cache_table: _DNSCacheTable) -> None:\n        dns_cache_table.add(self.host1, [self.result1])\n        dns_cache_table.remove(self.host1)\n        with pytest.raises(KeyError):\n            dns_cache_table.next_addrs(self.host1)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "dns_cache_table"
      ],
      "imports": [
        "asyncio",
        "gc",
        "hashlib",
        "platform",
        "socket",
        "ssl",
        "sys",
        "uuid",
        "collections.deque",
        "concurrent.futures",
        "contextlib.closing",
        "contextlib.suppress",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Literal",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "aiohappyeyeballs.AddrInfoType",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientRequest",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.connector",
        "aiohttp.web",
        "aiohttp.abc.ResolveResult",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector._SSL_CONTEXT_UNVERIFIED",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.connector.Connection",
        "aiohttp.connector.TCPConnector",
        "aiohttp.connector._DNSCacheTable",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.unused_port",
        "aiohttp.tracing.Trace"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_clear",
      "module": "test_connector",
      "class_name": "TestDNSCacheTable",
      "file_path": "__internal__/data/aiohttp/tests/test_connector.py",
      "line_number": 3181,
      "end_line_number": 3185,
      "source_code": "def test_clear(self, dns_cache_table: _DNSCacheTable) -> None:\n        dns_cache_table.add(self.host1, [self.result1])\n        dns_cache_table.clear()\n        with pytest.raises(KeyError):\n            dns_cache_table.next_addrs(self.host1)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "dns_cache_table"
      ],
      "imports": [
        "asyncio",
        "gc",
        "hashlib",
        "platform",
        "socket",
        "ssl",
        "sys",
        "uuid",
        "collections.deque",
        "concurrent.futures",
        "contextlib.closing",
        "contextlib.suppress",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Literal",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "aiohappyeyeballs.AddrInfoType",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientRequest",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.connector",
        "aiohttp.web",
        "aiohttp.abc.ResolveResult",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector._SSL_CONTEXT_UNVERIFIED",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.connector.Connection",
        "aiohttp.connector.TCPConnector",
        "aiohttp.connector._DNSCacheTable",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.unused_port",
        "aiohttp.tracing.Trace"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "dns_cache_table.clear",
          "body": "def clear(self) -> None:\n    nonlocal num_connections\n    num_connections = len(self)\n    super().clear()"
        }
      ]
    },
    {
      "name": "test_not_expired_ttl_None",
      "module": "test_connector",
      "class_name": "TestDNSCacheTable",
      "file_path": "__internal__/data/aiohttp/tests/test_connector.py",
      "line_number": 3187,
      "end_line_number": 3189,
      "source_code": "def test_not_expired_ttl_None(self, dns_cache_table: _DNSCacheTable) -> None:\n        dns_cache_table.add(self.host1, [self.result1])\n        assert not dns_cache_table.expired(self.host1)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "dns_cache_table"
      ],
      "imports": [
        "asyncio",
        "gc",
        "hashlib",
        "platform",
        "socket",
        "ssl",
        "sys",
        "uuid",
        "collections.deque",
        "concurrent.futures",
        "contextlib.closing",
        "contextlib.suppress",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Literal",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "aiohappyeyeballs.AddrInfoType",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientRequest",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.connector",
        "aiohttp.web",
        "aiohttp.abc.ResolveResult",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector._SSL_CONTEXT_UNVERIFIED",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.connector.Connection",
        "aiohttp.connector.TCPConnector",
        "aiohttp.connector._DNSCacheTable",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.unused_port",
        "aiohttp.tracing.Trace"
      ],
      "fixtures": [],
      "assertions": [
        "assert not dns_cache_table.expired(self.host1)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_not_expired_ttl",
      "module": "test_connector",
      "class_name": "TestDNSCacheTable",
      "file_path": "__internal__/data/aiohttp/tests/test_connector.py",
      "line_number": 3191,
      "end_line_number": 3194,
      "source_code": "def test_not_expired_ttl(self) -> None:\n        dns_cache_table = _DNSCacheTable(ttl=0.1)\n        dns_cache_table.add(self.host1, [self.result1])\n        assert not dns_cache_table.expired(self.host1)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "gc",
        "hashlib",
        "platform",
        "socket",
        "ssl",
        "sys",
        "uuid",
        "collections.deque",
        "concurrent.futures",
        "contextlib.closing",
        "contextlib.suppress",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Literal",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "aiohappyeyeballs.AddrInfoType",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientRequest",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.connector",
        "aiohttp.web",
        "aiohttp.abc.ResolveResult",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector._SSL_CONTEXT_UNVERIFIED",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.connector.Connection",
        "aiohttp.connector.TCPConnector",
        "aiohttp.connector._DNSCacheTable",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.unused_port",
        "aiohttp.tracing.Trace"
      ],
      "fixtures": [],
      "assertions": [
        "assert not dns_cache_table.expired(self.host1)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_expired_ttl",
      "module": "test_connector",
      "class_name": "TestDNSCacheTable",
      "file_path": "__internal__/data/aiohttp/tests/test_connector.py",
      "line_number": 3196,
      "end_line_number": 3203,
      "source_code": "def test_expired_ttl(self, monkeypatch: pytest.MonkeyPatch) -> None:\n        dns_cache_table = _DNSCacheTable(ttl=1)\n        monkeypatch.setattr(\"aiohttp.connector.monotonic\", lambda: 1)\n        dns_cache_table.add(self.host1, [self.result1])\n        monkeypatch.setattr(\"aiohttp.connector.monotonic\", lambda: 2)\n        assert not dns_cache_table.expired(self.host1)\n        monkeypatch.setattr(\"aiohttp.connector.monotonic\", lambda: 3)\n        assert dns_cache_table.expired(self.host1)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "monkeypatch"
      ],
      "imports": [
        "asyncio",
        "gc",
        "hashlib",
        "platform",
        "socket",
        "ssl",
        "sys",
        "uuid",
        "collections.deque",
        "concurrent.futures",
        "contextlib.closing",
        "contextlib.suppress",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Literal",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "aiohappyeyeballs.AddrInfoType",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientRequest",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.connector",
        "aiohttp.web",
        "aiohttp.abc.ResolveResult",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector._SSL_CONTEXT_UNVERIFIED",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.connector.Connection",
        "aiohttp.connector.TCPConnector",
        "aiohttp.connector._DNSCacheTable",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.unused_port",
        "aiohttp.tracing.Trace"
      ],
      "fixtures": [],
      "assertions": [
        "assert not dns_cache_table.expired(self.host1)",
        "assert dns_cache_table.expired(self.host1)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_never_expire",
      "module": "test_connector",
      "class_name": "TestDNSCacheTable",
      "file_path": "__internal__/data/aiohttp/tests/test_connector.py",
      "line_number": 3205,
      "end_line_number": 3210,
      "source_code": "def test_never_expire(self, monkeypatch: pytest.MonkeyPatch) -> None:\n        dns_cache_table = _DNSCacheTable(ttl=None)\n        monkeypatch.setattr(\"aiohttp.connector.monotonic\", lambda: 1)\n        dns_cache_table.add(self.host1, [self.result1])\n        monkeypatch.setattr(\"aiohttp.connector.monotonic\", lambda: 10000000)\n        assert not dns_cache_table.expired(self.host1)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "monkeypatch"
      ],
      "imports": [
        "asyncio",
        "gc",
        "hashlib",
        "platform",
        "socket",
        "ssl",
        "sys",
        "uuid",
        "collections.deque",
        "concurrent.futures",
        "contextlib.closing",
        "contextlib.suppress",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Literal",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "aiohappyeyeballs.AddrInfoType",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientRequest",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.connector",
        "aiohttp.web",
        "aiohttp.abc.ResolveResult",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector._SSL_CONTEXT_UNVERIFIED",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.connector.Connection",
        "aiohttp.connector.TCPConnector",
        "aiohttp.connector._DNSCacheTable",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.unused_port",
        "aiohttp.tracing.Trace"
      ],
      "fixtures": [],
      "assertions": [
        "assert not dns_cache_table.expired(self.host1)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_always_expire",
      "module": "test_connector",
      "class_name": "TestDNSCacheTable",
      "file_path": "__internal__/data/aiohttp/tests/test_connector.py",
      "line_number": 3212,
      "end_line_number": 3217,
      "source_code": "def test_always_expire(self, monkeypatch: pytest.MonkeyPatch) -> None:\n        dns_cache_table = _DNSCacheTable(ttl=0)\n        monkeypatch.setattr(\"aiohttp.connector.monotonic\", lambda: 1)\n        dns_cache_table.add(self.host1, [self.result1])\n        monkeypatch.setattr(\"aiohttp.connector.monotonic\", lambda: 1.00001)\n        assert dns_cache_table.expired(self.host1)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "monkeypatch"
      ],
      "imports": [
        "asyncio",
        "gc",
        "hashlib",
        "platform",
        "socket",
        "ssl",
        "sys",
        "uuid",
        "collections.deque",
        "concurrent.futures",
        "contextlib.closing",
        "contextlib.suppress",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Literal",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "aiohappyeyeballs.AddrInfoType",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientRequest",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.connector",
        "aiohttp.web",
        "aiohttp.abc.ResolveResult",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector._SSL_CONTEXT_UNVERIFIED",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.connector.Connection",
        "aiohttp.connector.TCPConnector",
        "aiohttp.connector._DNSCacheTable",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.unused_port",
        "aiohttp.tracing.Trace"
      ],
      "fixtures": [],
      "assertions": [
        "assert dns_cache_table.expired(self.host1)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_next_addrs",
      "module": "test_connector",
      "class_name": "TestDNSCacheTable",
      "file_path": "__internal__/data/aiohttp/tests/test_connector.py",
      "line_number": 3219,
      "end_line_number": 3242,
      "source_code": "def test_next_addrs(self, dns_cache_table: _DNSCacheTable) -> None:\n        result3: ResolveResult = {\n            \"hostname\": \"foo\",\n            \"host\": \"127.0.0.3\",\n            \"port\": 80,\n            \"family\": socket.AF_INET,\n            \"proto\": 0,\n            \"flags\": socket.AI_NUMERICHOST,\n        }\n        dns_cache_table.add(self.host2, [self.result1, self.result2, result3])\n\n        # Each calls to next_addrs return the hosts using\n        # a round robin strategy.\n        addrs = dns_cache_table.next_addrs(self.host2)\n        assert addrs == [self.result1, self.result2, result3]\n\n        addrs = dns_cache_table.next_addrs(self.host2)\n        assert addrs == [self.result2, result3, self.result1]\n\n        addrs = dns_cache_table.next_addrs(self.host2)\n        assert addrs == [result3, self.result1, self.result2]\n\n        addrs = dns_cache_table.next_addrs(self.host2)\n        assert addrs == [self.result1, self.result2, result3]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "dns_cache_table"
      ],
      "imports": [
        "asyncio",
        "gc",
        "hashlib",
        "platform",
        "socket",
        "ssl",
        "sys",
        "uuid",
        "collections.deque",
        "concurrent.futures",
        "contextlib.closing",
        "contextlib.suppress",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Literal",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "aiohappyeyeballs.AddrInfoType",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientRequest",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.connector",
        "aiohttp.web",
        "aiohttp.abc.ResolveResult",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector._SSL_CONTEXT_UNVERIFIED",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.connector.Connection",
        "aiohttp.connector.TCPConnector",
        "aiohttp.connector._DNSCacheTable",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.unused_port",
        "aiohttp.tracing.Trace"
      ],
      "fixtures": [],
      "assertions": [
        "assert addrs == [self.result1, self.result2, result3]",
        "assert addrs == [self.result2, result3, self.result1]",
        "assert addrs == [result3, self.result1, self.result2]",
        "assert addrs == [self.result1, self.result2, result3]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_next_addrs_single",
      "module": "test_connector",
      "class_name": "TestDNSCacheTable",
      "file_path": "__internal__/data/aiohttp/tests/test_connector.py",
      "line_number": 3244,
      "end_line_number": 3251,
      "source_code": "def test_next_addrs_single(self, dns_cache_table: _DNSCacheTable) -> None:\n        dns_cache_table.add(self.host2, [self.result1])\n\n        addrs = dns_cache_table.next_addrs(self.host2)\n        assert addrs == [self.result1]\n\n        addrs = dns_cache_table.next_addrs(self.host2)\n        assert addrs == [self.result1]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "dns_cache_table"
      ],
      "imports": [
        "asyncio",
        "gc",
        "hashlib",
        "platform",
        "socket",
        "ssl",
        "sys",
        "uuid",
        "collections.deque",
        "concurrent.futures",
        "contextlib.closing",
        "contextlib.suppress",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Literal",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "aiohappyeyeballs.AddrInfoType",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientRequest",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.connector",
        "aiohttp.web",
        "aiohttp.abc.ResolveResult",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector._SSL_CONTEXT_UNVERIFIED",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.connector.Connection",
        "aiohttp.connector.TCPConnector",
        "aiohttp.connector._DNSCacheTable",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.unused_port",
        "aiohttp.tracing.Trace"
      ],
      "fixtures": [],
      "assertions": [
        "assert addrs == [self.result1]",
        "assert addrs == [self.result1]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_connector_multiple_event_loop",
      "module": "test_connector",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_connector.py",
      "line_number": 3356,
      "end_line_number": 3385,
      "source_code": "def test_connector_multiple_event_loop() -> None:\n    \"\"\"Test the connector with multiple event loops.\"\"\"\n\n    async def async_connect() -> Literal[True]:\n        conn = aiohttp.TCPConnector()\n        loop = asyncio.get_running_loop()\n        req = ClientRequest(\"GET\", URL(\"https://127.0.0.1\"), loop=loop)\n        with suppress(aiohttp.ClientConnectorError):\n            with mock.patch.object(\n                conn._loop,\n                \"create_connection\",\n                autospec=True,\n                spec_set=True,\n                side_effect=ssl.CertificateError,\n            ):\n                await conn.connect(req, [], ClientTimeout())\n        return True\n\n    def test_connect() -> Literal[True]:\n        loop = asyncio.new_event_loop()\n        try:\n            return loop.run_until_complete(async_connect())\n        finally:\n            loop.close()\n\n    with futures.ThreadPoolExecutor() as executor:\n        res_list = [executor.submit(test_connect) for _ in range(2)]\n        raw_response_list = [res.result() for res in futures.as_completed(res_list)]\n\n    assert raw_response_list == [True, True]",
      "docstring": "Test the connector with multiple event loops.",
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "gc",
        "hashlib",
        "platform",
        "socket",
        "ssl",
        "sys",
        "uuid",
        "collections.deque",
        "concurrent.futures",
        "contextlib.closing",
        "contextlib.suppress",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Literal",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "aiohappyeyeballs.AddrInfoType",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientRequest",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.connector",
        "aiohttp.web",
        "aiohttp.abc.ResolveResult",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector._SSL_CONTEXT_UNVERIFIED",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.connector.Connection",
        "aiohttp.connector.TCPConnector",
        "aiohttp.connector._DNSCacheTable",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.unused_port",
        "aiohttp.tracing.Trace"
      ],
      "fixtures": [],
      "assertions": [
        "assert raw_response_list == [True, True]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "loop.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_default_ssl_context_creation_without_ssl",
      "module": "test_connector",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_connector.py",
      "line_number": 3388,
      "end_line_number": 3392,
      "source_code": "def test_default_ssl_context_creation_without_ssl() -> None:\n    \"\"\"Verify _make_ssl_context does not raise when ssl is not available.\"\"\"\n    with mock.patch.object(connector_module, \"ssl\", None):\n        assert connector_module._make_ssl_context(False) is None\n        assert connector_module._make_ssl_context(True) is None",
      "docstring": "Verify _make_ssl_context does not raise when ssl is not available.",
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "gc",
        "hashlib",
        "platform",
        "socket",
        "ssl",
        "sys",
        "uuid",
        "collections.deque",
        "concurrent.futures",
        "contextlib.closing",
        "contextlib.suppress",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Literal",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "aiohappyeyeballs.AddrInfoType",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientRequest",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.connector",
        "aiohttp.web",
        "aiohttp.abc.ResolveResult",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector._SSL_CONTEXT_UNVERIFIED",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.connector.Connection",
        "aiohttp.connector.TCPConnector",
        "aiohttp.connector._DNSCacheTable",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.unused_port",
        "aiohttp.tracing.Trace"
      ],
      "fixtures": [],
      "assertions": [
        "assert connector_module._make_ssl_context(False) is None",
        "assert connector_module._make_ssl_context(True) is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_next_addrs_basic",
      "module": "test_connector",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_connector.py",
      "line_number": 3164,
      "end_line_number": 3173,
      "source_code": "def test_next_addrs_basic(self, dns_cache_table: _DNSCacheTable) -> None:\n        dns_cache_table.add(self.host1, [self.result1])\n        dns_cache_table.add(self.host2, [self.result2])\n\n        addrs = dns_cache_table.next_addrs(self.host1)\n        assert addrs == [self.result1]\n        addrs = dns_cache_table.next_addrs(self.host2)\n        assert addrs == [self.result2]\n        with pytest.raises(KeyError):\n            dns_cache_table.next_addrs((\"no-such-host\", 80))",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "dns_cache_table"
      ],
      "imports": [
        "asyncio",
        "gc",
        "hashlib",
        "platform",
        "socket",
        "ssl",
        "sys",
        "uuid",
        "collections.deque",
        "concurrent.futures",
        "contextlib.closing",
        "contextlib.suppress",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Literal",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "aiohappyeyeballs.AddrInfoType",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientRequest",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.connector",
        "aiohttp.web",
        "aiohttp.abc.ResolveResult",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector._SSL_CONTEXT_UNVERIFIED",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.connector.Connection",
        "aiohttp.connector.TCPConnector",
        "aiohttp.connector._DNSCacheTable",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.unused_port",
        "aiohttp.tracing.Trace"
      ],
      "fixtures": [],
      "assertions": [
        "assert addrs == [self.result1]",
        "assert addrs == [self.result2]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_remove",
      "module": "test_connector",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_connector.py",
      "line_number": 3175,
      "end_line_number": 3179,
      "source_code": "def test_remove(self, dns_cache_table: _DNSCacheTable) -> None:\n        dns_cache_table.add(self.host1, [self.result1])\n        dns_cache_table.remove(self.host1)\n        with pytest.raises(KeyError):\n            dns_cache_table.next_addrs(self.host1)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "dns_cache_table"
      ],
      "imports": [
        "asyncio",
        "gc",
        "hashlib",
        "platform",
        "socket",
        "ssl",
        "sys",
        "uuid",
        "collections.deque",
        "concurrent.futures",
        "contextlib.closing",
        "contextlib.suppress",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Literal",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "aiohappyeyeballs.AddrInfoType",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientRequest",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.connector",
        "aiohttp.web",
        "aiohttp.abc.ResolveResult",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector._SSL_CONTEXT_UNVERIFIED",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.connector.Connection",
        "aiohttp.connector.TCPConnector",
        "aiohttp.connector._DNSCacheTable",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.unused_port",
        "aiohttp.tracing.Trace"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_clear",
      "module": "test_connector",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_connector.py",
      "line_number": 3181,
      "end_line_number": 3185,
      "source_code": "def test_clear(self, dns_cache_table: _DNSCacheTable) -> None:\n        dns_cache_table.add(self.host1, [self.result1])\n        dns_cache_table.clear()\n        with pytest.raises(KeyError):\n            dns_cache_table.next_addrs(self.host1)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "dns_cache_table"
      ],
      "imports": [
        "asyncio",
        "gc",
        "hashlib",
        "platform",
        "socket",
        "ssl",
        "sys",
        "uuid",
        "collections.deque",
        "concurrent.futures",
        "contextlib.closing",
        "contextlib.suppress",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Literal",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "aiohappyeyeballs.AddrInfoType",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientRequest",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.connector",
        "aiohttp.web",
        "aiohttp.abc.ResolveResult",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector._SSL_CONTEXT_UNVERIFIED",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.connector.Connection",
        "aiohttp.connector.TCPConnector",
        "aiohttp.connector._DNSCacheTable",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.unused_port",
        "aiohttp.tracing.Trace"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "dns_cache_table.clear",
          "body": "def clear(self) -> None:\n    nonlocal num_connections\n    num_connections = len(self)\n    super().clear()"
        }
      ]
    },
    {
      "name": "test_not_expired_ttl_None",
      "module": "test_connector",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_connector.py",
      "line_number": 3187,
      "end_line_number": 3189,
      "source_code": "def test_not_expired_ttl_None(self, dns_cache_table: _DNSCacheTable) -> None:\n        dns_cache_table.add(self.host1, [self.result1])\n        assert not dns_cache_table.expired(self.host1)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "dns_cache_table"
      ],
      "imports": [
        "asyncio",
        "gc",
        "hashlib",
        "platform",
        "socket",
        "ssl",
        "sys",
        "uuid",
        "collections.deque",
        "concurrent.futures",
        "contextlib.closing",
        "contextlib.suppress",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Literal",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "aiohappyeyeballs.AddrInfoType",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientRequest",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.connector",
        "aiohttp.web",
        "aiohttp.abc.ResolveResult",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector._SSL_CONTEXT_UNVERIFIED",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.connector.Connection",
        "aiohttp.connector.TCPConnector",
        "aiohttp.connector._DNSCacheTable",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.unused_port",
        "aiohttp.tracing.Trace"
      ],
      "fixtures": [],
      "assertions": [
        "assert not dns_cache_table.expired(self.host1)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_not_expired_ttl",
      "module": "test_connector",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_connector.py",
      "line_number": 3191,
      "end_line_number": 3194,
      "source_code": "def test_not_expired_ttl(self) -> None:\n        dns_cache_table = _DNSCacheTable(ttl=0.1)\n        dns_cache_table.add(self.host1, [self.result1])\n        assert not dns_cache_table.expired(self.host1)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "gc",
        "hashlib",
        "platform",
        "socket",
        "ssl",
        "sys",
        "uuid",
        "collections.deque",
        "concurrent.futures",
        "contextlib.closing",
        "contextlib.suppress",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Literal",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "aiohappyeyeballs.AddrInfoType",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientRequest",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.connector",
        "aiohttp.web",
        "aiohttp.abc.ResolveResult",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector._SSL_CONTEXT_UNVERIFIED",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.connector.Connection",
        "aiohttp.connector.TCPConnector",
        "aiohttp.connector._DNSCacheTable",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.unused_port",
        "aiohttp.tracing.Trace"
      ],
      "fixtures": [],
      "assertions": [
        "assert not dns_cache_table.expired(self.host1)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_expired_ttl",
      "module": "test_connector",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_connector.py",
      "line_number": 3196,
      "end_line_number": 3203,
      "source_code": "def test_expired_ttl(self, monkeypatch: pytest.MonkeyPatch) -> None:\n        dns_cache_table = _DNSCacheTable(ttl=1)\n        monkeypatch.setattr(\"aiohttp.connector.monotonic\", lambda: 1)\n        dns_cache_table.add(self.host1, [self.result1])\n        monkeypatch.setattr(\"aiohttp.connector.monotonic\", lambda: 2)\n        assert not dns_cache_table.expired(self.host1)\n        monkeypatch.setattr(\"aiohttp.connector.monotonic\", lambda: 3)\n        assert dns_cache_table.expired(self.host1)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "monkeypatch"
      ],
      "imports": [
        "asyncio",
        "gc",
        "hashlib",
        "platform",
        "socket",
        "ssl",
        "sys",
        "uuid",
        "collections.deque",
        "concurrent.futures",
        "contextlib.closing",
        "contextlib.suppress",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Literal",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "aiohappyeyeballs.AddrInfoType",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientRequest",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.connector",
        "aiohttp.web",
        "aiohttp.abc.ResolveResult",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector._SSL_CONTEXT_UNVERIFIED",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.connector.Connection",
        "aiohttp.connector.TCPConnector",
        "aiohttp.connector._DNSCacheTable",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.unused_port",
        "aiohttp.tracing.Trace"
      ],
      "fixtures": [],
      "assertions": [
        "assert not dns_cache_table.expired(self.host1)",
        "assert dns_cache_table.expired(self.host1)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_never_expire",
      "module": "test_connector",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_connector.py",
      "line_number": 3205,
      "end_line_number": 3210,
      "source_code": "def test_never_expire(self, monkeypatch: pytest.MonkeyPatch) -> None:\n        dns_cache_table = _DNSCacheTable(ttl=None)\n        monkeypatch.setattr(\"aiohttp.connector.monotonic\", lambda: 1)\n        dns_cache_table.add(self.host1, [self.result1])\n        monkeypatch.setattr(\"aiohttp.connector.monotonic\", lambda: 10000000)\n        assert not dns_cache_table.expired(self.host1)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "monkeypatch"
      ],
      "imports": [
        "asyncio",
        "gc",
        "hashlib",
        "platform",
        "socket",
        "ssl",
        "sys",
        "uuid",
        "collections.deque",
        "concurrent.futures",
        "contextlib.closing",
        "contextlib.suppress",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Literal",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "aiohappyeyeballs.AddrInfoType",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientRequest",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.connector",
        "aiohttp.web",
        "aiohttp.abc.ResolveResult",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector._SSL_CONTEXT_UNVERIFIED",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.connector.Connection",
        "aiohttp.connector.TCPConnector",
        "aiohttp.connector._DNSCacheTable",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.unused_port",
        "aiohttp.tracing.Trace"
      ],
      "fixtures": [],
      "assertions": [
        "assert not dns_cache_table.expired(self.host1)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_always_expire",
      "module": "test_connector",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_connector.py",
      "line_number": 3212,
      "end_line_number": 3217,
      "source_code": "def test_always_expire(self, monkeypatch: pytest.MonkeyPatch) -> None:\n        dns_cache_table = _DNSCacheTable(ttl=0)\n        monkeypatch.setattr(\"aiohttp.connector.monotonic\", lambda: 1)\n        dns_cache_table.add(self.host1, [self.result1])\n        monkeypatch.setattr(\"aiohttp.connector.monotonic\", lambda: 1.00001)\n        assert dns_cache_table.expired(self.host1)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "monkeypatch"
      ],
      "imports": [
        "asyncio",
        "gc",
        "hashlib",
        "platform",
        "socket",
        "ssl",
        "sys",
        "uuid",
        "collections.deque",
        "concurrent.futures",
        "contextlib.closing",
        "contextlib.suppress",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Literal",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "aiohappyeyeballs.AddrInfoType",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientRequest",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.connector",
        "aiohttp.web",
        "aiohttp.abc.ResolveResult",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector._SSL_CONTEXT_UNVERIFIED",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.connector.Connection",
        "aiohttp.connector.TCPConnector",
        "aiohttp.connector._DNSCacheTable",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.unused_port",
        "aiohttp.tracing.Trace"
      ],
      "fixtures": [],
      "assertions": [
        "assert dns_cache_table.expired(self.host1)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_next_addrs",
      "module": "test_connector",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_connector.py",
      "line_number": 3219,
      "end_line_number": 3242,
      "source_code": "def test_next_addrs(self, dns_cache_table: _DNSCacheTable) -> None:\n        result3: ResolveResult = {\n            \"hostname\": \"foo\",\n            \"host\": \"127.0.0.3\",\n            \"port\": 80,\n            \"family\": socket.AF_INET,\n            \"proto\": 0,\n            \"flags\": socket.AI_NUMERICHOST,\n        }\n        dns_cache_table.add(self.host2, [self.result1, self.result2, result3])\n\n        # Each calls to next_addrs return the hosts using\n        # a round robin strategy.\n        addrs = dns_cache_table.next_addrs(self.host2)\n        assert addrs == [self.result1, self.result2, result3]\n\n        addrs = dns_cache_table.next_addrs(self.host2)\n        assert addrs == [self.result2, result3, self.result1]\n\n        addrs = dns_cache_table.next_addrs(self.host2)\n        assert addrs == [result3, self.result1, self.result2]\n\n        addrs = dns_cache_table.next_addrs(self.host2)\n        assert addrs == [self.result1, self.result2, result3]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "dns_cache_table"
      ],
      "imports": [
        "asyncio",
        "gc",
        "hashlib",
        "platform",
        "socket",
        "ssl",
        "sys",
        "uuid",
        "collections.deque",
        "concurrent.futures",
        "contextlib.closing",
        "contextlib.suppress",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Literal",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "aiohappyeyeballs.AddrInfoType",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientRequest",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.connector",
        "aiohttp.web",
        "aiohttp.abc.ResolveResult",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector._SSL_CONTEXT_UNVERIFIED",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.connector.Connection",
        "aiohttp.connector.TCPConnector",
        "aiohttp.connector._DNSCacheTable",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.unused_port",
        "aiohttp.tracing.Trace"
      ],
      "fixtures": [],
      "assertions": [
        "assert addrs == [self.result1, self.result2, result3]",
        "assert addrs == [self.result2, result3, self.result1]",
        "assert addrs == [result3, self.result1, self.result2]",
        "assert addrs == [self.result1, self.result2, result3]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_next_addrs_single",
      "module": "test_connector",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_connector.py",
      "line_number": 3244,
      "end_line_number": 3251,
      "source_code": "def test_next_addrs_single(self, dns_cache_table: _DNSCacheTable) -> None:\n        dns_cache_table.add(self.host2, [self.result1])\n\n        addrs = dns_cache_table.next_addrs(self.host2)\n        assert addrs == [self.result1]\n\n        addrs = dns_cache_table.next_addrs(self.host2)\n        assert addrs == [self.result1]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "dns_cache_table"
      ],
      "imports": [
        "asyncio",
        "gc",
        "hashlib",
        "platform",
        "socket",
        "ssl",
        "sys",
        "uuid",
        "collections.deque",
        "concurrent.futures",
        "contextlib.closing",
        "contextlib.suppress",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Literal",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "aiohappyeyeballs.AddrInfoType",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientRequest",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.connector",
        "aiohttp.web",
        "aiohttp.abc.ResolveResult",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector._SSL_CONTEXT_UNVERIFIED",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.connector.Connection",
        "aiohttp.connector.TCPConnector",
        "aiohttp.connector._DNSCacheTable",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.unused_port",
        "aiohttp.tracing.Trace"
      ],
      "fixtures": [],
      "assertions": [
        "assert addrs == [self.result1]",
        "assert addrs == [self.result1]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_connect",
      "module": "test_connector",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_connector.py",
      "line_number": 3374,
      "end_line_number": 3379,
      "source_code": "def test_connect() -> Literal[True]:\n        loop = asyncio.new_event_loop()\n        try:\n            return loop.run_until_complete(async_connect())\n        finally:\n            loop.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "gc",
        "hashlib",
        "platform",
        "socket",
        "ssl",
        "sys",
        "uuid",
        "collections.deque",
        "concurrent.futures",
        "contextlib.closing",
        "contextlib.suppress",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterator",
        "typing.List",
        "typing.Literal",
        "typing.NoReturn",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "unittest.mock",
        "pytest",
        "aiohappyeyeballs.AddrInfoType",
        "pytest_mock.MockerFixture",
        "yarl.URL",
        "aiohttp",
        "aiohttp.ClientRequest",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "aiohttp.connector",
        "aiohttp.web",
        "aiohttp.abc.ResolveResult",
        "aiohttp.client_proto.ResponseHandler",
        "aiohttp.client_reqrep.ConnectionKey",
        "aiohttp.connector._SSL_CONTEXT_UNVERIFIED",
        "aiohttp.connector._SSL_CONTEXT_VERIFIED",
        "aiohttp.connector.Connection",
        "aiohttp.connector.TCPConnector",
        "aiohttp.connector._DNSCacheTable",
        "aiohttp.pytest_plugin.AiohttpClient",
        "aiohttp.pytest_plugin.AiohttpServer",
        "aiohttp.test_utils.make_mocked_coro",
        "aiohttp.test_utils.unused_port",
        "aiohttp.tracing.Trace"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "loop.close",
          "body": "def close(self) -> None:\n    pass"
        }
      ]
    },
    {
      "name": "test_fingerprint_sha256",
      "module": "test_client_fingerprint",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_fingerprint.py",
      "line_number": 11,
      "end_line_number": 14,
      "source_code": "def test_fingerprint_sha256() -> None:\n    sha256 = hashlib.sha256(b\"12345678\" * 64).digest()\n    fp = aiohttp.Fingerprint(sha256)\n    assert fp.fingerprint == sha256",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "hashlib",
        "unittest.mock",
        "pytest",
        "aiohttp"
      ],
      "fixtures": [],
      "assertions": [
        "assert fp.fingerprint == sha256"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_fingerprint_sha1",
      "module": "test_client_fingerprint",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_fingerprint.py",
      "line_number": 17,
      "end_line_number": 20,
      "source_code": "def test_fingerprint_sha1() -> None:\n    sha1 = hashlib.sha1(b\"12345678\" * 64).digest()\n    with pytest.raises(ValueError):\n        aiohttp.Fingerprint(sha1)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "hashlib",
        "unittest.mock",
        "pytest",
        "aiohttp"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_fingerprint_md5",
      "module": "test_client_fingerprint",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_fingerprint.py",
      "line_number": 23,
      "end_line_number": 26,
      "source_code": "def test_fingerprint_md5() -> None:\n    md5 = hashlib.md5(b\"12345678\" * 64).digest()\n    with pytest.raises(ValueError):\n        aiohttp.Fingerprint(md5)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "hashlib",
        "unittest.mock",
        "pytest",
        "aiohttp"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_fingerprint_check_no_ssl",
      "module": "test_client_fingerprint",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_client_fingerprint.py",
      "line_number": 29,
      "end_line_number": 34,
      "source_code": "def test_fingerprint_check_no_ssl() -> None:\n    sha256 = hashlib.sha256(b\"12345678\" * 64).digest()\n    fp = aiohttp.Fingerprint(sha256)\n    transport = mock.Mock()\n    transport.get_extra_info.return_value = None\n    fp.check(transport)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "hashlib",
        "unittest.mock",
        "pytest",
        "aiohttp"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_ctor",
      "module": "test_classbasedview",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/test_classbasedview.py",
      "line_number": 9,
      "end_line_number": 12,
      "source_code": "def test_ctor() -> None:\n    request = mock.Mock()\n    view = View(request)\n    assert view.request is request",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "unittest.mock",
        "pytest",
        "aiohttp.web",
        "aiohttp.web_urldispatcher.View"
      ],
      "fixtures": [],
      "assertions": [
        "assert view.request is request"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_client",
      "module": "test_autobahn",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/autobahn/test_autobahn.py",
      "line_number": 50,
      "end_line_number": 86,
      "source_code": "def test_client(report_dir: Path, request: Any) -> None:\n    try:\n        print(\"Starting autobahn-testsuite server\")\n        autobahn_container = docker.run(\n            detach=True,\n            image=\"autobahn-testsuite\",\n            name=\"autobahn\",\n            publish=[(9001, 9001)],\n            remove=True,\n            volumes=[\n                (f\"{request.fspath.dirname}/client\", \"/config\"),\n                (f\"{report_dir}\", \"/reports\"),\n            ],\n        )\n        print(\"Running aiohttp test client\")\n        client = subprocess.Popen(\n            [\"wait-for-it\", \"-s\", \"localhost:9001\", \"--\"]\n            + [sys.executable]\n            + [\"tests/autobahn/client/client.py\"]\n        )\n        client.wait()\n    finally:\n        print(\"Stopping client and server\")\n        client.terminate()\n        client.wait()\n        # https://github.com/gabrieldemarmiesse/python-on-whales/pull/580\n        autobahn_container.stop()  # type: ignore[union-attr]\n\n    failed_messages = get_failed_tests(f\"{report_dir}/clients\", \"aiohttp\")\n\n    assert not failed_messages, \"\\n\".join(\n        \"\\n\\t\".join(\n            f\"{field}: {msg[field]}\"\n            for field in (\"case\", \"description\", \"expectation\", \"expected\", \"received\")\n        )\n        for msg in failed_messages\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(sys.platform == 'darwin', reason=\"Don't run on macOS\")",
        "pytest.mark.xfail"
      ],
      "arguments": [
        "report_dir",
        "request"
      ],
      "imports": [
        "json",
        "subprocess",
        "sys",
        "pathlib.Path",
        "typing.Any",
        "typing.Dict",
        "typing.Generator",
        "typing.List",
        "pytest",
        "pytest.TempPathFactory",
        "python_on_whales.DockerException",
        "python_on_whales.docker"
      ],
      "fixtures": [],
      "assertions": [
        "assert not failed_messages, '\\n'.join(('\\n\\t'.join((f'{field}: {msg[field]}' for field in ('case', 'description', 'expectation', 'expected', 'received'))) for msg in failed_messages))"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_failed_tests",
          "body": "def get_failed_tests(report_path: str, name: str) -> List[Dict[str, Any]]:\n    path = Path(report_path)\n    result_summary = json.loads((path / 'index.json').read_text())[name]\n    failed_messages = []\n    PASS = {'OK', 'INFORMATIONAL'}\n    entry_fields = {'case', 'description', 'expectation', 'expected', 'received'}\n    for results in result_summary.values():\n        if results['behavior'] in PASS and results['behaviorClose'] in PASS:\n            continue\n        report = json.loads((path / results['reportfile']).read_text())\n        failed_messages.append({field: report[field] for field in entry_fields})\n    return failed_messages"
        },
        {
          "name": "docker.run",
          "body": "def run(conn: Connection) -> None:\n    response = ClientResponse('get', URL('http://def-cl-resp.org'), request_info=mock.Mock(), writer=WriterMock(), continue100=None, timer=TimerNoop(), traces=[], loop=loop, session=session)\n    response._closed = False\n    response._connection = conn"
        }
      ]
    },
    {
      "name": "test_server",
      "module": "test_autobahn",
      "class_name": null,
      "file_path": "__internal__/data/aiohttp/tests/autobahn/test_autobahn.py",
      "line_number": 91,
      "end_line_number": 132,
      "source_code": "def test_server(report_dir: Path, request: Any) -> None:\n    try:\n        print(\"Starting aiohttp test server\")\n        server = subprocess.Popen(\n            [sys.executable] + [\"tests/autobahn/server/server.py\"]\n        )\n        print(\"Starting autobahn-testsuite client\")\n        docker.run(\n            image=\"autobahn-testsuite\",\n            name=\"autobahn\",\n            remove=True,\n            volumes=[\n                (f\"{request.fspath.dirname}/server\", \"/config\"),\n                (f\"{report_dir}\", \"/reports\"),\n            ],\n            networks=[\"host\"],\n            command=[\n                \"wait-for-it\",\n                \"-s\",\n                \"localhost:9001\",\n                \"--\",\n                \"wstest\",\n                \"--mode\",\n                \"fuzzingclient\",\n                \"--spec\",\n                \"/config/fuzzingclient.json\",\n            ],\n        )\n    finally:\n        print(\"Stopping client and server\")\n        server.terminate()\n        server.wait()\n\n    failed_messages = get_failed_tests(f\"{report_dir}/servers\", \"AutobahnServer\")\n\n    assert not failed_messages, \"\\n\".join(\n        \"\\n\\t\".join(\n            f\"{field}: {msg[field]}\"\n            for field in (\"case\", \"description\", \"expectation\", \"expected\", \"received\")\n        )\n        for msg in failed_messages\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(sys.platform == 'darwin', reason=\"Don't run on macOS\")",
        "pytest.mark.xfail"
      ],
      "arguments": [
        "report_dir",
        "request"
      ],
      "imports": [
        "json",
        "subprocess",
        "sys",
        "pathlib.Path",
        "typing.Any",
        "typing.Dict",
        "typing.Generator",
        "typing.List",
        "pytest",
        "pytest.TempPathFactory",
        "python_on_whales.DockerException",
        "python_on_whales.docker"
      ],
      "fixtures": [],
      "assertions": [
        "assert not failed_messages, '\\n'.join(('\\n\\t'.join((f'{field}: {msg[field]}' for field in ('case', 'description', 'expectation', 'expected', 'received'))) for msg in failed_messages))"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_failed_tests",
          "body": "def get_failed_tests(report_path: str, name: str) -> List[Dict[str, Any]]:\n    path = Path(report_path)\n    result_summary = json.loads((path / 'index.json').read_text())[name]\n    failed_messages = []\n    PASS = {'OK', 'INFORMATIONAL'}\n    entry_fields = {'case', 'description', 'expectation', 'expected', 'received'}\n    for results in result_summary.values():\n        if results['behavior'] in PASS and results['behaviorClose'] in PASS:\n            continue\n        report = json.loads((path / results['reportfile']).read_text())\n        failed_messages.append({field: report[field] for field in entry_fields})\n    return failed_messages"
        },
        {
          "name": "docker.run",
          "body": "def run(conn: Connection) -> None:\n    response = ClientResponse('get', URL('http://def-cl-resp.org'), request_info=mock.Mock(), writer=WriterMock(), continue100=None, timer=TimerNoop(), traces=[], loop=loop, session=session)\n    response._closed = False\n    response._connection = conn"
        }
      ]
    }
  ]
}