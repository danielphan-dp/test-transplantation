{
  "tests": [
    {
      "name": "test_flaskify_path",
      "module": "test_flask_utils",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_flask_utils.py",
      "line_number": 4,
      "end_line_number": 16,
      "source_code": "def test_flaskify_path():\n    assert flask_utils.flaskify_path(\"{test-path}\") == \"<test_path>\"\n    assert flask_utils.flaskify_path(\"api/{test-path}\") == \"api/<test_path>\"\n    assert flask_utils.flaskify_path(\"my-api/{test-path}\") == \"my-api/<test_path>\"\n    assert flask_utils.flaskify_path(\"foo_bar/{a-b}/{c_d}\") == \"foo_bar/<a_b>/<c_d>\"\n    assert (\n        flask_utils.flaskify_path(\"foo/{a}/{b}\", {\"a\": \"integer\"}) == \"foo/<int:a>/<b>\"\n    )\n    assert (\n        flask_utils.flaskify_path(\"foo/{a}/{b}\", {\"a\": \"number\"}) == \"foo/<float:a>/<b>\"\n    )\n    assert flask_utils.flaskify_path(\"foo/{a}/{b}\", {\"a\": \"path\"}) == \"foo/<path:a>/<b>\"\n    assert flask_utils.flaskify_path(\"foo/{a}\", {\"a\": \"path\"}) == \"foo/<path:a>\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.frameworks.flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask_utils.flaskify_path('{test-path}') == '<test_path>'",
        "assert flask_utils.flaskify_path('api/{test-path}') == 'api/<test_path>'",
        "assert flask_utils.flaskify_path('my-api/{test-path}') == 'my-api/<test_path>'",
        "assert flask_utils.flaskify_path('foo_bar/{a-b}/{c_d}') == 'foo_bar/<a_b>/<c_d>'",
        "assert flask_utils.flaskify_path('foo/{a}/{b}', {'a': 'integer'}) == 'foo/<int:a>/<b>'",
        "assert flask_utils.flaskify_path('foo/{a}/{b}', {'a': 'number'}) == 'foo/<float:a>/<b>'",
        "assert flask_utils.flaskify_path('foo/{a}/{b}', {'a': 'path'}) == 'foo/<path:a>/<b>'",
        "assert flask_utils.flaskify_path('foo/{a}', {'a': 'path'}) == 'foo/<path:a>'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_flaskify_endpoint",
      "module": "test_flask_utils",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_flask_utils.py",
      "line_number": 19,
      "end_line_number": 27,
      "source_code": "def test_flaskify_endpoint():\n    assert flask_utils.flaskify_endpoint(\"module.function\") == \"module_function\"\n    assert flask_utils.flaskify_endpoint(\"function\") == \"function\"\n\n    name = \"module.function\"\n    randlen = 6\n    res = flask_utils.flaskify_endpoint(name, randlen)\n    assert res.startswith(\"module_function\")\n    assert len(res) == len(name) + 1 + randlen",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.frameworks.flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask_utils.flaskify_endpoint('module.function') == 'module_function'",
        "assert flask_utils.flaskify_endpoint('function') == 'function'",
        "assert res.startswith('module_function')",
        "assert len(res) == len(name) + 1 + randlen"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_routing_middleware",
      "module": "test_middleware",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_middleware.py",
      "line_number": 47,
      "end_line_number": 54,
      "source_code": "def test_routing_middleware(middleware_app):\n    app_client = middleware_app.test_client()\n\n    response = app_client.post(\"/v1.0/greeting/robbe\")\n\n    assert (\n        response.headers.get(\"operation_id\") == \"fakeapi.hello.post_greeting\"\n    ), response.status_code",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "middleware_app"
      ],
      "imports": [
        "typing",
        "unittest.mock.Mock",
        "pytest",
        "connexion.FlaskApp",
        "connexion.middleware.ConnexionMiddleware",
        "connexion.middleware.MiddlewarePosition",
        "connexion.middleware.swagger_ui.SwaggerUIMiddleware",
        "connexion.types.Environ",
        "connexion.types.ResponseStream",
        "connexion.types.StartResponse",
        "connexion.types.WSGIApp",
        "starlette.datastructures.MutableHeaders",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.headers.get('operation_id') == 'fakeapi.hello.post_greeting', response.status_code"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "response.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_add_middleware",
      "module": "test_middleware",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_middleware.py",
      "line_number": 57,
      "end_line_number": 67,
      "source_code": "def test_add_middleware(spec, app_class):\n    \"\"\"Test adding middleware via the `add_middleware` method.\"\"\"\n    app = build_app_from_fixture(\"simple\", app_class=app_class, spec_file=spec)\n    app.add_middleware(TestMiddleware)\n\n    app_client = app.test_client()\n    response = app_client.post(\"/v1.0/greeting/robbe\")\n\n    assert (\n        response.headers.get(\"operation_id\") == \"fakeapi.hello.post_greeting\"\n    ), response.status_code",
      "docstring": "Test adding middleware via the `add_middleware` method.",
      "decorators": [],
      "arguments": [
        "spec",
        "app_class"
      ],
      "imports": [
        "typing",
        "unittest.mock.Mock",
        "pytest",
        "connexion.FlaskApp",
        "connexion.middleware.ConnexionMiddleware",
        "connexion.middleware.MiddlewarePosition",
        "connexion.middleware.swagger_ui.SwaggerUIMiddleware",
        "connexion.types.Environ",
        "connexion.types.ResponseStream",
        "connexion.types.StartResponse",
        "connexion.types.WSGIApp",
        "starlette.datastructures.MutableHeaders",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.headers.get('operation_id') == 'fakeapi.hello.post_greeting', response.status_code"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "build_app_from_fixture",
          "body": "def build_app_from_fixture(api_spec_folder, *, app_class, spec_file, middlewares=None, **kwargs):\n    cnx_app = app_class(__name__, specification_dir=FIXTURES_FOLDER / api_spec_folder, middlewares=middlewares)\n    cnx_app.add_api(spec_file, **kwargs)\n    cnx_app._spec_file = spec_file\n    return cnx_app"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "response.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_position",
      "module": "test_middleware",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_middleware.py",
      "line_number": 70,
      "end_line_number": 88,
      "source_code": "def test_position(spec, app_class):\n    \"\"\"Test adding middleware via the `add_middleware` method.\"\"\"\n    middlewares = [\n        middleware\n        for middleware in ConnexionMiddleware.default_middlewares\n        if middleware != SwaggerUIMiddleware\n    ]\n    app = build_app_from_fixture(\n        \"simple\", app_class=app_class, spec_file=spec, middlewares=middlewares\n    )\n\n    with pytest.raises(ValueError) as exc_info:\n        app.add_middleware(TestMiddleware, position=MiddlewarePosition.BEFORE_SWAGGER)\n\n    assert (\n        exc_info.value.args[0]\n        == f\"Could not insert middleware at position BEFORE_SWAGGER. \"\n        f\"Please make sure you have a {SwaggerUIMiddleware} in your stack.\"\n    )",
      "docstring": "Test adding middleware via the `add_middleware` method.",
      "decorators": [],
      "arguments": [
        "spec",
        "app_class"
      ],
      "imports": [
        "typing",
        "unittest.mock.Mock",
        "pytest",
        "connexion.FlaskApp",
        "connexion.middleware.ConnexionMiddleware",
        "connexion.middleware.MiddlewarePosition",
        "connexion.middleware.swagger_ui.SwaggerUIMiddleware",
        "connexion.types.Environ",
        "connexion.types.ResponseStream",
        "connexion.types.StartResponse",
        "connexion.types.WSGIApp",
        "starlette.datastructures.MutableHeaders",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert exc_info.value.args[0] == f'Could not insert middleware at position BEFORE_SWAGGER. Please make sure you have a {SwaggerUIMiddleware} in your stack.'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "build_app_from_fixture",
          "body": "def build_app_from_fixture(api_spec_folder, *, app_class, spec_file, middlewares=None, **kwargs):\n    cnx_app = app_class(__name__, specification_dir=FIXTURES_FOLDER / api_spec_folder, middlewares=middlewares)\n    cnx_app.add_api(spec_file, **kwargs)\n    cnx_app._spec_file = spec_file\n    return cnx_app"
        }
      ]
    },
    {
      "name": "test_add_wsgi_middleware",
      "module": "test_middleware",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_middleware.py",
      "line_number": 91,
      "end_line_number": 111,
      "source_code": "def test_add_wsgi_middleware(spec):\n    app: FlaskApp = build_app_from_fixture(\"simple\", app_class=FlaskApp, spec_file=spec)\n\n    class WSGIMiddleware:\n        def __init__(self, app_: WSGIApp, mock_counter):\n            self.next_app = app_\n            self.mock_counter = mock_counter\n\n        def __call__(\n            self, environ: Environ, start_response: StartResponse\n        ) -> ResponseStream:\n            self.mock_counter()\n            return self.next_app(environ, start_response)\n\n    mock = Mock()\n    app.add_wsgi_middleware(WSGIMiddleware, mock_counter=mock)\n\n    app_client = app.test_client()\n    app_client.post(\"/v1.0/greeting/robbe\")\n\n    mock.assert_called_once()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "spec"
      ],
      "imports": [
        "typing",
        "unittest.mock.Mock",
        "pytest",
        "connexion.FlaskApp",
        "connexion.middleware.ConnexionMiddleware",
        "connexion.middleware.MiddlewarePosition",
        "connexion.middleware.swagger_ui.SwaggerUIMiddleware",
        "connexion.types.Environ",
        "connexion.types.ResponseStream",
        "connexion.types.StartResponse",
        "connexion.types.WSGIApp",
        "starlette.datastructures.MutableHeaders",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "build_app_from_fixture",
          "body": "def build_app_from_fixture(api_spec_folder, *, app_class, spec_file, middlewares=None, **kwargs):\n    cnx_app = app_class(__name__, specification_dir=FIXTURES_FOLDER / api_spec_folder, middlewares=middlewares)\n    cnx_app.add_api(spec_file, **kwargs)\n    cnx_app._spec_file = spec_file\n    return cnx_app"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        }
      ]
    },
    {
      "name": "test_validator_map",
      "module": "test_json_validation",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_json_validation.py",
      "line_number": 14,
      "end_line_number": 51,
      "source_code": "def test_validator_map(json_validation_spec_dir, spec):\n    def validate_type(validator, types, instance, schema):\n        types = _utils.ensure_list(types)\n        errors = Draft4RequestValidator.VALIDATORS[\"type\"](\n            validator, types, instance, schema\n        )\n        yield from errors\n\n        if \"string\" in types and \"minLength\" not in schema:\n            errors = Draft4RequestValidator.VALIDATORS[\"minLength\"](\n                validator, 1, instance, schema\n            )\n            yield from errors\n\n    MinLengthRequestValidator = extend(Draft4RequestValidator, {\"type\": validate_type})\n\n    class MyJSONBodyValidator(JSONRequestBodyValidator):\n        @property\n        def _validator(self):\n            return MinLengthRequestValidator(self._schema)\n\n    validator_map = {\"body\": {\"application/json\": MyJSONBodyValidator}}\n\n    app = App(__name__, specification_dir=json_validation_spec_dir)\n    app.add_api(spec, validate_responses=True, validator_map=validator_map)\n    app_client = app.test_client()\n\n    res = app_client.post(\n        \"/v1.0/minlength\",\n        json={\"foo\": \"bar\"},\n    )\n    assert res.status_code == 200\n\n    res = app_client.post(\n        \"/v1.0/minlength\",\n        json={\"foo\": \"\"},\n    )\n    assert res.status_code == 400",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_validation_spec_dir",
        "spec"
      ],
      "imports": [
        "json",
        "pathlib",
        "pytest",
        "connexion.App",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.spec.Specification",
        "connexion.validators.JSONRequestBodyValidator",
        "jsonschema.validators._utils",
        "jsonschema.validators.extend",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert res.status_code == 200",
        "assert res.status_code == 400"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        }
      ]
    },
    {
      "name": "test_readonly",
      "module": "test_json_validation",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_json_validation.py",
      "line_number": 54,
      "end_line_number": 78,
      "source_code": "def test_readonly(json_validation_spec_dir, spec, app_class):\n    app = build_app_from_fixture(\n        json_validation_spec_dir,\n        app_class=app_class,\n        spec_file=spec,\n        validate_responses=True,\n    )\n    app_client = app.test_client()\n\n    res = app_client.get(\"/v1.0/user\")\n    assert res.status_code == 200\n    assert res.json().get(\"user_id\") == 7\n\n    res = app_client.post(\n        \"/v1.0/user\",\n        json={\"name\": \"max\", \"password\": \"1234\"},\n    )\n    assert res.status_code == 200\n    assert res.json().get(\"user_id\") == 8\n\n    res = app_client.post(\n        \"/v1.0/user\",\n        json={\"user_id\": 9, \"name\": \"max\"},\n    )\n    assert res.status_code == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_validation_spec_dir",
        "spec",
        "app_class"
      ],
      "imports": [
        "json",
        "pathlib",
        "pytest",
        "connexion.App",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.spec.Specification",
        "connexion.validators.JSONRequestBodyValidator",
        "jsonschema.validators._utils",
        "jsonschema.validators.extend",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert res.status_code == 200",
        "assert res.json().get('user_id') == 7",
        "assert res.status_code == 200",
        "assert res.json().get('user_id') == 8",
        "assert res.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "build_app_from_fixture",
          "body": "def build_app_from_fixture(api_spec_folder, *, app_class, spec_file, middlewares=None, **kwargs):\n    cnx_app = app_class(__name__, specification_dir=FIXTURES_FOLDER / api_spec_folder, middlewares=middlewares)\n    cnx_app.add_api(spec_file, **kwargs)\n    cnx_app._spec_file = spec_file\n    return cnx_app"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "res.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "res.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_writeonly",
      "module": "test_json_validation",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_json_validation.py",
      "line_number": 81,
      "end_line_number": 105,
      "source_code": "def test_writeonly(json_validation_spec_dir, spec, app_class):\n    app = build_app_from_fixture(\n        json_validation_spec_dir,\n        app_class=app_class,\n        spec_file=spec,\n        validate_responses=True,\n    )\n    app_client = app.test_client()\n\n    res = app_client.post(\n        \"/v1.0/user\",\n        json={\"name\": \"max\", \"password\": \"1234\"},\n    )\n    assert res.status_code == 200\n    assert \"password\" not in res.json()\n\n    res = app_client.get(\"/v1.0/user\")\n    assert res.status_code == 200\n    assert \"password\" not in res.json()\n\n    res = app_client.get(\"/v1.0/user_with_password\")\n    assert res.status_code == 500\n    assert res.json()[\"detail\"].startswith(\n        \"Response body does not conform to specification\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_validation_spec_dir",
        "spec",
        "app_class"
      ],
      "imports": [
        "json",
        "pathlib",
        "pytest",
        "connexion.App",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.spec.Specification",
        "connexion.validators.JSONRequestBodyValidator",
        "jsonschema.validators._utils",
        "jsonschema.validators.extend",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert res.status_code == 200",
        "assert 'password' not in res.json()",
        "assert res.status_code == 200",
        "assert 'password' not in res.json()",
        "assert res.status_code == 500",
        "assert res.json()['detail'].startswith('Response body does not conform to specification')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "build_app_from_fixture",
          "body": "def build_app_from_fixture(api_spec_folder, *, app_class, spec_file, middlewares=None, **kwargs):\n    cnx_app = app_class(__name__, specification_dir=FIXTURES_FOLDER / api_spec_folder, middlewares=middlewares)\n    cnx_app.add_api(spec_file, **kwargs)\n    cnx_app._spec_file = spec_file\n    return cnx_app"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "res.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "res.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "res.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_nullable_default",
      "module": "test_json_validation",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_json_validation.py",
      "line_number": 108,
      "end_line_number": 110,
      "source_code": "def test_nullable_default(json_validation_spec_dir, spec):\n    spec_path = pathlib.Path(json_validation_spec_dir) / spec\n    Specification.load(spec_path)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_validation_spec_dir",
        "spec"
      ],
      "imports": [
        "json",
        "pathlib",
        "pytest",
        "connexion.App",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.spec.Specification",
        "connexion.validators.JSONRequestBodyValidator",
        "jsonschema.validators._utils",
        "jsonschema.validators.extend",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_multipart_form_json",
      "module": "test_json_validation",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_json_validation.py",
      "line_number": 114,
      "end_line_number": 130,
      "source_code": "def test_multipart_form_json(json_validation_spec_dir, spec, app_class):\n    app = build_app_from_fixture(\n        json_validation_spec_dir,\n        app_class=app_class,\n        spec_file=spec,\n        validate_responses=True,\n    )\n    app_client = app.test_client()\n\n    res = app_client.post(\n        \"/v1.0/multipart_form_json\",\n        files={\"file\": b\"\"},  # Force multipart/form-data content-type\n        data={\"x\": json.dumps({\"name\": \"joe\", \"age\": 20})},\n    )\n    assert res.status_code == 200\n    assert res.json()[\"name\"] == \"joe-reply\"\n    assert res.json()[\"age\"] == 30",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('spec', ['openapi.yaml'])"
      ],
      "arguments": [
        "json_validation_spec_dir",
        "spec",
        "app_class"
      ],
      "imports": [
        "json",
        "pathlib",
        "pytest",
        "connexion.App",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.spec.Specification",
        "connexion.validators.JSONRequestBodyValidator",
        "jsonschema.validators._utils",
        "jsonschema.validators.extend",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert res.status_code == 200",
        "assert res.json()['name'] == 'joe-reply'",
        "assert res.json()['age'] == 30"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "build_app_from_fixture",
          "body": "def build_app_from_fixture(api_spec_folder, *, app_class, spec_file, middlewares=None, **kwargs):\n    cnx_app = app_class(__name__, specification_dir=FIXTURES_FOLDER / api_spec_folder, middlewares=middlewares)\n    cnx_app.add_api(spec_file, **kwargs)\n    cnx_app._spec_file = spec_file\n    return cnx_app"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "res.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "res.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_multipart_form_json_array",
      "module": "test_json_validation",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_json_validation.py",
      "line_number": 134,
      "end_line_number": 154,
      "source_code": "def test_multipart_form_json_array(json_validation_spec_dir, spec, app_class):\n    app = build_app_from_fixture(\n        json_validation_spec_dir,\n        app_class=app_class,\n        spec_file=spec,\n        validate_responses=True,\n    )\n    app_client = app.test_client()\n\n    res = app_client.post(\n        \"/v1.0/multipart_form_json_array\",\n        files={\"file\": b\"\"},  # Force multipart/form-data content-type\n        data={\n            \"x\": json.dumps([{\"name\": \"joe\", \"age\": 20}, {\"name\": \"alena\", \"age\": 28}])\n        },\n    )\n    assert res.status_code == 200\n    assert res.json()[0][\"name\"] == \"joe-reply\"\n    assert res.json()[0][\"age\"] == 30\n    assert res.json()[1][\"name\"] == \"alena-reply\"\n    assert res.json()[1][\"age\"] == 38",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('spec', ['openapi.yaml'])"
      ],
      "arguments": [
        "json_validation_spec_dir",
        "spec",
        "app_class"
      ],
      "imports": [
        "json",
        "pathlib",
        "pytest",
        "connexion.App",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.spec.Specification",
        "connexion.validators.JSONRequestBodyValidator",
        "jsonschema.validators._utils",
        "jsonschema.validators.extend",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert res.status_code == 200",
        "assert res.json()[0]['name'] == 'joe-reply'",
        "assert res.json()[0]['age'] == 30",
        "assert res.json()[1]['name'] == 'alena-reply'",
        "assert res.json()[1]['age'] == 38"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "build_app_from_fixture",
          "body": "def build_app_from_fixture(api_spec_folder, *, app_class, spec_file, middlewares=None, **kwargs):\n    cnx_app = app_class(__name__, specification_dir=FIXTURES_FOLDER / api_spec_folder, middlewares=middlewares)\n    cnx_app.add_api(spec_file, **kwargs)\n    cnx_app._spec_file = spec_file\n    return cnx_app"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "res.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "res.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "res.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "res.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_mock_resolver_default",
      "module": "test_mock3",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_mock3.py",
      "line_number": 5,
      "end_line_number": 29,
      "source_code": "def test_mock_resolver_default():\n    resolver = MockResolver(mock_all=True)\n\n    responses = {\n        \"default\": {\n            \"content\": {\n                \"application/json\": {\n                    \"examples\": {\"super_cool_example\": {\"value\": {\"foo\": \"bar\"}}}\n                }\n            }\n        }\n    }\n\n    operation = OpenAPIOperation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation={\"responses\": responses},\n        resolver=resolver,\n    )\n    assert operation.operation_id == \"mock-1\"\n\n    response, status_code = resolver.mock_operation(operation)\n    assert status_code == 200\n    assert response == {\"foo\": \"bar\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.mock.MockResolver",
        "connexion.operations.OpenAPIOperation"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'mock-1'",
        "assert status_code == 200",
        "assert response == {'foo': 'bar'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_mock_resolver_numeric",
      "module": "test_mock3",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_mock3.py",
      "line_number": 32,
      "end_line_number": 56,
      "source_code": "def test_mock_resolver_numeric():\n    resolver = MockResolver(mock_all=True)\n\n    responses = {\n        \"200\": {\n            \"content\": {\n                \"application/json\": {\n                    \"examples\": {\"super_cool_example\": {\"value\": {\"foo\": \"bar\"}}}\n                }\n            }\n        }\n    }\n\n    operation = OpenAPIOperation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation={\"responses\": responses},\n        resolver=resolver,\n    )\n    assert operation.operation_id == \"mock-1\"\n\n    response, status_code = resolver.mock_operation(operation)\n    assert status_code == 200\n    assert response == {\"foo\": \"bar\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.mock.MockResolver",
        "connexion.operations.OpenAPIOperation"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'mock-1'",
        "assert status_code == 200",
        "assert response == {'foo': 'bar'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_mock_resolver_inline_schema_example",
      "module": "test_mock3",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_mock3.py",
      "line_number": 59,
      "end_line_number": 87,
      "source_code": "def test_mock_resolver_inline_schema_example():\n    resolver = MockResolver(mock_all=True)\n\n    responses = {\n        \"default\": {\n            \"content\": {\n                \"application/json\": {\n                    \"schema\": {\n                        \"type\": \"object\",\n                        \"properties\": {\"foo\": {\"schema\": {\"type\": \"string\"}}},\n                    },\n                    \"example\": {\"foo\": \"bar\"},\n                }\n            }\n        }\n    }\n\n    operation = OpenAPIOperation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation={\"responses\": responses},\n        resolver=resolver,\n    )\n    assert operation.operation_id == \"mock-1\"\n\n    response, status_code = resolver.mock_operation(operation)\n    assert status_code == 200\n    assert response == {\"foo\": \"bar\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.mock.MockResolver",
        "connexion.operations.OpenAPIOperation"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'mock-1'",
        "assert status_code == 200",
        "assert response == {'foo': 'bar'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_mock_resolver_no_examples",
      "module": "test_mock3",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_mock3.py",
      "line_number": 90,
      "end_line_number": 106,
      "source_code": "def test_mock_resolver_no_examples():\n    resolver = MockResolver(mock_all=True)\n\n    responses = {\"418\": {}}\n\n    operation = OpenAPIOperation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation={\"responses\": responses},\n        resolver=resolver,\n    )\n    assert operation.operation_id == \"mock-1\"\n\n    response, status_code = resolver.mock_operation(operation)\n    assert status_code == 418\n    assert response == \"No example response or response schema defined.\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.mock.MockResolver",
        "connexion.operations.OpenAPIOperation"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'mock-1'",
        "assert status_code == 418",
        "assert response == 'No example response or response schema defined.'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_mock_resolver_notimplemented",
      "module": "test_mock3",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_mock3.py",
      "line_number": 109,
      "end_line_number": 139,
      "source_code": "def test_mock_resolver_notimplemented():\n    resolver = MockResolver(mock_all=False)\n\n    responses = {\"418\": {}}\n\n    # do not mock the existent functions\n    operation = OpenAPIOperation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation={\"operationId\": \"fakeapi.hello.get\"},\n        resolver=resolver,\n    )\n    assert operation.operation_id == \"fakeapi.hello.get\"\n\n    # mock only the nonexistent ones\n    operation = OpenAPIOperation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation={\n            \"operationId\": \"fakeapi.hello.nonexistent_function\",\n            \"responses\": responses,\n        },\n        resolver=resolver,\n    )\n    # check if it is using the mock function\n    assert operation._resolution.function() == (\n        \"No example response or response schema defined.\",\n        418,\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.mock.MockResolver",
        "connexion.operations.OpenAPIOperation"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.hello.get'",
        "assert operation._resolution.function() == ('No example response or response schema defined.', 418)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_parameter_validator",
      "module": "test_validation",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_validation.py",
      "line_number": 12,
      "end_line_number": 136,
      "source_code": "def test_parameter_validator(monkeypatch):\n    params = [\n        {\"name\": \"p1\", \"in\": \"path\", \"type\": \"integer\", \"required\": True},\n        {\"name\": \"h1\", \"in\": \"header\", \"type\": \"string\", \"enum\": [\"a\", \"b\"]},\n        {\"name\": \"c1\", \"in\": \"cookie\", \"type\": \"string\", \"enum\": [\"a\", \"b\"]},\n        {\"name\": \"q1\", \"in\": \"query\", \"type\": \"integer\", \"maximum\": 3},\n        {\n            \"name\": \"a1\",\n            \"in\": \"query\",\n            \"type\": \"array\",\n            \"minItems\": 2,\n            \"maxItems\": 3,\n            \"items\": {\"type\": \"integer\", \"minimum\": 0},\n        },\n    ]\n\n    uri_parser = Swagger2URIParser(params, {})\n    validator = ParameterValidator(params, uri_parser=uri_parser)\n\n    kwargs = {\"query_params\": {}, \"headers\": {}, \"cookies\": {}}\n    request = MagicMock(path_params={}, **kwargs)\n    with pytest.raises(BadRequestProblem) as exc:\n        validator.validate_request(request)\n        assert exc.value.detail == \"Missing path parameter 'p1'\"\n\n    request = MagicMock(path_params={\"p1\": \"123\"}, **kwargs)\n    with pytest.raises(BadRequestProblem) as exc:\n        validator.validate_request(request)\n        assert exc.value.detail.startswith(\"'123' is not of type 'integer'\")\n\n    request = MagicMock(path_params={\"p1\": \"\"}, **kwargs)\n    with pytest.raises(BadRequestProblem) as exc:\n        validator.validate_request(request)\n        assert exc.value.detail.startswith(\"'' is not of type 'integer'\")\n\n    request = MagicMock(path_params={\"p1\": \"foo\"}, **kwargs)\n    with pytest.raises(BadRequestProblem) as exc:\n        validator.validate_request(request)\n        assert exc.value.detail.startswith(\"'foo' is not of type 'integer'\")\n\n    request = MagicMock(path_params={\"p1\": \"1.2\"}, **kwargs)\n    with pytest.raises(BadRequestProblem) as exc:\n        validator.validate_request(request)\n        assert exc.value.detail.startswith(\"'1.2' is not of type 'integer'\")\n\n    request = MagicMock(\n        path_params={\"p1\": 1}, query_params={\"q1\": 4}, headers={}, cookies={}\n    )\n    with pytest.raises(BadRequestProblem) as exc:\n        validator.validate_request(request)\n        assert exc.value.detail.startswith(\"4 is greater than the maximum of 3\")\n\n    request = MagicMock(\n        path_params={\"p1\": 1}, query_params={\"q1\": 3}, headers={}, cookies={}\n    )\n    try:\n        validator.validate_request(request)\n    except Exception as e:\n        pytest.fail(str(e))\n\n    request = MagicMock(\n        path_params={\"p1\": 1}, query_params={\"a1\": [1, 2]}, headers={}, cookies={}\n    )\n    try:\n        validator.validate_request(request)\n    except Exception as e:\n        pytest.fail(str(e))\n\n    request = MagicMock(\n        path_params={\"p1\": 1}, query_params={\"a1\": [1, \"a\"]}, headers={}, cookies={}\n    )\n    with pytest.raises(BadRequestProblem) as exc:\n        validator.validate_request(request)\n        assert exc.value.detail.startswith(\"'a' is not of type 'integer'\")\n\n    request = MagicMock(\n        path_params={\"p1\": 123}, query_params={}, headers={}, cookies={\"c1\": \"b\"}\n    )\n    try:\n        validator.validate_request(request)\n    except Exception as e:\n        pytest.fail(str(e))\n\n    request = MagicMock(\n        path_params={\"p1\": 123}, query={}, headers={}, cookies={\"c1\": \"x\"}\n    )\n    with pytest.raises(BadRequestProblem) as exc:\n        assert validator.validate_request(request)\n        assert exc.value.detail.startswith(\"'x' is not one of ['a', 'b']\")\n\n    request = MagicMock(\n        path_params={\"p1\": 1}, query_params={\"a1\": [1, -1]}, headers={}, cookies={}\n    )\n    with pytest.raises(BadRequestProblem) as exc:\n        validator.validate_request(request)\n        assert exc.value.detail.startswith(\"-1 is less than the minimum of 0\")\n\n    request = MagicMock(\n        path_params={\"p1\": 1}, query_params={\"a1\": 1}, headers={}, cookies={}\n    )\n    with pytest.raises(BadRequestProblem) as exc:\n        validator.validate_request(request)\n        assert exc.value.detail.startswith(\"[1] is too short\")\n\n    request = MagicMock(\n        path_params={\"p1\": 1}, query_params={\"a1\": [1, 2, 3, 4]}, headers={}, cookies={}\n    )\n    with pytest.raises(BadRequestProblem) as exc:\n        validator.validate_request(request)\n        assert exc.value.detail.startswith(\"[1, 2, 3, 4] is too long\")\n\n    request = MagicMock(\n        path_params={\"p1\": 123}, query_params={}, headers={\"h1\": \"a\"}, cookies={}\n    )\n    try:\n        validator.validate_request(request)\n    except Exception as e:\n        pytest.fail(str(e))\n\n    request = MagicMock(\n        path_params={\"p1\": 123}, query_params={}, headers={\"h1\": \"x\"}, cookies={}\n    )\n    with pytest.raises(BadRequestProblem) as exc:\n        validator.validate_request(request)\n        assert exc.value.detail.startswith(\"'x' is not one of ['a', 'b']\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "unittest.mock.MagicMock",
        "urllib.parse.quote_plus",
        "pytest",
        "connexion.exceptions.BadRequestProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.uri_parsing.Swagger2URIParser",
        "connexion.validators.AbstractRequestBodyValidator",
        "connexion.validators.ParameterValidator",
        "starlette.datastructures.QueryParams"
      ],
      "fixtures": [],
      "assertions": [
        "assert exc.value.detail == \"Missing path parameter 'p1'\"",
        "assert exc.value.detail.startswith(\"'123' is not of type 'integer'\")",
        "assert exc.value.detail.startswith(\"'' is not of type 'integer'\")",
        "assert exc.value.detail.startswith(\"'foo' is not of type 'integer'\")",
        "assert exc.value.detail.startswith(\"'1.2' is not of type 'integer'\")",
        "assert exc.value.detail.startswith('4 is greater than the maximum of 3')",
        "assert exc.value.detail.startswith(\"'a' is not of type 'integer'\")",
        "assert validator.validate_request(request)",
        "assert exc.value.detail.startswith(\"'x' is not one of ['a', 'b']\")",
        "assert exc.value.detail.startswith('-1 is less than the minimum of 0')",
        "assert exc.value.detail.startswith('[1] is too short')",
        "assert exc.value.detail.startswith('[1, 2, 3, 4] is too long')",
        "assert exc.value.detail.startswith(\"'x' is not one of ['a', 'b']\")"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_standard_resolve_x_router_controller",
      "module": "test_resolver_methodview",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver_methodview.py",
      "line_number": 10,
      "end_line_number": 22,
      "source_code": "def test_standard_resolve_x_router_controller():\n    operation = OpenAPIOperation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation={\n            \"x-openapi-router-controller\": \"fakeapi.hello\",\n            \"operationId\": \"post_greeting\",\n        },\n        components=COMPONENTS,\n        resolver=Resolver(),\n    )\n    assert operation.operation_id == \"fakeapi.hello.post_greeting\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.FlaskApp",
        "connexion.operations.OpenAPIOperation",
        "connexion.resolver.MethodResolver",
        "connexion.resolver.MethodViewResolver",
        "connexion.resolver.Resolver",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.hello.post_greeting'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_methodview_resolve_operation_id",
      "module": "test_resolver_methodview",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver_methodview.py",
      "line_number": 25,
      "end_line_number": 36,
      "source_code": "def test_methodview_resolve_operation_id(method_view_resolver):\n    operation = OpenAPIOperation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation={\n            \"operationId\": \"fakeapi.hello.post_greeting\",\n        },\n        components=COMPONENTS,\n        resolver=method_view_resolver(\"fakeapi\"),\n    )\n    assert operation.operation_id == \"fakeapi.hello.post_greeting\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "method_view_resolver"
      ],
      "imports": [
        "connexion.FlaskApp",
        "connexion.operations.OpenAPIOperation",
        "connexion.resolver.MethodResolver",
        "connexion.resolver.MethodViewResolver",
        "connexion.resolver.Resolver",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.hello.post_greeting'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "method_view_resolver",
          "body": "@pytest.fixture(scope='session', params=METHOD_VIEW_RESOLVERS)\ndef method_view_resolver(request):\n    return request.param"
        }
      ]
    },
    {
      "name": "test_methodview_resolve_x_router_controller_with_operation_id",
      "module": "test_resolver_methodview",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver_methodview.py",
      "line_number": 39,
      "end_line_number": 51,
      "source_code": "def test_methodview_resolve_x_router_controller_with_operation_id(method_view_resolver):\n    operation = OpenAPIOperation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation={\n            \"x-openapi-router-controller\": \"fakeapi.PetsView\",\n            \"operationId\": \"post_greeting\",\n        },\n        components=COMPONENTS,\n        resolver=method_view_resolver(\"fakeapi\"),\n    )\n    assert operation.operation_id == \"fakeapi.PetsView.post_greeting\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "method_view_resolver"
      ],
      "imports": [
        "connexion.FlaskApp",
        "connexion.operations.OpenAPIOperation",
        "connexion.resolver.MethodResolver",
        "connexion.resolver.MethodViewResolver",
        "connexion.resolver.Resolver",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.PetsView.post_greeting'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "method_view_resolver",
          "body": "@pytest.fixture(scope='session', params=METHOD_VIEW_RESOLVERS)\ndef method_view_resolver(request):\n    return request.param"
        }
      ]
    },
    {
      "name": "test_methodview_resolve_x_router_controller_without_operation_id",
      "module": "test_resolver_methodview",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver_methodview.py",
      "line_number": 54,
      "end_line_number": 65,
      "source_code": "def test_methodview_resolve_x_router_controller_without_operation_id(\n    method_view_resolver,\n):\n    operation = OpenAPIOperation(\n        method=\"GET\",\n        path=\"/hello/{id}\",\n        path_parameters=[],\n        operation={\"x-openapi-router-controller\": \"fakeapi.pets\"},\n        components=COMPONENTS,\n        resolver=method_view_resolver(\"fakeapi\"),\n    )\n    assert operation.operation_id == \"fakeapi.PetsView.get\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "method_view_resolver"
      ],
      "imports": [
        "connexion.FlaskApp",
        "connexion.operations.OpenAPIOperation",
        "connexion.resolver.MethodResolver",
        "connexion.resolver.MethodViewResolver",
        "connexion.resolver.Resolver",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.PetsView.get'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "method_view_resolver",
          "body": "@pytest.fixture(scope='session', params=METHOD_VIEW_RESOLVERS)\ndef method_view_resolver(request):\n    return request.param"
        }
      ]
    },
    {
      "name": "test_methodview_resolve_with_default_module_name",
      "module": "test_resolver_methodview",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver_methodview.py",
      "line_number": 68,
      "end_line_number": 77,
      "source_code": "def test_methodview_resolve_with_default_module_name(method_view_resolver):\n    operation = OpenAPIOperation(\n        method=\"GET\",\n        path=\"/pets/{id}\",\n        path_parameters=[],\n        operation={},\n        components=COMPONENTS,\n        resolver=method_view_resolver(\"fakeapi\"),\n    )\n    assert operation.operation_id == \"fakeapi.PetsView.get\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "method_view_resolver"
      ],
      "imports": [
        "connexion.FlaskApp",
        "connexion.operations.OpenAPIOperation",
        "connexion.resolver.MethodResolver",
        "connexion.resolver.MethodViewResolver",
        "connexion.resolver.Resolver",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.PetsView.get'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "method_view_resolver",
          "body": "@pytest.fixture(scope='session', params=METHOD_VIEW_RESOLVERS)\ndef method_view_resolver(request):\n    return request.param"
        }
      ]
    },
    {
      "name": "test_methodview_resolve_with_default_module_name_lowercase_verb",
      "module": "test_resolver_methodview",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver_methodview.py",
      "line_number": 80,
      "end_line_number": 91,
      "source_code": "def test_methodview_resolve_with_default_module_name_lowercase_verb(\n    method_view_resolver,\n):\n    operation = OpenAPIOperation(\n        method=\"get\",\n        path=\"/pets/{id}\",\n        path_parameters=[],\n        operation={},\n        components=COMPONENTS,\n        resolver=method_view_resolver(\"fakeapi\"),\n    )\n    assert operation.operation_id == \"fakeapi.PetsView.get\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "method_view_resolver"
      ],
      "imports": [
        "connexion.FlaskApp",
        "connexion.operations.OpenAPIOperation",
        "connexion.resolver.MethodResolver",
        "connexion.resolver.MethodViewResolver",
        "connexion.resolver.Resolver",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.PetsView.get'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "method_view_resolver",
          "body": "@pytest.fixture(scope='session', params=METHOD_VIEW_RESOLVERS)\ndef method_view_resolver(request):\n    return request.param"
        }
      ]
    },
    {
      "name": "test_methodview_resolve_with_default_module_name_will_translate_dashes_in_resource_name",
      "module": "test_resolver_methodview",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver_methodview.py",
      "line_number": 94,
      "end_line_number": 105,
      "source_code": "def test_methodview_resolve_with_default_module_name_will_translate_dashes_in_resource_name(\n    method_view_resolver,\n):\n    operation = OpenAPIOperation(\n        method=\"GET\",\n        path=\"/pets\",\n        path_parameters=[],\n        operation={},\n        components=COMPONENTS,\n        resolver=method_view_resolver(\"fakeapi\"),\n    )\n    assert operation.operation_id == \"fakeapi.PetsView.search\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "method_view_resolver"
      ],
      "imports": [
        "connexion.FlaskApp",
        "connexion.operations.OpenAPIOperation",
        "connexion.resolver.MethodResolver",
        "connexion.resolver.MethodViewResolver",
        "connexion.resolver.Resolver",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.PetsView.search'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "method_view_resolver",
          "body": "@pytest.fixture(scope='session', params=METHOD_VIEW_RESOLVERS)\ndef method_view_resolver(request):\n    return request.param"
        }
      ]
    },
    {
      "name": "test_methodview_resolve_with_default_module_name_can_resolve_api_root",
      "module": "test_resolver_methodview",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver_methodview.py",
      "line_number": 108,
      "end_line_number": 121,
      "source_code": "def test_methodview_resolve_with_default_module_name_can_resolve_api_root(\n    method_view_resolver,\n):\n    operation = OpenAPIOperation(\n        method=\"GET\",\n        path=\"/\",\n        path_parameters=[],\n        operation={},\n        components=COMPONENTS,\n        resolver=method_view_resolver(\n            \"fakeapi.pets\",\n        ),\n    )\n    assert operation.operation_id == \"fakeapi.PetsView.get\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "method_view_resolver"
      ],
      "imports": [
        "connexion.FlaskApp",
        "connexion.operations.OpenAPIOperation",
        "connexion.resolver.MethodResolver",
        "connexion.resolver.MethodViewResolver",
        "connexion.resolver.Resolver",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.PetsView.get'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "method_view_resolver",
          "body": "@pytest.fixture(scope='session', params=METHOD_VIEW_RESOLVERS)\ndef method_view_resolver(request):\n    return request.param"
        }
      ]
    },
    {
      "name": "test_methodview_resolve_with_default_module_name_will_resolve_resource_root_get_as_search",
      "module": "test_resolver_methodview",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver_methodview.py",
      "line_number": 124,
      "end_line_number": 135,
      "source_code": "def test_methodview_resolve_with_default_module_name_will_resolve_resource_root_get_as_search(\n    method_view_resolver,\n):\n    operation = OpenAPIOperation(\n        method=\"GET\",\n        path=\"/pets\",\n        path_parameters=[],\n        operation={},\n        components=COMPONENTS,\n        resolver=method_view_resolver(\"fakeapi\"),\n    )\n    assert operation.operation_id == \"fakeapi.PetsView.search\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "method_view_resolver"
      ],
      "imports": [
        "connexion.FlaskApp",
        "connexion.operations.OpenAPIOperation",
        "connexion.resolver.MethodResolver",
        "connexion.resolver.MethodViewResolver",
        "connexion.resolver.Resolver",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.PetsView.search'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "method_view_resolver",
          "body": "@pytest.fixture(scope='session', params=METHOD_VIEW_RESOLVERS)\ndef method_view_resolver(request):\n    return request.param"
        }
      ]
    },
    {
      "name": "test_methodview_resolve_with_default_module_name_and_x_router_controller_will_resolve_resource_root_get_as_search",
      "module": "test_resolver_methodview",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver_methodview.py",
      "line_number": 138,
      "end_line_number": 151,
      "source_code": "def test_methodview_resolve_with_default_module_name_and_x_router_controller_will_resolve_resource_root_get_as_search(\n    method_view_resolver,\n):\n    operation = OpenAPIOperation(\n        method=\"GET\",\n        path=\"/hello\",\n        path_parameters=[],\n        operation={\n            \"x-openapi-router-controller\": \"fakeapi.pets\",\n        },\n        components=COMPONENTS,\n        resolver=method_view_resolver(\"fakeapi\"),\n    )\n    assert operation.operation_id == \"fakeapi.PetsView.search\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "method_view_resolver"
      ],
      "imports": [
        "connexion.FlaskApp",
        "connexion.operations.OpenAPIOperation",
        "connexion.resolver.MethodResolver",
        "connexion.resolver.MethodViewResolver",
        "connexion.resolver.Resolver",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.PetsView.search'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "method_view_resolver",
          "body": "@pytest.fixture(scope='session', params=METHOD_VIEW_RESOLVERS)\ndef method_view_resolver(request):\n    return request.param"
        }
      ]
    },
    {
      "name": "test_method_resolve_with_default_module_name_will_resolve_resource_root_as_configured",
      "module": "test_resolver_methodview",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver_methodview.py",
      "line_number": 154,
      "end_line_number": 163,
      "source_code": "def test_method_resolve_with_default_module_name_will_resolve_resource_root_as_configured():\n    operation = OpenAPIOperation(\n        method=\"GET\",\n        path=\"/pets\",\n        path_parameters=[],\n        operation={},\n        components=COMPONENTS,\n        resolver=MethodResolver(\"fakeapi\", collection_endpoint_name=\"api_list\"),\n    )\n    assert operation.operation_id == \"fakeapi.PetsView.api_list\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.FlaskApp",
        "connexion.operations.OpenAPIOperation",
        "connexion.resolver.MethodResolver",
        "connexion.resolver.MethodViewResolver",
        "connexion.resolver.Resolver",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.PetsView.api_list'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_methodview_resolve_with_default_module_name_will_resolve_resource_root_as_configured",
      "module": "test_resolver_methodview",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver_methodview.py",
      "line_number": 166,
      "end_line_number": 176,
      "source_code": "def test_methodview_resolve_with_default_module_name_will_resolve_resource_root_as_configured():\n    operation = OpenAPIOperation(\n        method=\"GET\",\n        path=\"/pets\",\n        path_parameters=[],\n        operation={},\n        components=COMPONENTS,\n        resolver=MethodViewResolver(\"fakeapi\", collection_endpoint_name=\"api_list\"),\n    )\n    # The collection_endpoint_name is ignored\n    assert operation.operation_id == \"fakeapi.PetsView.search\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.FlaskApp",
        "connexion.operations.OpenAPIOperation",
        "connexion.resolver.MethodResolver",
        "connexion.resolver.MethodViewResolver",
        "connexion.resolver.Resolver",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.PetsView.search'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_methodview_resolve_with_default_module_name_will_resolve_resource_root_post_as_post",
      "module": "test_resolver_methodview",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver_methodview.py",
      "line_number": 179,
      "end_line_number": 190,
      "source_code": "def test_methodview_resolve_with_default_module_name_will_resolve_resource_root_post_as_post(\n    method_view_resolver,\n):\n    operation = OpenAPIOperation(\n        method=\"POST\",\n        path=\"/pets\",\n        path_parameters=[],\n        operation={},\n        components=COMPONENTS,\n        resolver=method_view_resolver(\"fakeapi\"),\n    )\n    assert operation.operation_id == \"fakeapi.PetsView.post\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "method_view_resolver"
      ],
      "imports": [
        "connexion.FlaskApp",
        "connexion.operations.OpenAPIOperation",
        "connexion.resolver.MethodResolver",
        "connexion.resolver.MethodViewResolver",
        "connexion.resolver.Resolver",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.PetsView.post'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "method_view_resolver",
          "body": "@pytest.fixture(scope='session', params=METHOD_VIEW_RESOLVERS)\ndef method_view_resolver(request):\n    return request.param"
        }
      ]
    },
    {
      "name": "test_method_view_resolver_integration",
      "module": "test_resolver_methodview",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver_methodview.py",
      "line_number": 193,
      "end_line_number": 213,
      "source_code": "def test_method_view_resolver_integration(spec):\n    method_view_app = build_app_from_fixture(\n        \"method_view\",\n        app_class=FlaskApp,\n        spec_file=spec,\n        resolver=MethodViewResolver(\"fakeapi.example_method_view\"),\n    )\n\n    client = method_view_app.test_client()\n\n    r = client.get(\"/v1.0/pets\")\n    assert r.json() == [{\"name\": \"get\"}]\n\n    r = client.get(\"/v1.0/pets/1\")\n    assert r.json() == {\"name\": \"get\", \"petId\": 1}\n\n    r = client.post(\"/v1.0/pets\", json={\"name\": \"Musti\"})\n    assert r.json() == {\"name\": \"post\", \"body\": {\"name\": \"Musti\"}}\n\n    r = client.put(\"/v1.0/pets/1\", json={\"name\": \"Igor\"})\n    assert r.json() == {\"name\": \"put\", \"petId\": 1, \"body\": {\"name\": \"Igor\"}}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "spec"
      ],
      "imports": [
        "connexion.FlaskApp",
        "connexion.operations.OpenAPIOperation",
        "connexion.resolver.MethodResolver",
        "connexion.resolver.MethodViewResolver",
        "connexion.resolver.Resolver",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert r.json() == [{'name': 'get'}]",
        "assert r.json() == {'name': 'get', 'petId': 1}",
        "assert r.json() == {'name': 'post', 'body': {'name': 'Musti'}}",
        "assert r.json() == {'name': 'put', 'petId': 1, 'body': {'name': 'Igor'}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "build_app_from_fixture",
          "body": "def build_app_from_fixture(api_spec_folder, *, app_class, spec_file, middlewares=None, **kwargs):\n    cnx_app = app_class(__name__, specification_dir=FIXTURES_FOLDER / api_spec_folder, middlewares=middlewares)\n    cnx_app.add_api(spec_file, **kwargs)\n    cnx_app._spec_file = spec_file\n    return cnx_app"
        },
        {
          "name": "client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "client.put",
          "body": "def put(self, *args, **kwargs):\n    kwargs.update({'name': 'put'})\n    return (kwargs, 201)"
        },
        {
          "name": "r.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "r.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "r.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "r.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_method_resolver_integration",
      "module": "test_resolver_methodview",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver_methodview.py",
      "line_number": 216,
      "end_line_number": 236,
      "source_code": "def test_method_resolver_integration(spec, app_class):\n    method_view_app = build_app_from_fixture(\n        \"method_view\",\n        app_class=app_class,\n        spec_file=spec,\n        resolver=MethodResolver(\"fakeapi.example_method_class\"),\n    )\n\n    client = method_view_app.test_client()\n\n    r = client.get(\"/v1.0/pets\")\n    assert r.json() == [{\"name\": \"search\"}]\n\n    r = client.get(\"/v1.0/pets/1\")\n    assert r.json() == {\"name\": \"get\", \"petId\": 1}\n\n    r = client.post(\"/v1.0/pets\", json={\"name\": \"Musti\"})\n    assert r.json() == {\"name\": \"post\", \"body\": {\"name\": \"Musti\"}}\n\n    r = client.put(\"/v1.0/pets/1\", json={\"name\": \"Igor\"})\n    assert r.json() == {\"name\": \"put\", \"petId\": 1, \"body\": {\"name\": \"Igor\"}}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "spec",
        "app_class"
      ],
      "imports": [
        "connexion.FlaskApp",
        "connexion.operations.OpenAPIOperation",
        "connexion.resolver.MethodResolver",
        "connexion.resolver.MethodViewResolver",
        "connexion.resolver.Resolver",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert r.json() == [{'name': 'search'}]",
        "assert r.json() == {'name': 'get', 'petId': 1}",
        "assert r.json() == {'name': 'post', 'body': {'name': 'Musti'}}",
        "assert r.json() == {'name': 'put', 'petId': 1, 'body': {'name': 'Igor'}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "build_app_from_fixture",
          "body": "def build_app_from_fixture(api_spec_folder, *, app_class, spec_file, middlewares=None, **kwargs):\n    cnx_app = app_class(__name__, specification_dir=FIXTURES_FOLDER / api_spec_folder, middlewares=middlewares)\n    cnx_app.add_api(spec_file, **kwargs)\n    cnx_app._spec_file = spec_file\n    return cnx_app"
        },
        {
          "name": "client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "client.put",
          "body": "def put(self, *args, **kwargs):\n    kwargs.update({'name': 'put'})\n    return (kwargs, 201)"
        },
        {
          "name": "r.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "r.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "r.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "r.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_standard_get_function",
      "module": "test_resolver",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver.py",
      "line_number": 8,
      "end_line_number": 12,
      "source_code": "def test_standard_get_function():\n    function = Resolver().resolve_function_from_operation_id(\n        \"connexion.FlaskApp.add_error_handler\"\n    )\n    assert function == connexion.FlaskApp.add_error_handler",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.apps",
        "pytest",
        "connexion.exceptions.ResolverError",
        "connexion.operations.Swagger2Operation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [
        "assert function == connexion.FlaskApp.add_error_handler"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_relative_get_function",
      "module": "test_resolver",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver.py",
      "line_number": 15,
      "end_line_number": 19,
      "source_code": "def test_relative_get_function():\n    function = RelativeResolver(\"connexion\").resolve_function_from_operation_id(\n        \"connexion.FlaskApp.add_error_handler\"\n    )\n    assert function == connexion.FlaskApp.add_error_handler",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.apps",
        "pytest",
        "connexion.exceptions.ResolverError",
        "connexion.operations.Swagger2Operation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [
        "assert function == connexion.FlaskApp.add_error_handler"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_resty_get_function",
      "module": "test_resolver",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver.py",
      "line_number": 22,
      "end_line_number": 26,
      "source_code": "def test_resty_get_function():\n    function = RestyResolver(\"connexion\").resolve_function_from_operation_id(\n        \"connexion.FlaskApp.add_error_handler\"\n    )\n    assert function == connexion.FlaskApp.add_error_handler",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.apps",
        "pytest",
        "connexion.exceptions.ResolverError",
        "connexion.operations.Swagger2Operation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [
        "assert function == connexion.FlaskApp.add_error_handler"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_missing_operation_id",
      "module": "test_resolver",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver.py",
      "line_number": 29,
      "end_line_number": 37,
      "source_code": "def test_missing_operation_id():\n    # Missing operationIDs should result in a well-defined error that can\n    # be handled upstream.\n    with pytest.raises(ResolverError):\n        Resolver().resolve_function_from_operation_id(None)\n    with pytest.raises(ResolverError):\n        RelativeResolver(\"connexion\").resolve_function_from_operation_id(None)\n    with pytest.raises(ResolverError):\n        RestyResolver(\"connexion\").resolve_function_from_operation_id(None)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.apps",
        "pytest",
        "connexion.exceptions.ResolverError",
        "connexion.operations.Swagger2Operation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_bad_operation_id",
      "module": "test_resolver",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver.py",
      "line_number": 40,
      "end_line_number": 52,
      "source_code": "def test_bad_operation_id():\n    # Unresolvable operationIDs should result in a well-defined error that can\n    # be handled upstream.\n    with pytest.raises(ResolverError):\n        Resolver().resolve_function_from_operation_id(\"ohai.I.do.not.exist\")\n    with pytest.raises(ResolverError):\n        RelativeResolver(\"connexion\").resolve_function_from_operation_id(\n            \"ohai.I.do.not.exist\"\n        )\n    with pytest.raises(ResolverError):\n        RestyResolver(\"connexion\").resolve_function_from_operation_id(\n            \"ohai.I.do.not.exist\"\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.apps",
        "pytest",
        "connexion.exceptions.ResolverError",
        "connexion.operations.Swagger2Operation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_standard_resolve_x_router_controller",
      "module": "test_resolver",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver.py",
      "line_number": 55,
      "end_line_number": 69,
      "source_code": "def test_standard_resolve_x_router_controller():\n    operation = Swagger2Operation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation={\n            \"x-swagger-router-controller\": \"fakeapi.hello\",\n            \"operationId\": \"post_greeting\",\n        },\n        app_produces=[\"application/json\"],\n        app_consumes=[\"application/json\"],\n        definitions={},\n        resolver=Resolver(),\n    )\n    assert operation.operation_id == \"fakeapi.hello.post_greeting\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.apps",
        "pytest",
        "connexion.exceptions.ResolverError",
        "connexion.operations.Swagger2Operation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.hello.post_greeting'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_relative_resolve_x_router_controller",
      "module": "test_resolver",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver.py",
      "line_number": 72,
      "end_line_number": 86,
      "source_code": "def test_relative_resolve_x_router_controller():\n    operation = Swagger2Operation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation={\n            \"x-swagger-router-controller\": \"fakeapi.hello\",\n            \"operationId\": \"post_greeting\",\n        },\n        app_produces=[\"application/json\"],\n        app_consumes=[\"application/json\"],\n        definitions={},\n        resolver=RelativeResolver(\"root_path\"),\n    )\n    assert operation.operation_id == \"fakeapi.hello.post_greeting\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.apps",
        "pytest",
        "connexion.exceptions.ResolverError",
        "connexion.operations.Swagger2Operation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.hello.post_greeting'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_relative_resolve_operation_id",
      "module": "test_resolver",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver.py",
      "line_number": 89,
      "end_line_number": 102,
      "source_code": "def test_relative_resolve_operation_id():\n    operation = Swagger2Operation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation={\n            \"operationId\": \"hello.post_greeting\",\n        },\n        app_produces=[\"application/json\"],\n        app_consumes=[\"application/json\"],\n        definitions={},\n        resolver=RelativeResolver(\"fakeapi\"),\n    )\n    assert operation.operation_id == \"fakeapi.hello.post_greeting\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.apps",
        "pytest",
        "connexion.exceptions.ResolverError",
        "connexion.operations.Swagger2Operation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.hello.post_greeting'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_relative_resolve_operation_id_with_module",
      "module": "test_resolver",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver.py",
      "line_number": 105,
      "end_line_number": 120,
      "source_code": "def test_relative_resolve_operation_id_with_module():\n    import fakeapi\n\n    operation = Swagger2Operation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation={\n            \"operationId\": \"hello.post_greeting\",\n        },\n        app_produces=[\"application/json\"],\n        app_consumes=[\"application/json\"],\n        definitions={},\n        resolver=RelativeResolver(fakeapi),\n    )\n    assert operation.operation_id == \"fakeapi.hello.post_greeting\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.apps",
        "pytest",
        "connexion.exceptions.ResolverError",
        "connexion.operations.Swagger2Operation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.hello.post_greeting'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_resty_resolve_operation_id",
      "module": "test_resolver",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver.py",
      "line_number": 123,
      "end_line_number": 136,
      "source_code": "def test_resty_resolve_operation_id():\n    operation = Swagger2Operation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation={\n            \"operationId\": \"fakeapi.hello.post_greeting\",\n        },\n        app_produces=[\"application/json\"],\n        app_consumes=[\"application/json\"],\n        definitions={},\n        resolver=RestyResolver(\"fakeapi\"),\n    )\n    assert operation.operation_id == \"fakeapi.hello.post_greeting\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.apps",
        "pytest",
        "connexion.exceptions.ResolverError",
        "connexion.operations.Swagger2Operation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.hello.post_greeting'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_resty_resolve_x_router_controller_with_operation_id",
      "module": "test_resolver",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver.py",
      "line_number": 139,
      "end_line_number": 153,
      "source_code": "def test_resty_resolve_x_router_controller_with_operation_id():\n    operation = Swagger2Operation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation={\n            \"x-swagger-router-controller\": \"fakeapi.hello\",\n            \"operationId\": \"post_greeting\",\n        },\n        app_produces=[\"application/json\"],\n        app_consumes=[\"application/json\"],\n        definitions={},\n        resolver=RestyResolver(\"fakeapi\"),\n    )\n    assert operation.operation_id == \"fakeapi.hello.post_greeting\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.apps",
        "pytest",
        "connexion.exceptions.ResolverError",
        "connexion.operations.Swagger2Operation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.hello.post_greeting'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_resty_resolve_x_router_controller_without_operation_id",
      "module": "test_resolver",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver.py",
      "line_number": 156,
      "end_line_number": 167,
      "source_code": "def test_resty_resolve_x_router_controller_without_operation_id():\n    operation = Swagger2Operation(\n        method=\"GET\",\n        path=\"/hello/{id}\",\n        path_parameters=[],\n        operation={\"x-swagger-router-controller\": \"fakeapi.hello\"},\n        app_produces=[\"application/json\"],\n        app_consumes=[\"application/json\"],\n        definitions={},\n        resolver=RestyResolver(\"fakeapi\"),\n    )\n    assert operation.operation_id == \"fakeapi.hello.get\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.apps",
        "pytest",
        "connexion.exceptions.ResolverError",
        "connexion.operations.Swagger2Operation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.hello.get'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_resty_resolve_with_default_module_name",
      "module": "test_resolver",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver.py",
      "line_number": 170,
      "end_line_number": 181,
      "source_code": "def test_resty_resolve_with_default_module_name():\n    operation = Swagger2Operation(\n        method=\"GET\",\n        path=\"/hello/{id}\",\n        path_parameters=[],\n        operation={},\n        app_produces=[\"application/json\"],\n        app_consumes=[\"application/json\"],\n        definitions={},\n        resolver=RestyResolver(\"fakeapi\"),\n    )\n    assert operation.operation_id == \"fakeapi.hello.get\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.apps",
        "pytest",
        "connexion.exceptions.ResolverError",
        "connexion.operations.Swagger2Operation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.hello.get'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_resty_resolve_with_default_module_name_nested",
      "module": "test_resolver",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver.py",
      "line_number": 184,
      "end_line_number": 195,
      "source_code": "def test_resty_resolve_with_default_module_name_nested():\n    operation = Swagger2Operation(\n        method=\"GET\",\n        path=\"/hello/{id}/world\",\n        path_parameters=[],\n        operation={},\n        app_produces=[\"application/json\"],\n        app_consumes=[\"application/json\"],\n        definitions={},\n        resolver=RestyResolver(\"fakeapi\"),\n    )\n    assert operation.operation_id == \"fakeapi.hello.world.search\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.apps",
        "pytest",
        "connexion.exceptions.ResolverError",
        "connexion.operations.Swagger2Operation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.hello.world.search'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_resty_resolve_with_default_module_name_lowercase_verb",
      "module": "test_resolver",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver.py",
      "line_number": 198,
      "end_line_number": 209,
      "source_code": "def test_resty_resolve_with_default_module_name_lowercase_verb():\n    operation = Swagger2Operation(\n        method=\"get\",\n        path=\"/hello/{id}\",\n        path_parameters=[],\n        operation={},\n        app_produces=[\"application/json\"],\n        app_consumes=[\"application/json\"],\n        definitions={},\n        resolver=RestyResolver(\"fakeapi\"),\n    )\n    assert operation.operation_id == \"fakeapi.hello.get\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.apps",
        "pytest",
        "connexion.exceptions.ResolverError",
        "connexion.operations.Swagger2Operation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.hello.get'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_resty_resolve_with_default_module_name_lowercase_verb_nested",
      "module": "test_resolver",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver.py",
      "line_number": 212,
      "end_line_number": 223,
      "source_code": "def test_resty_resolve_with_default_module_name_lowercase_verb_nested():\n    operation = Swagger2Operation(\n        method=\"get\",\n        path=\"/hello/world/{id}\",\n        path_parameters=[],\n        operation={},\n        app_produces=[\"application/json\"],\n        app_consumes=[\"application/json\"],\n        definitions={},\n        resolver=RestyResolver(\"fakeapi\"),\n    )\n    assert operation.operation_id == \"fakeapi.hello.world.get\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.apps",
        "pytest",
        "connexion.exceptions.ResolverError",
        "connexion.operations.Swagger2Operation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.hello.world.get'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_resty_resolve_with_default_module_name_will_translate_dashes_in_resource_name",
      "module": "test_resolver",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver.py",
      "line_number": 226,
      "end_line_number": 237,
      "source_code": "def test_resty_resolve_with_default_module_name_will_translate_dashes_in_resource_name():\n    operation = Swagger2Operation(\n        method=\"GET\",\n        path=\"/foo-bar\",\n        path_parameters=[],\n        operation={},\n        app_produces=[\"application/json\"],\n        app_consumes=[\"application/json\"],\n        definitions={},\n        resolver=RestyResolver(\"fakeapi\"),\n    )\n    assert operation.operation_id == \"fakeapi.foo_bar.search\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.apps",
        "pytest",
        "connexion.exceptions.ResolverError",
        "connexion.operations.Swagger2Operation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.foo_bar.search'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_resty_resolve_with_default_module_name_can_resolve_api_root",
      "module": "test_resolver",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver.py",
      "line_number": 240,
      "end_line_number": 251,
      "source_code": "def test_resty_resolve_with_default_module_name_can_resolve_api_root():\n    operation = Swagger2Operation(\n        method=\"GET\",\n        path=\"/\",\n        path_parameters=[],\n        operation={},\n        app_produces=[\"application/json\"],\n        app_consumes=[\"application/json\"],\n        definitions={},\n        resolver=RestyResolver(\"fakeapi\"),\n    )\n    assert operation.operation_id == \"fakeapi.get\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.apps",
        "pytest",
        "connexion.exceptions.ResolverError",
        "connexion.operations.Swagger2Operation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.get'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_resty_resolve_with_default_module_name_will_resolve_resource_root_get_as_search",
      "module": "test_resolver",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver.py",
      "line_number": 254,
      "end_line_number": 265,
      "source_code": "def test_resty_resolve_with_default_module_name_will_resolve_resource_root_get_as_search():\n    operation = Swagger2Operation(\n        method=\"GET\",\n        path=\"/hello\",\n        path_parameters=[],\n        operation={},\n        app_produces=[\"application/json\"],\n        app_consumes=[\"application/json\"],\n        definitions={},\n        resolver=RestyResolver(\"fakeapi\"),\n    )\n    assert operation.operation_id == \"fakeapi.hello.search\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.apps",
        "pytest",
        "connexion.exceptions.ResolverError",
        "connexion.operations.Swagger2Operation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.hello.search'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_resty_resolve_with_default_module_name_and_x_router_controller_will_resolve_resource_root_get_as_search",
      "module": "test_resolver",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver.py",
      "line_number": 268,
      "end_line_number": 281,
      "source_code": "def test_resty_resolve_with_default_module_name_and_x_router_controller_will_resolve_resource_root_get_as_search():\n    operation = Swagger2Operation(\n        method=\"GET\",\n        path=\"/hello\",\n        path_parameters=[],\n        operation={\n            \"x-swagger-router-controller\": \"fakeapi.hello\",\n        },\n        app_produces=[\"application/json\"],\n        app_consumes=[\"application/json\"],\n        definitions={},\n        resolver=RestyResolver(\"fakeapi\"),\n    )\n    assert operation.operation_id == \"fakeapi.hello.search\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.apps",
        "pytest",
        "connexion.exceptions.ResolverError",
        "connexion.operations.Swagger2Operation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.hello.search'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_resty_resolve_with_default_module_name_will_resolve_resource_root_as_configured",
      "module": "test_resolver",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver.py",
      "line_number": 284,
      "end_line_number": 295,
      "source_code": "def test_resty_resolve_with_default_module_name_will_resolve_resource_root_as_configured():\n    operation = Swagger2Operation(\n        method=\"GET\",\n        path=\"/hello\",\n        path_parameters=[],\n        operation={},\n        app_produces=[\"application/json\"],\n        app_consumes=[\"application/json\"],\n        definitions={},\n        resolver=RestyResolver(\"fakeapi\", collection_endpoint_name=\"api_list\"),\n    )\n    assert operation.operation_id == \"fakeapi.hello.api_list\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.apps",
        "pytest",
        "connexion.exceptions.ResolverError",
        "connexion.operations.Swagger2Operation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.hello.api_list'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_resty_resolve_with_default_module_name_will_resolve_resource_root_post_as_post",
      "module": "test_resolver",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver.py",
      "line_number": 298,
      "end_line_number": 309,
      "source_code": "def test_resty_resolve_with_default_module_name_will_resolve_resource_root_post_as_post():\n    operation = Swagger2Operation(\n        method=\"POST\",\n        path=\"/hello\",\n        path_parameters=[],\n        operation={},\n        app_produces=[\"application/json\"],\n        app_consumes=[\"application/json\"],\n        definitions={},\n        resolver=RestyResolver(\"fakeapi\"),\n    )\n    assert operation.operation_id == \"fakeapi.hello.post\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.apps",
        "pytest",
        "connexion.exceptions.ResolverError",
        "connexion.operations.Swagger2Operation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.hello.post'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_json_encoder",
      "module": "test_flask_encoder",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_flask_encoder.py",
      "line_number": 11,
      "end_line_number": 28,
      "source_code": "def test_json_encoder():\n    json_encoder = json.JSONEncoder\n    json_encoder.default = FlaskJSONProvider.default\n\n    s = json.dumps({1: 2}, cls=json_encoder)\n    assert '{\"1\": 2}' == s\n\n    s = json.dumps(datetime.date.today(), cls=json_encoder)\n    assert len(s) == 12\n\n    s = json.dumps(datetime.datetime.utcnow(), cls=json_encoder)\n    assert s.endswith('Z\"')\n\n    s = json.dumps(Decimal(1.01), cls=json_encoder)\n    assert s == \"1.01\"\n\n    s = json.dumps(math.expm1(1e-10), cls=json_encoder)\n    assert s == \"1.00000000005e-10\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime",
        "json",
        "math",
        "decimal.Decimal",
        "connexion.frameworks.flask.FlaskJSONProvider",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert '{\"1\": 2}' == s",
        "assert len(s) == 12",
        "assert s.endswith('Z\"')",
        "assert s == '1.01'",
        "assert s == '1.00000000005e-10'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_json_encoder_datetime_with_timezone",
      "module": "test_flask_encoder",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_flask_encoder.py",
      "line_number": 31,
      "end_line_number": 43,
      "source_code": "def test_json_encoder_datetime_with_timezone():\n    json_encoder = json.JSONEncoder\n    json_encoder.default = FlaskJSONProvider.default\n\n    class DummyTimezone(datetime.tzinfo):\n        def utcoffset(self, dt):\n            return datetime.timedelta(0)\n\n        def dst(self, dt):\n            return datetime.timedelta(0)\n\n    s = json.dumps(datetime.datetime.now(DummyTimezone()), cls=json_encoder)\n    assert s.endswith('+00:00\"')",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime",
        "json",
        "math",
        "decimal.Decimal",
        "connexion.frameworks.flask.FlaskJSONProvider",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert s.endswith('+00:00\"')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_readonly",
      "module": "test_flask_encoder",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_flask_encoder.py",
      "line_number": 46,
      "end_line_number": 90,
      "source_code": "def test_readonly(json_datetime_dir, spec, app_class):\n    app = build_app_from_fixture(\n        json_datetime_dir, app_class=app_class, spec_file=spec, validate_responses=True\n    )\n    app_client = app.test_client()\n\n    res = app_client.get(\"/v1.0/\" + spec.replace(\"yaml\", \"json\"))\n    assert res.status_code == 200, f\"Error is {res.text}\"\n    spec_data = res.json()\n\n    if spec == \"openapi.yaml\":\n        response_path = \"responses.200.content.application/json.schema\"\n    else:\n        response_path = \"responses.200.schema\"\n\n    def get_value(data, path):\n        for part in path.split(\".\"):\n            data = data.get(part)\n            assert data, f\"No data in part '{part}' of '{path}'\"\n        return data\n\n    example = get_value(spec_data, f\"paths./datetime.get.{response_path}.example.value\")\n    assert example in [\n        \"2000-01-23T04:56:07.000008+00:00\",  # PyYAML 5.3+\n        \"2000-01-23T04:56:07.000008Z\",\n    ]\n    example = get_value(spec_data, f\"paths./date.get.{response_path}.example.value\")\n    assert example == \"2000-01-23\"\n    example = get_value(spec_data, f\"paths./uuid.get.{response_path}.example.value\")\n    assert example == \"a7b8869c-5f24-4ce0-a5d1-3e44c3663aa9\"\n\n    res = app_client.get(\"/v1.0/datetime\")\n    assert res.status_code == 200, f\"Error is {res.text}\"\n    data = res.json()\n    assert data == {\"value\": \"2000-01-02T03:04:05.000006Z\"}\n\n    res = app_client.get(\"/v1.0/date\")\n    assert res.status_code == 200, f\"Error is {res.text}\"\n    data = res.json()\n    assert data == {\"value\": \"2000-01-02\"}\n\n    res = app_client.get(\"/v1.0/uuid\")\n    assert res.status_code == 200, f\"Error is {res.text}\"\n    data = res.json()\n    assert data == {\"value\": \"e7ff66d0-3ec2-4c4e-bed0-6e4723c24c51\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_datetime_dir",
        "spec",
        "app_class"
      ],
      "imports": [
        "datetime",
        "json",
        "math",
        "decimal.Decimal",
        "connexion.frameworks.flask.FlaskJSONProvider",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert res.status_code == 200, f'Error is {res.text}'",
        "assert example in ['2000-01-23T04:56:07.000008+00:00', '2000-01-23T04:56:07.000008Z']",
        "assert example == '2000-01-23'",
        "assert example == 'a7b8869c-5f24-4ce0-a5d1-3e44c3663aa9'",
        "assert res.status_code == 200, f'Error is {res.text}'",
        "assert data == {'value': '2000-01-02T03:04:05.000006Z'}",
        "assert res.status_code == 200, f'Error is {res.text}'",
        "assert data == {'value': '2000-01-02'}",
        "assert res.status_code == 200, f'Error is {res.text}'",
        "assert data == {'value': 'e7ff66d0-3ec2-4c4e-bed0-6e4723c24c51'}",
        "assert data, f\"No data in part '{part}' of '{path}'\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "build_app_from_fixture",
          "body": "def build_app_from_fixture(api_spec_folder, *, app_class, spec_file, middlewares=None, **kwargs):\n    cnx_app = app_class(__name__, specification_dir=FIXTURES_FOLDER / api_spec_folder, middlewares=middlewares)\n    cnx_app.add_api(spec_file, **kwargs)\n    cnx_app._spec_file = spec_file\n    return cnx_app"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "res.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "get_value",
          "body": "def get_value(data, path):\n    for part in path.split('.'):\n        data = data.get(part)\n        assert data, f\"No data in part '{part}' of '{path}'\"\n    return data"
        },
        {
          "name": "get_value",
          "body": "def get_value(data, path):\n    for part in path.split('.'):\n        data = data.get(part)\n        assert data, f\"No data in part '{part}' of '{path}'\"\n    return data"
        },
        {
          "name": "get_value",
          "body": "def get_value(data, path):\n    for part in path.split('.'):\n        data = data.get(part)\n        assert data, f\"No data in part '{part}' of '{path}'\"\n    return data"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "res.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "res.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "res.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "data.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_standard_resolve_x_router_controller",
      "module": "test_resolver3",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver3.py",
      "line_number": 7,
      "end_line_number": 19,
      "source_code": "def test_standard_resolve_x_router_controller():\n    operation = OpenAPIOperation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation={\n            \"x-openapi-router-controller\": \"fakeapi.hello\",\n            \"operationId\": \"post_greeting\",\n        },\n        components=COMPONENTS,\n        resolver=Resolver(),\n    )\n    assert operation.operation_id == \"fakeapi.hello.post_greeting\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.operations.OpenAPIOperation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.hello.post_greeting'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_relative_resolve_x_router_controller",
      "module": "test_resolver3",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver3.py",
      "line_number": 22,
      "end_line_number": 34,
      "source_code": "def test_relative_resolve_x_router_controller():\n    operation = OpenAPIOperation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation={\n            \"x-openapi-router-controller\": \"fakeapi.hello\",\n            \"operationId\": \"post_greeting\",\n        },\n        components=COMPONENTS,\n        resolver=RelativeResolver(\"root_path\"),\n    )\n    assert operation.operation_id == \"fakeapi.hello.post_greeting\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.operations.OpenAPIOperation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.hello.post_greeting'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_relative_resolve_operation_id",
      "module": "test_resolver3",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver3.py",
      "line_number": 37,
      "end_line_number": 48,
      "source_code": "def test_relative_resolve_operation_id():\n    operation = OpenAPIOperation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation={\n            \"operationId\": \"hello.post_greeting\",\n        },\n        components=COMPONENTS,\n        resolver=RelativeResolver(\"fakeapi\"),\n    )\n    assert operation.operation_id == \"fakeapi.hello.post_greeting\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.operations.OpenAPIOperation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.hello.post_greeting'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_relative_resolve_operation_id_with_module",
      "module": "test_resolver3",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver3.py",
      "line_number": 51,
      "end_line_number": 64,
      "source_code": "def test_relative_resolve_operation_id_with_module():\n    import fakeapi\n\n    operation = OpenAPIOperation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation={\n            \"operationId\": \"hello.post_greeting\",\n        },\n        components=COMPONENTS,\n        resolver=RelativeResolver(fakeapi),\n    )\n    assert operation.operation_id == \"fakeapi.hello.post_greeting\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.operations.OpenAPIOperation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.hello.post_greeting'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_resty_resolve_operation_id",
      "module": "test_resolver3",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver3.py",
      "line_number": 67,
      "end_line_number": 78,
      "source_code": "def test_resty_resolve_operation_id():\n    operation = OpenAPIOperation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation={\n            \"operationId\": \"fakeapi.hello.post_greeting\",\n        },\n        components=COMPONENTS,\n        resolver=RestyResolver(\"fakeapi\"),\n    )\n    assert operation.operation_id == \"fakeapi.hello.post_greeting\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.operations.OpenAPIOperation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.hello.post_greeting'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_resty_resolve_x_router_controller_with_operation_id",
      "module": "test_resolver3",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver3.py",
      "line_number": 81,
      "end_line_number": 93,
      "source_code": "def test_resty_resolve_x_router_controller_with_operation_id():\n    operation = OpenAPIOperation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation={\n            \"x-openapi-router-controller\": \"fakeapi.hello\",\n            \"operationId\": \"post_greeting\",\n        },\n        components=COMPONENTS,\n        resolver=RestyResolver(\"fakeapi\"),\n    )\n    assert operation.operation_id == \"fakeapi.hello.post_greeting\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.operations.OpenAPIOperation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.hello.post_greeting'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_resty_resolve_x_router_controller_without_operation_id",
      "module": "test_resolver3",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver3.py",
      "line_number": 96,
      "end_line_number": 105,
      "source_code": "def test_resty_resolve_x_router_controller_without_operation_id():\n    operation = OpenAPIOperation(\n        method=\"GET\",\n        path=\"/hello/{id}\",\n        path_parameters=[],\n        operation={\"x-openapi-router-controller\": \"fakeapi.hello\"},\n        components=COMPONENTS,\n        resolver=RestyResolver(\"fakeapi\"),\n    )\n    assert operation.operation_id == \"fakeapi.hello.get\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.operations.OpenAPIOperation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.hello.get'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_resty_resolve_with_default_module_name",
      "module": "test_resolver3",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver3.py",
      "line_number": 108,
      "end_line_number": 117,
      "source_code": "def test_resty_resolve_with_default_module_name():\n    operation = OpenAPIOperation(\n        method=\"GET\",\n        path=\"/hello/{id}\",\n        path_parameters=[],\n        operation={},\n        components=COMPONENTS,\n        resolver=RestyResolver(\"fakeapi\"),\n    )\n    assert operation.operation_id == \"fakeapi.hello.get\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.operations.OpenAPIOperation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.hello.get'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_resty_resolve_with_default_module_name",
      "module": "test_resolver3",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver3.py",
      "line_number": 120,
      "end_line_number": 129,
      "source_code": "def test_resty_resolve_with_default_module_name():\n    operation = OpenAPIOperation(\n        method=\"GET\",\n        path=\"/hello/{id}/world\",\n        path_parameters=[],\n        operation={},\n        components=COMPONENTS,\n        resolver=RestyResolver(\"fakeapi\"),\n    )\n    assert operation.operation_id == \"fakeapi.hello.world.search\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.operations.OpenAPIOperation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.hello.world.search'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_resty_resolve_with_default_module_name_lowercase_verb",
      "module": "test_resolver3",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver3.py",
      "line_number": 132,
      "end_line_number": 141,
      "source_code": "def test_resty_resolve_with_default_module_name_lowercase_verb():\n    operation = OpenAPIOperation(\n        method=\"get\",\n        path=\"/hello/{id}\",\n        path_parameters=[],\n        operation={},\n        components=COMPONENTS,\n        resolver=RestyResolver(\"fakeapi\"),\n    )\n    assert operation.operation_id == \"fakeapi.hello.get\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.operations.OpenAPIOperation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.hello.get'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_resty_resolve_with_default_module_name_lowercase_verb_nested",
      "module": "test_resolver3",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver3.py",
      "line_number": 144,
      "end_line_number": 153,
      "source_code": "def test_resty_resolve_with_default_module_name_lowercase_verb_nested():\n    operation = OpenAPIOperation(\n        method=\"get\",\n        path=\"/hello/world/{id}\",\n        path_parameters=[],\n        operation={},\n        components=COMPONENTS,\n        resolver=RestyResolver(\"fakeapi\"),\n    )\n    assert operation.operation_id == \"fakeapi.hello.world.get\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.operations.OpenAPIOperation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.hello.world.get'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_resty_resolve_with_default_module_name_will_translate_dashes_in_resource_name",
      "module": "test_resolver3",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver3.py",
      "line_number": 156,
      "end_line_number": 165,
      "source_code": "def test_resty_resolve_with_default_module_name_will_translate_dashes_in_resource_name():\n    operation = OpenAPIOperation(\n        method=\"GET\",\n        path=\"/foo-bar\",\n        path_parameters=[],\n        operation={},\n        components=COMPONENTS,\n        resolver=RestyResolver(\"fakeapi\"),\n    )\n    assert operation.operation_id == \"fakeapi.foo_bar.search\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.operations.OpenAPIOperation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.foo_bar.search'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_resty_resolve_with_default_module_name_can_resolve_api_root",
      "module": "test_resolver3",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver3.py",
      "line_number": 168,
      "end_line_number": 177,
      "source_code": "def test_resty_resolve_with_default_module_name_can_resolve_api_root():\n    operation = OpenAPIOperation(\n        method=\"GET\",\n        path=\"/\",\n        path_parameters=[],\n        operation={},\n        components=COMPONENTS,\n        resolver=RestyResolver(\"fakeapi\"),\n    )\n    assert operation.operation_id == \"fakeapi.get\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.operations.OpenAPIOperation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.get'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_resty_resolve_with_default_module_name_will_resolve_resource_root_get_as_search",
      "module": "test_resolver3",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver3.py",
      "line_number": 180,
      "end_line_number": 189,
      "source_code": "def test_resty_resolve_with_default_module_name_will_resolve_resource_root_get_as_search():\n    operation = OpenAPIOperation(\n        method=\"GET\",\n        path=\"/hello\",\n        path_parameters=[],\n        operation={},\n        components=COMPONENTS,\n        resolver=RestyResolver(\"fakeapi\"),\n    )\n    assert operation.operation_id == \"fakeapi.hello.search\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.operations.OpenAPIOperation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.hello.search'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_resty_resolve_with_default_module_name_and_x_router_controller_will_resolve_resource_root_get_as_search",
      "module": "test_resolver3",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver3.py",
      "line_number": 192,
      "end_line_number": 203,
      "source_code": "def test_resty_resolve_with_default_module_name_and_x_router_controller_will_resolve_resource_root_get_as_search():\n    operation = OpenAPIOperation(\n        method=\"GET\",\n        path=\"/hello\",\n        path_parameters=[],\n        operation={\n            \"x-openapi-router-controller\": \"fakeapi.hello\",\n        },\n        components=COMPONENTS,\n        resolver=RestyResolver(\"fakeapi\"),\n    )\n    assert operation.operation_id == \"fakeapi.hello.search\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.operations.OpenAPIOperation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.hello.search'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_resty_resolve_with_default_module_name_will_resolve_resource_root_as_configured",
      "module": "test_resolver3",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver3.py",
      "line_number": 206,
      "end_line_number": 215,
      "source_code": "def test_resty_resolve_with_default_module_name_will_resolve_resource_root_as_configured():\n    operation = OpenAPIOperation(\n        method=\"GET\",\n        path=\"/hello\",\n        path_parameters=[],\n        operation={},\n        components=COMPONENTS,\n        resolver=RestyResolver(\"fakeapi\", collection_endpoint_name=\"api_list\"),\n    )\n    assert operation.operation_id == \"fakeapi.hello.api_list\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.operations.OpenAPIOperation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.hello.api_list'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_resty_resolve_with_default_module_name_will_resolve_resource_root_post_as_post",
      "module": "test_resolver3",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_resolver3.py",
      "line_number": 218,
      "end_line_number": 227,
      "source_code": "def test_resty_resolve_with_default_module_name_will_resolve_resource_root_post_as_post():\n    operation = OpenAPIOperation(\n        method=\"POST\",\n        path=\"/hello\",\n        path_parameters=[],\n        operation={},\n        components=COMPONENTS,\n        resolver=RestyResolver(\"fakeapi\"),\n    )\n    assert operation.operation_id == \"fakeapi.hello.post\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.operations.OpenAPIOperation",
        "connexion.resolver.RelativeResolver",
        "connexion.resolver.Resolver",
        "connexion.resolver.RestyResolver",
        "fakeapi"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.hello.post'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_lifespan_handler",
      "module": "test_lifespan",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_lifespan.py",
      "line_number": 9,
      "end_line_number": 22,
      "source_code": "def test_lifespan_handler(app_class):\n    m = mock.MagicMock()\n\n    @contextlib.asynccontextmanager\n    async def lifespan(app):\n        m.startup()\n        yield\n        m.shutdown()\n\n    app = AsyncApp(__name__, lifespan=lifespan)\n    with app.test_client():\n        m.startup.assert_called()\n        m.shutdown.assert_not_called()\n    m.shutdown.assert_called()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app_class"
      ],
      "imports": [
        "contextlib",
        "sys",
        "unittest.mock",
        "pytest",
        "connexion.AsyncApp",
        "connexion.ConnexionMiddleware"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.MagicMock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_get_function_from_name",
      "module": "test_utils",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_utils.py",
      "line_number": 9,
      "end_line_number": 12,
      "source_code": "def test_get_function_from_name():\n    function = utils.get_function_from_name(\"math.ceil\")\n    assert function == math.ceil\n    assert function(2.7) == 3",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "math",
        "unittest.mock.MagicMock",
        "connexion.apps",
        "pytest",
        "connexion.utils"
      ],
      "fixtures": [],
      "assertions": [
        "assert function == math.ceil",
        "assert function(2.7) == 3"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get_function_from_name_no_module",
      "module": "test_utils",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_utils.py",
      "line_number": 15,
      "end_line_number": 17,
      "source_code": "def test_get_function_from_name_no_module():\n    with pytest.raises(ValueError):\n        utils.get_function_from_name(\"math\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "math",
        "unittest.mock.MagicMock",
        "connexion.apps",
        "pytest",
        "connexion.utils"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get_function_from_name_attr_error",
      "module": "test_utils",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_utils.py",
      "line_number": 20,
      "end_line_number": 30,
      "source_code": "def test_get_function_from_name_attr_error(monkeypatch):\n    \"\"\"\n    Test attribute error without import error on get_function_from_name.\n    Attribute errors due to import errors are tested on\n    test_api.test_invalid_operation_does_stop_application_to_setup\n    \"\"\"\n    deep_attr_mock = MagicMock()\n    deep_attr_mock.side_effect = AttributeError\n    monkeypatch.setattr(\"connexion.utils.deep_getattr\", deep_attr_mock)\n    with pytest.raises(AttributeError):\n        utils.get_function_from_name(\"math.ceil\")",
      "docstring": "Test attribute error without import error on get_function_from_name.\nAttribute errors due to import errors are tested on\ntest_api.test_invalid_operation_does_stop_application_to_setup",
      "decorators": [],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "math",
        "unittest.mock.MagicMock",
        "connexion.apps",
        "pytest",
        "connexion.utils"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get_function_from_name_for_class_method",
      "module": "test_utils",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_utils.py",
      "line_number": 33,
      "end_line_number": 35,
      "source_code": "def test_get_function_from_name_for_class_method():\n    function = utils.get_function_from_name(\"connexion.FlaskApp.add_error_handler\")\n    assert function == connexion.FlaskApp.add_error_handler",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "math",
        "unittest.mock.MagicMock",
        "connexion.apps",
        "pytest",
        "connexion.utils"
      ],
      "fixtures": [],
      "assertions": [
        "assert function == connexion.FlaskApp.add_error_handler"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_boolean",
      "module": "test_utils",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_utils.py",
      "line_number": 38,
      "end_line_number": 52,
      "source_code": "def test_boolean():\n    assert utils.boolean(\"true\")\n    assert utils.boolean(\"True\")\n    assert utils.boolean(\"TRUE\")\n    assert utils.boolean(True)\n    assert not utils.boolean(\"false\")\n    assert not utils.boolean(\"False\")\n    assert not utils.boolean(\"FALSE\")\n    assert not utils.boolean(False)\n\n    with pytest.raises(ValueError):\n        utils.boolean(\"foo\")\n\n    with pytest.raises(ValueError):\n        utils.boolean(None)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "math",
        "unittest.mock.MagicMock",
        "connexion.apps",
        "pytest",
        "connexion.utils"
      ],
      "fixtures": [],
      "assertions": [
        "assert utils.boolean('true')",
        "assert utils.boolean('True')",
        "assert utils.boolean('TRUE')",
        "assert utils.boolean(True)",
        "assert not utils.boolean('false')",
        "assert not utils.boolean('False')",
        "assert not utils.boolean('FALSE')",
        "assert not utils.boolean(False)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_deep_get_dict",
      "module": "test_utils",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_utils.py",
      "line_number": 55,
      "end_line_number": 57,
      "source_code": "def test_deep_get_dict():\n    obj = {\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\"}}}\n    assert utils.deep_get(obj, [\"properties\", \"id\"]) == {\"type\": \"string\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "math",
        "unittest.mock.MagicMock",
        "connexion.apps",
        "pytest",
        "connexion.utils"
      ],
      "fixtures": [],
      "assertions": [
        "assert utils.deep_get(obj, ['properties', 'id']) == {'type': 'string'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_deep_get_list",
      "module": "test_utils",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_utils.py",
      "line_number": 60,
      "end_line_number": 62,
      "source_code": "def test_deep_get_list():\n    obj = [{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\"}}}]\n    assert utils.deep_get(obj, [\"0\", \"properties\", \"id\"]) == {\"type\": \"string\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "math",
        "unittest.mock.MagicMock",
        "connexion.apps",
        "pytest",
        "connexion.utils"
      ],
      "fixtures": [],
      "assertions": [
        "assert utils.deep_get(obj, ['0', 'properties', 'id']) == {'type': 'string'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_is_json_mimetype",
      "module": "test_utils",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_utils.py",
      "line_number": 65,
      "end_line_number": 74,
      "source_code": "def test_is_json_mimetype():\n    assert utils.is_json_mimetype(\"application/json\")\n    assert utils.is_json_mimetype(\"application/vnd.com.myEntreprise.v6+json\")\n    assert utils.is_json_mimetype(\n        \"application/vnd.scanner.adapter.vuln.report.harbor+json; version=1.0\"\n    )\n    assert utils.is_json_mimetype(\n        \"application/vnd.com.myEntreprise.v6+json; charset=UTF-8\"\n    )\n    assert not utils.is_json_mimetype(\"text/html\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "math",
        "unittest.mock.MagicMock",
        "connexion.apps",
        "pytest",
        "connexion.utils"
      ],
      "fixtures": [],
      "assertions": [
        "assert utils.is_json_mimetype('application/json')",
        "assert utils.is_json_mimetype('application/vnd.com.myEntreprise.v6+json')",
        "assert utils.is_json_mimetype('application/vnd.scanner.adapter.vuln.report.harbor+json; version=1.0')",
        "assert utils.is_json_mimetype('application/vnd.com.myEntreprise.v6+json; charset=UTF-8')",
        "assert not utils.is_json_mimetype('text/html')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_sort_routes",
      "module": "test_utils",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_utils.py",
      "line_number": 77,
      "end_line_number": 128,
      "source_code": "def test_sort_routes():\n    routes = [\"/users/me\", \"/users/{username}\"]\n    expected = [\"/users/me\", \"/users/{username}\"]\n    assert utils.sort_routes(routes) == expected\n\n    routes = [\"/{path:path}\", \"/basepath/{path:path}\"]\n    expected = [\"/basepath/{path:path}\", \"/{path:path}\"]\n    assert utils.sort_routes(routes) == expected\n\n    routes = [\"/\", \"/basepath\"]\n    expected = [\"/basepath\", \"/\"]\n    assert utils.sort_routes(routes) == expected\n\n    routes = [\"/basepath/{path:path}\", \"/basepath/v2/{path:path}\"]\n    expected = [\"/basepath/v2/{path:path}\", \"/basepath/{path:path}\"]\n    assert utils.sort_routes(routes) == expected\n\n    routes = [\"/basepath\", \"/basepath/v2\"]\n    expected = [\"/basepath/v2\", \"/basepath\"]\n    assert utils.sort_routes(routes) == expected\n\n    routes = [\"/users/{username}\", \"/users/me\"]\n    expected = [\"/users/me\", \"/users/{username}\"]\n    assert utils.sort_routes(routes) == expected\n\n    routes = [\n        \"/users/{username}\",\n        \"/users/me\",\n        \"/users/{username}/items\",\n        \"/users/{username}/items/{item}\",\n    ]\n    expected = [\n        \"/users/me\",\n        \"/users/{username}/items/{item}\",\n        \"/users/{username}/items\",\n        \"/users/{username}\",\n    ]\n    assert utils.sort_routes(routes) == expected\n\n    routes = [\n        \"/users/{username}\",\n        \"/users/me\",\n        \"/users/{username}/items/{item}\",\n        \"/users/{username}/items/special\",\n    ]\n    expected = [\n        \"/users/me\",\n        \"/users/{username}/items/special\",\n        \"/users/{username}/items/{item}\",\n        \"/users/{username}\",\n    ]\n    assert utils.sort_routes(routes) == expected",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "math",
        "unittest.mock.MagicMock",
        "connexion.apps",
        "pytest",
        "connexion.utils"
      ],
      "fixtures": [],
      "assertions": [
        "assert utils.sort_routes(routes) == expected",
        "assert utils.sort_routes(routes) == expected",
        "assert utils.sort_routes(routes) == expected",
        "assert utils.sort_routes(routes) == expected",
        "assert utils.sort_routes(routes) == expected",
        "assert utils.sort_routes(routes) == expected",
        "assert utils.sort_routes(routes) == expected",
        "assert utils.sort_routes(routes) == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_sort_apis_by_basepath",
      "module": "test_utils",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_utils.py",
      "line_number": 131,
      "end_line_number": 145,
      "source_code": "def test_sort_apis_by_basepath():\n    api1 = MagicMock(base_path=\"/\")\n    api2 = MagicMock(base_path=\"/basepath\")\n    assert utils.sort_apis_by_basepath([api1, api2]) == [api2, api1]\n\n    api3 = MagicMock(base_path=\"/basepath/v2\")\n    assert utils.sort_apis_by_basepath([api1, api2, api3]) == [api3, api2, api1]\n\n    api4 = MagicMock(base_path=\"/healthz\")\n    assert utils.sort_apis_by_basepath([api1, api2, api3, api4]) == [\n        api3,\n        api2,\n        api4,\n        api1,\n    ]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "math",
        "unittest.mock.MagicMock",
        "connexion.apps",
        "pytest",
        "connexion.utils"
      ],
      "fixtures": [],
      "assertions": [
        "assert utils.sort_apis_by_basepath([api1, api2]) == [api2, api1]",
        "assert utils.sort_apis_by_basepath([api1, api2, api3]) == [api3, api2, api1]",
        "assert utils.sort_apis_by_basepath([api1, api2, api3, api4]) == [api3, api2, api4, api1]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_non_existent_reference",
      "module": "test_references",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_references.py",
      "line_number": 42,
      "end_line_number": 57,
      "source_code": "def test_non_existent_reference(api):\n    op_spec = {\n        \"parameters\": [\n            {\n                \"in\": \"body\",\n                \"name\": \"new_stack\",\n                \"required\": True,\n                \"schema\": {\"$ref\": \"#/definitions/new_stack\"},\n            }\n        ]\n    }\n    with pytest.raises(RefResolutionError) as exc_info:  # type: py.code.ExceptionInfo\n        resolve_refs(op_spec, {})\n\n    exception = exc_info.value\n    assert \"definitions/new_stack\" in str(exception)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "api"
      ],
      "imports": [
        "unittest.mock",
        "pytest",
        "connexion.json_schema.RefResolutionError",
        "connexion.json_schema.resolve_refs",
        "connexion.jsonifier.Jsonifier"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'definitions/new_stack' in str(exception)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_invalid_reference",
      "module": "test_references",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_references.py",
      "line_number": 60,
      "end_line_number": 78,
      "source_code": "def test_invalid_reference(api):\n    op_spec = {\n        \"parameters\": [\n            {\n                \"in\": \"body\",\n                \"name\": \"new_stack\",\n                \"required\": True,\n                \"schema\": {\"$ref\": \"#/notdefinitions/new_stack\"},\n            }\n        ]\n    }\n\n    with pytest.raises(RefResolutionError) as exc_info:  # type: py.code.ExceptionInfo\n        resolve_refs(\n            op_spec, {\"definitions\": DEFINITIONS, \"parameters\": PARAMETER_DEFINITIONS}\n        )\n\n    exception = exc_info.value\n    assert \"notdefinitions/new_stack\" in str(exception)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "api"
      ],
      "imports": [
        "unittest.mock",
        "pytest",
        "connexion.json_schema.RefResolutionError",
        "connexion.json_schema.resolve_refs",
        "connexion.jsonifier.Jsonifier"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'notdefinitions/new_stack' in str(exception)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_resolve_invalid_reference",
      "module": "test_references",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_references.py",
      "line_number": 81,
      "end_line_number": 91,
      "source_code": "def test_resolve_invalid_reference(api):\n    op_spec = {\n        \"operationId\": \"fakeapi.hello.post_greeting\",\n        \"parameters\": [{\"$ref\": \"/parameters/fail\"}],\n    }\n\n    with pytest.raises(RefResolutionError) as exc_info:\n        resolve_refs(op_spec, {\"parameters\": PARAMETER_DEFINITIONS})\n\n    exception = exc_info.value\n    assert \"parameters/fail\" in str(exception)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "api"
      ],
      "imports": [
        "unittest.mock",
        "pytest",
        "connexion.json_schema.RefResolutionError",
        "connexion.json_schema.resolve_refs",
        "connexion.jsonifier.Jsonifier"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'parameters/fail' in str(exception)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_resolve_web_reference",
      "module": "test_references",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_references.py",
      "line_number": 94,
      "end_line_number": 99,
      "source_code": "def test_resolve_web_reference(api):\n    op_spec = {\"parameters\": [{\"$ref\": \"https://reallyfake.asd/parameters.json\"}]}\n    store = {\"https://reallyfake.asd/parameters.json\": {\"name\": \"test\"}}\n\n    spec = resolve_refs(op_spec, store=store)\n    assert spec[\"parameters\"][0][\"name\"] == \"test\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "api"
      ],
      "imports": [
        "unittest.mock",
        "pytest",
        "connexion.json_schema.RefResolutionError",
        "connexion.json_schema.resolve_refs",
        "connexion.jsonifier.Jsonifier"
      ],
      "fixtures": [],
      "assertions": [
        "assert spec['parameters'][0]['name'] == 'test'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_resolve_ref_referring_to_another_ref",
      "module": "test_references",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_references.py",
      "line_number": 102,
      "end_line_number": 120,
      "source_code": "def test_resolve_ref_referring_to_another_ref(api):\n    expected = {\"type\": \"string\"}\n    op_spec = {\n        \"parameters\": [\n            {\n                \"schema\": {\"$ref\": \"#/definitions/A\"},\n            }\n        ],\n        \"definitions\": {\n            \"A\": {\n                \"$ref\": \"#/definitions/B\",\n            },\n            \"B\": expected,\n        },\n    }\n\n    spec = resolve_refs(op_spec)\n    assert spec[\"parameters\"][0][\"schema\"] == expected\n    assert spec[\"definitions\"][\"A\"] == expected",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "api"
      ],
      "imports": [
        "unittest.mock",
        "pytest",
        "connexion.json_schema.RefResolutionError",
        "connexion.json_schema.resolve_refs",
        "connexion.jsonifier.Jsonifier"
      ],
      "fixtures": [],
      "assertions": [
        "assert spec['parameters'][0]['schema'] == expected",
        "assert spec['definitions']['A'] == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_canonical_base_path",
      "module": "test_api",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_api.py",
      "line_number": 15,
      "end_line_number": 19,
      "source_code": "def test_canonical_base_path():\n    assert canonical_base_path(\"\") == \"\"\n    assert canonical_base_path(\"/\") == \"\"\n    assert canonical_base_path(\"/api\") == \"/api\"\n    assert canonical_base_path(\"/api/\") == \"/api\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "os",
        "pathlib",
        "tempfile",
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.FlaskApi",
        "connexion.exceptions.InvalidSpecification",
        "connexion.exceptions.ResolverError",
        "connexion.spec.Specification",
        "connexion.spec.canonical_base_path",
        "yaml.YAMLError"
      ],
      "fixtures": [],
      "assertions": [
        "assert canonical_base_path('') == ''",
        "assert canonical_base_path('/') == ''",
        "assert canonical_base_path('/api') == '/api'",
        "assert canonical_base_path('/api/') == '/api'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_api",
      "module": "test_api",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_api.py",
      "line_number": 22,
      "end_line_number": 43,
      "source_code": "def test_api():\n    api = FlaskApi(\n        Specification.load(TEST_FOLDER / \"fixtures/simple/swagger.yaml\"),\n        base_path=\"/api/v1.0\",\n    )\n    assert api.blueprint.name == \"/api/v1_0\"\n    assert api.blueprint.url_prefix == \"/api/v1.0\"\n\n    api2 = FlaskApi(Specification.load(TEST_FOLDER / \"fixtures/simple/swagger.yaml\"))\n    assert api2.blueprint.name == \"/v1_0\"\n    assert api2.blueprint.url_prefix == \"/v1.0\"\n\n    api3 = FlaskApi(\n        Specification.load(TEST_FOLDER / \"fixtures/simple/openapi.yaml\"),\n        base_path=\"/api/v1.0\",\n    )\n    assert api3.blueprint.name == \"/api/v1_0\"\n    assert api3.blueprint.url_prefix == \"/api/v1.0\"\n\n    api4 = FlaskApi(Specification.load(TEST_FOLDER / \"fixtures/simple/openapi.yaml\"))\n    assert api4.blueprint.name == \"/v1_0\"\n    assert api4.blueprint.url_prefix == \"/v1.0\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "os",
        "pathlib",
        "tempfile",
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.FlaskApi",
        "connexion.exceptions.InvalidSpecification",
        "connexion.exceptions.ResolverError",
        "connexion.spec.Specification",
        "connexion.spec.canonical_base_path",
        "yaml.YAMLError"
      ],
      "fixtures": [],
      "assertions": [
        "assert api.blueprint.name == '/api/v1_0'",
        "assert api.blueprint.url_prefix == '/api/v1.0'",
        "assert api2.blueprint.name == '/v1_0'",
        "assert api2.blueprint.url_prefix == '/v1.0'",
        "assert api3.blueprint.name == '/api/v1_0'",
        "assert api3.blueprint.url_prefix == '/api/v1.0'",
        "assert api4.blueprint.name == '/v1_0'",
        "assert api4.blueprint.url_prefix == '/v1.0'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_api_base_path_slash",
      "module": "test_api",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_api.py",
      "line_number": 46,
      "end_line_number": 51,
      "source_code": "def test_api_base_path_slash():\n    api = FlaskApi(\n        Specification.load(TEST_FOLDER / \"fixtures/simple/basepath-slash.yaml\")\n    )\n    assert api.blueprint.name == \"/\"\n    assert api.blueprint.url_prefix == \"\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "os",
        "pathlib",
        "tempfile",
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.FlaskApi",
        "connexion.exceptions.InvalidSpecification",
        "connexion.exceptions.ResolverError",
        "connexion.spec.Specification",
        "connexion.spec.canonical_base_path",
        "yaml.YAMLError"
      ],
      "fixtures": [],
      "assertions": [
        "assert api.blueprint.name == '/'",
        "assert api.blueprint.url_prefix == ''"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_remote_api",
      "module": "test_api",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_api.py",
      "line_number": 54,
      "end_line_number": 87,
      "source_code": "def test_remote_api():\n    api = FlaskApi(\n        Specification.load(\n            \"https://raw.githubusercontent.com/spec-first/connexion/165a915/tests/fixtures/simple/swagger.yaml\"\n        ),\n        base_path=\"/api/v1.0\",\n    )\n    assert api.blueprint.name == \"/api/v1_0\"\n    assert api.blueprint.url_prefix == \"/api/v1.0\"\n\n    api2 = FlaskApi(\n        Specification.load(\n            \"https://raw.githubusercontent.com/spec-first/connexion/165a915/tests/fixtures/simple/swagger.yaml\"\n        )\n    )\n    assert api2.blueprint.name == \"/v1_0\"\n    assert api2.blueprint.url_prefix == \"/v1.0\"\n\n    api3 = FlaskApi(\n        Specification.load(\n            \"https://raw.githubusercontent.com/spec-first/connexion/165a915/tests/fixtures/simple/openapi.yaml\"\n        ),\n        base_path=\"/api/v1.0\",\n    )\n    assert api3.blueprint.name == \"/api/v1_0\"\n    assert api3.blueprint.url_prefix == \"/api/v1.0\"\n\n    api4 = FlaskApi(\n        Specification.load(\n            \"https://raw.githubusercontent.com/spec-first/connexion/165a915/tests/fixtures/simple/openapi.yaml\"\n        )\n    )\n    assert api4.blueprint.name == \"/v1_0\"\n    assert api4.blueprint.url_prefix == \"/v1.0\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "os",
        "pathlib",
        "tempfile",
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.FlaskApi",
        "connexion.exceptions.InvalidSpecification",
        "connexion.exceptions.ResolverError",
        "connexion.spec.Specification",
        "connexion.spec.canonical_base_path",
        "yaml.YAMLError"
      ],
      "fixtures": [],
      "assertions": [
        "assert api.blueprint.name == '/api/v1_0'",
        "assert api.blueprint.url_prefix == '/api/v1.0'",
        "assert api2.blueprint.name == '/v1_0'",
        "assert api2.blueprint.url_prefix == '/v1.0'",
        "assert api3.blueprint.name == '/api/v1_0'",
        "assert api3.blueprint.url_prefix == '/api/v1.0'",
        "assert api4.blueprint.name == '/v1_0'",
        "assert api4.blueprint.url_prefix == '/v1.0'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_template",
      "module": "test_api",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_api.py",
      "line_number": 90,
      "end_line_number": 106,
      "source_code": "def test_template():\n    api1 = FlaskApi(\n        Specification.load(\n            TEST_FOLDER / \"fixtures/simple/swagger.yaml\", arguments={\"title\": \"test\"}\n        ),\n        base_path=\"/api/v1.0\",\n    )\n    assert api1.specification[\"info\"][\"title\"] == \"test\"\n\n    api2 = FlaskApi(\n        Specification.load(\n            TEST_FOLDER / \"fixtures/simple/swagger.yaml\",\n            arguments={\"title\": \"other test\"},\n        ),\n        base_path=\"/api/v1.0\",\n    )\n    assert api2.specification[\"info\"][\"title\"] == \"other test\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "os",
        "pathlib",
        "tempfile",
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.FlaskApi",
        "connexion.exceptions.InvalidSpecification",
        "connexion.exceptions.ResolverError",
        "connexion.spec.Specification",
        "connexion.spec.canonical_base_path",
        "yaml.YAMLError"
      ],
      "fixtures": [],
      "assertions": [
        "assert api1.specification['info']['title'] == 'test'",
        "assert api2.specification['info']['title'] == 'other test'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_invalid_operation_does_stop_application_to_setup",
      "module": "test_api",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_api.py",
      "line_number": 109,
      "end_line_number": 144,
      "source_code": "def test_invalid_operation_does_stop_application_to_setup():\n    with pytest.raises(ResolverError):\n        FlaskApi(\n            Specification.load(\n                TEST_FOLDER / \"fixtures/op_error_api/swagger.yaml\",\n                arguments={\"title\": \"OK\"},\n            ),\n            base_path=\"/api/v1.0\",\n        )\n\n    with pytest.raises(ResolverError):\n        FlaskApi(\n            Specification.load(\n                TEST_FOLDER / \"fixtures/missing_op_id/swagger.yaml\",\n                arguments={\"title\": \"OK\"},\n            ),\n            base_path=\"/api/v1.0\",\n        )\n\n    with pytest.raises(ResolverError):\n        FlaskApi(\n            Specification.load(\n                TEST_FOLDER / \"fixtures/module_not_implemented/swagger.yaml\",\n                arguments={\"title\": \"OK\"},\n            ),\n            base_path=\"/api/v1.0\",\n        )\n\n    with pytest.raises(ResolverError):\n        FlaskApi(\n            Specification.load(\n                TEST_FOLDER / \"fixtures/user_module_loading_error/swagger.yaml\",\n                arguments={\"title\": \"OK\"},\n            ),\n            base_path=\"/api/v1.0\",\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "os",
        "pathlib",
        "tempfile",
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.FlaskApi",
        "connexion.exceptions.InvalidSpecification",
        "connexion.exceptions.ResolverError",
        "connexion.spec.Specification",
        "connexion.spec.canonical_base_path",
        "yaml.YAMLError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_other_errors_stop_application_to_setup",
      "module": "test_api",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_api.py",
      "line_number": 147,
      "end_line_number": 156,
      "source_code": "def test_other_errors_stop_application_to_setup():\n    # Errors should still result exceptions!\n    with pytest.raises(InvalidSpecification):\n        FlaskApi(\n            Specification.load(\n                TEST_FOLDER / \"fixtures/bad_specs/swagger.yaml\",\n                arguments={\"title\": \"OK\"},\n            ),\n            base_path=\"/api/v1.0\",\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "os",
        "pathlib",
        "tempfile",
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.FlaskApi",
        "connexion.exceptions.InvalidSpecification",
        "connexion.exceptions.ResolverError",
        "connexion.spec.Specification",
        "connexion.spec.canonical_base_path",
        "yaml.YAMLError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_invalid_schema_file_structure",
      "module": "test_api",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_api.py",
      "line_number": 159,
      "end_line_number": 167,
      "source_code": "def test_invalid_schema_file_structure():\n    with pytest.raises(InvalidSpecification):\n        FlaskApi(\n            Specification.load(\n                TEST_FOLDER / \"fixtures/invalid_schema/swagger.yaml\",\n                arguments={\"title\": \"OK\"},\n            ),\n            base_path=\"/api/v1.0\",\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "os",
        "pathlib",
        "tempfile",
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.FlaskApi",
        "connexion.exceptions.InvalidSpecification",
        "connexion.exceptions.ResolverError",
        "connexion.spec.Specification",
        "connexion.spec.canonical_base_path",
        "yaml.YAMLError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_invalid_encoding",
      "module": "test_api",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_api.py",
      "line_number": 170,
      "end_line_number": 178,
      "source_code": "def test_invalid_encoding():\n    with tempfile.NamedTemporaryFile(mode=\"wb\", delete=False) as f:\n        f.write(\n            \"swagger: '2.0'\\ninfo:\\n  title: Foo \u6574\\n  version: v1\\npaths: {}\".encode(\n                \"gbk\"\n            )\n        )\n    FlaskApi(Specification.load(pathlib.Path(f.name)), base_path=\"/api/v1.0\")\n    os.unlink(f.name)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "os",
        "pathlib",
        "tempfile",
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.FlaskApi",
        "connexion.exceptions.InvalidSpecification",
        "connexion.exceptions.ResolverError",
        "connexion.spec.Specification",
        "connexion.spec.canonical_base_path",
        "yaml.YAMLError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_use_of_safe_load_for_yaml_swagger_specs",
      "module": "test_api",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_api.py",
      "line_number": 181,
      "end_line_number": 189,
      "source_code": "def test_use_of_safe_load_for_yaml_swagger_specs():\n    with pytest.raises(YAMLError):\n        with tempfile.NamedTemporaryFile(delete=False) as f:\n            f.write(b\"!!python/object:object {}\\n\")\n        try:\n            FlaskApi(Specification.load(pathlib.Path(f.name)), base_path=\"/api/v1.0\")\n            os.unlink(f.name)\n        except InvalidSpecification:\n            pytest.fail(\"Could load invalid YAML file, use yaml.safe_load!\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "os",
        "pathlib",
        "tempfile",
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.FlaskApi",
        "connexion.exceptions.InvalidSpecification",
        "connexion.exceptions.ResolverError",
        "connexion.spec.Specification",
        "connexion.spec.canonical_base_path",
        "yaml.YAMLError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_validation_error_on_completely_invalid_swagger_spec",
      "module": "test_api",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_api.py",
      "line_number": 192,
      "end_line_number": 197,
      "source_code": "def test_validation_error_on_completely_invalid_swagger_spec():\n    with tempfile.NamedTemporaryFile(delete=False) as f:\n        f.write(b\"[1]\\n\")\n    with pytest.raises(InvalidSpecification):\n        FlaskApi(Specification.load(pathlib.Path(f.name)), base_path=\"/api/v1.0\")\n    os.unlink(f.name)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "os",
        "pathlib",
        "tempfile",
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.FlaskApi",
        "connexion.exceptions.InvalidSpecification",
        "connexion.exceptions.ResolverError",
        "connexion.spec.Specification",
        "connexion.spec.canonical_base_path",
        "yaml.YAMLError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_relative_refs",
      "module": "test_api",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_api.py",
      "line_number": 200,
      "end_line_number": 203,
      "source_code": "def test_relative_refs(relative_refs, spec):\n    spec_path = relative_refs / spec\n    specification = Specification.load(spec_path)\n    assert \"$ref\" not in specification.raw",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "relative_refs",
        "spec"
      ],
      "imports": [
        "os",
        "pathlib",
        "tempfile",
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.FlaskApi",
        "connexion.exceptions.InvalidSpecification",
        "connexion.exceptions.ResolverError",
        "connexion.spec.Specification",
        "connexion.spec.canonical_base_path",
        "yaml.YAMLError"
      ],
      "fixtures": [],
      "assertions": [
        "assert '$ref' not in specification.raw"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_build_example_from_schema_string",
      "module": "test_mock2",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_mock2.py",
      "line_number": 7,
      "end_line_number": 12,
      "source_code": "def test_build_example_from_schema_string():\n    schema = {\n        \"type\": \"string\",\n    }\n    example = build_example_from_schema(schema)\n    assert isinstance(example, str)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "re.fullmatch",
        "connexion.utils.build_example_from_schema"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(example, str)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_build_example_from_schema_integer",
      "module": "test_mock2",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_mock2.py",
      "line_number": 15,
      "end_line_number": 20,
      "source_code": "def test_build_example_from_schema_integer():\n    schema = {\n        \"type\": \"integer\",\n    }\n    example = build_example_from_schema(schema)\n    assert isinstance(example, int)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "re.fullmatch",
        "connexion.utils.build_example_from_schema"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(example, int)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_build_example_from_schema_number",
      "module": "test_mock2",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_mock2.py",
      "line_number": 23,
      "end_line_number": 28,
      "source_code": "def test_build_example_from_schema_number():\n    schema = {\n        \"type\": \"number\",\n    }\n    example = build_example_from_schema(schema)\n    assert isinstance(example, float)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "re.fullmatch",
        "connexion.utils.build_example_from_schema"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(example, float)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_build_example_from_schema_boolean",
      "module": "test_mock2",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_mock2.py",
      "line_number": 31,
      "end_line_number": 36,
      "source_code": "def test_build_example_from_schema_boolean():\n    schema = {\n        \"type\": \"boolean\",\n    }\n    example = build_example_from_schema(schema)\n    assert isinstance(example, bool)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "re.fullmatch",
        "connexion.utils.build_example_from_schema"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(example, bool)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_build_example_from_schema_integer_minimum",
      "module": "test_mock2",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_mock2.py",
      "line_number": 39,
      "end_line_number": 45,
      "source_code": "def test_build_example_from_schema_integer_minimum():\n    schema = {\n        \"type\": \"integer\",\n        \"minimum\": 4,\n    }\n    example = build_example_from_schema(schema)\n    assert example >= schema[\"minimum\"] and isinstance(example, int)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "re.fullmatch",
        "connexion.utils.build_example_from_schema"
      ],
      "fixtures": [],
      "assertions": [
        "assert example >= schema['minimum'] and isinstance(example, int)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_build_example_from_schema_integer_maximum",
      "module": "test_mock2",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_mock2.py",
      "line_number": 48,
      "end_line_number": 54,
      "source_code": "def test_build_example_from_schema_integer_maximum():\n    schema = {\n        \"type\": \"integer\",\n        \"maximum\": 17,\n    }\n    example = build_example_from_schema(schema)\n    assert example <= schema[\"maximum\"] and isinstance(example, int)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "re.fullmatch",
        "connexion.utils.build_example_from_schema"
      ],
      "fixtures": [],
      "assertions": [
        "assert example <= schema['maximum'] and isinstance(example, int)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_build_example_from_schema_integer_exclusive_minimum",
      "module": "test_mock2",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_mock2.py",
      "line_number": 57,
      "end_line_number": 64,
      "source_code": "def test_build_example_from_schema_integer_exclusive_minimum():\n    schema = {\n        \"type\": \"integer\",\n        \"minimum\": 4,\n        \"exclusiveMinimum\": True,\n    }\n    example = build_example_from_schema(schema)\n    assert example > schema[\"minimum\"] and isinstance(example, int)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "re.fullmatch",
        "connexion.utils.build_example_from_schema"
      ],
      "fixtures": [],
      "assertions": [
        "assert example > schema['minimum'] and isinstance(example, int)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_build_example_from_schema_integer_exclusive_maximum",
      "module": "test_mock2",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_mock2.py",
      "line_number": 67,
      "end_line_number": 74,
      "source_code": "def test_build_example_from_schema_integer_exclusive_maximum():\n    schema = {\n        \"type\": \"integer\",\n        \"maximum\": 17,\n        \"exclusiveMaximum\": True,\n    }\n    example = build_example_from_schema(schema)\n    assert example < schema[\"maximum\"] and isinstance(example, int)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "re.fullmatch",
        "connexion.utils.build_example_from_schema"
      ],
      "fixtures": [],
      "assertions": [
        "assert example < schema['maximum'] and isinstance(example, int)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_build_example_from_schema_string_regular_expression",
      "module": "test_mock2",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_mock2.py",
      "line_number": 77,
      "end_line_number": 84,
      "source_code": "def test_build_example_from_schema_string_regular_expression():\n    pattern = r\"^\\d{3}-\\d{2}-\\d{4}$\"\n    schema = {\n        \"type\": \"string\",\n        \"pattern\": pattern,\n    }\n    example = build_example_from_schema(schema)\n    assert fullmatch(pattern, example) != None and isinstance(example, str)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "re.fullmatch",
        "connexion.utils.build_example_from_schema"
      ],
      "fixtures": [],
      "assertions": [
        "assert fullmatch(pattern, example) != None and isinstance(example, str)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_build_example_from_schema_string_maximum",
      "module": "test_mock2",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_mock2.py",
      "line_number": 87,
      "end_line_number": 93,
      "source_code": "def test_build_example_from_schema_string_maximum():\n    schema = {\n        \"type\": \"string\",\n        \"maxLength\": 20,\n    }\n    example = build_example_from_schema(schema)\n    assert isinstance(example, str) and len(example) <= schema[\"maxLength\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "re.fullmatch",
        "connexion.utils.build_example_from_schema"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(example, str) and len(example) <= schema['maxLength']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_build_example_from_schema_string_minimum",
      "module": "test_mock2",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_mock2.py",
      "line_number": 96,
      "end_line_number": 102,
      "source_code": "def test_build_example_from_schema_string_minimum():\n    schema = {\n        \"type\": \"string\",\n        \"minLength\": 20,\n    }\n    example = build_example_from_schema(schema)\n    assert isinstance(example, str) and len(example) >= schema[\"minLength\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "re.fullmatch",
        "connexion.utils.build_example_from_schema"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(example, str) and len(example) >= schema['minLength']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_build_example_from_schema_enum",
      "module": "test_mock2",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_mock2.py",
      "line_number": 105,
      "end_line_number": 109,
      "source_code": "def test_build_example_from_schema_enum():\n    schema = {\"type\": \"string\", \"enum\": [\"asc\", \"desc\"]}\n    example = build_example_from_schema(schema)\n    assert isinstance(example, str)\n    assert example == \"asc\" or example == \"desc\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "re.fullmatch",
        "connexion.utils.build_example_from_schema"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(example, str)",
        "assert example == 'asc' or example == 'desc'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_build_example_from_complex_schema",
      "module": "test_mock2",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_mock2.py",
      "line_number": 112,
      "end_line_number": 162,
      "source_code": "def test_build_example_from_complex_schema():\n    schema = {\n        \"type\": \"object\",\n        \"properties\": {\n            \"datetimeField\": {\"type\": \"string\", \"format\": \"date-time\"},\n            \"integerField\": {\n                \"type\": \"integer\",\n                \"minimum\": 2,\n                \"maximum\": 5,\n                \"exclusiveMinimum\": True,\n                \"multipleOf\": 2,\n            },\n            \"arrayOfNumbersField\": {\n                \"type\": \"array\",\n                \"items\": {\n                    \"type\": \"number\",\n                    \"format\": \"float\",\n                    \"minimum\": 0.1,\n                    \"maximum\": 0.9,\n                    \"multipleOf\": 0.1,\n                },\n                \"minItems\": 3,\n                \"maxItems\": 5,\n            },\n            \"objectField\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"nestedBoolean\": {\"type\": \"boolean\"},\n                    \"stringWithExample\": {\n                        \"type\": \"string\",\n                        \"example\": \"example-string\",\n                    },\n                },\n            },\n        },\n    }\n    example = build_example_from_schema(schema)\n\n    # Check that ValueError is not raised on invalid datetime.\n    datetime.fromisoformat(example[\"datetimeField\"])\n    assert example[\"integerField\"] == 4\n\n    assert isinstance(example[\"arrayOfNumbersField\"], list)\n    assert 3 <= len(example[\"arrayOfNumbersField\"]) <= 5\n    assert all(0.1 <= num <= 0.9 for num in example[\"arrayOfNumbersField\"])\n\n    example_boolean = example[\"objectField\"][\"nestedBoolean\"]\n    assert example_boolean is True or example_boolean is False\n\n    # Check that if an example is provided then it is used directly.\n    assert example[\"objectField\"][\"stringWithExample\"] == \"example-string\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "re.fullmatch",
        "connexion.utils.build_example_from_schema"
      ],
      "fixtures": [],
      "assertions": [
        "assert example['integerField'] == 4",
        "assert isinstance(example['arrayOfNumbersField'], list)",
        "assert 3 <= len(example['arrayOfNumbersField']) <= 5",
        "assert all((0.1 <= num <= 0.9 for num in example['arrayOfNumbersField']))",
        "assert example_boolean is True or example_boolean is False",
        "assert example['objectField']['stringWithExample'] == 'example-string'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_mock_resolver_default",
      "module": "test_mock",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_mock.py",
      "line_number": 5,
      "end_line_number": 24,
      "source_code": "def test_mock_resolver_default():\n    resolver = MockResolver(mock_all=True)\n\n    responses = {\"default\": {\"examples\": {\"application/json\": {\"foo\": \"bar\"}}}}\n\n    operation = Swagger2Operation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation={\"responses\": responses},\n        app_produces=[\"application/json\"],\n        app_consumes=[\"application/json\"],\n        definitions={},\n        resolver=resolver,\n    )\n    assert operation.operation_id == \"mock-1\"\n\n    response, status_code = resolver.mock_operation(operation)\n    assert status_code == 200\n    assert response == {\"foo\": \"bar\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.mock.MockResolver",
        "connexion.operations.OpenAPIOperation",
        "connexion.operations.Swagger2Operation"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'mock-1'",
        "assert status_code == 200",
        "assert response == {'foo': 'bar'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_mock_resolver_numeric",
      "module": "test_mock",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_mock.py",
      "line_number": 27,
      "end_line_number": 46,
      "source_code": "def test_mock_resolver_numeric():\n    resolver = MockResolver(mock_all=True)\n\n    responses = {\"200\": {\"examples\": {\"application/json\": {\"foo\": \"bar\"}}}}\n\n    operation = Swagger2Operation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation={\"responses\": responses},\n        app_produces=[\"application/json\"],\n        app_consumes=[\"application/json\"],\n        definitions={},\n        resolver=resolver,\n    )\n    assert operation.operation_id == \"mock-1\"\n\n    response, status_code = resolver.mock_operation(operation)\n    assert status_code == 200\n    assert response == {\"foo\": \"bar\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.mock.MockResolver",
        "connexion.operations.OpenAPIOperation",
        "connexion.operations.Swagger2Operation"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'mock-1'",
        "assert status_code == 200",
        "assert response == {'foo': 'bar'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_mock_resolver_example",
      "module": "test_mock",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_mock.py",
      "line_number": 49,
      "end_line_number": 76,
      "source_code": "def test_mock_resolver_example():\n    resolver = MockResolver(mock_all=True)\n\n    responses = {\n        \"default\": {\n            \"schema\": {\n                \"type\": \"object\",\n                \"properties\": {\"foo\": {\"type\": \"string\"}},\n                \"example\": {\"foo\": \"bar\"},\n            }\n        }\n    }\n\n    operation = Swagger2Operation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation={\"responses\": responses},\n        app_produces=[\"application/json\"],\n        app_consumes=[\"application/json\"],\n        definitions={},\n        resolver=resolver,\n    )\n    assert operation.operation_id == \"mock-1\"\n\n    response, status_code = resolver.mock_operation(operation)\n    assert status_code == 200\n    assert response == {\"foo\": \"bar\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.mock.MockResolver",
        "connexion.operations.OpenAPIOperation",
        "connexion.operations.Swagger2Operation"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'mock-1'",
        "assert status_code == 200",
        "assert response == {'foo': 'bar'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_mock_resolver_example_nested_in_object",
      "module": "test_mock",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_mock.py",
      "line_number": 79,
      "end_line_number": 105,
      "source_code": "def test_mock_resolver_example_nested_in_object():\n    resolver = MockResolver(mock_all=True)\n\n    responses = {\n        \"default\": {\n            \"schema\": {\n                \"type\": \"object\",\n                \"properties\": {\"foo\": {\"type\": \"string\", \"example\": \"bar\"}},\n            }\n        }\n    }\n\n    operation = Swagger2Operation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation={\"responses\": responses},\n        app_produces=[\"application/json\"],\n        app_consumes=[\"application/json\"],\n        definitions={},\n        resolver=resolver,\n    )\n    assert operation.operation_id == \"mock-1\"\n\n    response, status_code = resolver.mock_operation(operation)\n    assert status_code == 200\n    assert response == {\"foo\": \"bar\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.mock.MockResolver",
        "connexion.operations.OpenAPIOperation",
        "connexion.operations.Swagger2Operation"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'mock-1'",
        "assert status_code == 200",
        "assert response == {'foo': 'bar'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_mock_resolver_example_nested_in_list",
      "module": "test_mock",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_mock.py",
      "line_number": 108,
      "end_line_number": 134,
      "source_code": "def test_mock_resolver_example_nested_in_list():\n    resolver = MockResolver(mock_all=True)\n\n    responses = {\n        \"default\": {\n            \"schema\": {\n                \"type\": \"array\",\n                \"items\": {\"type\": \"string\", \"example\": \"bar\"},\n            }\n        }\n    }\n\n    operation = Swagger2Operation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation={\"responses\": responses},\n        app_produces=[\"application/json\"],\n        app_consumes=[\"application/json\"],\n        definitions={},\n        resolver=resolver,\n    )\n    assert operation.operation_id == \"mock-1\"\n\n    response, status_code = resolver.mock_operation(operation)\n    assert status_code == 200\n    assert response == [\"bar\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.mock.MockResolver",
        "connexion.operations.OpenAPIOperation",
        "connexion.operations.Swagger2Operation"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'mock-1'",
        "assert status_code == 200",
        "assert response == ['bar']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_mock_resolver_example_nested_in_object_openapi",
      "module": "test_mock",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_mock.py",
      "line_number": 137,
      "end_line_number": 164,
      "source_code": "def test_mock_resolver_example_nested_in_object_openapi():\n    resolver = MockResolver(mock_all=True)\n\n    responses = {\n        \"default\": {\n            \"content\": {\n                \"application/json\": {\n                    \"schema\": {\n                        \"type\": \"object\",\n                        \"properties\": {\"foo\": {\"type\": \"string\", \"example\": \"bar\"}},\n                    }\n                }\n            }\n        }\n    }\n\n    operation = OpenAPIOperation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation={\"responses\": responses},\n        resolver=resolver,\n    )\n    assert operation.operation_id == \"mock-1\"\n\n    response, status_code = resolver.mock_operation(operation)\n    assert status_code == 200\n    assert response == {\"foo\": \"bar\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.mock.MockResolver",
        "connexion.operations.OpenAPIOperation",
        "connexion.operations.Swagger2Operation"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'mock-1'",
        "assert status_code == 200",
        "assert response == {'foo': 'bar'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_mock_resolver_example_nested_in_list_openapi",
      "module": "test_mock",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_mock.py",
      "line_number": 167,
      "end_line_number": 194,
      "source_code": "def test_mock_resolver_example_nested_in_list_openapi():\n    resolver = MockResolver(mock_all=True)\n\n    responses = {\n        \"default\": {\n            \"content\": {\n                \"application/json\": {\n                    \"schema\": {\n                        \"type\": \"array\",\n                        \"items\": {\"type\": \"string\", \"example\": \"bar\"},\n                    }\n                }\n            }\n        }\n    }\n\n    operation = OpenAPIOperation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation={\"responses\": responses},\n        resolver=resolver,\n    )\n    assert operation.operation_id == \"mock-1\"\n\n    response, status_code = resolver.mock_operation(operation)\n    assert status_code == 200\n    assert response == [\"bar\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.mock.MockResolver",
        "connexion.operations.OpenAPIOperation",
        "connexion.operations.Swagger2Operation"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'mock-1'",
        "assert status_code == 200",
        "assert response == ['bar']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_mock_resolver_no_example_nested_in_object",
      "module": "test_mock",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_mock.py",
      "line_number": 197,
      "end_line_number": 228,
      "source_code": "def test_mock_resolver_no_example_nested_in_object():\n    resolver = MockResolver(mock_all=True)\n\n    responses = {\n        \"200\": {\n            \"schema\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"foo\": {\n                        \"type\": \"string\",\n                    }\n                },\n            }\n        }\n    }\n\n    operation = Swagger2Operation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation={\"responses\": responses},\n        app_produces=[\"application/json\"],\n        app_consumes=[\"application/json\"],\n        definitions={},\n        resolver=resolver,\n    )\n    assert operation.operation_id == \"mock-1\"\n\n    response, status_code = resolver.mock_operation(operation)\n    assert status_code == 200\n    assert isinstance(response, dict)\n    assert isinstance(response[\"foo\"], str)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.mock.MockResolver",
        "connexion.operations.OpenAPIOperation",
        "connexion.operations.Swagger2Operation"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'mock-1'",
        "assert status_code == 200",
        "assert isinstance(response, dict)",
        "assert isinstance(response['foo'], str)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_mock_resolver_no_example_nested_in_list_openapi",
      "module": "test_mock",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_mock.py",
      "line_number": 231,
      "end_line_number": 261,
      "source_code": "def test_mock_resolver_no_example_nested_in_list_openapi():\n    resolver = MockResolver(mock_all=True)\n\n    responses = {\n        \"202\": {\n            \"content\": {\n                \"application/json\": {\n                    \"schema\": {\n                        \"type\": \"array\",\n                        \"items\": {\n                            \"type\": \"string\",\n                        },\n                    }\n                }\n            }\n        }\n    }\n\n    operation = OpenAPIOperation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation={\"responses\": responses},\n        resolver=resolver,\n    )\n    assert operation.operation_id == \"mock-1\"\n\n    response, status_code = resolver.mock_operation(operation)\n    assert status_code == 202\n    assert isinstance(response, list)\n    assert all(isinstance(c, str) for c in response)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.mock.MockResolver",
        "connexion.operations.OpenAPIOperation",
        "connexion.operations.Swagger2Operation"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'mock-1'",
        "assert status_code == 202",
        "assert isinstance(response, list)",
        "assert all((isinstance(c, str) for c in response))"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_mock_resolver_no_examples",
      "module": "test_mock",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_mock.py",
      "line_number": 264,
      "end_line_number": 283,
      "source_code": "def test_mock_resolver_no_examples():\n    resolver = MockResolver(mock_all=True)\n\n    responses = {\"418\": {}}\n\n    operation = Swagger2Operation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation={\"responses\": responses},\n        app_produces=[\"application/json\"],\n        app_consumes=[\"application/json\"],\n        definitions={},\n        resolver=resolver,\n    )\n    assert operation.operation_id == \"mock-1\"\n\n    response, status_code = resolver.mock_operation(operation)\n    assert status_code == 418\n    assert response == \"No example response or response schema defined.\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.mock.MockResolver",
        "connexion.operations.OpenAPIOperation",
        "connexion.operations.Swagger2Operation"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'mock-1'",
        "assert status_code == 418",
        "assert response == 'No example response or response schema defined.'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_mock_resolver_notimplemented",
      "module": "test_mock",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_mock.py",
      "line_number": 286,
      "end_line_number": 323,
      "source_code": "def test_mock_resolver_notimplemented():\n    resolver = MockResolver(mock_all=False)\n\n    responses = {\"418\": {}}\n\n    # do not mock the existent functions\n    operation = Swagger2Operation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation={\"operationId\": \"fakeapi.hello.get\"},\n        app_produces=[\"application/json\"],\n        app_consumes=[\"application/json\"],\n        definitions={},\n        resolver=resolver,\n    )\n    assert operation.operation_id == \"fakeapi.hello.get\"\n\n    # mock only the nonexistent ones\n    operation = Swagger2Operation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation={\n            \"operationId\": \"fakeapi.hello.nonexistent_function\",\n            \"responses\": responses,\n        },\n        app_produces=[\"application/json\"],\n        app_consumes=[\"application/json\"],\n        definitions={},\n        resolver=resolver,\n    )\n\n    # check if it is using the mock function\n    assert operation._resolution.function() == (\n        \"No example response or response schema defined.\",\n        418,\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.mock.MockResolver",
        "connexion.operations.OpenAPIOperation",
        "connexion.operations.Swagger2Operation"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.operation_id == 'fakeapi.hello.get'",
        "assert operation._resolution.function() == ('No example response or response schema defined.', 418)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_operation",
      "module": "test_operation2",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_operation2.py",
      "line_number": 402,
      "end_line_number": 421,
      "source_code": "def test_operation(api):\n    op_spec = make_operation(OPERATION1)\n    operation = Swagger2Operation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation=op_spec,\n        app_produces=[\"application/json\"],\n        app_consumes=[\"application/json\"],\n        definitions=DEFINITIONS,\n        resolver=Resolver(),\n    )\n\n    assert operation.method == \"GET\"\n    assert operation.produces == [\"application/json\"]\n    assert operation.consumes == [\"application/json\"]\n\n    expected_body_schema = op_spec[\"parameters\"][0][\"schema\"]\n    expected_body_schema.update({\"definitions\": DEFINITIONS})\n    assert operation.body_schema() == expected_body_schema",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "api"
      ],
      "imports": [
        "copy",
        "logging",
        "math",
        "pathlib",
        "types",
        "unittest.mock",
        "pytest",
        "connexion.exceptions.InvalidSpecification",
        "connexion.json_schema.resolve_refs",
        "connexion.jsonifier.Jsonifier",
        "connexion.middleware.security.SecurityOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.resolver.Resolver",
        "connexion.security.ApiKeySecurityHandler",
        "connexion.security.OAuthSecurityHandler",
        "connexion.security.SecurityHandlerFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.method == 'GET'",
        "assert operation.produces == ['application/json']",
        "assert operation.consumes == ['application/json']",
        "assert operation.body_schema() == expected_body_schema"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_operation",
          "body": "def make_operation(op, definitions=True, parameters=True):\n    \"\"\"note the wrapper because definitions namespace and\n    operation namespace collide\n    \"\"\"\n    new_op = {'wrapper': copy.deepcopy(op)}\n    if definitions:\n        new_op.update({'definitions': DEFINITIONS})\n    if parameters:\n        new_op.update({'parameters': PARAMETER_DEFINITIONS})\n    return resolve_refs(new_op)['wrapper']"
        }
      ]
    },
    {
      "name": "test_operation_remote_token_info",
      "module": "test_operation2",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_operation2.py",
      "line_number": 424,
      "end_line_number": 450,
      "source_code": "def test_operation_remote_token_info():\n    class MockOAuthHandler(OAuthSecurityHandler):\n        \"\"\"Mock.\"\"\"\n\n    security_handler_factory = SecurityHandlerFactory({\"oauth2\": MockOAuthHandler})\n    oauth_security_handler = security_handler_factory.security_handlers[\"oauth2\"]\n    verify_oauth = mock.MagicMock(return_value=\"verify_oauth_result\")\n    oauth_security_handler._get_verify_func = verify_oauth\n    oauth_security_handler.get_token_info_remote = mock.MagicMock(\n        return_value=\"get_token_info_remote_result\"\n    )\n\n    SecurityOperation(\n        next_app=mock.Mock,\n        security_handler_factory=security_handler_factory,\n        security=[{\"oauth\": [\"uid\"]}],\n        security_schemes=SECURITY_DEFINITIONS_REMOTE,\n    )\n\n    verify_oauth.assert_called_with(\n        \"get_token_info_remote_result\",\n        oauth_security_handler.validate_scope,\n        [\"uid\"],\n    )\n    oauth_security_handler.get_token_info_remote.assert_called_with(\n        \"https://oauth.example/token_info\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "copy",
        "logging",
        "math",
        "pathlib",
        "types",
        "unittest.mock",
        "pytest",
        "connexion.exceptions.InvalidSpecification",
        "connexion.json_schema.resolve_refs",
        "connexion.jsonifier.Jsonifier",
        "connexion.middleware.security.SecurityOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.resolver.Resolver",
        "connexion.security.ApiKeySecurityHandler",
        "connexion.security.OAuthSecurityHandler",
        "connexion.security.SecurityHandlerFactory"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.MagicMock(return_value='verify_oauth_result')",
        "mock.MagicMock(return_value='get_token_info_remote_result')"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_operation_array",
      "module": "test_operation2",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_operation2.py",
      "line_number": 453,
      "end_line_number": 476,
      "source_code": "def test_operation_array(api):\n    op_spec = make_operation(OPERATION7)\n    operation = Swagger2Operation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation=op_spec,\n        app_produces=[\"application/json\"],\n        app_consumes=[\"application/json\"],\n        definitions=DEFINITIONS,\n        resolver=Resolver(),\n    )\n    assert isinstance(operation.function, types.FunctionType)\n\n    assert operation.method == \"GET\"\n    assert operation.produces == [\"application/json\"]\n    assert operation.consumes == [\"application/json\"]\n\n    expected_body_schema = {\n        \"type\": \"array\",\n        \"items\": DEFINITIONS[\"new_stack\"],\n        \"definitions\": DEFINITIONS,\n    }\n    assert operation.body_schema() == expected_body_schema",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "api"
      ],
      "imports": [
        "copy",
        "logging",
        "math",
        "pathlib",
        "types",
        "unittest.mock",
        "pytest",
        "connexion.exceptions.InvalidSpecification",
        "connexion.json_schema.resolve_refs",
        "connexion.jsonifier.Jsonifier",
        "connexion.middleware.security.SecurityOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.resolver.Resolver",
        "connexion.security.ApiKeySecurityHandler",
        "connexion.security.OAuthSecurityHandler",
        "connexion.security.SecurityHandlerFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(operation.function, types.FunctionType)",
        "assert operation.method == 'GET'",
        "assert operation.produces == ['application/json']",
        "assert operation.consumes == ['application/json']",
        "assert operation.body_schema() == expected_body_schema"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_operation",
          "body": "def make_operation(op, definitions=True, parameters=True):\n    \"\"\"note the wrapper because definitions namespace and\n    operation namespace collide\n    \"\"\"\n    new_op = {'wrapper': copy.deepcopy(op)}\n    if definitions:\n        new_op.update({'definitions': DEFINITIONS})\n    if parameters:\n        new_op.update({'parameters': PARAMETER_DEFINITIONS})\n    return resolve_refs(new_op)['wrapper']"
        }
      ]
    },
    {
      "name": "test_operation_composed_definition",
      "module": "test_operation2",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_operation2.py",
      "line_number": 479,
      "end_line_number": 499,
      "source_code": "def test_operation_composed_definition(api):\n    op_spec = make_operation(OPERATION8)\n    operation = Swagger2Operation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation=op_spec,\n        app_produces=[\"application/json\"],\n        app_consumes=[\"application/json\"],\n        definitions=DEFINITIONS,\n        resolver=Resolver(),\n    )\n    assert isinstance(operation.function, types.FunctionType)\n\n    assert operation.method == \"GET\"\n    assert operation.produces == [\"application/json\"]\n    assert operation.consumes == [\"application/json\"]\n\n    expected_body_schema = op_spec[\"parameters\"][0][\"schema\"]\n    expected_body_schema.update({\"definitions\": DEFINITIONS})\n    assert operation.body_schema() == expected_body_schema",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "api"
      ],
      "imports": [
        "copy",
        "logging",
        "math",
        "pathlib",
        "types",
        "unittest.mock",
        "pytest",
        "connexion.exceptions.InvalidSpecification",
        "connexion.json_schema.resolve_refs",
        "connexion.jsonifier.Jsonifier",
        "connexion.middleware.security.SecurityOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.resolver.Resolver",
        "connexion.security.ApiKeySecurityHandler",
        "connexion.security.OAuthSecurityHandler",
        "connexion.security.SecurityHandlerFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(operation.function, types.FunctionType)",
        "assert operation.method == 'GET'",
        "assert operation.produces == ['application/json']",
        "assert operation.consumes == ['application/json']",
        "assert operation.body_schema() == expected_body_schema"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_operation",
          "body": "def make_operation(op, definitions=True, parameters=True):\n    \"\"\"note the wrapper because definitions namespace and\n    operation namespace collide\n    \"\"\"\n    new_op = {'wrapper': copy.deepcopy(op)}\n    if definitions:\n        new_op.update({'definitions': DEFINITIONS})\n    if parameters:\n        new_op.update({'parameters': PARAMETER_DEFINITIONS})\n    return resolve_refs(new_op)['wrapper']"
        }
      ]
    },
    {
      "name": "test_operation_local_security_oauth2",
      "module": "test_operation2",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_operation2.py",
      "line_number": 502,
      "end_line_number": 526,
      "source_code": "def test_operation_local_security_oauth2():\n    class MockOAuthHandler(OAuthSecurityHandler):\n        \"\"\"Mock.\"\"\"\n\n    security_handler_factory = SecurityHandlerFactory({\"oauth2\": MockOAuthHandler})\n    oauth_security_handler = security_handler_factory.security_handlers[\"oauth2\"]\n    verify_oauth = mock.MagicMock(return_value=\"verify_oauth_result\")\n    oauth_security_handler._get_verify_func = verify_oauth\n\n    SecurityOperation(\n        next_app=mock.Mock,\n        security_handler_factory=security_handler_factory,\n        security=[{\"oauth\": [\"uid\"]}],\n        security_schemes=SECURITY_DEFINITIONS_LOCAL,\n    )\n\n    verify_oauth.assert_called_with(\n        math.ceil, oauth_security_handler.validate_scope, [\"uid\"]\n    )\n\n    verify_oauth.assert_called_with(\n        math.ceil,\n        security_handler_factory.security_handlers[\"oauth2\"].validate_scope,\n        [\"uid\"],\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "copy",
        "logging",
        "math",
        "pathlib",
        "types",
        "unittest.mock",
        "pytest",
        "connexion.exceptions.InvalidSpecification",
        "connexion.json_schema.resolve_refs",
        "connexion.jsonifier.Jsonifier",
        "connexion.middleware.security.SecurityOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.resolver.Resolver",
        "connexion.security.ApiKeySecurityHandler",
        "connexion.security.OAuthSecurityHandler",
        "connexion.security.SecurityHandlerFactory"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.MagicMock(return_value='verify_oauth_result')"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_operation_local_security_duplicate_token_info",
      "module": "test_operation2",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_operation2.py",
      "line_number": 529,
      "end_line_number": 551,
      "source_code": "def test_operation_local_security_duplicate_token_info():\n    class MockOAuthHandler(OAuthSecurityHandler):\n        \"\"\"Mock.\"\"\"\n\n    security_handler_factory = SecurityHandlerFactory({\"oauth2\": MockOAuthHandler})\n    oauth_security_handler = security_handler_factory.security_handlers[\"oauth2\"]\n    verify_oauth = mock.MagicMock(return_value=\"verify_oauth_result\")\n    oauth_security_handler._get_verify_func = verify_oauth\n\n    SecurityOperation(\n        next_app=mock.Mock,\n        security_handler_factory=security_handler_factory,\n        security=[{\"oauth\": [\"uid\"]}],\n        security_schemes=SECURITY_DEFINITIONS_BOTH,\n    )\n\n    verify_oauth.call_args.assert_called_with(\n        math.ceil, oauth_security_handler.validate_scope\n    )\n\n    verify_oauth.call_args.assert_called_with(\n        math.ceil, security_handler_factory.security_handlers[\"oauth2\"].validate_scope\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "copy",
        "logging",
        "math",
        "pathlib",
        "types",
        "unittest.mock",
        "pytest",
        "connexion.exceptions.InvalidSpecification",
        "connexion.json_schema.resolve_refs",
        "connexion.jsonifier.Jsonifier",
        "connexion.middleware.security.SecurityOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.resolver.Resolver",
        "connexion.security.ApiKeySecurityHandler",
        "connexion.security.OAuthSecurityHandler",
        "connexion.security.SecurityHandlerFactory"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.MagicMock(return_value='verify_oauth_result')"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_multi_body",
      "module": "test_operation2",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_operation2.py",
      "line_number": 554,
      "end_line_number": 574,
      "source_code": "def test_multi_body(api):\n    with pytest.raises(InvalidSpecification) as exc_info:  # type: py.code.ExceptionInfo\n        op_spec = make_operation(OPERATION2)\n        operation = Swagger2Operation(\n            method=\"GET\",\n            path=\"endpoint\",\n            path_parameters=[],\n            operation=op_spec,\n            app_produces=[\"application/json\"],\n            app_consumes=[\"application/json\"],\n            definitions=DEFINITIONS,\n            resolver=Resolver(),\n        )\n        operation.body_schema()\n\n    exception = exc_info.value\n    assert str(exception) == \"GET endpoint: There can be one 'body' parameter at most\"\n    assert (\n        repr(exception)\n        == \"\"\"<InvalidSpecification: \"GET endpoint: There can be one 'body' parameter at most\">\"\"\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "api"
      ],
      "imports": [
        "copy",
        "logging",
        "math",
        "pathlib",
        "types",
        "unittest.mock",
        "pytest",
        "connexion.exceptions.InvalidSpecification",
        "connexion.json_schema.resolve_refs",
        "connexion.jsonifier.Jsonifier",
        "connexion.middleware.security.SecurityOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.resolver.Resolver",
        "connexion.security.ApiKeySecurityHandler",
        "connexion.security.OAuthSecurityHandler",
        "connexion.security.SecurityHandlerFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(exception) == \"GET endpoint: There can be one 'body' parameter at most\"",
        "assert repr(exception) == '<InvalidSpecification: \"GET endpoint: There can be one \\'body\\' parameter at most\">'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_operation",
          "body": "def make_operation(op, definitions=True, parameters=True):\n    \"\"\"note the wrapper because definitions namespace and\n    operation namespace collide\n    \"\"\"\n    new_op = {'wrapper': copy.deepcopy(op)}\n    if definitions:\n        new_op.update({'definitions': DEFINITIONS})\n    if parameters:\n        new_op.update({'parameters': PARAMETER_DEFINITIONS})\n    return resolve_refs(new_op)['wrapper']"
        }
      ]
    },
    {
      "name": "test_no_token_info",
      "module": "test_operation2",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_operation2.py",
      "line_number": 577,
      "end_line_number": 584,
      "source_code": "def test_no_token_info():\n    security_handler_factory = SecurityHandlerFactory()\n    SecurityOperation(\n        next_app=mock.Mock,\n        security_handler_factory=security_handler_factory,\n        security=[{\"oauth\": [\"uid\"]}],\n        security_schemes=SECURITY_DEFINITIONS_WO_INFO,\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "copy",
        "logging",
        "math",
        "pathlib",
        "types",
        "unittest.mock",
        "pytest",
        "connexion.exceptions.InvalidSpecification",
        "connexion.json_schema.resolve_refs",
        "connexion.jsonifier.Jsonifier",
        "connexion.middleware.security.SecurityOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.resolver.Resolver",
        "connexion.security.ApiKeySecurityHandler",
        "connexion.security.OAuthSecurityHandler",
        "connexion.security.SecurityHandlerFactory"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_multiple_security_schemes_and",
      "module": "test_operation2",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_operation2.py",
      "line_number": 587,
      "end_line_number": 617,
      "source_code": "def test_multiple_security_schemes_and():\n    \"\"\"Tests an operation with multiple security schemes in AND fashion.\"\"\"\n\n    def return_api_key_name(func, in_, name, scopes):\n        return name\n\n    class MockApiKeyHandler(ApiKeySecurityHandler):\n        \"\"\"Mock\"\"\"\n\n    security_handler_factory = SecurityHandlerFactory({\"apiKey\": MockApiKeyHandler})\n    apikey_security_handler = security_handler_factory.security_handlers[\"apiKey\"]\n    verify_api_key = mock.MagicMock(side_effect=return_api_key_name)\n    apikey_security_handler._get_verify_func = verify_api_key\n    verify_multiple = mock.MagicMock(return_value=\"verify_multiple_result\")\n    security_handler_factory.verify_multiple_schemes = verify_multiple\n\n    security = [{\"key1\": [], \"key2\": []}]\n\n    SecurityOperation(\n        next_app=mock.Mock,\n        security_handler_factory=security_handler_factory,\n        security=security,\n        security_schemes=SECURITY_DEFINITIONS_2_KEYS,\n    )\n\n    assert verify_api_key.call_count == 2\n    verify_api_key.assert_any_call(math.ceil, \"header\", \"X-Auth-1\", [])\n    verify_api_key.assert_any_call(math.ceil, \"header\", \"X-Auth-2\", [])\n    # Assert verify_multiple_schemes is called with mapping from scheme name\n    # to result of security_handler_factory.verify_api_key()\n    verify_multiple.assert_called_with({\"key1\": \"X-Auth-1\", \"key2\": \"X-Auth-2\"})",
      "docstring": "Tests an operation with multiple security schemes in AND fashion.",
      "decorators": [],
      "arguments": [],
      "imports": [
        "copy",
        "logging",
        "math",
        "pathlib",
        "types",
        "unittest.mock",
        "pytest",
        "connexion.exceptions.InvalidSpecification",
        "connexion.json_schema.resolve_refs",
        "connexion.jsonifier.Jsonifier",
        "connexion.middleware.security.SecurityOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.resolver.Resolver",
        "connexion.security.ApiKeySecurityHandler",
        "connexion.security.OAuthSecurityHandler",
        "connexion.security.SecurityHandlerFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert verify_api_key.call_count == 2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.MagicMock(side_effect=return_api_key_name)",
        "mock.MagicMock(return_value='verify_multiple_result')"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_multiple_oauth_in_and",
      "module": "test_operation2",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_operation2.py",
      "line_number": 620,
      "end_line_number": 639,
      "source_code": "def test_multiple_oauth_in_and(caplog):\n    \"\"\"Tests an operation with multiple oauth security schemes in AND fashion.\n    These should be ignored and raise a warning.\n    \"\"\"\n    caplog.set_level(logging.WARNING, logger=\"connexion.operations.secure\")\n    security_handler_factory = SecurityHandlerFactory()\n\n    security = [{\"oauth_1\": [\"uid\"], \"oauth_2\": [\"uid\"]}]\n\n    SecurityOperation(\n        next_app=mock.Mock,\n        security_handler_factory=security_handler_factory,\n        security=security,\n        security_schemes=SECURITY_DEFINITIONS_2_OAUTH,\n    )\n\n    assert (\n        \"... multiple OAuth2 security schemes in AND fashion not supported\"\n        in caplog.text\n    )",
      "docstring": "Tests an operation with multiple oauth security schemes in AND fashion.\nThese should be ignored and raise a warning.",
      "decorators": [],
      "arguments": [
        "caplog"
      ],
      "imports": [
        "copy",
        "logging",
        "math",
        "pathlib",
        "types",
        "unittest.mock",
        "pytest",
        "connexion.exceptions.InvalidSpecification",
        "connexion.json_schema.resolve_refs",
        "connexion.jsonifier.Jsonifier",
        "connexion.middleware.security.SecurityOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.resolver.Resolver",
        "connexion.security.ApiKeySecurityHandler",
        "connexion.security.OAuthSecurityHandler",
        "connexion.security.SecurityHandlerFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert '... multiple OAuth2 security schemes in AND fashion not supported' in caplog.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_parameter_reference",
      "module": "test_operation2",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_operation2.py",
      "line_number": 642,
      "end_line_number": 654,
      "source_code": "def test_parameter_reference(api):\n    op_spec = make_operation(OPERATION3, definitions=False)\n    operation = Swagger2Operation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation=op_spec,\n        app_produces=[\"application/json\"],\n        app_consumes=[\"application/json\"],\n        definitions={},\n        resolver=Resolver(),\n    )\n    assert operation.parameters == [{\"in\": \"path\", \"type\": \"integer\"}]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "api"
      ],
      "imports": [
        "copy",
        "logging",
        "math",
        "pathlib",
        "types",
        "unittest.mock",
        "pytest",
        "connexion.exceptions.InvalidSpecification",
        "connexion.json_schema.resolve_refs",
        "connexion.jsonifier.Jsonifier",
        "connexion.middleware.security.SecurityOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.resolver.Resolver",
        "connexion.security.ApiKeySecurityHandler",
        "connexion.security.OAuthSecurityHandler",
        "connexion.security.SecurityHandlerFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert operation.parameters == [{'in': 'path', 'type': 'integer'}]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_operation",
          "body": "def make_operation(op, definitions=True, parameters=True):\n    \"\"\"note the wrapper because definitions namespace and\n    operation namespace collide\n    \"\"\"\n    new_op = {'wrapper': copy.deepcopy(op)}\n    if definitions:\n        new_op.update({'definitions': DEFINITIONS})\n    if parameters:\n        new_op.update({'parameters': PARAMETER_DEFINITIONS})\n    return resolve_refs(new_op)['wrapper']"
        }
      ]
    },
    {
      "name": "test_default",
      "module": "test_operation2",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_operation2.py",
      "line_number": 657,
      "end_line_number": 686,
      "source_code": "def test_default(api):\n    op_spec = make_operation(OPERATION4)\n    op_spec[\"parameters\"][1][\"default\"] = 1\n    Swagger2Operation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation=op_spec,\n        app_produces=[\"application/json\"],\n        app_consumes=[\"application/json\"],\n        definitions=DEFINITIONS,\n        resolver=Resolver(),\n    )\n    op_spec = make_operation(OPERATION6, parameters=False)\n    op_spec[\"parameters\"][0][\"default\"] = {\n        \"keep_stacks\": 1,\n        \"image_version\": \"one\",\n        \"senza_yaml\": \"senza.yaml\",\n        \"new_traffic\": 100,\n    }\n    Swagger2Operation(\n        method=\"POST\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation=op_spec,\n        app_produces=[\"application/json\"],\n        app_consumes=[\"application/json\"],\n        definitions=DEFINITIONS,\n        resolver=Resolver(),\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "api"
      ],
      "imports": [
        "copy",
        "logging",
        "math",
        "pathlib",
        "types",
        "unittest.mock",
        "pytest",
        "connexion.exceptions.InvalidSpecification",
        "connexion.json_schema.resolve_refs",
        "connexion.jsonifier.Jsonifier",
        "connexion.middleware.security.SecurityOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.resolver.Resolver",
        "connexion.security.ApiKeySecurityHandler",
        "connexion.security.OAuthSecurityHandler",
        "connexion.security.SecurityHandlerFactory"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_operation",
          "body": "def make_operation(op, definitions=True, parameters=True):\n    \"\"\"note the wrapper because definitions namespace and\n    operation namespace collide\n    \"\"\"\n    new_op = {'wrapper': copy.deepcopy(op)}\n    if definitions:\n        new_op.update({'definitions': DEFINITIONS})\n    if parameters:\n        new_op.update({'parameters': PARAMETER_DEFINITIONS})\n    return resolve_refs(new_op)['wrapper']"
        },
        {
          "name": "make_operation",
          "body": "def make_operation(op, definitions=True, parameters=True):\n    \"\"\"note the wrapper because definitions namespace and\n    operation namespace collide\n    \"\"\"\n    new_op = {'wrapper': copy.deepcopy(op)}\n    if definitions:\n        new_op.update({'definitions': DEFINITIONS})\n    if parameters:\n        new_op.update({'parameters': PARAMETER_DEFINITIONS})\n    return resolve_refs(new_op)['wrapper']"
        }
      ]
    },
    {
      "name": "test_get_path_parameter_types",
      "module": "test_operation2",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_operation2.py",
      "line_number": 689,
      "end_line_number": 712,
      "source_code": "def test_get_path_parameter_types(api):\n    op_spec = make_operation(OPERATION1, parameters=False)\n    op_spec[\"parameters\"] = [\n        {\"in\": \"path\", \"type\": \"int\", \"name\": \"int_path\"},\n        {\"in\": \"path\", \"type\": \"string\", \"name\": \"string_path\"},\n        {\"in\": \"path\", \"type\": \"string\", \"format\": \"path\", \"name\": \"path_path\"},\n    ]\n\n    operation = Swagger2Operation(\n        method=\"GET\",\n        path=\"endpoint\",\n        path_parameters=[],\n        operation=op_spec,\n        app_produces=[\"application/json\"],\n        app_consumes=[\"application/json\"],\n        definitions=DEFINITIONS,\n        resolver=Resolver(),\n    )\n\n    assert {\n        \"int_path\": \"int\",\n        \"string_path\": \"string\",\n        \"path_path\": \"path\",\n    } == operation.get_path_parameter_types()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "api"
      ],
      "imports": [
        "copy",
        "logging",
        "math",
        "pathlib",
        "types",
        "unittest.mock",
        "pytest",
        "connexion.exceptions.InvalidSpecification",
        "connexion.json_schema.resolve_refs",
        "connexion.jsonifier.Jsonifier",
        "connexion.middleware.security.SecurityOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.resolver.Resolver",
        "connexion.security.ApiKeySecurityHandler",
        "connexion.security.OAuthSecurityHandler",
        "connexion.security.SecurityHandlerFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert {'int_path': 'int', 'string_path': 'string', 'path_path': 'path'} == operation.get_path_parameter_types()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_operation",
          "body": "def make_operation(op, definitions=True, parameters=True):\n    \"\"\"note the wrapper because definitions namespace and\n    operation namespace collide\n    \"\"\"\n    new_op = {'wrapper': copy.deepcopy(op)}\n    if definitions:\n        new_op.update({'definitions': DEFINITIONS})\n    if parameters:\n        new_op.update({'parameters': PARAMETER_DEFINITIONS})\n    return resolve_refs(new_op)['wrapper']"
        }
      ]
    },
    {
      "name": "test_oauth_scopes_in_or",
      "module": "test_operation2",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_operation2.py",
      "line_number": 715,
      "end_line_number": 740,
      "source_code": "def test_oauth_scopes_in_or():\n    \"\"\"Tests whether an OAuth security scheme with 2 different possible scopes is correctly handled.\"\"\"\n\n    class MockOAuthFactory(OAuthSecurityHandler):\n        \"\"\"Mock.\"\"\"\n\n    security_handler_factory = SecurityHandlerFactory({\"oauth2\": MockOAuthFactory})\n    oauth_security_handler = security_handler_factory.security_handlers[\"oauth2\"]\n    verify_oauth = mock.MagicMock(return_value=\"verify_oauth_result\")\n    oauth_security_handler._get_verify_func = verify_oauth\n\n    security = [{\"oauth\": [\"myscope\"]}, {\"oauth\": [\"myscope2\"]}]\n\n    SecurityOperation(\n        next_app=mock.Mock,\n        security_handler_factory=security_handler_factory,\n        security=security,\n        security_schemes=SECURITY_DEFINITIONS_LOCAL,\n    )\n\n    verify_oauth.assert_has_calls(\n        [\n            mock.call(math.ceil, oauth_security_handler.validate_scope, [\"myscope\"]),\n            mock.call(math.ceil, oauth_security_handler.validate_scope, [\"myscope2\"]),\n        ]\n    )",
      "docstring": "Tests whether an OAuth security scheme with 2 different possible scopes is correctly handled.",
      "decorators": [],
      "arguments": [],
      "imports": [
        "copy",
        "logging",
        "math",
        "pathlib",
        "types",
        "unittest.mock",
        "pytest",
        "connexion.exceptions.InvalidSpecification",
        "connexion.json_schema.resolve_refs",
        "connexion.jsonifier.Jsonifier",
        "connexion.middleware.security.SecurityOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.resolver.Resolver",
        "connexion.security.ApiKeySecurityHandler",
        "connexion.security.OAuthSecurityHandler",
        "connexion.security.SecurityHandlerFactory"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.MagicMock(return_value='verify_oauth_result')"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_form_transformation",
      "module": "test_operation2",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_operation2.py",
      "line_number": 743,
      "end_line_number": 798,
      "source_code": "def test_form_transformation(api):\n    mock_self = mock.Mock()\n\n    swagger_form_parameters = [\n        {\n            \"in\": \"formData\",\n            \"name\": \"param\",\n            \"type\": \"string\",\n            \"default\": \"foo@bar.com\",\n            \"required\": True,\n            \"format\": \"email\",\n        },\n        {\n            \"in\": \"formData\",\n            \"name\": \"array_param\",\n            \"type\": \"array\",\n            \"items\": {\n                \"type\": \"integer\",\n            },\n            \"collectionFormat\": \"multi\",\n            \"x-nullable\": True,\n        },\n    ]\n\n    openapi_expected = {\n        \"schema\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"param\": {\n                    \"type\": \"string\",\n                    \"format\": \"email\",\n                    \"default\": \"foo@bar.com\",\n                },\n                \"array_param\": {\n                    \"type\": \"array\",\n                    \"items\": {\n                        \"type\": \"integer\",\n                    },\n                    \"nullable\": True,\n                },\n            },\n            \"default\": {\"param\": \"foo@bar.com\"},\n            \"required\": [\"param\"],\n        },\n        \"encoding\": {\n            \"array_param\": {\n                \"style\": \"form\",\n                \"explode\": True,\n            }\n        },\n    }\n\n    assert (\n        Swagger2Operation._transform_form(mock_self, swagger_form_parameters)\n        == openapi_expected\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "api"
      ],
      "imports": [
        "copy",
        "logging",
        "math",
        "pathlib",
        "types",
        "unittest.mock",
        "pytest",
        "connexion.exceptions.InvalidSpecification",
        "connexion.json_schema.resolve_refs",
        "connexion.jsonifier.Jsonifier",
        "connexion.middleware.security.SecurityOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.resolver.Resolver",
        "connexion.security.ApiKeySecurityHandler",
        "connexion.security.OAuthSecurityHandler",
        "connexion.security.SecurityHandlerFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert Swagger2Operation._transform_form(mock_self, swagger_form_parameters) == openapi_expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.Mock()"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_print_version",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_cli.py",
      "line_number": 70,
      "end_line_number": 77,
      "source_code": "def test_print_version():\n\n    output = io.StringIO()\n    with pytest.raises(SystemExit) as e_info, contextlib.redirect_stdout(output):\n        main([\"--version\"])\n\n    assert e_info.value.code == 0\n    assert f\"Connexion {importlib_metadata.version('connexion')}\" in output.getvalue()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "contextlib",
        "io",
        "logging",
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.cli.main",
        "connexion.exceptions.ResolverError",
        "connexion.options.SwaggerUIOptions",
        "conftest.FIXTURES_FOLDER",
        "importlib_metadata",
        "importlib.metadata"
      ],
      "fixtures": [],
      "assertions": [
        "assert e_info.value.code == 0",
        "assert f\"Connexion {importlib_metadata.version('connexion')}\" in output.getvalue()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_run_missing_spec",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_cli.py",
      "line_number": 80,
      "end_line_number": 86,
      "source_code": "def test_run_missing_spec():\n    output = io.StringIO()\n    with pytest.raises(SystemExit) as e_info, contextlib.redirect_stderr(output):\n        main([\"run\"])\n\n    assert e_info.value.code != 0\n    assert \"the following arguments are required: spec_file\" in output.getvalue()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "contextlib",
        "io",
        "logging",
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.cli.main",
        "connexion.exceptions.ResolverError",
        "connexion.options.SwaggerUIOptions",
        "conftest.FIXTURES_FOLDER",
        "importlib_metadata",
        "importlib.metadata"
      ],
      "fixtures": [],
      "assertions": [
        "assert e_info.value.code != 0",
        "assert 'the following arguments are required: spec_file' in output.getvalue()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_run_simple_spec",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_cli.py",
      "line_number": 89,
      "end_line_number": 93,
      "source_code": "def test_run_simple_spec(mock_app_run, spec_file):\n    main([\"run\", spec_file])\n\n    app_instance = mock_app_run()\n    app_instance.run.assert_called()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "mock_app_run",
        "spec_file"
      ],
      "imports": [
        "contextlib",
        "io",
        "logging",
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.cli.main",
        "connexion.exceptions.ResolverError",
        "connexion.options.SwaggerUIOptions",
        "conftest.FIXTURES_FOLDER",
        "importlib_metadata",
        "importlib.metadata"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "mock_app_run",
          "body": "@pytest.fixture(scope='function')\ndef mock_app_run(app_class, monkeypatch):\n    mocked_app = MagicMock(name='mocked_app', wraps=app_class(__name__))\n\n    def mocked_run(*args, **kwargs):\n        mocked_app.middleware._build_middleware_stack()\n    mocked_app.run = MagicMock(name='mocked_app.run', side_effect=mocked_run)\n\n    def get_mocked_app(*args, **kwargs):\n        return mocked_app\n    mocked_app_class = MagicMock(name='mocked_app_class', side_effect=get_mocked_app)\n\n    def get_mocked_app_class(*args, **kwargs):\n        return mocked_app_class\n    monkeypatch.setattr('connexion.cli.connexion.utils.get_function_from_name', get_mocked_app_class)\n    return mocked_app_class"
        }
      ]
    },
    {
      "name": "test_run_spec_with_host",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_cli.py",
      "line_number": 96,
      "end_line_number": 100,
      "source_code": "def test_run_spec_with_host(mock_app_run, spec_file):\n    main([\"run\", spec_file, \"--host\", \"custom.host\"])\n\n    app_instance = mock_app_run()\n    app_instance.run.assert_called()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "mock_app_run",
        "spec_file"
      ],
      "imports": [
        "contextlib",
        "io",
        "logging",
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.cli.main",
        "connexion.exceptions.ResolverError",
        "connexion.options.SwaggerUIOptions",
        "conftest.FIXTURES_FOLDER",
        "importlib_metadata",
        "importlib.metadata"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "mock_app_run",
          "body": "@pytest.fixture(scope='function')\ndef mock_app_run(app_class, monkeypatch):\n    mocked_app = MagicMock(name='mocked_app', wraps=app_class(__name__))\n\n    def mocked_run(*args, **kwargs):\n        mocked_app.middleware._build_middleware_stack()\n    mocked_app.run = MagicMock(name='mocked_app.run', side_effect=mocked_run)\n\n    def get_mocked_app(*args, **kwargs):\n        return mocked_app\n    mocked_app_class = MagicMock(name='mocked_app_class', side_effect=get_mocked_app)\n\n    def get_mocked_app_class(*args, **kwargs):\n        return mocked_app_class\n    monkeypatch.setattr('connexion.cli.connexion.utils.get_function_from_name', get_mocked_app_class)\n    return mocked_app_class"
        }
      ]
    },
    {
      "name": "test_run_no_options_all_default",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_cli.py",
      "line_number": 103,
      "end_line_number": 105,
      "source_code": "def test_run_no_options_all_default(mock_app_run, expected_arguments, spec_file):\n    main([\"run\", spec_file])\n    mock_app_run.assert_called_with(\"connexion.cli\", **expected_arguments)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "mock_app_run",
        "expected_arguments",
        "spec_file"
      ],
      "imports": [
        "contextlib",
        "io",
        "logging",
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.cli.main",
        "connexion.exceptions.ResolverError",
        "connexion.options.SwaggerUIOptions",
        "conftest.FIXTURES_FOLDER",
        "importlib_metadata",
        "importlib.metadata"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_run_using_option_console_ui_from",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_cli.py",
      "line_number": 108,
      "end_line_number": 113,
      "source_code": "def test_run_using_option_console_ui_from(mock_app_run, expected_arguments, spec_file):\n    user_path = \"/some/path/here\"\n    main([\"run\", spec_file, \"--swagger-ui-template-dir\", user_path])\n\n    expected_arguments[\"swagger_ui_options\"].swagger_ui_template_dir = user_path\n    mock_app_run.assert_called_with(\"connexion.cli\", **expected_arguments)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "mock_app_run",
        "expected_arguments",
        "spec_file"
      ],
      "imports": [
        "contextlib",
        "io",
        "logging",
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.cli.main",
        "connexion.exceptions.ResolverError",
        "connexion.options.SwaggerUIOptions",
        "conftest.FIXTURES_FOLDER",
        "importlib_metadata",
        "importlib.metadata"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_run_using_option_console_ui_url",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_cli.py",
      "line_number": 116,
      "end_line_number": 121,
      "source_code": "def test_run_using_option_console_ui_url(mock_app_run, expected_arguments, spec_file):\n    user_url = \"/console_ui_test\"\n    main([\"run\", spec_file, \"--swagger-ui-path\", user_url])\n\n    expected_arguments[\"swagger_ui_options\"].swagger_ui_path = user_url\n    mock_app_run.assert_called_with(\"connexion.cli\", **expected_arguments)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "mock_app_run",
        "expected_arguments",
        "spec_file"
      ],
      "imports": [
        "contextlib",
        "io",
        "logging",
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.cli.main",
        "connexion.exceptions.ResolverError",
        "connexion.options.SwaggerUIOptions",
        "conftest.FIXTURES_FOLDER",
        "importlib_metadata",
        "importlib.metadata"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_run_using_option_auth_all_paths",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_cli.py",
      "line_number": 124,
      "end_line_number": 128,
      "source_code": "def test_run_using_option_auth_all_paths(mock_app_run, expected_arguments, spec_file):\n    main([\"run\", spec_file, \"--auth-all-paths\"])\n\n    expected_arguments[\"auth_all_paths\"] = True\n    mock_app_run.assert_called_with(\"connexion.cli\", **expected_arguments)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "mock_app_run",
        "expected_arguments",
        "spec_file"
      ],
      "imports": [
        "contextlib",
        "io",
        "logging",
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.cli.main",
        "connexion.exceptions.ResolverError",
        "connexion.options.SwaggerUIOptions",
        "conftest.FIXTURES_FOLDER",
        "importlib_metadata",
        "importlib.metadata"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_run_in_very_verbose_mode",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_cli.py",
      "line_number": 131,
      "end_line_number": 141,
      "source_code": "def test_run_in_very_verbose_mode(\n    mock_app_run, expected_arguments, spec_file, monkeypatch\n):\n    logging_config = MagicMock(name=\"connexion.cli.logging.basicConfig\")\n    monkeypatch.setattr(\"connexion.cli.logging.basicConfig\", logging_config)\n\n    main([\"run\", spec_file, \"-vv\"])\n\n    logging_config.assert_called_with(level=logging.DEBUG)\n\n    mock_app_run.assert_called_with(\"connexion.cli\", **expected_arguments)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "mock_app_run",
        "expected_arguments",
        "spec_file",
        "monkeypatch"
      ],
      "imports": [
        "contextlib",
        "io",
        "logging",
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.cli.main",
        "connexion.exceptions.ResolverError",
        "connexion.options.SwaggerUIOptions",
        "conftest.FIXTURES_FOLDER",
        "importlib_metadata",
        "importlib.metadata"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_run_in_verbose_mode",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_cli.py",
      "line_number": 144,
      "end_line_number": 152,
      "source_code": "def test_run_in_verbose_mode(mock_app_run, expected_arguments, spec_file, monkeypatch):\n    logging_config = MagicMock(name=\"connexion.cli.logging.basicConfig\")\n    monkeypatch.setattr(\"connexion.cli.logging.basicConfig\", logging_config)\n\n    main([\"run\", spec_file, \"-v\"])\n\n    logging_config.assert_called_with(level=logging.INFO)\n\n    mock_app_run.assert_called_with(\"connexion.cli\", **expected_arguments)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "mock_app_run",
        "expected_arguments",
        "spec_file",
        "monkeypatch"
      ],
      "imports": [
        "contextlib",
        "io",
        "logging",
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.cli.main",
        "connexion.exceptions.ResolverError",
        "connexion.options.SwaggerUIOptions",
        "conftest.FIXTURES_FOLDER",
        "importlib_metadata",
        "importlib.metadata"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_run_using_option_base_path",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_cli.py",
      "line_number": 155,
      "end_line_number": 165,
      "source_code": "def test_run_using_option_base_path(mock_app_run, expected_arguments, spec_file):\n    main([\"run\", spec_file, \"--base-path\", \"/foo\"])\n\n    expected_arguments = dict(\n        base_path=\"/foo\",\n        resolver_error=None,\n        validate_responses=False,\n        strict_validation=False,\n    )\n    app_instance = mock_app_run()\n    app_instance.add_api.assert_called_with(spec_file, **expected_arguments)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "mock_app_run",
        "expected_arguments",
        "spec_file"
      ],
      "imports": [
        "contextlib",
        "io",
        "logging",
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.cli.main",
        "connexion.exceptions.ResolverError",
        "connexion.options.SwaggerUIOptions",
        "conftest.FIXTURES_FOLDER",
        "importlib_metadata",
        "importlib.metadata"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "mock_app_run",
          "body": "@pytest.fixture(scope='function')\ndef mock_app_run(app_class, monkeypatch):\n    mocked_app = MagicMock(name='mocked_app', wraps=app_class(__name__))\n\n    def mocked_run(*args, **kwargs):\n        mocked_app.middleware._build_middleware_stack()\n    mocked_app.run = MagicMock(name='mocked_app.run', side_effect=mocked_run)\n\n    def get_mocked_app(*args, **kwargs):\n        return mocked_app\n    mocked_app_class = MagicMock(name='mocked_app_class', side_effect=get_mocked_app)\n\n    def get_mocked_app_class(*args, **kwargs):\n        return mocked_app_class\n    monkeypatch.setattr('connexion.cli.connexion.utils.get_function_from_name', get_mocked_app_class)\n    return mocked_app_class"
        }
      ]
    },
    {
      "name": "test_run_unimplemented_operations",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_cli.py",
      "line_number": 168,
      "end_line_number": 175,
      "source_code": "def test_run_unimplemented_operations(mock_app_run):\n    spec_file = str(FIXTURES_FOLDER / \"missing_implementation/swagger.yaml\")\n    with pytest.raises(ResolverError):\n        main([\"run\", spec_file])\n\n    spec_file = str(FIXTURES_FOLDER / \"module_does_not_exist/swagger.yaml\")\n    with pytest.raises(ResolverError):\n        main([\"run\", spec_file])",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "mock_app_run"
      ],
      "imports": [
        "contextlib",
        "io",
        "logging",
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.cli.main",
        "connexion.exceptions.ResolverError",
        "connexion.options.SwaggerUIOptions",
        "conftest.FIXTURES_FOLDER",
        "importlib_metadata",
        "importlib.metadata"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_run_unimplemented_operations_with_stub1",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_cli.py",
      "line_number": 178,
      "end_line_number": 180,
      "source_code": "def test_run_unimplemented_operations_with_stub1(mock_app_run):\n    spec_file = str(FIXTURES_FOLDER / \"missing_implementation/swagger.yaml\")\n    main([\"run\", spec_file, \"--stub\"])",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "mock_app_run"
      ],
      "imports": [
        "contextlib",
        "io",
        "logging",
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.cli.main",
        "connexion.exceptions.ResolverError",
        "connexion.options.SwaggerUIOptions",
        "conftest.FIXTURES_FOLDER",
        "importlib_metadata",
        "importlib.metadata"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_run_unimplemented_operations_with_stub2",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_cli.py",
      "line_number": 183,
      "end_line_number": 185,
      "source_code": "def test_run_unimplemented_operations_with_stub2(mock_app_run):\n    spec_file = str(FIXTURES_FOLDER / \"module_does_not_exist/swagger.yaml\")\n    main([\"run\", spec_file, \"--stub\"])",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "mock_app_run"
      ],
      "imports": [
        "contextlib",
        "io",
        "logging",
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.cli.main",
        "connexion.exceptions.ResolverError",
        "connexion.options.SwaggerUIOptions",
        "conftest.FIXTURES_FOLDER",
        "importlib_metadata",
        "importlib.metadata"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_run_unimplemented_operations_and_mock",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_cli.py",
      "line_number": 188,
      "end_line_number": 190,
      "source_code": "def test_run_unimplemented_operations_and_mock(mock_app_run):\n    spec_file = str(FIXTURES_FOLDER / \"missing_implementation/swagger.yaml\")\n    main([\"run\", spec_file, \"--mock=all\"])",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "mock_app_run"
      ],
      "imports": [
        "contextlib",
        "io",
        "logging",
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.cli.main",
        "connexion.exceptions.ResolverError",
        "connexion.options.SwaggerUIOptions",
        "conftest.FIXTURES_FOLDER",
        "importlib_metadata",
        "importlib.metadata"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_media_type_dict",
      "module": "test_datastructures",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/test_datastructures.py",
      "line_number": 4,
      "end_line_number": 22,
      "source_code": "def test_media_type_dict():\n    d = MediaTypeDict(\n        {\n            \"*/*\": \"*/*\",\n            \"*/json\": \"*/json\",\n            \"*/*json\": \"*/*json\",\n            \"multipart/*\": \"multipart/*\",\n            \"multipart/form-data\": \"multipart/form-data\",\n        }\n    )\n\n    assert d[\"application/json\"] == \"*/json\"\n    assert d[\"application/problem+json\"] == \"*/*json\"\n    assert d[\"application/x-www-form-urlencoded\"] == \"*/*\"\n    assert d[\"multipart/form-data\"] == \"multipart/form-data\"\n    assert d[\"multipart/byteranges\"] == \"multipart/*\"\n\n    # Test __contains__\n    assert \"application/json\" in d",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "connexion.datastructures.MediaTypeDict"
      ],
      "fixtures": [],
      "assertions": [
        "assert d['application/json'] == '*/json'",
        "assert d['application/problem+json'] == '*/*json'",
        "assert d['application/x-www-form-urlencoded'] == '*/*'",
        "assert d['multipart/form-data'] == 'multipart/form-data'",
        "assert d['multipart/byteranges'] == 'multipart/*'",
        "assert 'application/json' in d"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get_valid_parameter",
      "module": "test_validation",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/decorators/test_validation.py",
      "line_number": 10,
      "end_line_number": 14,
      "source_code": "def test_get_valid_parameter():\n    result = ParameterValidator.validate_parameter(\n        \"formdata\", 20, {\"type\": \"number\", \"name\": \"foobar\"}\n    )\n    assert result is None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.json_schema.Draft4ResponseValidator",
        "connexion.utils.coerce_type",
        "connexion.validators.parameter.ParameterValidator",
        "jsonschema.ValidationError"
      ],
      "fixtures": [],
      "assertions": [
        "assert result is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get_valid_parameter_with_required_attr",
      "module": "test_validation",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/decorators/test_validation.py",
      "line_number": 17,
      "end_line_number": 20,
      "source_code": "def test_get_valid_parameter_with_required_attr():\n    param = {\"type\": \"number\", \"required\": True, \"name\": \"foobar\"}\n    result = ParameterValidator.validate_parameter(\"formdata\", 20, param)\n    assert result is None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.json_schema.Draft4ResponseValidator",
        "connexion.utils.coerce_type",
        "connexion.validators.parameter.ParameterValidator",
        "jsonschema.ValidationError"
      ],
      "fixtures": [],
      "assertions": [
        "assert result is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get_valid_path_parameter",
      "module": "test_validation",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/decorators/test_validation.py",
      "line_number": 23,
      "end_line_number": 26,
      "source_code": "def test_get_valid_path_parameter():\n    param = {\"required\": True, \"schema\": {\"type\": \"number\"}, \"name\": \"foobar\"}\n    result = ParameterValidator.validate_parameter(\"path\", 20, param)\n    assert result is None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.json_schema.Draft4ResponseValidator",
        "connexion.utils.coerce_type",
        "connexion.validators.parameter.ParameterValidator",
        "jsonschema.ValidationError"
      ],
      "fixtures": [],
      "assertions": [
        "assert result is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get_missing_required_parameter",
      "module": "test_validation",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/decorators/test_validation.py",
      "line_number": 29,
      "end_line_number": 32,
      "source_code": "def test_get_missing_required_parameter():\n    param = {\"type\": \"number\", \"required\": True, \"name\": \"foo\"}\n    result = ParameterValidator.validate_parameter(\"formdata\", None, param)\n    assert result == \"Missing formdata parameter 'foo'\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.json_schema.Draft4ResponseValidator",
        "connexion.utils.coerce_type",
        "connexion.validators.parameter.ParameterValidator",
        "jsonschema.ValidationError"
      ],
      "fixtures": [],
      "assertions": [
        "assert result == \"Missing formdata parameter 'foo'\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get_x_nullable_parameter",
      "module": "test_validation",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/decorators/test_validation.py",
      "line_number": 35,
      "end_line_number": 38,
      "source_code": "def test_get_x_nullable_parameter():\n    param = {\"type\": \"number\", \"required\": True, \"name\": \"foo\", \"x-nullable\": True}\n    result = ParameterValidator.validate_parameter(\"formdata\", \"None\", param)\n    assert result is None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.json_schema.Draft4ResponseValidator",
        "connexion.utils.coerce_type",
        "connexion.validators.parameter.ParameterValidator",
        "jsonschema.ValidationError"
      ],
      "fixtures": [],
      "assertions": [
        "assert result is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get_nullable_parameter",
      "module": "test_validation",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/decorators/test_validation.py",
      "line_number": 41,
      "end_line_number": 48,
      "source_code": "def test_get_nullable_parameter():\n    param = {\n        \"schema\": {\"type\": \"number\", \"nullable\": True},\n        \"required\": True,\n        \"name\": \"foo\",\n    }\n    result = ParameterValidator.validate_parameter(\"query\", \"null\", param)\n    assert result is None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.json_schema.Draft4ResponseValidator",
        "connexion.utils.coerce_type",
        "connexion.validators.parameter.ParameterValidator",
        "jsonschema.ValidationError"
      ],
      "fixtures": [],
      "assertions": [
        "assert result is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get_explodable_object_parameter",
      "module": "test_validation",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/decorators/test_validation.py",
      "line_number": 51,
      "end_line_number": 60,
      "source_code": "def test_get_explodable_object_parameter():\n    param = {\n        \"schema\": {\"type\": \"object\", \"additionalProperties\": True},\n        \"required\": True,\n        \"name\": \"foo\",\n        \"style\": \"deepObject\",\n        \"explode\": True,\n    }\n    result = ParameterValidator.validate_parameter(\"query\", {\"bar\": 1}, param)\n    assert result is None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.json_schema.Draft4ResponseValidator",
        "connexion.utils.coerce_type",
        "connexion.validators.parameter.ParameterValidator",
        "jsonschema.ValidationError"
      ],
      "fixtures": [],
      "assertions": [
        "assert result is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get_valid_parameter_with_enum_array_header",
      "module": "test_validation",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/decorators/test_validation.py",
      "line_number": 63,
      "end_line_number": 74,
      "source_code": "def test_get_valid_parameter_with_enum_array_header():\n    value = \"VALUE1,VALUE2\"\n    param = {\n        \"schema\": {\n            \"type\": \"array\",\n            \"items\": {\"type\": \"string\", \"enum\": [\"VALUE1\", \"VALUE2\"]},\n        },\n        \"name\": \"test_header_param\",\n    }\n    value = coerce_type(param, value, \"header\", \"test_header_param\")\n    result = ParameterValidator.validate_parameter(\"header\", value, param)\n    assert result is None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.json_schema.Draft4ResponseValidator",
        "connexion.utils.coerce_type",
        "connexion.validators.parameter.ParameterValidator",
        "jsonschema.ValidationError"
      ],
      "fixtures": [],
      "assertions": [
        "assert result is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_invalid_type",
      "module": "test_validation",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/decorators/test_validation.py",
      "line_number": 77,
      "end_line_number": 90,
      "source_code": "def test_invalid_type(monkeypatch):\n    logger = MagicMock()\n    monkeypatch.setattr(\"connexion.validators.parameter.logger\", logger)\n    result = ParameterValidator.validate_parameter(\n        \"formdata\", 20, {\"name\": \"foo\", \"type\": \"string\"}\n    )\n    expected_result = \"\"\"20 is not of type 'string'\n\nFailed validating 'type' in schema:\n    {'name': 'foo', 'type': 'string'}\n\nOn instance:\n    20\"\"\"\n    assert result == expected_result",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.json_schema.Draft4ResponseValidator",
        "connexion.utils.coerce_type",
        "connexion.validators.parameter.ParameterValidator",
        "jsonschema.ValidationError"
      ],
      "fixtures": [],
      "assertions": [
        "assert result == expected_result"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_invalid_type_value_error",
      "module": "test_validation",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/decorators/test_validation.py",
      "line_number": 93,
      "end_line_number": 98,
      "source_code": "def test_invalid_type_value_error(monkeypatch):\n    value = {\"test\": 1, \"second\": 2}\n    result = ParameterValidator.validate_parameter(\n        \"formdata\", value, {\"type\": \"boolean\", \"name\": \"foo\"}\n    )\n    assert result.startswith(\"{'test': 1, 'second': 2} is not of type 'boolean'\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.json_schema.Draft4ResponseValidator",
        "connexion.utils.coerce_type",
        "connexion.validators.parameter.ParameterValidator",
        "jsonschema.ValidationError"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.startswith(\"{'test': 1, 'second': 2} is not of type 'boolean'\")"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_enum_error",
      "module": "test_validation",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/decorators/test_validation.py",
      "line_number": 101,
      "end_line_number": 105,
      "source_code": "def test_enum_error(monkeypatch):\n    value = \"INVALID\"\n    param = {\"schema\": {\"type\": \"string\", \"enum\": [\"valid\"]}, \"name\": \"test_path_param\"}\n    result = ParameterValidator.validate_parameter(\"path\", value, param)\n    assert result.startswith(\"'INVALID' is not one of ['valid']\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.json_schema.Draft4ResponseValidator",
        "connexion.utils.coerce_type",
        "connexion.validators.parameter.ParameterValidator",
        "jsonschema.ValidationError"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.startswith(\"'INVALID' is not one of ['valid']\")"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_support_nullable_properties",
      "module": "test_validation",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/decorators/test_validation.py",
      "line_number": 108,
      "end_line_number": 116,
      "source_code": "def test_support_nullable_properties():\n    schema = {\n        \"type\": \"object\",\n        \"properties\": {\"foo\": {\"type\": \"string\", \"x-nullable\": True}},\n    }\n    try:\n        Draft4RequestValidator(schema).validate({\"foo\": None})\n    except ValidationError:\n        pytest.fail(\"Shouldn't raise ValidationError\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.json_schema.Draft4ResponseValidator",
        "connexion.utils.coerce_type",
        "connexion.validators.parameter.ParameterValidator",
        "jsonschema.ValidationError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_support_nullable_properties_raises_validation_error",
      "module": "test_validation",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/decorators/test_validation.py",
      "line_number": 119,
      "end_line_number": 126,
      "source_code": "def test_support_nullable_properties_raises_validation_error():\n    schema = {\n        \"type\": \"object\",\n        \"properties\": {\"foo\": {\"type\": \"string\", \"x-nullable\": False}},\n    }\n\n    with pytest.raises(ValidationError):\n        Draft4RequestValidator(schema).validate({\"foo\": None})",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.json_schema.Draft4ResponseValidator",
        "connexion.utils.coerce_type",
        "connexion.validators.parameter.ParameterValidator",
        "jsonschema.ValidationError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_support_nullable_properties_not_iterable",
      "module": "test_validation",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/decorators/test_validation.py",
      "line_number": 129,
      "end_line_number": 135,
      "source_code": "def test_support_nullable_properties_not_iterable():\n    schema = {\n        \"type\": \"object\",\n        \"properties\": {\"foo\": {\"type\": \"string\", \"x-nullable\": True}},\n    }\n    with pytest.raises(ValidationError):\n        Draft4RequestValidator(schema).validate(12345)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.json_schema.Draft4ResponseValidator",
        "connexion.utils.coerce_type",
        "connexion.validators.parameter.ParameterValidator",
        "jsonschema.ValidationError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_nullable_enum",
      "module": "test_validation",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/decorators/test_validation.py",
      "line_number": 138,
      "end_line_number": 143,
      "source_code": "def test_nullable_enum():\n    schema = {\"enum\": [\"foo\", 7], \"nullable\": True}\n    try:\n        Draft4RequestValidator(schema).validate(None)\n    except ValidationError:\n        pytest.fail(\"Shouldn't raise ValidationError\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.json_schema.Draft4ResponseValidator",
        "connexion.utils.coerce_type",
        "connexion.validators.parameter.ParameterValidator",
        "jsonschema.ValidationError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_nullable_enum_error",
      "module": "test_validation",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/decorators/test_validation.py",
      "line_number": 146,
      "end_line_number": 149,
      "source_code": "def test_nullable_enum_error():\n    schema = {\"enum\": [\"foo\", 7]}\n    with pytest.raises(ValidationError):\n        Draft4RequestValidator(schema).validate(None)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.json_schema.Draft4ResponseValidator",
        "connexion.utils.coerce_type",
        "connexion.validators.parameter.ParameterValidator",
        "jsonschema.ValidationError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_writeonly_value",
      "module": "test_validation",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/decorators/test_validation.py",
      "line_number": 152,
      "end_line_number": 160,
      "source_code": "def test_writeonly_value():\n    schema = {\n        \"type\": \"object\",\n        \"properties\": {\"foo\": {\"type\": \"string\", \"writeOnly\": True}},\n    }\n    try:\n        Draft4RequestValidator(schema).validate({\"foo\": \"bar\"})\n    except ValidationError:\n        pytest.fail(\"Shouldn't raise ValidationError\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.json_schema.Draft4ResponseValidator",
        "connexion.utils.coerce_type",
        "connexion.validators.parameter.ParameterValidator",
        "jsonschema.ValidationError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_writeonly_value_error",
      "module": "test_validation",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/decorators/test_validation.py",
      "line_number": 163,
      "end_line_number": 169,
      "source_code": "def test_writeonly_value_error():\n    schema = {\n        \"type\": \"object\",\n        \"properties\": {\"foo\": {\"type\": \"string\", \"writeOnly\": True}},\n    }\n    with pytest.raises(ValidationError):\n        Draft4ResponseValidator(schema).validate({\"foo\": \"bar\"})",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.json_schema.Draft4ResponseValidator",
        "connexion.utils.coerce_type",
        "connexion.validators.parameter.ParameterValidator",
        "jsonschema.ValidationError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_writeonly_required",
      "module": "test_validation",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/decorators/test_validation.py",
      "line_number": 172,
      "end_line_number": 181,
      "source_code": "def test_writeonly_required():\n    schema = {\n        \"type\": \"object\",\n        \"required\": [\"foo\"],\n        \"properties\": {\"foo\": {\"type\": \"string\", \"writeOnly\": True}},\n    }\n    try:\n        Draft4RequestValidator(schema).validate({\"foo\": \"bar\"})\n    except ValidationError:\n        pytest.fail(\"Shouldn't raise ValidationError\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.json_schema.Draft4ResponseValidator",
        "connexion.utils.coerce_type",
        "connexion.validators.parameter.ParameterValidator",
        "jsonschema.ValidationError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_writeonly_required_error",
      "module": "test_validation",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/decorators/test_validation.py",
      "line_number": 184,
      "end_line_number": 191,
      "source_code": "def test_writeonly_required_error():\n    schema = {\n        \"type\": \"object\",\n        \"required\": [\"foo\"],\n        \"properties\": {\"foo\": {\"type\": \"string\", \"writeOnly\": True}},\n    }\n    with pytest.raises(ValidationError):\n        Draft4RequestValidator(schema).validate({\"bar\": \"baz\"})",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.json_schema.Draft4ResponseValidator",
        "connexion.utils.coerce_type",
        "connexion.validators.parameter.ParameterValidator",
        "jsonschema.ValidationError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_parameter_coercion",
      "module": "test_uri_parsing",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/decorators/test_uri_parsing.py",
      "line_number": 270,
      "end_line_number": 321,
      "source_code": "def test_parameter_coercion():\n    params = [\n        {\"name\": \"p1\", \"in\": \"path\", \"type\": \"integer\", \"required\": True},\n        {\"name\": \"h1\", \"in\": \"header\", \"type\": \"string\", \"enum\": [\"a\", \"b\"]},\n        {\"name\": \"q1\", \"in\": \"query\", \"type\": \"integer\", \"maximum\": 3},\n        {\n            \"name\": \"a1\",\n            \"in\": \"query\",\n            \"type\": \"array\",\n            \"minItems\": 2,\n            \"maxItems\": 3,\n            \"items\": {\"type\": \"integer\", \"minimum\": 0},\n        },\n    ]\n\n    uri_parser = Swagger2URIParser(params, {})\n\n    parsed_param = uri_parser.resolve_path({\"p1\": \"123\"})\n    assert parsed_param == {\"p1\": 123}\n\n    parsed_param = uri_parser.resolve_path({\"p1\": \"\"})\n    assert parsed_param == {\"p1\": \"\"}\n\n    parsed_param = uri_parser.resolve_path({\"p1\": \"foo\"})\n    assert parsed_param == {\"p1\": \"foo\"}\n\n    parsed_param = uri_parser.resolve_path({\"p1\": \"1.2\"})\n    assert parsed_param == {\"p1\": \"1.2\"}\n\n    parsed_param = uri_parser.resolve_path({\"p1\": 1})\n    assert parsed_param == {\"p1\": 1}\n\n    parsed_param = uri_parser.resolve_query(QueryParams(\"q1=4\"))\n    assert parsed_param == {\"q1\": 4}\n\n    parsed_param = uri_parser.resolve_query(QueryParams(\"q1=3\"))\n    assert parsed_param == {\"q1\": 3}\n\n    parsed_param = uri_parser.resolve_query(QueryParams(f\"a1={quote_plus('1,2')}\"))\n    assert parsed_param == {\"a1\": [2]}  # Swagger2URIParser\n\n    parsed_param = uri_parser.resolve_query(QueryParams(f\"a1={quote_plus('1,a')}\"))\n    assert parsed_param == {\"a1\": [\"a\"]}  # Swagger2URIParser\n\n    parsed_param = uri_parser.resolve_query(QueryParams(f\"a1={quote_plus('1,-1')}\"))\n    assert parsed_param == {\"a1\": [1]}  # Swagger2URIParser\n\n    parsed_param = uri_parser.resolve_query(QueryParams(f\"a1=1\"))\n    assert parsed_param == {\"a1\": [1]}  # Swagger2URIParser\n\n    parsed_param = uri_parser.resolve_query(QueryParams(f\"a1={quote_plus('1,2,3,4')}\"))\n    assert parsed_param == {\"a1\": [4]}",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "urllib.parse.quote_plus",
        "pytest",
        "connexion.uri_parsing.AlwaysMultiURIParser",
        "connexion.uri_parsing.FirstValueURIParser",
        "connexion.uri_parsing.OpenAPIURIParser",
        "connexion.uri_parsing.Swagger2URIParser",
        "starlette.datastructures.QueryParams",
        "werkzeug.datastructures.MultiDict"
      ],
      "fixtures": [],
      "assertions": [
        "assert parsed_param == {'p1': 123}",
        "assert parsed_param == {'p1': ''}",
        "assert parsed_param == {'p1': 'foo'}",
        "assert parsed_param == {'p1': '1.2'}",
        "assert parsed_param == {'p1': 1}",
        "assert parsed_param == {'q1': 4}",
        "assert parsed_param == {'q1': 3}",
        "assert parsed_param == {'a1': [2]}",
        "assert parsed_param == {'a1': ['a']}",
        "assert parsed_param == {'a1': [1]}",
        "assert parsed_param == {'a1': [1]}",
        "assert parsed_param == {'a1': [4]}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_sync_injection",
      "module": "test_parameter",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/decorators/test_parameter.py",
      "line_number": 15,
      "end_line_number": 33,
      "source_code": "def test_sync_injection():\n    request = MagicMock(name=\"request\")\n    request.path_params = {\"p1\": \"123\"}\n    request.get_body.return_value = {}\n\n    func = MagicMock()\n\n    def handler(**kwargs):\n        func(**kwargs)\n\n    operation = MagicMock(name=\"operation\")\n    operation.is_request_body_defined = False\n    operation.body_name = lambda _: \"body\"\n\n    with TestContext(operation=operation):\n        parameter_decorator = SyncParameterDecorator(framework=FlaskFramework)\n        decorated_handler = parameter_decorator(handler)\n        decorated_handler(request)\n    func.assert_called_with(p1=\"123\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "sys",
        "unittest.mock.AsyncMock",
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.decorators.parameter.AsyncParameterDecorator",
        "connexion.decorators.parameter.SyncParameterDecorator",
        "connexion.decorators.parameter.pythonic",
        "connexion.frameworks.flask.Flask",
        "connexion.frameworks.starlette.Starlette",
        "connexion.testing.TestContext"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_sync_injection_with_context",
      "module": "test_parameter",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/decorators/test_parameter.py",
      "line_number": 61,
      "end_line_number": 81,
      "source_code": "def test_sync_injection_with_context():\n    request = MagicMock(name=\"request\")\n    request.path_params = {\"p1\": \"123\"}\n    request.get_body.return_value = {}\n\n    func = MagicMock()\n\n    def handler(context_, **kwargs):\n        func(context_, **kwargs)\n\n    context = {\"test\": \"success\"}\n\n    operation = MagicMock(name=\"operation\")\n    operation.is_request_body_defined = False\n    operation.body_name = lambda _: \"body\"\n\n    with TestContext(context=context, operation=operation):\n        parameter_decorator = SyncParameterDecorator(framework=FlaskFramework)\n        decorated_handler = parameter_decorator(handler)\n        decorated_handler(request)\n        func.assert_called_with(context, p1=\"123\", test=\"success\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "sys",
        "unittest.mock.AsyncMock",
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.decorators.parameter.AsyncParameterDecorator",
        "connexion.decorators.parameter.SyncParameterDecorator",
        "connexion.decorators.parameter.pythonic",
        "connexion.frameworks.flask.Flask",
        "connexion.frameworks.starlette.Starlette",
        "connexion.testing.TestContext"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_pythonic_params",
      "module": "test_parameter",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/decorators/test_parameter.py",
      "line_number": 111,
      "end_line_number": 113,
      "source_code": "def test_pythonic_params():\n    assert pythonic(\"orderBy[eq]\") == \"order_by_eq\"\n    assert pythonic(\"ids[]\") == \"ids\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "sys",
        "unittest.mock.AsyncMock",
        "unittest.mock.MagicMock",
        "pytest",
        "connexion.decorators.parameter.AsyncParameterDecorator",
        "connexion.decorators.parameter.SyncParameterDecorator",
        "connexion.decorators.parameter.pythonic",
        "connexion.frameworks.flask.Flask",
        "connexion.frameworks.starlette.Starlette",
        "connexion.testing.TestContext"
      ],
      "fixtures": [],
      "assertions": [
        "assert pythonic('orderBy[eq]') == 'order_by_eq'",
        "assert pythonic('ids[]') == 'ids'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get_tokeninfo_url",
      "module": "test_security",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/decorators/test_security.py",
      "line_number": 23,
      "end_line_number": 52,
      "source_code": "def test_get_tokeninfo_url(monkeypatch):\n    security_handler = OAuthSecurityHandler()\n    security_handler.get_token_info_remote = MagicMock(\n        return_value=\"get_token_info_remote_result\"\n    )\n    env = {}\n    monkeypatch.setattr(\"os.environ\", env)\n    logger = MagicMock()\n    monkeypatch.setattr(\"connexion.security.logger\", logger)\n\n    security_def = {}\n    assert security_handler.get_tokeninfo_func(security_def) is None\n    logger.warn.assert_not_called()\n\n    env[\"TOKENINFO_URL\"] = \"issue-146\"\n    assert (\n        security_handler.get_tokeninfo_func(security_def)\n        == \"get_token_info_remote_result\"\n    )\n    security_handler.get_token_info_remote.assert_called_with(\"issue-146\")\n    logger.warn.assert_not_called()\n    logger.warn.reset_mock()\n\n    security_def = {\"x-tokenInfoUrl\": \"bar\"}\n    assert (\n        security_handler.get_tokeninfo_func(security_def)\n        == \"get_token_info_remote_result\"\n    )\n    security_handler.get_token_info_remote.assert_called_with(\"bar\")\n    logger.warn.assert_not_called()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "json",
        "unittest.mock.MagicMock",
        "unittest.mock.patch",
        "pytest",
        "requests",
        "connexion.exceptions.BadRequestProblem",
        "connexion.exceptions.ConnexionException",
        "connexion.exceptions.OAuthProblem",
        "connexion.exceptions.OAuthResponseProblem",
        "connexion.exceptions.OAuthScopeProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.security.NO_VALUE",
        "connexion.security.ApiKeySecurityHandler",
        "connexion.security.BasicSecurityHandler",
        "connexion.security.OAuthSecurityHandler",
        "connexion.security.SecurityHandlerFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert security_handler.get_tokeninfo_func(security_def) is None",
        "assert security_handler.get_tokeninfo_func(security_def) == 'get_token_info_remote_result'",
        "assert security_handler.get_tokeninfo_func(security_def) == 'get_token_info_remote_result'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_verify_oauth_missing_auth_header",
      "module": "test_security",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/decorators/test_security.py",
      "line_number": 55,
      "end_line_number": 66,
      "source_code": "def test_verify_oauth_missing_auth_header():\n    def somefunc(token):\n        return None\n\n    security_handler = OAuthSecurityHandler()\n    wrapped_func = security_handler._get_verify_func(\n        somefunc, security_handler.validate_scope, [\"admin\"]\n    )\n\n    request = ConnexionRequest(scope={\"type\": \"http\", \"headers\": []})\n\n    assert wrapped_func(request) is NO_VALUE",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "json",
        "unittest.mock.MagicMock",
        "unittest.mock.patch",
        "pytest",
        "requests",
        "connexion.exceptions.BadRequestProblem",
        "connexion.exceptions.ConnexionException",
        "connexion.exceptions.OAuthProblem",
        "connexion.exceptions.OAuthResponseProblem",
        "connexion.exceptions.OAuthScopeProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.security.NO_VALUE",
        "connexion.security.ApiKeySecurityHandler",
        "connexion.security.BasicSecurityHandler",
        "connexion.security.OAuthSecurityHandler",
        "connexion.security.SecurityHandlerFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert wrapped_func(request) is NO_VALUE"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "security_handler._get_verify_func",
          "body": "def _get_verify_func(self, basic_info_func):\n    check_basic_info_func = self.check_basic_auth(basic_info_func)\n\n    def wrapper(request):\n        (auth_type, user_pass) = self.get_auth_header_value(request)\n        if auth_type != 'my_basic':\n            return NO_VALUE\n        try:\n            (username, password) = base64.b64decode(user_pass).decode('latin1').split(':', 1)\n        except Exception:\n            raise OAuthProblem(detail='Invalid authorization header')\n        return check_basic_info_func(request, username, password)\n    return wrapper"
        }
      ]
    },
    {
      "name": "test_verify_basic_missing_auth_header",
      "module": "test_security",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/decorators/test_security.py",
      "line_number": 174,
      "end_line_number": 185,
      "source_code": "def test_verify_basic_missing_auth_header():\n    def somefunc(username, password, required_scopes=None):\n        return None\n\n    security_handler = BasicSecurityHandler()\n    wrapped_func = security_handler._get_verify_func(somefunc)\n\n    request = ConnexionRequest(\n        scope={\"type\": \"http\", \"headers\": [[b\"authorization\", b\"Bearer 123\"]]}\n    )\n\n    assert wrapped_func(request) is NO_VALUE",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "json",
        "unittest.mock.MagicMock",
        "unittest.mock.patch",
        "pytest",
        "requests",
        "connexion.exceptions.BadRequestProblem",
        "connexion.exceptions.ConnexionException",
        "connexion.exceptions.OAuthProblem",
        "connexion.exceptions.OAuthResponseProblem",
        "connexion.exceptions.OAuthScopeProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.security.NO_VALUE",
        "connexion.security.ApiKeySecurityHandler",
        "connexion.security.BasicSecurityHandler",
        "connexion.security.OAuthSecurityHandler",
        "connexion.security.SecurityHandlerFactory"
      ],
      "fixtures": [],
      "assertions": [
        "assert wrapped_func(request) is NO_VALUE"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "security_handler._get_verify_func",
          "body": "def _get_verify_func(self, basic_info_func):\n    check_basic_info_func = self.check_basic_auth(basic_info_func)\n\n    def wrapper(request):\n        (auth_type, user_pass) = self.get_auth_header_value(request)\n        if auth_type != 'my_basic':\n            return NO_VALUE\n        try:\n            (username, password) = base64.b64decode(user_pass).decode('latin1').split(':', 1)\n        except Exception:\n            raise OAuthProblem(detail='Invalid authorization header')\n        return check_basic_info_func(request, username, password)\n    return wrapper"
        }
      ]
    },
    {
      "name": "test_raise_most_specific",
      "module": "test_security",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/decorators/test_security.py",
      "line_number": 356,
      "end_line_number": 360,
      "source_code": "def test_raise_most_specific(errors, most_specific):\n    \"\"\"Tests whether most specific exception is raised from a list.\"\"\"\n    security_handler_factory = SecurityHandlerFactory()\n    with pytest.raises(most_specific):\n        security_handler_factory._raise_most_specific(errors)",
      "docstring": "Tests whether most specific exception is raised from a list.",
      "decorators": [
        "pytest.mark.parametrize('errors, most_specific', [([OAuthProblem()], OAuthProblem), ([OAuthProblem(), OAuthScopeProblem([], [])], OAuthScopeProblem), ([OAuthProblem(), OAuthScopeProblem([], []), BadRequestProblem], OAuthScopeProblem), ([OAuthProblem(), OAuthScopeProblem([], []), BadRequestProblem, ConnexionException], OAuthScopeProblem), ([BadRequestProblem(), ConnexionException()], BadRequestProblem), ([ConnexionException()], ConnexionException)])"
      ],
      "arguments": [
        "errors",
        "most_specific"
      ],
      "imports": [
        "json",
        "unittest.mock.MagicMock",
        "unittest.mock.patch",
        "pytest",
        "requests",
        "connexion.exceptions.BadRequestProblem",
        "connexion.exceptions.ConnexionException",
        "connexion.exceptions.OAuthProblem",
        "connexion.exceptions.OAuthResponseProblem",
        "connexion.exceptions.OAuthScopeProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.security.NO_VALUE",
        "connexion.security.ApiKeySecurityHandler",
        "connexion.security.BasicSecurityHandler",
        "connexion.security.OAuthSecurityHandler",
        "connexion.security.SecurityHandlerFactory"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_parameter_validation",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 8,
      "end_line_number": 28,
      "source_code": "def test_parameter_validation(simple_app):\n    app_client = simple_app.test_client()\n\n    url = \"/v1.0/test_parameter_validation\"\n\n    response = app_client.get(url, params={\"date\": \"2015-08-26\"})\n    assert response.status_code == 200\n\n    for invalid_int in \"\", \"foo\", \"0.1\":\n        response = app_client.get(url, params={\"int\": invalid_int})\n        assert response.status_code == 400\n\n    response = app_client.get(url, params={\"int\": \"123\"})\n    assert response.status_code == 200\n\n    for invalid_bool in \"\", \"foo\", \"yes\":\n        response = app_client.get(url, params={\"bool\": invalid_bool})\n        assert response.status_code == 400\n\n    response = app_client.get(url, params={\"bool\": \"true\"})\n    assert response.status_code == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.status_code == 200",
        "assert response.status_code == 200",
        "assert response.status_code == 400",
        "assert response.status_code == 400"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_required_query_param",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 31,
      "end_line_number": 39,
      "source_code": "def test_required_query_param(simple_app):\n    app_client = simple_app.test_client()\n\n    url = \"/v1.0/test_required_query_param\"\n    response = app_client.get(url)\n    assert response.status_code == 400\n\n    response = app_client.get(url, params={\"n\": \"1.23\"})\n    assert response.status_code == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 400",
        "assert response.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_array_query_param",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 42,
      "end_line_number": 72,
      "source_code": "def test_array_query_param(simple_app):\n    app_client = simple_app.test_client()\n    headers = {\"Content-type\": \"application/json\"}\n    url = \"/v1.0/test_array_csv_query_param\"\n    response = app_client.get(url, headers=headers)\n    array_response: List[str] = response.json()\n    assert array_response == [\"squash\", \"banana\"]\n    url = \"/v1.0/test_array_csv_query_param?items=one,two,three\"\n    response = app_client.get(url, headers=headers)\n    array_response: List[str] = response.json()\n    assert array_response == [\"one\", \"two\", \"three\"]\n    url = \"/v1.0/test_array_pipes_query_param?items=1|2|3\"\n    response = app_client.get(url, headers=headers)\n    array_response: List[int] = response.json()\n    assert array_response == [1, 2, 3]\n    url = \"/v1.0/test_array_unsupported_query_param?items=1;2;3\"\n    response = app_client.get(url, headers=headers)\n    array_response: List[str] = response.json()  # unsupported collectionFormat\n    assert array_response == [\"1;2;3\"]\n    url = \"/v1.0/test_array_csv_query_param?items=A&items=B&items=C&items=D,E,F\"\n    response = app_client.get(url, headers=headers)\n    array_response: List[str] = response.json()  # multi array with csv format\n    assert array_response == [\"D\", \"E\", \"F\"]\n    url = \"/v1.0/test_array_multi_query_param?items=A&items=B&items=C&items=D,E,F\"\n    response = app_client.get(url, headers=headers)\n    array_response: List[str] = response.json()  # multi array with csv format\n    assert array_response == [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"]\n    url = \"/v1.0/test_array_pipes_query_param?items=4&items=5&items=6&items=7|8|9\"\n    response = app_client.get(url, headers=headers)\n    array_response: List[int] = response.json()  # multi array with pipes format\n    assert array_response == [7, 8, 9]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert array_response == ['squash', 'banana']",
        "assert array_response == ['one', 'two', 'three']",
        "assert array_response == [1, 2, 3]",
        "assert array_response == ['1;2;3']",
        "assert array_response == ['D', 'E', 'F']",
        "assert array_response == ['A', 'B', 'C', 'D', 'E', 'F']",
        "assert array_response == [7, 8, 9]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "response.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "response.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "response.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "response.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "response.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "response.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "response.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_array_form_param",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 75,
      "end_line_number": 99,
      "source_code": "def test_array_form_param(simple_app):\n    app_client = simple_app.test_client()\n    headers = {\"Content-type\": \"application/x-www-form-urlencoded\"}\n    url = \"/v1.0/test_array_csv_form_param\"\n    response = app_client.post(url, headers=headers)\n    array_response: List[str] = response.json()\n    assert array_response == [\"squash\", \"banana\"]\n    url = \"/v1.0/test_array_csv_form_param\"\n    response = app_client.post(url, headers=headers, data={\"items\": \"one,two,three\"})\n    array_response: List[str] = response.json()\n    assert array_response == [\"one\", \"two\", \"three\"]\n    url = \"/v1.0/test_array_pipes_form_param\"\n    response = app_client.post(url, headers=headers, data={\"items\": \"1|2|3\"})\n    array_response: List[int] = response.json()\n    assert array_response == [1, 2, 3]\n    url = \"/v1.0/test_array_csv_form_param\"\n    data = \"items=A&items=B&items=C&items=D,E,F\"\n    response = app_client.post(url, headers=headers, content=data)\n    array_response: List[str] = response.json()  # multi array with csv format\n    assert array_response == [\"D\", \"E\", \"F\"]\n    url = \"/v1.0/test_array_pipes_form_param\"\n    data = \"items=4&items=5&items=6&items=7|8|9\"\n    response = app_client.post(url, headers=headers, content=data)\n    array_response: List[int] = response.json()  # multi array with pipes format\n    assert array_response == [7, 8, 9]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert array_response == ['squash', 'banana']",
        "assert array_response == ['one', 'two', 'three']",
        "assert array_response == [1, 2, 3]",
        "assert array_response == ['D', 'E', 'F']",
        "assert array_response == [7, 8, 9]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "response.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "response.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "response.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "response.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "response.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_extra_query_param",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 102,
      "end_line_number": 107,
      "source_code": "def test_extra_query_param(simple_app):\n    app_client = simple_app.test_client()\n    headers = {\"Content-type\": \"application/json\"}\n    url = \"/v1.0/test_parameter_validation?extra_parameter=true\"\n    resp = app_client.get(url, headers=headers)\n    assert resp.status_code == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_strict_extra_query_param",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 110,
      "end_line_number": 117,
      "source_code": "def test_strict_extra_query_param(strict_app):\n    app_client = strict_app.test_client()\n    headers = {\"Content-type\": \"application/json\"}\n    url = \"/v1.0/test_parameter_validation?extra_parameter=true\"\n    resp = app_client.get(url, headers=headers)\n    assert resp.status_code == 400\n    response = resp.json()\n    assert response[\"detail\"] == \"Extra query parameter(s) extra_parameter not in spec\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "strict_app"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 400",
        "assert response['detail'] == 'Extra query parameter(s) extra_parameter not in spec'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_strict_formdata_param",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 120,
      "end_line_number": 127,
      "source_code": "def test_strict_formdata_param(strict_app):\n    app_client = strict_app.test_client()\n    headers = {\"Content-type\": \"application/x-www-form-urlencoded\"}\n    url = \"/v1.0/test_array_csv_form_param\"\n    resp = app_client.post(url, headers=headers, data={\"items\": \"mango\"})\n    response = resp.json()\n    assert response == [\"mango\"]\n    assert resp.status_code == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "strict_app"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert response == ['mango']",
        "assert resp.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_path_parameter_someint",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 144,
      "end_line_number": 148,
      "source_code": "def test_path_parameter_someint(simple_app, arg, result):\n    assert isinstance(arg, str)  # sanity check\n    app_client = simple_app.test_client()\n    resp = app_client.get(f\"/v1.0/test-int-path/{arg}\")\n    assert resp.text == f'\"{result}\"\\n'",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('arg, result', [['123', 'int 123'], ['0', 'int 0'], ['0000', 'int 0'], ['+123', 'int 123'], ['+0', 'int 0'], ['-0', 'int 0'], ['-123', 'int -123']])"
      ],
      "arguments": [
        "simple_app",
        "arg",
        "result"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(arg, str)",
        "assert resp.text == f'\"{result}\"\\n'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_path_parameter_someint__bad",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 151,
      "end_line_number": 155,
      "source_code": "def test_path_parameter_someint__bad(simple_app):\n    # non-integer values will not match Flask route\n    app_client = simple_app.test_client()\n    resp = app_client.get(\"/v1.0/test-int-path/foo\")\n    assert resp.status_code == 404, resp.text",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 404, resp.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_path_parameter_somefloat",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 177,
      "end_line_number": 181,
      "source_code": "def test_path_parameter_somefloat(simple_app, arg, result):\n    assert isinstance(arg, str)  # sanity check\n    app_client = simple_app.test_client()\n    resp = app_client.get(f\"/v1.0/test-float-path/{arg}\")\n    assert resp.text == f'\"{result}\"\\n'",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('arg, result', [['123.45', 'float 123.45'], ['123.0', 'float 123'], ['0.999999999999999999', 'float 1'], ['+123.45', 'float 123.45'], ['-123.45', 'float -123.45'], ['123.', 'float 123'], ['.45', 'float 0.45'], ['123', 'float 123'], ['0', 'float 0'], ['0000', 'float 0'], ['-0.000000001', 'float -1e-09'], ['100000000000', 'float 1e+11']])"
      ],
      "arguments": [
        "simple_app",
        "arg",
        "result"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(arg, str)",
        "assert resp.text == f'\"{result}\"\\n'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_path_parameter_doublefloat",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 190,
      "end_line_number": 194,
      "source_code": "def test_path_parameter_doublefloat(simple_app, arg, arg2, result):\n    assert isinstance(arg, str) and isinstance(arg2, str)  # sanity check\n    app_client = simple_app.test_client()\n    resp = app_client.get(f\"/v1.0/test-float-path/{arg}/{arg2}\")\n    assert resp.text == f'\"{result}\"\\n'",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('arg, arg2, result', [['-0.000000001', '0.3', 'float -1e-09, 0.3']])"
      ],
      "arguments": [
        "simple_app",
        "arg",
        "arg2",
        "result"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(arg, str) and isinstance(arg2, str)",
        "assert resp.text == f'\"{result}\"\\n'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_path_parameter_somefloat__bad",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 197,
      "end_line_number": 201,
      "source_code": "def test_path_parameter_somefloat__bad(simple_app):\n    # non-float values will not match Flask route\n    app_client = simple_app.test_client()\n    resp = app_client.get(\"/v1.0/test-float-path/123,45\")\n    assert resp.status_code == 404, resp.text",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 404, resp.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_default_param",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 204,
      "end_line_number": 209,
      "source_code": "def test_default_param(strict_app):\n    app_client = strict_app.test_client()\n    resp = app_client.get(\"/v1.0/test-default-query-parameter\")\n    assert resp.status_code == 200\n    response = resp.json()\n    assert response[\"app_name\"] == \"connexion\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "strict_app"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 200",
        "assert response['app_name'] == 'connexion'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_falsy_param",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 212,
      "end_line_number": 222,
      "source_code": "def test_falsy_param(simple_app):\n    app_client = simple_app.test_client()\n    resp = app_client.get(\"/v1.0/test-falsy-param\", params={\"falsy\": 0})\n    assert resp.status_code == 200\n    response = resp.json()\n    assert response == 0\n\n    resp = app_client.get(\"/v1.0/test-falsy-param\")\n    assert resp.status_code == 200\n    response = resp.json()\n    assert response == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 200",
        "assert response == 0",
        "assert resp.status_code == 200",
        "assert response == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_formdata_param",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 225,
      "end_line_number": 230,
      "source_code": "def test_formdata_param(simple_app):\n    app_client = simple_app.test_client()\n    resp = app_client.post(\"/v1.0/test-formData-param\", data={\"formData\": \"test\"})\n    assert resp.status_code == 200\n    response = resp.json()\n    assert response == \"test\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 200",
        "assert response == 'test'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_formdata_bad_request",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 233,
      "end_line_number": 241,
      "source_code": "def test_formdata_bad_request(simple_app):\n    app_client = simple_app.test_client()\n    resp = app_client.post(\"/v1.0/test-formData-param\")\n    assert resp.status_code == 400\n    response = resp.json()\n    assert response[\"detail\"] in [\n        \"Missing formdata parameter 'formData'\",\n        \"'formData' is a required property\",  # OAS3\n    ]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 400",
        "assert response['detail'] in [\"Missing formdata parameter 'formData'\", \"'formData' is a required property\"]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_formdata_missing_param",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 244,
      "end_line_number": 249,
      "source_code": "def test_formdata_missing_param(simple_app):\n    app_client = simple_app.test_client()\n    resp = app_client.post(\n        \"/v1.0/test-formData-missing-param\", data={\"missing_formData\": \"test\"}\n    )\n    assert resp.status_code == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        }
      ]
    },
    {
      "name": "test_formdata_extra_param",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 252,
      "end_line_number": 257,
      "source_code": "def test_formdata_extra_param(simple_app):\n    app_client = simple_app.test_client()\n    resp = app_client.post(\n        \"/v1.0/test-formData-param\", data={\"formData\": \"test\", \"extra_formData\": \"test\"}\n    )\n    assert resp.status_code == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        }
      ]
    },
    {
      "name": "test_strict_formdata_extra_param",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 260,
      "end_line_number": 269,
      "source_code": "def test_strict_formdata_extra_param(strict_app):\n    app_client = strict_app.test_client()\n    resp = app_client.post(\n        \"/v1.0/test-formData-param\", data={\"formData\": \"test\", \"extra_formData\": \"test\"}\n    )\n    assert resp.status_code == 400\n    assert (\n        resp.json()[\"detail\"]\n        == \"Extra formData parameter(s) extra_formData not in spec\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "strict_app"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 400",
        "assert resp.json()['detail'] == 'Extra formData parameter(s) extra_formData not in spec'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_formdata_file_upload",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 272,
      "end_line_number": 291,
      "source_code": "def test_formdata_file_upload(simple_app):\n    \"\"\"Test that a single file is accepted and provided to the user as a file object if the openapi\n    specification defines single file. Do not accept multiple files.\"\"\"\n    app_client = simple_app.test_client()\n\n    resp = app_client.post(\n        \"/v1.0/test-formData-file-upload\",\n        files=[\n            (\"file\", (\"filename.txt\", BytesIO(b\"file contents\"))),\n            (\"file\", (\"filename2.txt\", BytesIO(b\"file2 contents\"))),\n        ],\n    )\n    assert resp.status_code == 400\n\n    resp = app_client.post(\n        \"/v1.0/test-formData-file-upload\",\n        files={\"file\": (\"filename.txt\", BytesIO(b\"file contents\"))},\n    )\n    assert resp.status_code == 200\n    assert resp.json() == {\"filename.txt\": \"file contents\"}",
      "docstring": "Test that a single file is accepted and provided to the user as a file object if the openapi\nspecification defines single file. Do not accept multiple files.",
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 400",
        "assert resp.status_code == 200",
        "assert resp.json() == {'filename.txt': 'file contents'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_formdata_multiple_file_upload",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 294,
      "end_line_number": 316,
      "source_code": "def test_formdata_multiple_file_upload(simple_app):\n    \"\"\"Test that multiple files are accepted and provided to the user as a list if the openapi\n    specification defines an array of files.\"\"\"\n    app_client = simple_app.test_client()\n    resp = app_client.post(\n        \"/v1.0/test-formData-multiple-file-upload\",\n        files=[\n            (\"file\", (\"filename.txt\", BytesIO(b\"file contents\"))),\n            (\"file\", (\"filename2.txt\", BytesIO(b\"file2 contents\"))),\n        ],\n    )\n    assert resp.status_code == 200\n    assert resp.json() == {\n        \"filename.txt\": \"file contents\",\n        \"filename2.txt\": \"file2 contents\",\n    }\n\n    resp = app_client.post(\n        \"/v1.0/test-formData-multiple-file-upload\",\n        files={\"file\": (\"filename.txt\", BytesIO(b\"file contents\"))},\n    )\n    assert resp.status_code == 200\n    assert resp.json() == {\"filename.txt\": \"file contents\"}",
      "docstring": "Test that multiple files are accepted and provided to the user as a list if the openapi\nspecification defines an array of files.",
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 200",
        "assert resp.json() == {'filename.txt': 'file contents', 'filename2.txt': 'file2 contents'}",
        "assert resp.status_code == 200",
        "assert resp.json() == {'filename.txt': 'file contents'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_mixed_formdata",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 319,
      "end_line_number": 333,
      "source_code": "def test_mixed_formdata(simple_app):\n    app_client = simple_app.test_client()\n    resp = app_client.post(\n        \"/v1.0/test-mixed-formData\",\n        data={\"formData\": \"test\"},\n        files={\"file\": (\"filename.txt\", BytesIO(b\"file contents\"))},\n    )\n\n    assert resp.status_code == 200\n    assert resp.json() == {\n        \"data\": {\"formData\": \"test\"},\n        \"files\": {\n            \"filename.txt\": \"file contents\",\n        },\n    }",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 200",
        "assert resp.json() == {'data': {'formData': 'test'}, 'files': {'filename.txt': 'file contents'}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_formdata_file_upload_bad_request",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 336,
      "end_line_number": 346,
      "source_code": "def test_formdata_file_upload_bad_request(simple_app):\n    app_client = simple_app.test_client()\n    resp = app_client.post(\n        \"/v1.0/test-formData-file-upload\",\n        headers={\"Content-Type\": b\"multipart/form-data; boundary=-\"},\n    )\n    assert resp.status_code == 400\n    assert resp.json()[\"detail\"] in [\n        \"Missing formdata parameter 'file'\",\n        \"'file' is a required property\",  # OAS3\n    ]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 400",
        "assert resp.json()['detail'] in [\"Missing formdata parameter 'file'\", \"'file' is a required property\"]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_formdata_file_upload_missing_param",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 349,
      "end_line_number": 355,
      "source_code": "def test_formdata_file_upload_missing_param(simple_app):\n    app_client = simple_app.test_client()\n    resp = app_client.post(\n        \"/v1.0/test-formData-file-upload-missing-param\",\n        files={\"missing_fileData\": (\"example.txt\", BytesIO(b\"file contents\"))},\n    )\n    assert resp.status_code == 200, resp.text",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 200, resp.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        }
      ]
    },
    {
      "name": "test_body_not_allowed_additional_properties",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 358,
      "end_line_number": 368,
      "source_code": "def test_body_not_allowed_additional_properties(simple_app):\n    app_client = simple_app.test_client()\n    body = {\"body1\": \"bodyString\", \"additional_property\": \"test1\"}\n    resp = app_client.post(\n        \"/v1.0/body-not-allowed-additional-properties\",\n        json=body,\n    )\n    assert resp.status_code == 400\n\n    response = resp.json()\n    assert \"Additional properties are not allowed\" in response[\"detail\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 400",
        "assert 'Additional properties are not allowed' in response['detail']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_body_in_get_request",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 371,
      "end_line_number": 380,
      "source_code": "def test_body_in_get_request(simple_app):\n    app_client = simple_app.test_client()\n    body = {\"body1\": \"bodyString\"}\n    resp = app_client.request(\n        \"GET\",\n        \"/v1.0/body-in-get-request\",\n        json=body,\n    )\n    assert resp.status_code == 200\n    assert resp.json() == body",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 200",
        "assert resp.json() == body"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_bool_as_default_param",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 383,
      "end_line_number": 391,
      "source_code": "def test_bool_as_default_param(simple_app):\n    app_client = simple_app.test_client()\n    resp = app_client.get(\"/v1.0/test-bool-param\")\n    assert resp.status_code == 200\n\n    resp = app_client.get(\"/v1.0/test-bool-param\", params={\"thruthiness\": True})\n    assert resp.status_code == 200\n    response = resp.json()\n    assert response is True",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 200",
        "assert resp.status_code == 200",
        "assert response is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_bool_param",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 394,
      "end_line_number": 404,
      "source_code": "def test_bool_param(simple_app):\n    app_client = simple_app.test_client()\n    resp = app_client.get(\"/v1.0/test-bool-param\", params={\"thruthiness\": True})\n    assert resp.status_code == 200\n    response = resp.json()\n    assert response is True\n\n    resp = app_client.get(\"/v1.0/test-bool-param\", params={\"thruthiness\": False})\n    assert resp.status_code == 200\n    response = resp.json()\n    assert response is False",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 200",
        "assert response is True",
        "assert resp.status_code == 200",
        "assert response is False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_bool_array_param",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 407,
      "end_line_number": 422,
      "source_code": "def test_bool_array_param(simple_app):\n    app_client = simple_app.test_client()\n    resp = app_client.get(\"/v1.0/test-bool-array-param?thruthiness=true,true,true\")\n    assert resp.status_code == 200, resp.text\n    response = resp.json()\n    assert response is True\n\n    app_client = simple_app.test_client()\n    resp = app_client.get(\"/v1.0/test-bool-array-param?thruthiness=true,true,false\")\n    assert resp.status_code == 200, resp.text\n    response = resp.json()\n    assert response is False\n\n    app_client = simple_app.test_client()\n    resp = app_client.get(\"/v1.0/test-bool-array-param\")\n    assert resp.status_code == 200, resp.text",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 200, resp.text",
        "assert response is True",
        "assert resp.status_code == 200, resp.text",
        "assert response is False",
        "assert resp.status_code == 200, resp.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_required_param_miss_config",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 425,
      "end_line_number": 435,
      "source_code": "def test_required_param_miss_config(simple_app):\n    app_client = simple_app.test_client()\n\n    resp = app_client.get(\"/v1.0/test-required-param\")\n    assert resp.status_code == 400\n\n    resp = app_client.get(\"/v1.0/test-required-param\", params={\"simple\": \"test\"})\n    assert resp.status_code == 200\n\n    resp = app_client.get(\"/v1.0/test-required-param\")\n    assert resp.status_code == 400",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 400",
        "assert resp.status_code == 200",
        "assert resp.status_code == 400"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_parameters_defined_in_path_level",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 438,
      "end_line_number": 445,
      "source_code": "def test_parameters_defined_in_path_level(simple_app):\n    app_client = simple_app.test_client()\n    resp = app_client.get(\"/v1.0/parameters-in-root-path?title=nice-get\")\n    assert resp.status_code == 200\n    assert resp.json() == [\"nice-get\"]\n\n    resp = app_client.get(\"/v1.0/parameters-in-root-path\")\n    assert resp.status_code == 400",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 200",
        "assert resp.json() == ['nice-get']",
        "assert resp.status_code == 400"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_array_in_path",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 448,
      "end_line_number": 457,
      "source_code": "def test_array_in_path(simple_app):\n    app_client = simple_app.test_client()\n    resp = app_client.get(\"/v1.0/test-array-in-path/one_item\")\n    assert resp.json() == [\"one_item\"]\n\n    resp = app_client.get(\"/v1.0/test-array-in-path/one_item,another_item\")\n    assert resp.json() == [\n        \"one_item\",\n        \"another_item\",\n    ]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.json() == ['one_item']",
        "assert resp.json() == ['one_item', 'another_item']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_nullable_parameter",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 460,
      "end_line_number": 485,
      "source_code": "def test_nullable_parameter(simple_app):\n    app_client = simple_app.test_client()\n    resp = app_client.get(\"/v1.0/nullable-parameters?time_start=null\")\n    assert resp.json() == \"it was None\"\n\n    resp = app_client.get(\"/v1.0/nullable-parameters?time_start=None\")\n    assert resp.json() == \"it was None\"\n\n    time_start = 1010\n    resp = app_client.get(f\"/v1.0/nullable-parameters?time_start={time_start}\")\n    assert resp.json() == time_start\n\n    resp = app_client.post(\"/v1.0/nullable-parameters\", data={\"post_param\": \"None\"})\n    assert resp.json() == \"it was None\"\n\n    resp = app_client.post(\"/v1.0/nullable-parameters\", data={\"post_param\": \"null\"})\n    assert resp.json() == \"it was None\"\n\n    headers = {\"Content-Type\": \"application/json\"}\n    resp = app_client.put(\"/v1.0/nullable-parameters\", content=\"null\", headers=headers)\n    assert resp.json() == \"it was None\"\n\n    resp = app_client.put(\n        \"/v1.0/nullable-parameters-noargs\", content=\"null\", headers=headers\n    )\n    assert resp.json() == \"hello\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.json() == 'it was None'",
        "assert resp.json() == 'it was None'",
        "assert resp.json() == time_start",
        "assert resp.json() == 'it was None'",
        "assert resp.json() == 'it was None'",
        "assert resp.json() == 'it was None'",
        "assert resp.json() == 'hello'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "app_client.put",
          "body": "def put(self, *args, **kwargs):\n    kwargs.update({'name': 'put'})\n    return (kwargs, 201)"
        },
        {
          "name": "app_client.put",
          "body": "def put(self, *args, **kwargs):\n    kwargs.update({'name': 'put'})\n    return (kwargs, 201)"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_args_kwargs",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 488,
      "end_line_number": 508,
      "source_code": "def test_args_kwargs(simple_app):\n    app_client = simple_app.test_client()\n    resp = app_client.get(\"/v1.0/query-params-as-kwargs\")\n    assert resp.status_code == 200\n    assert resp.json() == {}\n\n    resp = app_client.get(\"/v1.0/query-params-as-kwargs?foo=a&bar=b\")\n    assert resp.status_code == 200\n    assert resp.json() == {\"foo\": \"a\"}\n\n    if simple_app._spec_file == \"openapi.yaml\":\n        body = {\"foo\": \"a\", \"bar\": \"b\"}\n        resp = app_client.post(\n            \"/v1.0/body-params-as-kwargs\",\n            json=body,\n        )\n        assert resp.status_code == 200\n        # having only kwargs, the handler would have been passed 'body'\n        assert resp.json() == {\n            \"body\": {\"foo\": \"a\", \"bar\": \"b\"},\n        }",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 200",
        "assert resp.json() == {}",
        "assert resp.status_code == 200",
        "assert resp.json() == {'foo': 'a'}",
        "assert resp.status_code == 200",
        "assert resp.json() == {'body': {'foo': 'a', 'bar': 'b'}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_param_sanitization",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 511,
      "end_line_number": 555,
      "source_code": "def test_param_sanitization(simple_app):\n    app_client = simple_app.test_client()\n    resp = app_client.post(\"/v1.0/param-sanitization\")\n    assert resp.status_code == 200\n    assert resp.json() == {}\n\n    resp = app_client.post(\n        \"/v1.0/param-sanitization?$query=queryString\", data={\"$form\": \"formString\"}\n    )\n    assert resp.status_code == 200\n    assert resp.json() == {\n        \"query\": \"queryString\",\n        \"form\": \"formString\",\n    }\n\n    body = {\"body1\": \"bodyString\", \"body2\": \"otherString\"}\n    resp = app_client.post(\n        \"/v1.0/body-sanitization\",\n        json=body,\n        headers={\"Content-Type\": \"application/json\"},\n    )\n    assert resp.status_code == 200\n    assert resp.json() == body\n\n    body = {\"body1\": \"bodyString\", \"body2\": 12, \"body3\": {\"a\": \"otherString\"}}\n    resp = app_client.post(\n        \"/v1.0/body-sanitization-additional-properties\",\n        json=body,\n        headers={\"Content-Type\": \"application/json\"},\n    )\n    assert resp.status_code == 200\n    assert resp.json() == body\n\n    body = {\n        \"body1\": \"bodyString\",\n        \"additional_property\": \"test1\",\n        \"additional_property2\": \"test2\",\n    }\n    resp = app_client.post(\n        \"/v1.0/body-sanitization-additional-properties-defined\",\n        json=body,\n        headers={\"Content-Type\": \"application/json\"},\n    )\n    assert resp.status_code == 200\n    assert resp.json() == body",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 200",
        "assert resp.json() == {}",
        "assert resp.status_code == 200",
        "assert resp.json() == {'query': 'queryString', 'form': 'formString'}",
        "assert resp.status_code == 200",
        "assert resp.json() == body",
        "assert resp.status_code == 200",
        "assert resp.json() == body",
        "assert resp.status_code == 200",
        "assert resp.json() == body"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_no_sanitization_in_request_body",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 558,
      "end_line_number": 572,
      "source_code": "def test_no_sanitization_in_request_body(simple_app):\n    app_client = simple_app.test_client()\n    data = {\n        \"name\": \"John\",\n        \"$surname\": \"Doe\",\n        \"1337\": True,\n        \"!#/bin/sh\": False,\n        \"(1/0)\": \"division by zero\",\n        \"s/$/EOL/\": \"regular expression\",\n        \"@8am\": \"time\",\n    }\n    response = app_client.post(\"/v1.0/forward\", json=data)\n\n    assert response.status_code == 200\n    assert response.json() == data",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.json() == data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "response.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_parameters_snake_case",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 575,
      "end_line_number": 634,
      "source_code": "def test_parameters_snake_case(snake_case_app):\n    app_client = snake_case_app.test_client()\n    headers = {\"Content-type\": \"application/json\"}\n    resp = app_client.post(\n        \"/v1.0/test-post-path-snake/123\",\n        headers=headers,\n        json={\"a\": \"test\"},\n    )\n    assert resp.status_code == 200\n    resp = app_client.post(\n        \"/v1.0/test-post-path-shadow/123\",\n        headers=headers,\n        json={\"a\": \"test\"},\n    )\n    assert resp.status_code == 200\n    resp = app_client.post(\n        \"/v1.0/test-post-query-snake?someId=123\",\n        headers=headers,\n        json={\"a\": \"test\"},\n    )\n    assert resp.status_code == 200\n    resp = app_client.post(\n        \"/v1.0/test-post-query-shadow?id=123&class=header\",\n        headers=headers,\n        json={\"a\": \"test\"},\n    )\n    assert resp.status_code == 200\n    resp = app_client.get(\"/v1.0/test-get-path-snake/123\")\n    assert resp.status_code == 200\n    resp = app_client.get(\"/v1.0/test-get-path-shadow/123\")\n    assert resp.status_code == 200\n    resp = app_client.get(\"/v1.0/test-get-query-snake?someId=123\")\n    assert resp.status_code == 200\n    resp = app_client.get(\"/v1.0/test-get-query-shadow?list=123\")\n    assert resp.status_code == 200\n    # Tests for when CamelCase parameter is supplied, of which the snake_case version\n    # matches an existing parameter and view func argument, or vice versa\n    resp = app_client.get(\n        \"/v1.0/test-get-camel-case-version?truthiness=true&orderBy=asc\"\n    )\n    assert resp.status_code == 200, resp.text\n    assert resp.json() == {\"truthiness\": True, \"order_by\": \"asc\"}\n    resp = app_client.get(\"/v1.0/test-get-camel-case-version?truthiness=5\")\n    assert resp.status_code == 400\n    assert resp.json()[\"detail\"].startswith(\"'5' is not of type 'boolean'\")\n    # Incorrectly cased params should be ignored\n    resp = app_client.get(\n        \"/v1.0/test-get-camel-case-version?Truthiness=true&order_by=asc\"\n    )\n    assert resp.status_code == 200\n    assert resp.json() == {\n        \"truthiness\": False,\n        \"order_by\": None,\n    }  # default values\n    resp = app_client.get(\"/v1.0/test-get-camel-case-version?Truthiness=5&order_by=4\")\n    assert resp.status_code == 200\n    assert resp.json() == {\n        \"truthiness\": False,\n        \"order_by\": None,\n    }",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "snake_case_app"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 200",
        "assert resp.status_code == 200",
        "assert resp.status_code == 200",
        "assert resp.status_code == 200",
        "assert resp.status_code == 200",
        "assert resp.status_code == 200",
        "assert resp.status_code == 200",
        "assert resp.status_code == 200",
        "assert resp.status_code == 200, resp.text",
        "assert resp.json() == {'truthiness': True, 'order_by': 'asc'}",
        "assert resp.status_code == 400",
        "assert resp.json()['detail'].startswith(\"'5' is not of type 'boolean'\")",
        "assert resp.status_code == 200",
        "assert resp.json() == {'truthiness': False, 'order_by': None}",
        "assert resp.status_code == 200",
        "assert resp.json() == {'truthiness': False, 'order_by': None}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_get_unicode_request",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 638,
      "end_line_number": 643,
      "source_code": "def test_get_unicode_request(simple_app):\n    \"\"\"Regression test for Python 2 UnicodeEncodeError bug during parameter parsing.\"\"\"\n    app_client = simple_app.test_client()\n    resp = app_client.get(\"/v1.0/get_unicode_request?price=%C2%A319.99\")  # \u00a319.99\n    assert resp.status_code == 200\n    assert resp.json()[\"price\"] == \"\u00a319.99\"",
      "docstring": "Regression test for Python 2 UnicodeEncodeError bug during parameter parsing.",
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 200",
        "assert resp.json()['price'] == '\u00a319.99'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_cookie_param",
      "module": "test_parameters",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_parameters.py",
      "line_number": 646,
      "end_line_number": 650,
      "source_code": "def test_cookie_param(simple_app):\n    app_client = simple_app.test_client(cookies={\"test_cookie\": \"hello\"})\n    response = app_client.get(\"/v1.0/test-cookie-param\")\n    assert response.status_code == 200\n    assert response.json() == {\"cookie_value\": \"hello\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "io.BytesIO",
        "typing.List",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.json() == {'cookie_value': 'hello'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "response.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_errors",
      "module": "test_errors",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_errors.py",
      "line_number": 5,
      "end_line_number": 90,
      "source_code": "def test_errors(problem_app):\n    app_client = problem_app.test_client()\n\n    greeting404 = app_client.get(\"/v1.0/greeting\")\n    assert greeting404.headers.get(\"content-type\") == \"application/problem+json\"\n    assert greeting404.status_code == 404\n    error404 = greeting404.json()\n    assert error404[\"type\"] == \"about:blank\"\n    assert error404[\"title\"] == \"Not Found\"\n    assert error404[\"status\"] == 404\n    assert \"instance\" not in error404\n\n    get_greeting = app_client.get(\"/v1.0/greeting/jsantos\")\n    assert get_greeting.headers.get(\"content-type\") == \"application/problem+json\"\n    assert get_greeting.status_code == 405\n    error405 = get_greeting.json()\n    assert error405[\"type\"] == \"about:blank\"\n    assert error405[\"title\"] == \"Method Not Allowed\"\n    assert error405[\"status\"] == 405\n    assert \"instance\" not in error405\n\n    get500 = app_client.get(\"/v1.0/except\")\n    assert get500.headers.get(\"content-type\") == \"application/problem+json\"\n    assert get500.status_code == 500\n    error500 = get500.json()\n    assert error500[\"type\"] == \"about:blank\"\n    assert error500[\"title\"] == \"Internal Server Error\"\n    assert (\n        error500[\"detail\"]\n        == \"The server encountered an internal error and was unable to complete your request. \"\n        \"Either the server is overloaded or there is an error in the application.\"\n    )\n    assert error500[\"status\"] == 500\n    assert \"instance\" not in error500\n\n    get_problem = app_client.get(\"/v1.0/problem\")\n    assert get_problem.headers.get(\"content-type\") == \"application/problem+json\"\n    assert get_problem.status_code == 402\n    assert get_problem.headers[\"x-Test-Header\"] == \"In Test\"\n    error_problem = get_problem.json()\n    assert error_problem[\"type\"] == \"http://www.example.com/error\"\n    assert error_problem[\"title\"] == \"Some Error\"\n    assert error_problem[\"detail\"] == \"Something went wrong somewhere\"\n    assert error_problem[\"status\"] == 402\n    assert error_problem[\"instance\"] == \"instance1\"\n\n    get_problem2 = app_client.get(\"/v1.0/other_problem\")\n    assert get_problem2.headers.get(\"content-type\") == \"application/problem+json\"\n    assert get_problem2.status_code == 402\n    error_problem2 = get_problem2.json()\n    assert error_problem2[\"type\"] == \"about:blank\"\n    assert error_problem2[\"title\"] == \"Some Error\"\n    assert error_problem2[\"detail\"] == \"Something went wrong somewhere\"\n    assert error_problem2[\"status\"] == 402\n    assert error_problem2[\"instance\"] == \"instance1\"\n\n    problematic_json = app_client.get(\n        \"/v1.0/json_response_with_undefined_value_to_serialize\"\n    )\n    assert problematic_json.status_code == 500\n\n    custom_problem = app_client.get(\"/v1.0/customized_problem_response\")\n    assert custom_problem.status_code == 403\n    problem_body = custom_problem.json()\n    assert \"amount\" in problem_body\n    assert problem_body[\"amount\"] == 23.0\n\n    problem_as_exception = app_client.get(\"/v1.0/problem_exception_with_extra_args\")\n    assert problem_as_exception.status_code == 500\n    problem_as_exception_body = problem_as_exception.json()\n    assert \"age\" in problem_as_exception_body\n    assert problem_as_exception_body[\"age\"] == 30\n\n    unsupported_media_type = app_client.post(\n        \"/v1.0/post_wrong_content_type\",\n        content=\"<html></html>\",\n        headers={\"content-type\": \"text/html\"},\n    )\n    assert unsupported_media_type.status_code == 415\n    unsupported_media_type_body = unsupported_media_type.json()\n    assert unsupported_media_type_body[\"type\"] == \"about:blank\"\n    assert unsupported_media_type_body[\"title\"] == \"Unsupported Media Type\"\n    assert unsupported_media_type_body[\"detail\"].startswith(\n        \"Invalid Content-type (text/html)\"\n    )\n    assert unsupported_media_type_body[\"status\"] == 415",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "problem_app"
      ],
      "imports": [],
      "fixtures": [],
      "assertions": [
        "assert greeting404.headers.get('content-type') == 'application/problem+json'",
        "assert greeting404.status_code == 404",
        "assert error404['type'] == 'about:blank'",
        "assert error404['title'] == 'Not Found'",
        "assert error404['status'] == 404",
        "assert 'instance' not in error404",
        "assert get_greeting.headers.get('content-type') == 'application/problem+json'",
        "assert get_greeting.status_code == 405",
        "assert error405['type'] == 'about:blank'",
        "assert error405['title'] == 'Method Not Allowed'",
        "assert error405['status'] == 405",
        "assert 'instance' not in error405",
        "assert get500.headers.get('content-type') == 'application/problem+json'",
        "assert get500.status_code == 500",
        "assert error500['type'] == 'about:blank'",
        "assert error500['title'] == 'Internal Server Error'",
        "assert error500['detail'] == 'The server encountered an internal error and was unable to complete your request. Either the server is overloaded or there is an error in the application.'",
        "assert error500['status'] == 500",
        "assert 'instance' not in error500",
        "assert get_problem.headers.get('content-type') == 'application/problem+json'",
        "assert get_problem.status_code == 402",
        "assert get_problem.headers['x-Test-Header'] == 'In Test'",
        "assert error_problem['type'] == 'http://www.example.com/error'",
        "assert error_problem['title'] == 'Some Error'",
        "assert error_problem['detail'] == 'Something went wrong somewhere'",
        "assert error_problem['status'] == 402",
        "assert error_problem['instance'] == 'instance1'",
        "assert get_problem2.headers.get('content-type') == 'application/problem+json'",
        "assert get_problem2.status_code == 402",
        "assert error_problem2['type'] == 'about:blank'",
        "assert error_problem2['title'] == 'Some Error'",
        "assert error_problem2['detail'] == 'Something went wrong somewhere'",
        "assert error_problem2['status'] == 402",
        "assert error_problem2['instance'] == 'instance1'",
        "assert problematic_json.status_code == 500",
        "assert custom_problem.status_code == 403",
        "assert 'amount' in problem_body",
        "assert problem_body['amount'] == 23.0",
        "assert problem_as_exception.status_code == 500",
        "assert 'age' in problem_as_exception_body",
        "assert problem_as_exception_body['age'] == 30",
        "assert unsupported_media_type.status_code == 415",
        "assert unsupported_media_type_body['type'] == 'about:blank'",
        "assert unsupported_media_type_body['title'] == 'Unsupported Media Type'",
        "assert unsupported_media_type_body['detail'].startswith('Invalid Content-type (text/html)')",
        "assert unsupported_media_type_body['status'] == 415"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "greeting404.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "get_greeting.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "get500.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "get_problem.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "get_problem2.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "custom_problem.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "problem_as_exception.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "unsupported_media_type.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "greeting404.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "get_greeting.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "get500.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "get_problem.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "get_problem2.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_should_raise_400_for_no_json",
      "module": "test_errors",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_errors.py",
      "line_number": 93,
      "end_line_number": 97,
      "source_code": "def test_should_raise_400_for_no_json(simple_app):\n    app_client = simple_app.test_client()\n    response = app_client.post(\"/v1.0/test-empty-object-body\")\n    assert response.status_code == 400\n    assert response.json()[\"detail\"] == \"Request body must not be empty\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 400",
        "assert response.json()['detail'] == 'Request body must not be empty'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "response.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_app",
      "module": "test_unordered_definition",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_unordered_definition.py",
      "line_number": 4,
      "end_line_number": 9,
      "source_code": "def test_app(unordered_definition_app):\n    app_client = unordered_definition_app.test_client()\n    response = app_client.get(\"/v1.0/unordered-params/1?first=first&second=2\")\n    assert response.status_code == 400\n    response_data = response.json()\n    assert response_data[\"detail\"].startswith(\"'first' is not of type 'integer'\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "unordered_definition_app"
      ],
      "imports": [
        "json"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 400",
        "assert response_data['detail'].startswith(\"'first' is not of type 'integer'\")"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "response.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_schema",
      "module": "test_schema",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_schema.py",
      "line_number": 4,
      "end_line_number": 51,
      "source_code": "def test_schema(schema_app):\n    app_client = schema_app.test_client()\n\n    empty_request = app_client.post(\"/v1.0/test_schema\", json={})\n    assert empty_request.status_code == 400\n    assert empty_request.headers.get(\"content-type\") == \"application/problem+json\"\n    empty_request_response = empty_request.json()\n    assert empty_request_response[\"title\"] == \"Bad Request\"\n    assert empty_request_response[\"detail\"].startswith(\n        \"'image_version' is a required property\"\n    )\n\n    bad_type = app_client.post(\"/v1.0/test_schema\", json={\"image_version\": 22})\n    assert bad_type.status_code == 400\n    assert bad_type.headers.get(\"content-type\") == \"application/problem+json\"\n    bad_type_response = bad_type.json()\n    assert bad_type_response[\"title\"] == \"Bad Request\"\n    assert bad_type_response[\"detail\"].startswith(\"22 is not of type 'string'\")\n\n    bad_type_path = app_client.post(\"/v1.0/test_schema\", json={\"image_version\": 22})\n    assert bad_type_path.status_code == 400\n    assert bad_type_path.headers.get(\"content-type\") == \"application/problem+json\"\n    bad_type_path_response = bad_type_path.json()\n    assert bad_type_path_response[\"title\"] == \"Bad Request\"\n    assert bad_type_path_response[\"detail\"].endswith(\" - 'image_version'\")\n\n    good_request = app_client.post(\n        \"/v1.0/test_schema\",\n        json={\"image_version\": \"version\"},\n    )\n    assert good_request.status_code == 200\n    good_request_response = good_request.json()\n    assert good_request_response[\"image_version\"] == \"version\"\n\n    good_request_extra = app_client.post(\n        \"/v1.0/test_schema\",\n        json={\"image_version\": \"version\", \"extra\": \"stuff\"},\n    )\n    assert good_request_extra.status_code == 200\n    good_request_extra_response = good_request.json()\n    assert good_request_extra_response[\"image_version\"] == \"version\"\n\n    wrong_type = app_client.post(\"/v1.0/test_schema\", json=42)\n    assert wrong_type.status_code == 400\n    assert wrong_type.headers.get(\"content-type\") == \"application/problem+json\"\n    wrong_type_response = wrong_type.json()\n    assert wrong_type_response[\"title\"] == \"Bad Request\"\n    assert wrong_type_response[\"detail\"].startswith(\"42 is not of type 'object'\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "schema_app"
      ],
      "imports": [
        "json"
      ],
      "fixtures": [],
      "assertions": [
        "assert empty_request.status_code == 400",
        "assert empty_request.headers.get('content-type') == 'application/problem+json'",
        "assert empty_request_response['title'] == 'Bad Request'",
        "assert empty_request_response['detail'].startswith(\"'image_version' is a required property\")",
        "assert bad_type.status_code == 400",
        "assert bad_type.headers.get('content-type') == 'application/problem+json'",
        "assert bad_type_response['title'] == 'Bad Request'",
        "assert bad_type_response['detail'].startswith(\"22 is not of type 'string'\")",
        "assert bad_type_path.status_code == 400",
        "assert bad_type_path.headers.get('content-type') == 'application/problem+json'",
        "assert bad_type_path_response['title'] == 'Bad Request'",
        "assert bad_type_path_response['detail'].endswith(\" - 'image_version'\")",
        "assert good_request.status_code == 200",
        "assert good_request_response['image_version'] == 'version'",
        "assert good_request_extra.status_code == 200",
        "assert good_request_extra_response['image_version'] == 'version'",
        "assert wrong_type.status_code == 400",
        "assert wrong_type.headers.get('content-type') == 'application/problem+json'",
        "assert wrong_type_response['title'] == 'Bad Request'",
        "assert wrong_type_response['detail'].startswith(\"42 is not of type 'object'\")"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "empty_request.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "bad_type.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "bad_type_path.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "good_request.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "good_request.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "wrong_type.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "empty_request.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "bad_type.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "bad_type_path.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "wrong_type.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_schema_response",
      "module": "test_schema",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_schema.py",
      "line_number": 54,
      "end_line_number": 112,
      "source_code": "def test_schema_response(schema_app):\n    app_client = schema_app.test_client()\n\n    request = app_client.get(\n        \"/v1.0/test_schema/response/object/valid\",\n    )\n    assert request.status_code == 200, request.text\n    request = app_client.get(\n        \"/v1.0/test_schema/response/object/invalid_type\",\n    )\n    assert request.status_code == 500, request.text\n    request = app_client.get(\n        \"/v1.0/test_schema/response/object/invalid_requirements\",\n    )\n    assert request.status_code == 500, request.text\n    request = app_client.get(\n        \"/v1.0/test_schema/response/string/valid\",\n    )\n    assert request.status_code == 200, request.text\n    request = app_client.get(\n        \"/v1.0/test_schema/response/string/invalid\",\n    )\n    assert request.status_code == 500, request.text\n    request = app_client.get(\n        \"/v1.0/test_schema/response/integer/valid\",\n    )\n    assert request.status_code == 200, request.text\n    request = app_client.get(\n        \"/v1.0/test_schema/response/integer/invalid\",\n    )\n    assert request.status_code == 500, request.text\n    request = app_client.get(\n        \"/v1.0/test_schema/response/number/valid\",\n    )\n    assert request.status_code == 200, request.text\n    request = app_client.get(\n        \"/v1.0/test_schema/response/number/invalid\",\n    )\n    assert request.status_code == 500, request.text\n    request = app_client.get(\n        \"/v1.0/test_schema/response/boolean/valid\",\n    )\n    assert request.status_code == 200, request.text\n    request = app_client.get(\n        \"/v1.0/test_schema/response/boolean/invalid\",\n    )\n    assert request.status_code == 500, request.text\n    request = app_client.get(\n        \"/v1.0/test_schema/response/array/valid\",\n    )\n    assert request.status_code == 200, request.text\n    request = app_client.get(\n        \"/v1.0/test_schema/response/array/invalid_dict\",\n    )\n    assert request.status_code == 500, request.text\n    request = app_client.get(\n        \"/v1.0/test_schema/response/array/invalid_string\",\n    )\n    assert request.status_code == 500, request.text",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "schema_app"
      ],
      "imports": [
        "json"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.status_code == 200, request.text",
        "assert request.status_code == 500, request.text",
        "assert request.status_code == 500, request.text",
        "assert request.status_code == 200, request.text",
        "assert request.status_code == 500, request.text",
        "assert request.status_code == 200, request.text",
        "assert request.status_code == 500, request.text",
        "assert request.status_code == 200, request.text",
        "assert request.status_code == 500, request.text",
        "assert request.status_code == 200, request.text",
        "assert request.status_code == 500, request.text",
        "assert request.status_code == 200, request.text",
        "assert request.status_code == 500, request.text",
        "assert request.status_code == 500, request.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_schema_in_query",
      "module": "test_schema",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_schema.py",
      "line_number": 115,
      "end_line_number": 126,
      "source_code": "def test_schema_in_query(schema_app):\n    app_client = schema_app.test_client()\n    headers = {\"Content-type\": \"application/json\"}\n\n    good_request = app_client.post(\n        \"/v1.0/test_schema_in_query\",\n        headers=headers,\n        params={\"image_version\": \"version\", \"not_required\": \"test\"},\n    )\n    assert good_request.status_code == 200\n    good_request_response = good_request.json()\n    assert good_request_response[\"image_version\"] == \"version\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "schema_app"
      ],
      "imports": [
        "json"
      ],
      "fixtures": [],
      "assertions": [
        "assert good_request.status_code == 200",
        "assert good_request_response['image_version'] == 'version'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "good_request.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_schema_list",
      "module": "test_schema",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_schema.py",
      "line_number": 129,
      "end_line_number": 144,
      "source_code": "def test_schema_list(schema_app):\n    app_client = schema_app.test_client()\n\n    wrong_type = app_client.post(\"/v1.0/test_schema_list\", json=42)\n    assert wrong_type.status_code == 400\n    assert wrong_type.headers.get(\"content-type\") == \"application/problem+json\"\n    wrong_type_response = wrong_type.json()\n    assert wrong_type_response[\"title\"] == \"Bad Request\"\n    assert wrong_type_response[\"detail\"].startswith(\"42 is not of type 'array'\")\n\n    wrong_items = app_client.post(\"/v1.0/test_schema_list\", json=[42])\n    assert wrong_items.status_code == 400\n    assert wrong_items.headers.get(\"content-type\") == \"application/problem+json\"\n    wrong_items_response = wrong_items.json()\n    assert wrong_items_response[\"title\"] == \"Bad Request\"\n    assert wrong_items_response[\"detail\"].startswith(\"42 is not of type 'string'\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "schema_app"
      ],
      "imports": [
        "json"
      ],
      "fixtures": [],
      "assertions": [
        "assert wrong_type.status_code == 400",
        "assert wrong_type.headers.get('content-type') == 'application/problem+json'",
        "assert wrong_type_response['title'] == 'Bad Request'",
        "assert wrong_type_response['detail'].startswith(\"42 is not of type 'array'\")",
        "assert wrong_items.status_code == 400",
        "assert wrong_items.headers.get('content-type') == 'application/problem+json'",
        "assert wrong_items_response['title'] == 'Bad Request'",
        "assert wrong_items_response['detail'].startswith(\"42 is not of type 'string'\")"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "wrong_type.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "wrong_items.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "wrong_type.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "wrong_items.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_schema_map",
      "module": "test_schema",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_schema.py",
      "line_number": 147,
      "end_line_number": 172,
      "source_code": "def test_schema_map(schema_app):\n    app_client = schema_app.test_client()\n\n    valid_object = {\n        \"foo\": {\"image_version\": \"string\"},\n        \"bar\": {\"image_version\": \"string\"},\n    }\n\n    invalid_object = {\"foo\": 42}\n\n    wrong_type = app_client.post(\"/v1.0/test_schema_map\", json=42)\n    assert wrong_type.status_code == 400\n    assert wrong_type.headers.get(\"content-type\") == \"application/problem+json\"\n    wrong_type_response = wrong_type.json()\n    assert wrong_type_response[\"title\"] == \"Bad Request\"\n    assert wrong_type_response[\"detail\"].startswith(\"42 is not of type 'object'\")\n\n    wrong_items = app_client.post(\"/v1.0/test_schema_map\", json=invalid_object)\n    assert wrong_items.status_code == 400\n    assert wrong_items.headers.get(\"content-type\") == \"application/problem+json\"\n    wrong_items_response = wrong_items.json()\n    assert wrong_items_response[\"title\"] == \"Bad Request\"\n    assert wrong_items_response[\"detail\"].startswith(\"42 is not of type 'object'\")\n\n    right_type = app_client.post(\"/v1.0/test_schema_map\", json=valid_object)\n    assert right_type.status_code == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "schema_app"
      ],
      "imports": [
        "json"
      ],
      "fixtures": [],
      "assertions": [
        "assert wrong_type.status_code == 400",
        "assert wrong_type.headers.get('content-type') == 'application/problem+json'",
        "assert wrong_type_response['title'] == 'Bad Request'",
        "assert wrong_type_response['detail'].startswith(\"42 is not of type 'object'\")",
        "assert wrong_items.status_code == 400",
        "assert wrong_items.headers.get('content-type') == 'application/problem+json'",
        "assert wrong_items_response['title'] == 'Bad Request'",
        "assert wrong_items_response['detail'].startswith(\"42 is not of type 'object'\")",
        "assert right_type.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "wrong_type.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "wrong_items.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "wrong_type.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "wrong_items.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_schema_recursive",
      "module": "test_schema",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_schema.py",
      "line_number": 175,
      "end_line_number": 207,
      "source_code": "def test_schema_recursive(schema_app):\n    app_client = schema_app.test_client()\n\n    valid_object = {\n        \"children\": [\n            {\"children\": []},\n            {\n                \"children\": [\n                    {\"children\": []},\n                ]\n            },\n            {\"children\": []},\n        ]\n    }\n\n    invalid_object = {\"children\": [42]}\n\n    wrong_type = app_client.post(\"/v1.0/test_schema_recursive\", json=42)\n    assert wrong_type.status_code == 400\n    assert wrong_type.headers.get(\"content-type\") == \"application/problem+json\"\n    wrong_type_response = wrong_type.json()\n    assert wrong_type_response[\"title\"] == \"Bad Request\"\n    assert wrong_type_response[\"detail\"].startswith(\"42 is not of type 'object'\")\n\n    wrong_items = app_client.post(\"/v1.0/test_schema_recursive\", json=invalid_object)\n    assert wrong_items.status_code == 400\n    assert wrong_items.headers.get(\"content-type\") == \"application/problem+json\"\n    wrong_items_response = wrong_items.json()\n    assert wrong_items_response[\"title\"] == \"Bad Request\"\n    assert wrong_items_response[\"detail\"].startswith(\"42 is not of type 'object'\")\n\n    right_type = app_client.post(\"/v1.0/test_schema_recursive\", json=valid_object)\n    assert right_type.status_code == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "schema_app"
      ],
      "imports": [
        "json"
      ],
      "fixtures": [],
      "assertions": [
        "assert wrong_type.status_code == 400",
        "assert wrong_type.headers.get('content-type') == 'application/problem+json'",
        "assert wrong_type_response['title'] == 'Bad Request'",
        "assert wrong_type_response['detail'].startswith(\"42 is not of type 'object'\")",
        "assert wrong_items.status_code == 400",
        "assert wrong_items.headers.get('content-type') == 'application/problem+json'",
        "assert wrong_items_response['title'] == 'Bad Request'",
        "assert wrong_items_response['detail'].startswith(\"42 is not of type 'object'\")",
        "assert right_type.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "wrong_type.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "wrong_items.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "wrong_type.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "wrong_items.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_schema_format",
      "module": "test_schema",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_schema.py",
      "line_number": 210,
      "end_line_number": 218,
      "source_code": "def test_schema_format(schema_app):\n    app_client = schema_app.test_client()\n\n    wrong_type = app_client.post(\"/v1.0/test_schema_format\", json=\"xy\")\n    assert wrong_type.status_code == 400\n    assert wrong_type.headers.get(\"content-type\") == \"application/problem+json\"\n    wrong_type_response = wrong_type.json()\n    assert wrong_type_response[\"title\"] == \"Bad Request\"\n    assert \"'xy' is not a 'email'\" in wrong_type_response[\"detail\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "schema_app"
      ],
      "imports": [
        "json"
      ],
      "fixtures": [],
      "assertions": [
        "assert wrong_type.status_code == 400",
        "assert wrong_type.headers.get('content-type') == 'application/problem+json'",
        "assert wrong_type_response['title'] == 'Bad Request'",
        "assert \"'xy' is not a 'email'\" in wrong_type_response['detail']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "wrong_type.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "wrong_type.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_schema_array",
      "module": "test_schema",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_schema.py",
      "line_number": 221,
      "end_line_number": 228,
      "source_code": "def test_schema_array(schema_app):\n    app_client = schema_app.test_client()\n\n    array_request = app_client.post(\"/v1.0/schema_array\", json=[\"list\", \"hello\"])\n    assert array_request.status_code == 200\n    assert array_request.headers.get(\"content-type\") == \"application/json\"\n    array_response = array_request.json()\n    assert array_response == [\"list\", \"hello\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "schema_app"
      ],
      "imports": [
        "json"
      ],
      "fixtures": [],
      "assertions": [
        "assert array_request.status_code == 200",
        "assert array_request.headers.get('content-type') == 'application/json'",
        "assert array_response == ['list', 'hello']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "array_request.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "array_request.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_schema_int",
      "module": "test_schema",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_schema.py",
      "line_number": 231,
      "end_line_number": 239,
      "source_code": "def test_schema_int(schema_app):\n    app_client = schema_app.test_client()\n    headers = {\"Content-type\": \"application/json\"}\n\n    array_request = app_client.post(\"/v1.0/schema_int\", json=42)\n    assert array_request.status_code == 200\n    assert array_request.headers.get(\"content-type\") == \"application/json\"\n    array_response = array_request.json()  # type: list\n    assert array_response == 42",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "schema_app"
      ],
      "imports": [
        "json"
      ],
      "fixtures": [],
      "assertions": [
        "assert array_request.status_code == 200",
        "assert array_request.headers.get('content-type') == 'application/json'",
        "assert array_response == 42"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "array_request.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "array_request.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_global_response_definitions",
      "module": "test_schema",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_schema.py",
      "line_number": 242,
      "end_line_number": 245,
      "source_code": "def test_global_response_definitions(schema_app):\n    app_client = schema_app.test_client()\n    resp = app_client.get(\"/v1.0/define_global_response\")\n    assert resp.json() == [\"general\", \"list\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "schema_app"
      ],
      "imports": [
        "json"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.json() == ['general', 'list']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_media_range",
      "module": "test_schema",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_schema.py",
      "line_number": 248,
      "end_line_number": 252,
      "source_code": "def test_media_range(schema_app):\n    app_client = schema_app.test_client()\n\n    array_request = app_client.post(\"/v1.0/media_range\", json={})\n    assert array_request.status_code == 200, array_request.text",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "schema_app"
      ],
      "imports": [
        "json"
      ],
      "fixtures": [],
      "assertions": [
        "assert array_request.status_code == 200, array_request.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        }
      ]
    },
    {
      "name": "test_simple",
      "module": "test_swagger_ui",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_swagger_ui.py",
      "line_number": 1,
      "end_line_number": 4,
      "source_code": "def test_simple(swagger_ui_app):\n    app_client = swagger_ui_app.test_client()\n    response = app_client.get(\"/v1.0/spec.json\")\n    assert response.status_code == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "swagger_ui_app"
      ],
      "imports": [],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_app_with_relative_path",
      "module": "test_bootstrap",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_bootstrap.py",
      "line_number": 18,
      "end_line_number": 29,
      "source_code": "def test_app_with_relative_path(simple_api_spec_dir, spec):\n    # Create the app with a relative path and run the test_app testcase below.\n    app = App(\n        __name__,\n        specification_dir=\"..\" / simple_api_spec_dir.relative_to(TEST_FOLDER),\n    )\n    app.add_api(spec)\n\n    app_client = app.test_client()\n    get_bye = app_client.get(\"/v1.0/bye/jsantos\")\n    assert get_bye.status_code == 200\n    assert get_bye.text == \"Goodbye jsantos\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_api_spec_dir",
        "spec"
      ],
      "imports": [
        "json",
        "unittest.mock",
        "jinja2",
        "pytest",
        "yaml",
        "connexion.App",
        "connexion.exceptions.InvalidSpecification",
        "connexion.http_facts.METHODS",
        "connexion.json_schema.ExtendedSafeLoader",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.options.SwaggerUIOptions",
        "conftest.TEST_FOLDER",
        "conftest.build_app_from_fixture",
        "connexion.uri_parsing.FirstValueURIParser"
      ],
      "fixtures": [],
      "assertions": [
        "assert get_bye.status_code == 200",
        "assert get_bye.text == 'Goodbye jsantos'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_app_with_different_uri_parser",
      "module": "test_bootstrap",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_bootstrap.py",
      "line_number": 32,
      "end_line_number": 46,
      "source_code": "def test_app_with_different_uri_parser(simple_api_spec_dir):\n    from connexion.uri_parsing import FirstValueURIParser\n\n    app = App(\n        __name__,\n        specification_dir=\"..\" / simple_api_spec_dir.relative_to(TEST_FOLDER),\n        uri_parser_class=FirstValueURIParser,\n    )\n    app.add_api(\"swagger.yaml\")\n\n    app_client = app.test_client()\n    resp = app_client.get(\"/v1.0/test_array_csv_query_param?items=a,b,c&items=d,e,f\")\n    assert resp.status_code == 200\n    j = resp.json()\n    assert j == [\"a\", \"b\", \"c\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_api_spec_dir"
      ],
      "imports": [
        "json",
        "unittest.mock",
        "jinja2",
        "pytest",
        "yaml",
        "connexion.App",
        "connexion.exceptions.InvalidSpecification",
        "connexion.http_facts.METHODS",
        "connexion.json_schema.ExtendedSafeLoader",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.options.SwaggerUIOptions",
        "conftest.TEST_FOLDER",
        "conftest.build_app_from_fixture",
        "connexion.uri_parsing.FirstValueURIParser"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 200",
        "assert j == ['a', 'b', 'c']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_swagger_ui",
      "module": "test_bootstrap",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_bootstrap.py",
      "line_number": 49,
      "end_line_number": 58,
      "source_code": "def test_swagger_ui(simple_api_spec_dir, spec):\n    app = App(__name__, specification_dir=simple_api_spec_dir)\n    app.add_api(spec)\n    app_client = app.test_client()\n    swagger_ui = app_client.get(\"/v1.0/ui/\")\n    assert swagger_ui.status_code == 200\n    spec_json_filename = \"/v1.0/{spec}\".format(spec=spec.replace(\"yaml\", \"json\"))\n    assert spec_json_filename in swagger_ui.text\n    if \"openapi\" in spec:\n        assert \"swagger-ui-config.json\" not in swagger_ui.text",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_api_spec_dir",
        "spec"
      ],
      "imports": [
        "json",
        "unittest.mock",
        "jinja2",
        "pytest",
        "yaml",
        "connexion.App",
        "connexion.exceptions.InvalidSpecification",
        "connexion.http_facts.METHODS",
        "connexion.json_schema.ExtendedSafeLoader",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.options.SwaggerUIOptions",
        "conftest.TEST_FOLDER",
        "conftest.build_app_from_fixture",
        "connexion.uri_parsing.FirstValueURIParser"
      ],
      "fixtures": [],
      "assertions": [
        "assert swagger_ui.status_code == 200",
        "assert spec_json_filename in swagger_ui.text",
        "assert 'swagger-ui-config.json' not in swagger_ui.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_swagger_ui_with_config",
      "module": "test_bootstrap",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_bootstrap.py",
      "line_number": 61,
      "end_line_number": 74,
      "source_code": "def test_swagger_ui_with_config(simple_api_spec_dir, spec):\n    swagger_ui_config = {\"displayOperationId\": True}\n    swagger_ui_options = SwaggerUIOptions(swagger_ui_config=swagger_ui_config)\n    app = App(\n        __name__,\n        specification_dir=simple_api_spec_dir,\n        swagger_ui_options=swagger_ui_options,\n    )\n    app.add_api(spec)\n    app_client = app.test_client()\n    swagger_ui = app_client.get(\"/v1.0/ui/\")\n    assert swagger_ui.status_code == 200\n    if \"openapi\" in spec:\n        assert 'configUrl: \"swagger-ui-config.json\"' in swagger_ui.text",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_api_spec_dir",
        "spec"
      ],
      "imports": [
        "json",
        "unittest.mock",
        "jinja2",
        "pytest",
        "yaml",
        "connexion.App",
        "connexion.exceptions.InvalidSpecification",
        "connexion.http_facts.METHODS",
        "connexion.json_schema.ExtendedSafeLoader",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.options.SwaggerUIOptions",
        "conftest.TEST_FOLDER",
        "conftest.build_app_from_fixture",
        "connexion.uri_parsing.FirstValueURIParser"
      ],
      "fixtures": [],
      "assertions": [
        "assert swagger_ui.status_code == 200",
        "assert 'configUrl: \"swagger-ui-config.json\"' in swagger_ui.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_no_swagger_ui",
      "module": "test_bootstrap",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_bootstrap.py",
      "line_number": 77,
      "end_line_number": 94,
      "source_code": "def test_no_swagger_ui(simple_api_spec_dir, spec):\n    swagger_ui_options = SwaggerUIOptions(swagger_ui=False)\n    app = App(\n        __name__,\n        specification_dir=simple_api_spec_dir,\n        swagger_ui_options=swagger_ui_options,\n    )\n    app.add_api(spec)\n\n    app_client = app.test_client()\n    swagger_ui = app_client.get(\"/v1.0/ui/\")\n    assert swagger_ui.status_code == 404\n\n    app2 = App(__name__, specification_dir=simple_api_spec_dir)\n    app2.add_api(spec, swagger_ui_options=SwaggerUIOptions(swagger_ui=False))\n    app2_client = app2.test_client()\n    swagger_ui2 = app2_client.get(\"/v1.0/ui/\")\n    assert swagger_ui2.status_code == 404",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_api_spec_dir",
        "spec"
      ],
      "imports": [
        "json",
        "unittest.mock",
        "jinja2",
        "pytest",
        "yaml",
        "connexion.App",
        "connexion.exceptions.InvalidSpecification",
        "connexion.http_facts.METHODS",
        "connexion.json_schema.ExtendedSafeLoader",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.options.SwaggerUIOptions",
        "conftest.TEST_FOLDER",
        "conftest.build_app_from_fixture",
        "connexion.uri_parsing.FirstValueURIParser"
      ],
      "fixtures": [],
      "assertions": [
        "assert swagger_ui.status_code == 404",
        "assert swagger_ui2.status_code == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app2_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_swagger_ui_config_json",
      "module": "test_bootstrap",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_bootstrap.py",
      "line_number": 97,
      "end_line_number": 111,
      "source_code": "def test_swagger_ui_config_json(simple_api_spec_dir, spec):\n    \"\"\"Verify the swagger-ui-config.json file is returned for swagger_ui_config option passed to app.\"\"\"\n    swagger_ui_config = {\"displayOperationId\": True}\n    swagger_ui_options = SwaggerUIOptions(swagger_ui_config=swagger_ui_config)\n    app = App(\n        __name__,\n        specification_dir=simple_api_spec_dir,\n        swagger_ui_options=swagger_ui_options,\n    )\n    app.add_api(spec)\n    app_client = app.test_client()\n    url = \"/v1.0/ui/swagger-ui-config.json\"\n    swagger_ui_config_json = app_client.get(url)\n    assert swagger_ui_config_json.status_code == 200\n    assert swagger_ui_config == swagger_ui_config_json.json()",
      "docstring": "Verify the swagger-ui-config.json file is returned for swagger_ui_config option passed to app.",
      "decorators": [],
      "arguments": [
        "simple_api_spec_dir",
        "spec"
      ],
      "imports": [
        "json",
        "unittest.mock",
        "jinja2",
        "pytest",
        "yaml",
        "connexion.App",
        "connexion.exceptions.InvalidSpecification",
        "connexion.http_facts.METHODS",
        "connexion.json_schema.ExtendedSafeLoader",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.options.SwaggerUIOptions",
        "conftest.TEST_FOLDER",
        "conftest.build_app_from_fixture",
        "connexion.uri_parsing.FirstValueURIParser"
      ],
      "fixtures": [],
      "assertions": [
        "assert swagger_ui_config_json.status_code == 200",
        "assert swagger_ui_config == swagger_ui_config_json.json()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "swagger_ui_config_json.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_no_swagger_ui_config_json",
      "module": "test_bootstrap",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_bootstrap.py",
      "line_number": 114,
      "end_line_number": 121,
      "source_code": "def test_no_swagger_ui_config_json(simple_api_spec_dir, spec):\n    \"\"\"Verify the swagger-ui-config.json file is not returned when the swagger_ui_config option not passed to app.\"\"\"\n    app = App(__name__, specification_dir=simple_api_spec_dir)\n    app.add_api(spec)\n    app_client = app.test_client()\n    url = \"/v1.0/ui/swagger-ui-config.json\"\n    swagger_ui_config_json = app_client.get(url)\n    assert swagger_ui_config_json.status_code == 404",
      "docstring": "Verify the swagger-ui-config.json file is not returned when the swagger_ui_config option not passed to app.",
      "decorators": [],
      "arguments": [
        "simple_api_spec_dir",
        "spec"
      ],
      "imports": [
        "json",
        "unittest.mock",
        "jinja2",
        "pytest",
        "yaml",
        "connexion.App",
        "connexion.exceptions.InvalidSpecification",
        "connexion.http_facts.METHODS",
        "connexion.json_schema.ExtendedSafeLoader",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.options.SwaggerUIOptions",
        "conftest.TEST_FOLDER",
        "conftest.build_app_from_fixture",
        "connexion.uri_parsing.FirstValueURIParser"
      ],
      "fixtures": [],
      "assertions": [
        "assert swagger_ui_config_json.status_code == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_swagger_json_app",
      "module": "test_bootstrap",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_bootstrap.py",
      "line_number": 124,
      "end_line_number": 132,
      "source_code": "def test_swagger_json_app(simple_api_spec_dir, spec):\n    \"\"\"Verify the spec json file is returned for default setting passed to app.\"\"\"\n    app = App(__name__, specification_dir=simple_api_spec_dir)\n    app.add_api(spec)\n    app_client = app.test_client()\n    url = \"/v1.0/{spec}\"\n    url = url.format(spec=spec.replace(\"yaml\", \"json\"))\n    spec_json = app_client.get(url)\n    assert spec_json.status_code == 200",
      "docstring": "Verify the spec json file is returned for default setting passed to app.",
      "decorators": [],
      "arguments": [
        "simple_api_spec_dir",
        "spec"
      ],
      "imports": [
        "json",
        "unittest.mock",
        "jinja2",
        "pytest",
        "yaml",
        "connexion.App",
        "connexion.exceptions.InvalidSpecification",
        "connexion.http_facts.METHODS",
        "connexion.json_schema.ExtendedSafeLoader",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.options.SwaggerUIOptions",
        "conftest.TEST_FOLDER",
        "conftest.build_app_from_fixture",
        "connexion.uri_parsing.FirstValueURIParser"
      ],
      "fixtures": [],
      "assertions": [
        "assert spec_json.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_swagger_yaml_app",
      "module": "test_bootstrap",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_bootstrap.py",
      "line_number": 135,
      "end_line_number": 143,
      "source_code": "def test_swagger_yaml_app(simple_api_spec_dir, spec):\n    \"\"\"Verify the spec yaml file is returned for default setting passed to app.\"\"\"\n    app = App(__name__, specification_dir=simple_api_spec_dir)\n    app.add_api(spec)\n    app_client = app.test_client()\n    url = \"/v1.0/{spec}\"\n    url = url.format(spec=spec)\n    spec_response = app_client.get(url)\n    assert spec_response.status_code == 200",
      "docstring": "Verify the spec yaml file is returned for default setting passed to app.",
      "decorators": [],
      "arguments": [
        "simple_api_spec_dir",
        "spec"
      ],
      "imports": [
        "json",
        "unittest.mock",
        "jinja2",
        "pytest",
        "yaml",
        "connexion.App",
        "connexion.exceptions.InvalidSpecification",
        "connexion.http_facts.METHODS",
        "connexion.json_schema.ExtendedSafeLoader",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.options.SwaggerUIOptions",
        "conftest.TEST_FOLDER",
        "conftest.build_app_from_fixture",
        "connexion.uri_parsing.FirstValueURIParser"
      ],
      "fixtures": [],
      "assertions": [
        "assert spec_response.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_no_swagger_json_app",
      "module": "test_bootstrap",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_bootstrap.py",
      "line_number": 146,
      "end_line_number": 160,
      "source_code": "def test_no_swagger_json_app(simple_api_spec_dir, spec):\n    \"\"\"Verify the spec json file is not returned when set to False when creating app.\"\"\"\n    swagger_ui_options = SwaggerUIOptions(serve_spec=False)\n    app = App(\n        __name__,\n        specification_dir=simple_api_spec_dir,\n        swagger_ui_options=swagger_ui_options,\n    )\n    app.add_api(spec)\n\n    app_client = app.test_client()\n    url = \"/v1.0/{spec}\"\n    url = url.format(spec=spec.replace(\"yaml\", \"json\"))\n    spec_json = app_client.get(url)\n    assert spec_json.status_code == 404",
      "docstring": "Verify the spec json file is not returned when set to False when creating app.",
      "decorators": [],
      "arguments": [
        "simple_api_spec_dir",
        "spec"
      ],
      "imports": [
        "json",
        "unittest.mock",
        "jinja2",
        "pytest",
        "yaml",
        "connexion.App",
        "connexion.exceptions.InvalidSpecification",
        "connexion.http_facts.METHODS",
        "connexion.json_schema.ExtendedSafeLoader",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.options.SwaggerUIOptions",
        "conftest.TEST_FOLDER",
        "conftest.build_app_from_fixture",
        "connexion.uri_parsing.FirstValueURIParser"
      ],
      "fixtures": [],
      "assertions": [
        "assert spec_json.status_code == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_dict_as_yaml_path",
      "module": "test_bootstrap",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_bootstrap.py",
      "line_number": 163,
      "end_line_number": 182,
      "source_code": "def test_dict_as_yaml_path(simple_api_spec_dir, spec):\n    openapi_yaml_path = simple_api_spec_dir / spec\n\n    with openapi_yaml_path.open(mode=\"rb\") as openapi_yaml:\n        contents = openapi_yaml.read()\n        try:\n            openapi_template = contents.decode()\n        except UnicodeDecodeError:\n            openapi_template = contents.decode(\"utf-8\", \"replace\")\n\n        openapi_string = jinja2.Template(openapi_template).render({})\n        specification = yaml.load(openapi_string, ExtendedSafeLoader)  # type: dict\n\n    app = App(__name__, specification_dir=simple_api_spec_dir)\n    app.add_api(specification)\n\n    app_client = app.test_client()\n    url = \"/v1.0/{spec}\".format(spec=spec.replace(\"yaml\", \"json\"))\n    swagger_json = app_client.get(url)\n    assert swagger_json.status_code == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_api_spec_dir",
        "spec"
      ],
      "imports": [
        "json",
        "unittest.mock",
        "jinja2",
        "pytest",
        "yaml",
        "connexion.App",
        "connexion.exceptions.InvalidSpecification",
        "connexion.http_facts.METHODS",
        "connexion.json_schema.ExtendedSafeLoader",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.options.SwaggerUIOptions",
        "conftest.TEST_FOLDER",
        "conftest.build_app_from_fixture",
        "connexion.uri_parsing.FirstValueURIParser"
      ],
      "fixtures": [],
      "assertions": [
        "assert swagger_json.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_swagger_json_api",
      "module": "test_bootstrap",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_bootstrap.py",
      "line_number": 185,
      "end_line_number": 193,
      "source_code": "def test_swagger_json_api(simple_api_spec_dir, spec):\n    \"\"\"Verify the spec json file is returned for default setting passed to api.\"\"\"\n    app = App(__name__, specification_dir=simple_api_spec_dir)\n    app.add_api(spec)\n\n    app_client = app.test_client()\n    url = \"/v1.0/{spec}\".format(spec=spec.replace(\"yaml\", \"json\"))\n    swagger_json = app_client.get(url)\n    assert swagger_json.status_code == 200",
      "docstring": "Verify the spec json file is returned for default setting passed to api.",
      "decorators": [],
      "arguments": [
        "simple_api_spec_dir",
        "spec"
      ],
      "imports": [
        "json",
        "unittest.mock",
        "jinja2",
        "pytest",
        "yaml",
        "connexion.App",
        "connexion.exceptions.InvalidSpecification",
        "connexion.http_facts.METHODS",
        "connexion.json_schema.ExtendedSafeLoader",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.options.SwaggerUIOptions",
        "conftest.TEST_FOLDER",
        "conftest.build_app_from_fixture",
        "connexion.uri_parsing.FirstValueURIParser"
      ],
      "fixtures": [],
      "assertions": [
        "assert swagger_json.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_no_swagger_json_api",
      "module": "test_bootstrap",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_bootstrap.py",
      "line_number": 196,
      "end_line_number": 204,
      "source_code": "def test_no_swagger_json_api(simple_api_spec_dir, spec):\n    \"\"\"Verify the spec json file is not returned when set to False when adding api.\"\"\"\n    app = App(__name__, specification_dir=simple_api_spec_dir)\n    app.add_api(spec, swagger_ui_options=SwaggerUIOptions(serve_spec=False))\n\n    app_client = app.test_client()\n    url = \"/v1.0/{spec}\".format(spec=spec.replace(\"yaml\", \"json\"))\n    swagger_json = app_client.get(url)\n    assert swagger_json.status_code == 404",
      "docstring": "Verify the spec json file is not returned when set to False when adding api.",
      "decorators": [],
      "arguments": [
        "simple_api_spec_dir",
        "spec"
      ],
      "imports": [
        "json",
        "unittest.mock",
        "jinja2",
        "pytest",
        "yaml",
        "connexion.App",
        "connexion.exceptions.InvalidSpecification",
        "connexion.http_facts.METHODS",
        "connexion.json_schema.ExtendedSafeLoader",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.options.SwaggerUIOptions",
        "conftest.TEST_FOLDER",
        "conftest.build_app_from_fixture",
        "connexion.uri_parsing.FirstValueURIParser"
      ],
      "fixtures": [],
      "assertions": [
        "assert swagger_json.status_code == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_swagger_json_content_type",
      "module": "test_bootstrap",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_bootstrap.py",
      "line_number": 207,
      "end_line_number": 213,
      "source_code": "def test_swagger_json_content_type(simple_app):\n    app_client = simple_app.test_client()\n    spec = simple_app._spec_file\n    url = \"/v1.0/{spec}\".format(spec=spec.replace(\"yaml\", \"json\"))\n    response = app_client.get(url)\n    assert response.status_code == 200\n    assert response.headers.get(\"content-type\") == \"application/json\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "unittest.mock",
        "jinja2",
        "pytest",
        "yaml",
        "connexion.App",
        "connexion.exceptions.InvalidSpecification",
        "connexion.http_facts.METHODS",
        "connexion.json_schema.ExtendedSafeLoader",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.options.SwaggerUIOptions",
        "conftest.TEST_FOLDER",
        "conftest.build_app_from_fixture",
        "connexion.uri_parsing.FirstValueURIParser"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.headers.get('content-type') == 'application/json'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "response.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_single_route",
      "module": "test_bootstrap",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_bootstrap.py",
      "line_number": 216,
      "end_line_number": 240,
      "source_code": "def test_single_route():\n    app = App(__name__)\n\n    def route1():\n        return \"single 1\"\n\n    @app.route(\"/single2\", methods=[\"POST\"])\n    def route2():\n        return \"single 2\"\n\n    app_client = app.test_client()\n\n    app.add_url_rule(\"/single1\", \"single1\", route1, methods=[\"GET\"])\n\n    get_single1 = app_client.get(\"/single1\")\n    assert get_single1.text == \"single 1\"\n\n    post_single1 = app_client.post(\"/single1\")\n    assert post_single1.status_code == 405\n\n    post_single2 = app_client.post(\"/single2\")\n    assert post_single2.text == \"single 2\"\n\n    get_single2 = app_client.get(\"/single2\")\n    assert get_single2.status_code == 405",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "json",
        "unittest.mock",
        "jinja2",
        "pytest",
        "yaml",
        "connexion.App",
        "connexion.exceptions.InvalidSpecification",
        "connexion.http_facts.METHODS",
        "connexion.json_schema.ExtendedSafeLoader",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.options.SwaggerUIOptions",
        "conftest.TEST_FOLDER",
        "conftest.build_app_from_fixture",
        "connexion.uri_parsing.FirstValueURIParser"
      ],
      "fixtures": [],
      "assertions": [
        "assert get_single1.text == 'single 1'",
        "assert post_single1.status_code == 405",
        "assert post_single2.text == 'single 2'",
        "assert get_single2.status_code == 405"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_resolve_method",
      "module": "test_bootstrap",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_bootstrap.py",
      "line_number": 243,
      "end_line_number": 246,
      "source_code": "def test_resolve_method(simple_app):\n    app_client = simple_app.test_client()\n    resp = app_client.get(\"/v1.0/resolver-test/method\")\n    assert resp.text == '\"DummyClass\"\\n'",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "unittest.mock",
        "jinja2",
        "pytest",
        "yaml",
        "connexion.App",
        "connexion.exceptions.InvalidSpecification",
        "connexion.http_facts.METHODS",
        "connexion.json_schema.ExtendedSafeLoader",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.options.SwaggerUIOptions",
        "conftest.TEST_FOLDER",
        "conftest.build_app_from_fixture",
        "connexion.uri_parsing.FirstValueURIParser"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.text == '\"DummyClass\"\\n'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_resolve_classmethod",
      "module": "test_bootstrap",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_bootstrap.py",
      "line_number": 249,
      "end_line_number": 252,
      "source_code": "def test_resolve_classmethod(simple_app):\n    app_client = simple_app.test_client()\n    resp = app_client.get(\"/v1.0/resolver-test/classmethod\")\n    assert resp.text == '\"DummyClass\"\\n'",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "unittest.mock",
        "jinja2",
        "pytest",
        "yaml",
        "connexion.App",
        "connexion.exceptions.InvalidSpecification",
        "connexion.http_facts.METHODS",
        "connexion.json_schema.ExtendedSafeLoader",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.options.SwaggerUIOptions",
        "conftest.TEST_FOLDER",
        "conftest.build_app_from_fixture",
        "connexion.uri_parsing.FirstValueURIParser"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.text == '\"DummyClass\"\\n'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_default_query_param_does_not_match_defined_type",
      "module": "test_bootstrap",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_bootstrap.py",
      "line_number": 255,
      "end_line_number": 265,
      "source_code": "def test_default_query_param_does_not_match_defined_type(\n    default_param_error_spec_dir, app_class, spec\n):\n    with pytest.raises(InvalidSpecification):\n        app = build_app_from_fixture(\n            default_param_error_spec_dir,\n            app_class=app_class,\n            spec_file=spec,\n            validate_responses=True,\n        )\n        app.middleware._build_middleware_stack()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "default_param_error_spec_dir",
        "app_class",
        "spec"
      ],
      "imports": [
        "json",
        "unittest.mock",
        "jinja2",
        "pytest",
        "yaml",
        "connexion.App",
        "connexion.exceptions.InvalidSpecification",
        "connexion.http_facts.METHODS",
        "connexion.json_schema.ExtendedSafeLoader",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.options.SwaggerUIOptions",
        "conftest.TEST_FOLDER",
        "conftest.build_app_from_fixture",
        "connexion.uri_parsing.FirstValueURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "build_app_from_fixture",
          "body": "def build_app_from_fixture(api_spec_folder, *, app_class, spec_file, middlewares=None, **kwargs):\n    cnx_app = app_class(__name__, specification_dir=FIXTURES_FOLDER / api_spec_folder, middlewares=middlewares)\n    cnx_app.add_api(spec_file, **kwargs)\n    cnx_app._spec_file = spec_file\n    return cnx_app"
        }
      ]
    },
    {
      "name": "test_handle_add_operation_error",
      "module": "test_bootstrap",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_bootstrap.py",
      "line_number": 268,
      "end_line_number": 277,
      "source_code": "def test_handle_add_operation_error(simple_api_spec_dir, monkeypatch):\n    app = App(__name__, specification_dir=simple_api_spec_dir)\n    monkeypatch.setattr(\n        AbstractRoutingAPI,\n        \"add_operation\",\n        mock.MagicMock(side_effect=Exception(\"operation error!\")),\n    )\n    with pytest.raises(Exception):\n        app.add_api(\"swagger.yaml\", resolver=lambda oid: (lambda foo: \"bar\"))\n        app.middleware._build_middleware_stack()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_api_spec_dir",
        "monkeypatch"
      ],
      "imports": [
        "json",
        "unittest.mock",
        "jinja2",
        "pytest",
        "yaml",
        "connexion.App",
        "connexion.exceptions.InvalidSpecification",
        "connexion.http_facts.METHODS",
        "connexion.json_schema.ExtendedSafeLoader",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.options.SwaggerUIOptions",
        "conftest.TEST_FOLDER",
        "conftest.build_app_from_fixture",
        "connexion.uri_parsing.FirstValueURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mock.MagicMock(side_effect=Exception('operation error!'))"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_using_all_fields_in_path_item",
      "module": "test_bootstrap",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_bootstrap.py",
      "line_number": 280,
      "end_line_number": 294,
      "source_code": "def test_using_all_fields_in_path_item(simple_api_spec_dir):\n    \"\"\"Test that connexion will try to add an endpoint only on http methods.\n\n    test also that each http methods has its own endpoint.\n    \"\"\"\n    app = App(__name__, specification_dir=simple_api_spec_dir)\n    app.add_api(\"openapi.yaml\")\n    app.middleware._build_middleware_stack()\n\n    test_methods = set()\n    for rule in app.app.url_map.iter_rules():\n        if rule.rule != \"/v1.0/add_operation_on_http_methods_only\":\n            continue\n        test_methods.update({method.lower() for method in rule.methods})\n    assert set(test_methods) == METHODS",
      "docstring": "Test that connexion will try to add an endpoint only on http methods.\n\ntest also that each http methods has its own endpoint.",
      "decorators": [],
      "arguments": [
        "simple_api_spec_dir"
      ],
      "imports": [
        "json",
        "unittest.mock",
        "jinja2",
        "pytest",
        "yaml",
        "connexion.App",
        "connexion.exceptions.InvalidSpecification",
        "connexion.http_facts.METHODS",
        "connexion.json_schema.ExtendedSafeLoader",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.options.SwaggerUIOptions",
        "conftest.TEST_FOLDER",
        "conftest.build_app_from_fixture",
        "connexion.uri_parsing.FirstValueURIParser"
      ],
      "fixtures": [],
      "assertions": [
        "assert set(test_methods) == METHODS"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_async_route",
      "module": "test_bootstrap",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_bootstrap.py",
      "line_number": 297,
      "end_line_number": 300,
      "source_code": "def test_async_route(simple_app):\n    app_client = simple_app.test_client()\n    resp = app_client.get(\"/v1.0/async-route\")\n    assert resp.status_code == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "unittest.mock",
        "jinja2",
        "pytest",
        "yaml",
        "connexion.App",
        "connexion.exceptions.InvalidSpecification",
        "connexion.http_facts.METHODS",
        "connexion.json_schema.ExtendedSafeLoader",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.options.SwaggerUIOptions",
        "conftest.TEST_FOLDER",
        "conftest.build_app_from_fixture",
        "connexion.uri_parsing.FirstValueURIParser"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_add_error_handler",
      "module": "test_bootstrap",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_bootstrap.py",
      "line_number": 303,
      "end_line_number": 318,
      "source_code": "def test_add_error_handler(app_class, simple_api_spec_dir):\n    app = app_class(__name__, specification_dir=simple_api_spec_dir)\n    app.add_api(\"openapi.yaml\")\n\n    def not_found(request: ConnexionRequest, exc: Exception) -> ConnexionResponse:\n        return ConnexionResponse(\n            status_code=404, body=json.dumps({\"error\": \"NotFound\"})\n        )\n\n    app.add_error_handler(404, not_found)\n\n    app_client = app.test_client()\n\n    response = app_client.get(\"/does_not_exist\")\n    assert response.status_code == 404\n    assert response.json()[\"error\"] == \"NotFound\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app_class",
        "simple_api_spec_dir"
      ],
      "imports": [
        "json",
        "unittest.mock",
        "jinja2",
        "pytest",
        "yaml",
        "connexion.App",
        "connexion.exceptions.InvalidSpecification",
        "connexion.http_facts.METHODS",
        "connexion.json_schema.ExtendedSafeLoader",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.options.SwaggerUIOptions",
        "conftest.TEST_FOLDER",
        "conftest.build_app_from_fixture",
        "connexion.uri_parsing.FirstValueURIParser"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 404",
        "assert response.json()['error'] == 'NotFound'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_class",
          "body": "@pytest.fixture(scope='session', params=APP_CLASSES)\ndef app_class(request):\n    return request.param"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "response.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_app",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_responses.py",
      "line_number": 11,
      "end_line_number": 48,
      "source_code": "def test_app(simple_app):\n    app_client = simple_app.test_client()\n\n    # by default the Swagger UI is enabled\n    swagger_ui = app_client.get(\"/v1.0/ui/\")\n    assert swagger_ui.status_code == 200\n    assert \"Swagger UI\" in swagger_ui.text\n\n    # test return Swagger UI static files\n    swagger_icon = app_client.get(\"/v1.0/ui/swagger-ui.js\")\n    assert swagger_icon.status_code == 200\n\n    post_greeting_url = app_client.post(\n        \"/v1.0/greeting/jsantos/the/third/of/his/name\", data={}\n    )\n    assert post_greeting_url.status_code == 200\n    assert post_greeting_url.headers.get(\"content-type\") == \"application/json\"\n    greeting_response_url = post_greeting_url.json()\n    assert (\n        greeting_response_url[\"greeting\"]\n        == \"Hello jsantos thanks for the/third/of/his/name\"\n    )\n\n    post_greeting = app_client.post(\"/v1.0/greeting/jsantos\", data={})\n    assert post_greeting.status_code == 200\n    assert post_greeting.headers.get(\"content-type\") == \"application/json\"\n    greeting_response = post_greeting.json()\n    assert greeting_response[\"greeting\"] == \"Hello jsantos\"\n\n    get_bye = app_client.get(\"/v1.0/bye/jsantos\")\n    assert get_bye.status_code == 200\n    assert get_bye.text == \"Goodbye jsantos\"\n\n    post_greeting = app_client.post(\"/v1.0/greeting/jsantos\", data={})\n    assert post_greeting.status_code == 200\n    assert post_greeting.headers.get(\"content-type\") == \"application/json\"\n    greeting_response = post_greeting.json()\n    assert greeting_response[\"greeting\"] == \"Hello jsantos\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "struct.unpack",
        "yaml",
        "connexion.FlaskApp",
        "connexion.frameworks.flask.FlaskJSONProvider",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert swagger_ui.status_code == 200",
        "assert 'Swagger UI' in swagger_ui.text",
        "assert swagger_icon.status_code == 200",
        "assert post_greeting_url.status_code == 200",
        "assert post_greeting_url.headers.get('content-type') == 'application/json'",
        "assert greeting_response_url['greeting'] == 'Hello jsantos thanks for the/third/of/his/name'",
        "assert post_greeting.status_code == 200",
        "assert post_greeting.headers.get('content-type') == 'application/json'",
        "assert greeting_response['greeting'] == 'Hello jsantos'",
        "assert get_bye.status_code == 200",
        "assert get_bye.text == 'Goodbye jsantos'",
        "assert post_greeting.status_code == 200",
        "assert post_greeting.headers.get('content-type') == 'application/json'",
        "assert greeting_response['greeting'] == 'Hello jsantos'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "post_greeting_url.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "post_greeting.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "post_greeting.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "post_greeting_url.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "post_greeting.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "post_greeting.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_openapi_yaml_behind_proxy",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_responses.py",
      "line_number": 51,
      "end_line_number": 77,
      "source_code": "def test_openapi_yaml_behind_proxy(reverse_proxied_app):\n    \"\"\"Verify the swagger.json file is returned with base_path updated\n    according to X-Original-URI header.\n    \"\"\"\n    app_client = reverse_proxied_app.test_client()\n\n    headers = {\"X-Forwarded-Path\": \"/behind/proxy\"}\n\n    swagger_ui = app_client.get(\"/v1.0/ui/\", headers=headers)\n    assert swagger_ui.status_code == 200\n\n    openapi_yaml = app_client.get(\n        \"/v1.0/\" + reverse_proxied_app._spec_file, headers=headers\n    )\n    assert openapi_yaml.status_code == 200\n    assert openapi_yaml.headers.get(\"Content-Type\").startswith(\"text/yaml\")\n    spec = yaml.load(openapi_yaml.text, Loader=yaml.BaseLoader)\n\n    if reverse_proxied_app._spec_file == \"swagger.yaml\":\n        assert 'url: \"/behind/proxy/v1.0/swagger.json\"' in swagger_ui.text\n        assert (\n            spec.get(\"basePath\") == \"/behind/proxy/v1.0\"\n        ), \"basePath should contains original URI\"\n    else:\n        assert 'url: \"/behind/proxy/v1.0/openapi.json\"' in swagger_ui.text\n        url = spec.get(\"servers\", [{}])[0].get(\"url\")\n        assert url == \"/behind/proxy/v1.0\", \"basePath should contains original URI\"",
      "docstring": "Verify the swagger.json file is returned with base_path updated\naccording to X-Original-URI header.",
      "decorators": [],
      "arguments": [
        "reverse_proxied_app"
      ],
      "imports": [
        "json",
        "struct.unpack",
        "yaml",
        "connexion.FlaskApp",
        "connexion.frameworks.flask.FlaskJSONProvider",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert swagger_ui.status_code == 200",
        "assert openapi_yaml.status_code == 200",
        "assert openapi_yaml.headers.get('Content-Type').startswith('text/yaml')",
        "assert 'url: \"/behind/proxy/v1.0/swagger.json\"' in swagger_ui.text",
        "assert spec.get('basePath') == '/behind/proxy/v1.0', 'basePath should contains original URI'",
        "assert 'url: \"/behind/proxy/v1.0/openapi.json\"' in swagger_ui.text",
        "assert url == '/behind/proxy/v1.0', 'basePath should contains original URI'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "openapi_yaml.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "spec.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "spec.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_produce_decorator",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_responses.py",
      "line_number": 80,
      "end_line_number": 84,
      "source_code": "def test_produce_decorator(simple_app):\n    app_client = simple_app.test_client()\n\n    get_bye = app_client.get(\"/v1.0/bye/jsantos\")\n    assert get_bye.headers.get(\"content-type\", \"\").startswith(\"text/plain\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "struct.unpack",
        "yaml",
        "connexion.FlaskApp",
        "connexion.frameworks.flask.FlaskJSONProvider",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert get_bye.headers.get('content-type', '').startswith('text/plain')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "get_bye.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_returning_response_tuple",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_responses.py",
      "line_number": 87,
      "end_line_number": 94,
      "source_code": "def test_returning_response_tuple(simple_app):\n    app_client = simple_app.test_client()\n\n    result = app_client.get(\"/v1.0/response_tuple\")\n    assert result.status_code == 201, result.text\n    assert result.headers.get(\"content-type\") == \"application/json\"\n    result_data = result.json()\n    assert result_data == {\"foo\": \"bar\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "struct.unpack",
        "yaml",
        "connexion.FlaskApp",
        "connexion.frameworks.flask.FlaskJSONProvider",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.status_code == 201, result.text",
        "assert result.headers.get('content-type') == 'application/json'",
        "assert result_data == {'foo': 'bar'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "result.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "result.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_jsonifier",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_responses.py",
      "line_number": 97,
      "end_line_number": 119,
      "source_code": "def test_jsonifier(simple_app):\n    app_client = simple_app.test_client()\n\n    post_greeting = app_client.post(\"/v1.0/greeting/jsantos\")\n    assert post_greeting.status_code == 200\n    assert post_greeting.headers.get(\"content-type\") == \"application/json\"\n    greeting_response = post_greeting.json()\n    assert greeting_response[\"greeting\"] == \"Hello jsantos\"\n\n    get_list_greeting = app_client.get(\"/v1.0/list/jsantos\")\n    assert get_list_greeting.status_code == 200\n    assert get_list_greeting.headers.get(\"content-type\") == \"application/json\"\n    greeting_response = get_list_greeting.json()\n    assert len(greeting_response) == 2\n    assert greeting_response[0] == \"hello\"\n    assert greeting_response[1] == \"jsantos\"\n\n    get_greetings = app_client.get(\"/v1.0/greetings/jsantos\")\n    assert get_greetings.status_code == 200\n    assert get_greetings.headers.get(\"content-type\") == \"application/x.connexion+json\"\n    greetings_response = get_greetings.json()\n    assert len(greetings_response) == 1\n    assert greetings_response[\"greetings\"] == \"Hello jsantos\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "struct.unpack",
        "yaml",
        "connexion.FlaskApp",
        "connexion.frameworks.flask.FlaskJSONProvider",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert post_greeting.status_code == 200",
        "assert post_greeting.headers.get('content-type') == 'application/json'",
        "assert greeting_response['greeting'] == 'Hello jsantos'",
        "assert get_list_greeting.status_code == 200",
        "assert get_list_greeting.headers.get('content-type') == 'application/json'",
        "assert len(greeting_response) == 2",
        "assert greeting_response[0] == 'hello'",
        "assert greeting_response[1] == 'jsantos'",
        "assert get_greetings.status_code == 200",
        "assert get_greetings.headers.get('content-type') == 'application/x.connexion+json'",
        "assert len(greetings_response) == 1",
        "assert greetings_response['greetings'] == 'Hello jsantos'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "post_greeting.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "get_list_greeting.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "get_greetings.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "post_greeting.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "get_list_greeting.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "get_greetings.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_not_content_response",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_responses.py",
      "line_number": 122,
      "end_line_number": 127,
      "source_code": "def test_not_content_response(simple_app):\n    app_client = simple_app.test_client()\n\n    get_no_content_response = app_client.get(\"/v1.0/test_no_content_response\")\n    assert get_no_content_response.status_code == 204\n    assert get_no_content_response.headers.get(\"content-length\") is None",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "struct.unpack",
        "yaml",
        "connexion.FlaskApp",
        "connexion.frameworks.flask.FlaskJSONProvider",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert get_no_content_response.status_code == 204",
        "assert get_no_content_response.headers.get('content-length') is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "get_no_content_response.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_pass_through",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_responses.py",
      "line_number": 130,
      "end_line_number": 140,
      "source_code": "def test_pass_through(simple_app):\n    app_client = simple_app.test_client()\n\n    response = app_client.get(\"/v1.0/multimime\")\n    assert response.status_code == 500\n    detail = response.json()[\"detail\"]\n    assert (\n        detail == \"Multiple response content types are defined in the \"\n        \"operation spec, but the handler response did not specify \"\n        \"which one to return.\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "struct.unpack",
        "yaml",
        "connexion.FlaskApp",
        "connexion.frameworks.flask.FlaskJSONProvider",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 500",
        "assert detail == 'Multiple response content types are defined in the operation spec, but the handler response did not specify which one to return.'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "response.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_can_use_httpstatus_enum",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_responses.py",
      "line_number": 143,
      "end_line_number": 147,
      "source_code": "def test_can_use_httpstatus_enum(simple_openapi_app):\n    app_client = simple_openapi_app.test_client()\n\n    response = app_client.get(\"/v1.0/httpstatus\")\n    assert response.status_code == 201",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_openapi_app"
      ],
      "imports": [
        "json",
        "struct.unpack",
        "yaml",
        "connexion.FlaskApp",
        "connexion.frameworks.flask.FlaskJSONProvider",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 201"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_empty",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_responses.py",
      "line_number": 150,
      "end_line_number": 155,
      "source_code": "def test_empty(simple_app):\n    app_client = simple_app.test_client()\n\n    response = app_client.get(\"/v1.0/empty\")\n    assert response.status_code == 204\n    assert not response.text",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "struct.unpack",
        "yaml",
        "connexion.FlaskApp",
        "connexion.frameworks.flask.FlaskJSONProvider",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 204",
        "assert not response.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_exploded_deep_object_param_endpoint_openapi_simple",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_responses.py",
      "line_number": 158,
      "end_line_number": 164,
      "source_code": "def test_exploded_deep_object_param_endpoint_openapi_simple(simple_openapi_app):\n    app_client = simple_openapi_app.test_client()\n\n    response = app_client.get(\"/v1.0/exploded-deep-object-param?id[foo]=bar\")\n    assert response.status_code == 200\n    response_data = response.json()\n    assert response_data == {\"foo\": \"bar\", \"foo4\": \"blubb\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_openapi_app"
      ],
      "imports": [
        "json",
        "struct.unpack",
        "yaml",
        "connexion.FlaskApp",
        "connexion.frameworks.flask.FlaskJSONProvider",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response_data == {'foo': 'bar', 'foo4': 'blubb'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "response.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_exploded_deep_object_param_endpoint_openapi_multiple_data_types",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_responses.py",
      "line_number": 167,
      "end_line_number": 182,
      "source_code": "def test_exploded_deep_object_param_endpoint_openapi_multiple_data_types(\n    simple_openapi_app,\n):\n    app_client = simple_openapi_app.test_client()\n\n    response = app_client.get(\n        \"/v1.0/exploded-deep-object-param?id[foo]=bar&id[fooint]=2&id[fooboo]=false\"\n    )\n    assert response.status_code == 200, response.text\n    response_data = response.json()\n    assert response_data == {\n        \"foo\": \"bar\",\n        \"fooint\": 2,\n        \"fooboo\": False,\n        \"foo4\": \"blubb\",\n    }",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_openapi_app"
      ],
      "imports": [
        "json",
        "struct.unpack",
        "yaml",
        "connexion.FlaskApp",
        "connexion.frameworks.flask.FlaskJSONProvider",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200, response.text",
        "assert response_data == {'foo': 'bar', 'fooint': 2, 'fooboo': False, 'foo4': 'blubb'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "response.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_exploded_deep_object_param_endpoint_openapi_additional_properties",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_responses.py",
      "line_number": 185,
      "end_line_number": 195,
      "source_code": "def test_exploded_deep_object_param_endpoint_openapi_additional_properties(\n    simple_openapi_app,\n):\n    app_client = simple_openapi_app.test_client()\n\n    response = app_client.get(\n        \"/v1.0/exploded-deep-object-param-additional-properties?id[foo]=bar&id[fooint]=2\"\n    )\n    assert response.status_code == 200\n    response_data = response.json()\n    assert response_data == {\"foo\": \"bar\", \"fooint\": \"2\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_openapi_app"
      ],
      "imports": [
        "json",
        "struct.unpack",
        "yaml",
        "connexion.FlaskApp",
        "connexion.frameworks.flask.FlaskJSONProvider",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response_data == {'foo': 'bar', 'fooint': '2'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "response.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_exploded_deep_object_param_endpoint_openapi_additional_properties_false",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_responses.py",
      "line_number": 198,
      "end_line_number": 206,
      "source_code": "def test_exploded_deep_object_param_endpoint_openapi_additional_properties_false(\n    simple_openapi_app,\n):\n    app_client = simple_openapi_app.test_client()\n\n    response = app_client.get(\n        \"/v1.0/exploded-deep-object-param?id[foo]=bar&id[foofoo]=barbar\"\n    )\n    assert response.status_code == 400",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_openapi_app"
      ],
      "imports": [
        "json",
        "struct.unpack",
        "yaml",
        "connexion.FlaskApp",
        "connexion.frameworks.flask.FlaskJSONProvider",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 400"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_exploded_deep_object_param_endpoint_openapi_with_dots",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_responses.py",
      "line_number": 209,
      "end_line_number": 217,
      "source_code": "def test_exploded_deep_object_param_endpoint_openapi_with_dots(simple_openapi_app):\n    app_client = simple_openapi_app.test_client()\n\n    response = app_client.get(\n        \"/v1.0/exploded-deep-object-param-additional-properties?id[foo]=bar&id[foo.foo]=barbar\"\n    )\n    assert response.status_code == 200\n    response_data = response.json()\n    assert response_data == {\"foo\": \"bar\", \"foo.foo\": \"barbar\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_openapi_app"
      ],
      "imports": [
        "json",
        "struct.unpack",
        "yaml",
        "connexion.FlaskApp",
        "connexion.frameworks.flask.FlaskJSONProvider",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response_data == {'foo': 'bar', 'foo.foo': 'barbar'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "response.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_nested_exploded_deep_object_param_endpoint_openapi",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_responses.py",
      "line_number": 220,
      "end_line_number": 231,
      "source_code": "def test_nested_exploded_deep_object_param_endpoint_openapi(simple_openapi_app):\n    app_client = simple_openapi_app.test_client()\n\n    response = app_client.get(\n        \"/v1.0/nested-exploded-deep-object-param?id[foo][foo2]=bar&id[foofoo]=barbar\"\n    )\n    assert response.status_code == 200\n    response_data = response.json()\n    assert response_data == {\n        \"foo\": {\"foo2\": \"bar\", \"foo3\": \"blubb\"},\n        \"foofoo\": \"barbar\",\n    }",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_openapi_app"
      ],
      "imports": [
        "json",
        "struct.unpack",
        "yaml",
        "connexion.FlaskApp",
        "connexion.frameworks.flask.FlaskJSONProvider",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response_data == {'foo': {'foo2': 'bar', 'foo3': 'blubb'}, 'foofoo': 'barbar'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "response.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_redirect_endpoint",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_responses.py",
      "line_number": 234,
      "end_line_number": 237,
      "source_code": "def test_redirect_endpoint(simple_app):\n    app_client = simple_app.test_client()\n    resp = app_client.get(\"/v1.0/test-redirect-endpoint\", follow_redirects=False)\n    assert resp.status_code == 302",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "struct.unpack",
        "yaml",
        "connexion.FlaskApp",
        "connexion.frameworks.flask.FlaskJSONProvider",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 302"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_redirect_response_endpoint",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_responses.py",
      "line_number": 240,
      "end_line_number": 245,
      "source_code": "def test_redirect_response_endpoint(simple_app):\n    app_client = simple_app.test_client()\n    resp = app_client.get(\n        \"/v1.0/test-redirect-response-endpoint\", follow_redirects=False\n    )\n    assert resp.status_code == 302",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "struct.unpack",
        "yaml",
        "connexion.FlaskApp",
        "connexion.frameworks.flask.FlaskJSONProvider",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 302"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_default_object_body",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_responses.py",
      "line_number": 248,
      "end_line_number": 262,
      "source_code": "def test_default_object_body(simple_app):\n    app_client = simple_app.test_client()\n    resp = app_client.post(\n        \"/v1.0/test-default-object-body\", headers={\"content-type\": \"application/json\"}\n    )\n    assert resp.status_code == 200\n    response = resp.json()\n    assert response[\"stack\"] == {\"image_version\": \"default_image\"}\n\n    resp = app_client.post(\n        \"/v1.0/test-default-integer-body\", headers={\"content-type\": \"application/json\"}\n    )\n    assert resp.status_code == 200\n    response = resp.json()\n    assert response == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "struct.unpack",
        "yaml",
        "connexion.FlaskApp",
        "connexion.frameworks.flask.FlaskJSONProvider",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 200",
        "assert response['stack'] == {'image_version': 'default_image'}",
        "assert resp.status_code == 200",
        "assert response == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_required_body",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_responses.py",
      "line_number": 265,
      "end_line_number": 273,
      "source_code": "def test_required_body(simple_app):\n    app_client = simple_app.test_client()\n    resp = app_client.post(\n        \"/v1.0/test-required-body\", headers={\"content-type\": \"application/json\"}\n    )\n    assert resp.status_code == 400\n\n    resp = app_client.post(\"/v1.0/test-required-body\", json={\"foo\": \"bar\"})\n    assert resp.status_code == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "struct.unpack",
        "yaml",
        "connexion.FlaskApp",
        "connexion.frameworks.flask.FlaskJSONProvider",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 400",
        "assert resp.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        }
      ]
    },
    {
      "name": "test_empty_object_body",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_responses.py",
      "line_number": 276,
      "end_line_number": 284,
      "source_code": "def test_empty_object_body(simple_app):\n    app_client = simple_app.test_client()\n    resp = app_client.post(\n        \"/v1.0/test-empty-object-body\",\n        json={},\n    )\n    assert resp.status_code == 200\n    response = resp.json()\n    assert response[\"stack\"] == {}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "struct.unpack",
        "yaml",
        "connexion.FlaskApp",
        "connexion.frameworks.flask.FlaskJSONProvider",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 200",
        "assert response['stack'] == {}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_nested_additional_properties",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_responses.py",
      "line_number": 287,
      "end_line_number": 296,
      "source_code": "def test_nested_additional_properties(simple_openapi_app):\n    app_client = simple_openapi_app.test_client()\n    resp = app_client.post(\n        \"/v1.0/test-nested-additional-properties\",\n        json={\"nested\": {\"object\": True}},\n        headers={\"Content-Type\": \"application/json\"},\n    )\n    assert resp.status_code == 200\n    response = resp.json()\n    assert response == {\"nested\": {\"object\": True}}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_openapi_app"
      ],
      "imports": [
        "json",
        "struct.unpack",
        "yaml",
        "connexion.FlaskApp",
        "connexion.frameworks.flask.FlaskJSONProvider",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 200",
        "assert response == {'nested': {'object': True}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_custom_provider",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_responses.py",
      "line_number": 299,
      "end_line_number": 317,
      "source_code": "def test_custom_provider(spec):\n    simple_flask_app = build_app_from_fixture(\n        \"simple\", app_class=FlaskApp, spec_file=spec, validate_responses=True\n    )\n\n    class CustomProvider(FlaskJSONProvider):\n        def default(self, o):\n            if o.__class__.__name__ == \"DummyClass\":\n                return \"cool result\"\n            return super().default(o)\n\n    flask_app = simple_flask_app.app\n    flask_app.json = CustomProvider(flask_app)\n    app_client = simple_flask_app.test_client()\n\n    resp = app_client.get(\"/v1.0/custom-json-response\")\n    assert resp.status_code == 200\n    response = resp.json()\n    assert response[\"theResult\"] == \"cool result\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "spec"
      ],
      "imports": [
        "json",
        "struct.unpack",
        "yaml",
        "connexion.FlaskApp",
        "connexion.frameworks.flask.FlaskJSONProvider",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 200",
        "assert response['theResult'] == 'cool result'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "build_app_from_fixture",
          "body": "def build_app_from_fixture(api_spec_folder, *, app_class, spec_file, middlewares=None, **kwargs):\n    cnx_app = app_class(__name__, specification_dir=FIXTURES_FOLDER / api_spec_folder, middlewares=middlewares)\n    cnx_app.add_api(spec_file, **kwargs)\n    cnx_app._spec_file = spec_file\n    return cnx_app"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_content_type_not_json",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_responses.py",
      "line_number": 320,
      "end_line_number": 336,
      "source_code": "def test_content_type_not_json(simple_app):\n    app_client = simple_app.test_client()\n\n    resp = app_client.get(\"/v1.0/blob-response\")\n    assert resp.status_code == 200\n\n    try:\n        # AsyncApp\n        content = resp.content\n    except AttributeError:\n        # FlaskApp\n        content = resp.data\n\n    # validate binary content\n    text, number = unpack(\"!4sh\", content)\n    assert text == b\"cool\"\n    assert number == 8",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "struct.unpack",
        "yaml",
        "connexion.FlaskApp",
        "connexion.frameworks.flask.FlaskJSONProvider",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 200",
        "assert text == b'cool'",
        "assert number == 8"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_maybe_blob_or_json",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_responses.py",
      "line_number": 339,
      "end_line_number": 356,
      "source_code": "def test_maybe_blob_or_json(simple_app):\n    app_client = simple_app.test_client()\n\n    resp = app_client.get(\"/v1.0/binary-response\")\n    assert resp.status_code == 200\n    assert resp.headers.get(\"content-type\") == \"application/octet-stream\"\n\n    try:\n        # AsyncApp\n        content = resp.content\n    except AttributeError:\n        # FlaskApp\n        content = resp.data\n\n    # validate binary content\n    text, number = unpack(\"!4sh\", content)\n    assert text == b\"cool\"\n    assert number == 8",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "struct.unpack",
        "yaml",
        "connexion.FlaskApp",
        "connexion.frameworks.flask.FlaskJSONProvider",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 200",
        "assert resp.headers.get('content-type') == 'application/octet-stream'",
        "assert text == b'cool'",
        "assert number == 8"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "resp.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_bad_operations",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_responses.py",
      "line_number": 359,
      "end_line_number": 370,
      "source_code": "def test_bad_operations(bad_operations_app):\n    # Bad operationIds in bad_operations_app should result in 501\n    app_client = bad_operations_app.test_client()\n\n    resp = app_client.get(\"/v1.0/welcome\")\n    assert resp.status_code == 501\n\n    resp = app_client.put(\"/v1.0/welcome\")\n    assert resp.status_code == 501\n\n    resp = app_client.post(\"/v1.0/welcome\")\n    assert resp.status_code == 501",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "bad_operations_app"
      ],
      "imports": [
        "json",
        "struct.unpack",
        "yaml",
        "connexion.FlaskApp",
        "connexion.frameworks.flask.FlaskJSONProvider",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 501",
        "assert resp.status_code == 501",
        "assert resp.status_code == 501"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.put",
          "body": "def put(self, *args, **kwargs):\n    kwargs.update({'name': 'put'})\n    return (kwargs, 201)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        }
      ]
    },
    {
      "name": "test_text_request",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_responses.py",
      "line_number": 373,
      "end_line_number": 377,
      "source_code": "def test_text_request(simple_app):\n    app_client = simple_app.test_client()\n\n    resp = app_client.post(\"/v1.0/text-request\", content=\"text\")\n    assert resp.status_code == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "struct.unpack",
        "yaml",
        "connexion.FlaskApp",
        "connexion.frameworks.flask.FlaskJSONProvider",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        }
      ]
    },
    {
      "name": "test_operation_handler_returns_flask_object",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_responses.py",
      "line_number": 380,
      "end_line_number": 383,
      "source_code": "def test_operation_handler_returns_flask_object(invalid_resp_allowed_app):\n    app_client = invalid_resp_allowed_app.test_client()\n    resp = app_client.get(\"/v1.0/get_non_conforming_response\")\n    assert resp.status_code == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "invalid_resp_allowed_app"
      ],
      "imports": [
        "json",
        "struct.unpack",
        "yaml",
        "connexion.FlaskApp",
        "connexion.frameworks.flask.FlaskJSONProvider",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_post_wrong_content_type",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_responses.py",
      "line_number": 386,
      "end_line_number": 409,
      "source_code": "def test_post_wrong_content_type(simple_app):\n    app_client = simple_app.test_client()\n    resp = app_client.post(\n        \"/v1.0/post_wrong_content_type\",\n        headers={\"content-type\": \"application/xml\"},\n        json={\"some\": \"data\"},\n    )\n    assert resp.status_code == 415\n\n    resp = app_client.post(\n        \"/v1.0/post_wrong_content_type\",\n        headers={\"content-type\": \"application/x-www-form-urlencoded\"},\n        content=\"a=1&b=2\",\n    )\n    assert resp.status_code == 415\n\n    resp = app_client.post(\n        \"/v1.0/post_wrong_content_type\",\n        headers={\"content-type\": \"application/json\"},\n        content=\"not a valid json\",\n    )\n    assert (\n        resp.status_code == 400\n    ), \"Should return 400 when Content-Type is json but content not parsable\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "struct.unpack",
        "yaml",
        "connexion.FlaskApp",
        "connexion.frameworks.flask.FlaskJSONProvider",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 415",
        "assert resp.status_code == 415",
        "assert resp.status_code == 400, 'Should return 400 when Content-Type is json but content not parsable'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        }
      ]
    },
    {
      "name": "test_get_unicode_response",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_responses.py",
      "line_number": 412,
      "end_line_number": 416,
      "source_code": "def test_get_unicode_response(simple_app):\n    app_client = simple_app.test_client()\n    resp = app_client.get(\"/v1.0/get_unicode_response\")\n    actualJson = {\"currency\": \"\\xa3\", \"key\": \"leena\"}\n    assert resp.json() == actualJson",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "struct.unpack",
        "yaml",
        "connexion.FlaskApp",
        "connexion.frameworks.flask.FlaskJSONProvider",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.json() == actualJson"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "resp.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_get_enum_response",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_responses.py",
      "line_number": 419,
      "end_line_number": 422,
      "source_code": "def test_get_enum_response(simple_app):\n    app_client = simple_app.test_client()\n    resp = app_client.get(\"/v1.0/get_enum_response\")\n    assert resp.status_code == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "struct.unpack",
        "yaml",
        "connexion.FlaskApp",
        "connexion.frameworks.flask.FlaskJSONProvider",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_get_httpstatus_response",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_responses.py",
      "line_number": 425,
      "end_line_number": 428,
      "source_code": "def test_get_httpstatus_response(simple_app):\n    app_client = simple_app.test_client()\n    resp = app_client.get(\"/v1.0/get_httpstatus_response\")\n    assert resp.status_code == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "struct.unpack",
        "yaml",
        "connexion.FlaskApp",
        "connexion.frameworks.flask.FlaskJSONProvider",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_get_bad_default_response",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_responses.py",
      "line_number": 431,
      "end_line_number": 437,
      "source_code": "def test_get_bad_default_response(simple_app):\n    app_client = simple_app.test_client()\n    resp = app_client.get(\"/v1.0/get_bad_default_response/200\")\n    assert resp.status_code == 200\n\n    resp = app_client.get(\"/v1.0/get_bad_default_response/202\")\n    assert resp.status_code == 500",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "struct.unpack",
        "yaml",
        "connexion.FlaskApp",
        "connexion.frameworks.flask.FlaskJSONProvider",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 200",
        "assert resp.status_code == 500"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_streaming_response",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_responses.py",
      "line_number": 440,
      "end_line_number": 443,
      "source_code": "def test_streaming_response(simple_app):\n    app_client = simple_app.test_client()\n    resp = app_client.get(\"/v1.0/get_streaming_response\")\n    assert resp.status_code == 200, resp.text",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json",
        "struct.unpack",
        "yaml",
        "connexion.FlaskApp",
        "connexion.frameworks.flask.FlaskJSONProvider",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 200, resp.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_oneof",
      "module": "test_responses",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_responses.py",
      "line_number": 446,
      "end_line_number": 471,
      "source_code": "def test_oneof(simple_openapi_app):\n    app_client = simple_openapi_app.test_client()\n\n    post_greeting = app_client.post(\n        \"/v1.0/oneof_greeting\",\n        json={\"name\": 3},\n    )\n    assert post_greeting.status_code == 200\n    assert post_greeting.headers.get(\"content-type\") == \"application/json\"\n    greeting_response = post_greeting.json()\n    assert greeting_response[\"greeting\"] == \"Hello 3\"\n\n    post_greeting = app_client.post(\n        \"/v1.0/oneof_greeting\",\n        json={\"name\": True},\n    )\n    assert post_greeting.status_code == 200\n    assert post_greeting.headers.get(\"content-type\") == \"application/json\"\n    greeting_response = post_greeting.json()\n    assert greeting_response[\"greeting\"] == \"Hello True\"\n\n    post_greeting = app_client.post(\n        \"/v1.0/oneof_greeting\",\n        json={\"name\": \"jsantos\"},\n    )\n    assert post_greeting.status_code == 400",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_openapi_app"
      ],
      "imports": [
        "json",
        "struct.unpack",
        "yaml",
        "connexion.FlaskApp",
        "connexion.frameworks.flask.FlaskJSONProvider",
        "conftest.build_app_from_fixture"
      ],
      "fixtures": [],
      "assertions": [
        "assert post_greeting.status_code == 200",
        "assert post_greeting.headers.get('content-type') == 'application/json'",
        "assert greeting_response['greeting'] == 'Hello 3'",
        "assert post_greeting.status_code == 200",
        "assert post_greeting.headers.get('content-type') == 'application/json'",
        "assert greeting_response['greeting'] == 'Hello True'",
        "assert post_greeting.status_code == 400"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "post_greeting.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "post_greeting.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "post_greeting.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "post_greeting.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_app_with_multiple_definition",
      "module": "test_bootstrap_multiple_spec",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_bootstrap_multiple_spec.py",
      "line_number": 26,
      "end_line_number": 48,
      "source_code": "def test_app_with_multiple_definition(\n    multiple_yaml_same_basepath_dir, specs, app_class\n):\n    app = app_class(\n        __name__,\n        specification_dir=\"..\"\n        / multiple_yaml_same_basepath_dir.relative_to(TEST_FOLDER),\n    )\n\n    for spec in specs:\n        print(spec)\n        app.add_api(**spec)\n\n    app_client = app.test_client()\n\n    response = app_client.post(\"/v1.0/greeting/Igor\")\n    assert response.status_code == 200\n    print(response.text)\n    assert response.json()[\"greeting\"] == \"Hello Igor\"\n\n    response = app_client.get(\"/v1.0/bye/Musti\")\n    assert response.status_code == 200\n    assert response.text == \"Goodbye Musti\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('specs', SPECS)"
      ],
      "arguments": [
        "multiple_yaml_same_basepath_dir",
        "specs",
        "app_class"
      ],
      "imports": [
        "json",
        "pytest",
        "conftest.TEST_FOLDER"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.json()['greeting'] == 'Hello Igor'",
        "assert response.status_code == 200",
        "assert response.text == 'Goodbye Musti'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_class",
          "body": "@pytest.fixture(scope='session', params=APP_CLASSES)\ndef app_class(request):\n    return request.param"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "response.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_cors_valid",
      "module": "test_cors",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_cors.py",
      "line_number": 4,
      "end_line_number": 10,
      "source_code": "def test_cors_valid(cors_openapi_app):\n    app_client = cors_openapi_app.test_client()\n    origin = \"http://localhost\"\n    response = app_client.post(\"/v1.0/goodday/dan\", data={}, headers={\"Origin\": origin})\n    assert response.status_code == 201\n    assert \"Access-Control-Allow-Origin\" in response.headers\n    assert origin == response.headers[\"Access-Control-Allow-Origin\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "cors_openapi_app"
      ],
      "imports": [
        "json"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 201",
        "assert 'Access-Control-Allow-Origin' in response.headers",
        "assert origin == response.headers['Access-Control-Allow-Origin']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        }
      ]
    },
    {
      "name": "test_cors_invalid",
      "module": "test_cors",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_cors.py",
      "line_number": 13,
      "end_line_number": 20,
      "source_code": "def test_cors_invalid(cors_openapi_app):\n    app_client = cors_openapi_app.test_client()\n    response = app_client.options(\n        \"/v1.0/goodday/dan\",\n        headers={\"Origin\": \"http://0.0.0.0\", \"Access-Control-Request-Method\": \"POST\"},\n    )\n    assert response.status_code == 400\n    assert \"Access-Control-Allow-Origin\" not in response.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "cors_openapi_app"
      ],
      "imports": [
        "json"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 400",
        "assert 'Access-Control-Allow-Origin' not in response.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_cors_validation_error",
      "module": "test_cors",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_cors.py",
      "line_number": 23,
      "end_line_number": 33,
      "source_code": "def test_cors_validation_error(cors_openapi_app):\n    app_client = cors_openapi_app.test_client()\n    origin = \"http://localhost\"\n    response = app_client.post(\n        \"/v1.0/body-not-allowed-additional-properties\",\n        data={},\n        headers={\"Origin\": origin},\n    )\n    assert response.status_code == 400\n    assert \"Access-Control-Allow-Origin\" in response.headers\n    assert origin == response.headers[\"Access-Control-Allow-Origin\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "cors_openapi_app"
      ],
      "imports": [
        "json"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 400",
        "assert 'Access-Control-Allow-Origin' in response.headers",
        "assert origin == response.headers['Access-Control-Allow-Origin']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        }
      ]
    },
    {
      "name": "test_cors_server_error",
      "module": "test_cors",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_cors.py",
      "line_number": 36,
      "end_line_number": 44,
      "source_code": "def test_cors_server_error(cors_openapi_app):\n    app_client = cors_openapi_app.test_client()\n    origin = \"http://localhost\"\n    response = app_client.post(\n        \"/v1.0/goodday/noheader\", data={}, headers={\"Origin\": origin}\n    )\n    assert response.status_code == 500\n    assert \"Access-Control-Allow-Origin\" in response.headers\n    assert origin == response.headers[\"Access-Control-Allow-Origin\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "cors_openapi_app"
      ],
      "imports": [
        "json"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 500",
        "assert 'Access-Control-Allow-Origin' in response.headers",
        "assert origin == response.headers['Access-Control-Allow-Origin']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        }
      ]
    },
    {
      "name": "test_security_over_nonexistent_endpoints",
      "module": "test_secure_api",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_secure_api.py",
      "line_number": 59,
      "end_line_number": 89,
      "source_code": "def test_security_over_nonexistent_endpoints(oauth_requests, secure_api_app):\n    app_client = secure_api_app.test_client()\n    headers = {\"Authorization\": \"Bearer 300\"}\n    get_inexistent_endpoint = app_client.get(\n        \"/v1.0/does-not-exist-invalid-token\", headers=headers\n    )\n    assert get_inexistent_endpoint.status_code == 401\n    assert (\n        get_inexistent_endpoint.headers.get(\"content-type\")\n        == \"application/problem+json\"\n    )\n\n    headers = {\"Authorization\": \"Bearer 100\"}\n    get_inexistent_endpoint = app_client.get(\n        \"/v1.0/does-not-exist-valid-token\", headers=headers\n    )\n    assert get_inexistent_endpoint.status_code == 404\n    assert (\n        get_inexistent_endpoint.headers.get(\"content-type\")\n        == \"application/problem+json\"\n    )\n\n    get_inexistent_endpoint = app_client.get(\"/v1.0/does-not-exist-no-token\")\n    assert get_inexistent_endpoint.status_code == 401\n\n    headers = {\"Authorization\": \"Bearer 100\"}\n    post_greeting = app_client.post(\"/v1.0/greeting/rcaricio\", data={}, headers=headers)\n    assert post_greeting.status_code == 200\n\n    post_greeting = app_client.post(\"/v1.0/greeting/rcaricio\", data={})\n    assert post_greeting.status_code == 401",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "oauth_requests",
        "secure_api_app"
      ],
      "imports": [
        "base64",
        "json",
        "pytest",
        "connexion.App",
        "connexion.exceptions.OAuthProblem",
        "connexion.security.NO_VALUE",
        "connexion.security.BasicSecurityHandler",
        "connexion.security.OAuthSecurityHandler"
      ],
      "fixtures": [],
      "assertions": [
        "assert get_inexistent_endpoint.status_code == 401",
        "assert get_inexistent_endpoint.headers.get('content-type') == 'application/problem+json'",
        "assert get_inexistent_endpoint.status_code == 404",
        "assert get_inexistent_endpoint.headers.get('content-type') == 'application/problem+json'",
        "assert get_inexistent_endpoint.status_code == 401",
        "assert post_greeting.status_code == 200",
        "assert post_greeting.status_code == 401"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "get_inexistent_endpoint.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "get_inexistent_endpoint.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_security",
      "module": "test_secure_api",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_secure_api.py",
      "line_number": 92,
      "end_line_number": 170,
      "source_code": "def test_security(oauth_requests, secure_endpoint_app):\n    app_client = secure_endpoint_app.test_client()\n\n    get_bye_no_auth = app_client.get(\"/v1.0/byesecure/jsantos\")\n    assert get_bye_no_auth.status_code == 401\n    assert get_bye_no_auth.headers.get(\"content-type\") == \"application/problem+json\"\n    get_bye_no_auth_response = get_bye_no_auth.json()\n    assert get_bye_no_auth_response[\"detail\"] == \"No authorization token provided\"\n\n    headers = {\"Authorization\": \"Bearer 100\"}\n    get_bye_good_auth = app_client.get(\"/v1.0/byesecure/jsantos\", headers=headers)\n    assert get_bye_good_auth.status_code == 200\n    assert get_bye_good_auth.text == \"Goodbye jsantos (Secure: test-user)\"\n\n    headers = {\"Authorization\": \"Bearer 200\"}\n    get_bye_wrong_scope = app_client.get(\"/v1.0/byesecure/jsantos\", headers=headers)\n    assert get_bye_wrong_scope.status_code == 403\n    assert get_bye_wrong_scope.headers.get(\"content-type\") == \"application/problem+json\"\n    get_bye_wrong_scope_response = get_bye_wrong_scope.json()\n    assert get_bye_wrong_scope_response[\"detail\"].startswith(\n        \"Provided token does not have the required scope\"\n    )\n\n    headers = {\"Authorization\": \"Bearer 300\"}\n    get_bye_bad_token = app_client.get(\"/v1.0/byesecure/jsantos\", headers=headers)\n    assert get_bye_bad_token.status_code == 401\n    assert get_bye_bad_token.headers.get(\"content-type\") == \"application/problem+json\"\n    get_bye_bad_token_response = get_bye_bad_token.json()\n    assert get_bye_bad_token_response[\"detail\"] == \"Provided token is not valid\"\n\n    response = app_client.get(\"/v1.0/more-than-one-security-definition\")\n    assert response.status_code == 401\n\n    # also tests case-insensitivity\n    headers = {\"X-AUTH\": \"mykey\"}\n    response = app_client.get(\n        \"/v1.0/more-than-one-security-definition\", headers=headers\n    )\n    assert response.status_code == 200\n\n    headers = {\"Authorization\": \"Bearer 100\"}\n    get_bye_good_auth = app_client.get(\n        \"/v1.0/byesecure-ignoring-context/hjacobs\", headers=headers\n    )\n    assert get_bye_good_auth.status_code == 200\n    assert get_bye_good_auth.text == \"Goodbye hjacobs (Secure!)\"\n\n    headers = {\"Authorization\": \"Bearer 100\"}\n    get_bye_from_flask = app_client.get(\"/v1.0/byesecure-from-flask\", headers=headers)\n    assert get_bye_from_flask.text == \"Goodbye test-user (Secure!)\"\n\n    headers = {\"Authorization\": \"Bearer 100\"}\n    get_bye_from_connexion = app_client.get(\n        \"/v1.0/byesecure-from-connexion\", headers=headers\n    )\n    assert get_bye_from_connexion.text == \"Goodbye test-user (Secure!)\"\n\n    headers = {\"Authorization\": \"Bearer 100\"}\n    get_bye_from_connexion = app_client.get(\n        \"/v1.0/byesecure-jwt/test-user\", headers=headers\n    )\n    assert get_bye_from_connexion.text == \"Goodbye test-user (Secure: 100)\"\n\n    # has optional auth\n    response = app_client.get(\"/v1.0/optional-auth\")\n    assert response.status_code == 200\n    assert response.text == '\"Unauthenticated\"\\n'\n    headers = {\"X-AUTH\": \"mykey\"}\n    response = app_client.get(\"/v1.0/optional-auth\", headers=headers)\n    assert response.status_code == 200\n    assert response.text == '\"Authenticated\"\\n'\n    headers = {\"X-AUTH\": \"wrong-key\"}\n    response = app_client.get(\"/v1.0/optional-auth\", headers=headers)\n    assert response.text == '\"Unauthenticated\"\\n'\n    assert response.status_code == 200\n\n    # security function throws exception\n    response = app_client.get(\"/v1.0/auth-exception\", headers={\"X-Api-Key\": \"foo\"})\n    assert response.status_code == 401",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "oauth_requests",
        "secure_endpoint_app"
      ],
      "imports": [
        "base64",
        "json",
        "pytest",
        "connexion.App",
        "connexion.exceptions.OAuthProblem",
        "connexion.security.NO_VALUE",
        "connexion.security.BasicSecurityHandler",
        "connexion.security.OAuthSecurityHandler"
      ],
      "fixtures": [],
      "assertions": [
        "assert get_bye_no_auth.status_code == 401",
        "assert get_bye_no_auth.headers.get('content-type') == 'application/problem+json'",
        "assert get_bye_no_auth_response['detail'] == 'No authorization token provided'",
        "assert get_bye_good_auth.status_code == 200",
        "assert get_bye_good_auth.text == 'Goodbye jsantos (Secure: test-user)'",
        "assert get_bye_wrong_scope.status_code == 403",
        "assert get_bye_wrong_scope.headers.get('content-type') == 'application/problem+json'",
        "assert get_bye_wrong_scope_response['detail'].startswith('Provided token does not have the required scope')",
        "assert get_bye_bad_token.status_code == 401",
        "assert get_bye_bad_token.headers.get('content-type') == 'application/problem+json'",
        "assert get_bye_bad_token_response['detail'] == 'Provided token is not valid'",
        "assert response.status_code == 401",
        "assert response.status_code == 200",
        "assert get_bye_good_auth.status_code == 200",
        "assert get_bye_good_auth.text == 'Goodbye hjacobs (Secure!)'",
        "assert get_bye_from_flask.text == 'Goodbye test-user (Secure!)'",
        "assert get_bye_from_connexion.text == 'Goodbye test-user (Secure!)'",
        "assert get_bye_from_connexion.text == 'Goodbye test-user (Secure: 100)'",
        "assert response.status_code == 200",
        "assert response.text == '\"Unauthenticated\"\\n'",
        "assert response.status_code == 200",
        "assert response.text == '\"Authenticated\"\\n'",
        "assert response.text == '\"Unauthenticated\"\\n'",
        "assert response.status_code == 200",
        "assert response.status_code == 401"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "get_bye_no_auth.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "get_bye_wrong_scope.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "get_bye_bad_token.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "get_bye_no_auth.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "get_bye_wrong_scope.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "get_bye_bad_token.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_checking_that_client_token_has_all_necessary_scopes",
      "module": "test_secure_api",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_secure_api.py",
      "line_number": 173,
      "end_line_number": 201,
      "source_code": "def test_checking_that_client_token_has_all_necessary_scopes(\n    oauth_requests, secure_endpoint_app\n):\n    app_client = secure_endpoint_app.test_client()\n\n    # has only one of the required scopes\n    headers = {\"Authorization\": \"Bearer has_myscope\"}\n    response = app_client.get(\"/v1.0/more-than-one-scope\", headers=headers)\n    assert response.status_code == 403\n\n    # has none of the necessary scopes\n    headers = {\"Authorization\": \"Bearer has_wrongscope\"}\n    response = app_client.get(\"/v1.0/more-than-one-scope\", headers=headers)\n    assert response.status_code == 403\n\n    # is not auth\n    headers = {\"Authorization\": \"Bearer is_not_invalid\"}\n    response = app_client.get(\"/v1.0/more-than-one-scope\", headers=headers)\n    assert response.status_code == 401\n\n    # has all necessary scopes\n    headers = {\"Authorization\": \"Bearer has_myscope_otherscope\"}\n    response = app_client.get(\"/v1.0/more-than-one-scope\", headers=headers)\n    assert response.status_code == 200\n\n    # has all necessary scopes but under key 'scopes'\n    headers = {\"Authorization\": \"Bearer has_scopes_in_scopes_with_s\"}\n    response = app_client.get(\"/v1.0/more-than-one-scope\", headers=headers)\n    assert response.status_code == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "oauth_requests",
        "secure_endpoint_app"
      ],
      "imports": [
        "base64",
        "json",
        "pytest",
        "connexion.App",
        "connexion.exceptions.OAuthProblem",
        "connexion.security.NO_VALUE",
        "connexion.security.BasicSecurityHandler",
        "connexion.security.OAuthSecurityHandler"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 403",
        "assert response.status_code == 403",
        "assert response.status_code == 401",
        "assert response.status_code == 200",
        "assert response.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_security_with_strict_validation",
      "module": "test_secure_api",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_secure_api.py",
      "line_number": 204,
      "end_line_number": 227,
      "source_code": "def test_security_with_strict_validation(secure_endpoint_strict_app):\n    app_client = secure_endpoint_strict_app.test_client()\n\n    res = app_client.get(\"/v1.0/test_apikey_query_parameter_validation\")\n    assert res.status_code == 401\n\n    res = app_client.get(\n        \"/v1.0/test_apikey_query_parameter_validation\",\n        params={\"name\": \"foo\"},\n    )\n    assert res.status_code == 401\n\n    res = app_client.get(\n        \"/v1.0/test_apikey_query_parameter_validation\",\n        params={\"apikey\": \"mykey\", \"name\": \"foo\"},\n    )\n    assert res.status_code == 200\n\n    res = app_client.get(\n        \"/v1.0/test_apikey_query_parameter_validation\",\n        params={\"apikey\": \"mykey\", \"name\": \"foo\", \"extra_param\": \"bar\"},\n    )\n    assert res.status_code == 400\n    assert res.json()[\"detail\"] == \"Extra query parameter(s) extra_param not in spec\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "secure_endpoint_strict_app"
      ],
      "imports": [
        "base64",
        "json",
        "pytest",
        "connexion.App",
        "connexion.exceptions.OAuthProblem",
        "connexion.security.NO_VALUE",
        "connexion.security.BasicSecurityHandler",
        "connexion.security.OAuthSecurityHandler"
      ],
      "fixtures": [],
      "assertions": [
        "assert res.status_code == 401",
        "assert res.status_code == 401",
        "assert res.status_code == 200",
        "assert res.status_code == 400",
        "assert res.json()['detail'] == 'Extra query parameter(s) extra_param not in spec'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        },
        {
          "name": "res.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        }
      ]
    },
    {
      "name": "test_security_map",
      "module": "test_secure_api",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_secure_api.py",
      "line_number": 230,
      "end_line_number": 290,
      "source_code": "def test_security_map(secure_api_spec_dir, spec):\n    class MyBasicSecurityHandler(BasicSecurityHandler):\n        \"\"\"Uses my_basic instead of basic as auth type.\"\"\"\n\n        def _get_verify_func(self, basic_info_func):\n            check_basic_info_func = self.check_basic_auth(basic_info_func)\n\n            def wrapper(request):\n                auth_type, user_pass = self.get_auth_header_value(request)\n                if auth_type != \"my_basic\":\n                    return NO_VALUE\n\n                try:\n                    username, password = (\n                        base64.b64decode(user_pass).decode(\"latin1\").split(\":\", 1)\n                    )\n                except Exception:\n                    raise OAuthProblem(detail=\"Invalid authorization header\")\n\n                return check_basic_info_func(request, username, password)\n\n            return wrapper\n\n    security_map = {\n        \"basic\": MyBasicSecurityHandler,\n    }\n    # api level\n    app = App(__name__, specification_dir=secure_api_spec_dir)\n    app.add_api(spec, security_map=security_map)\n    app_client = app.test_client()\n\n    res = app_client.post(\n        \"/v1.0/greeting_basic/\",\n        headers={\"Authorization\": \"basic dGVzdDp0ZXN0\"},\n    )\n    assert res.status_code == 401\n\n    res = app_client.post(\n        \"/v1.0/greeting_basic\",\n        headers={\"Authorization\": \"my_basic dGVzdDp0ZXN0\"},\n    )\n    assert res.status_code == 200\n\n    # app level\n    app = App(\n        __name__, specification_dir=secure_api_spec_dir, security_map=security_map\n    )\n    app.add_api(spec)\n    app_client = app.test_client()\n\n    res = app_client.post(\n        \"/v1.0/greeting_basic/\",\n        headers={\"Authorization\": \"basic dGVzdDp0ZXN0\"},\n    )\n    assert res.status_code == 401\n\n    res = app_client.post(\n        \"/v1.0/greeting_basic\",\n        headers={\"Authorization\": \"my_basic dGVzdDp0ZXN0\"},\n    )\n    assert res.status_code == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "secure_api_spec_dir",
        "spec"
      ],
      "imports": [
        "base64",
        "json",
        "pytest",
        "connexion.App",
        "connexion.exceptions.OAuthProblem",
        "connexion.security.NO_VALUE",
        "connexion.security.BasicSecurityHandler",
        "connexion.security.OAuthSecurityHandler"
      ],
      "fixtures": [],
      "assertions": [
        "assert res.status_code == 401",
        "assert res.status_code == 200",
        "assert res.status_code == 401",
        "assert res.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        }
      ]
    },
    {
      "name": "test_headers_jsonifier",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_headers.py",
      "line_number": 4,
      "end_line_number": 10,
      "source_code": "def test_headers_jsonifier(simple_app):\n    app_client = simple_app.test_client()\n\n    response = app_client.post(\"/v1.0/goodday/dan\", data={})\n    assert response.status_code == 201\n    # Default Werkzeug behavior was changed in 2.1 (https://github.com/pallets/werkzeug/issues/2352)\n    assert response.headers[\"Location\"] in [\"http://localhost/my/uri\", \"/my/uri\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 201",
        "assert response.headers['Location'] in ['http://localhost/my/uri', '/my/uri']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        }
      ]
    },
    {
      "name": "test_headers_produces",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_headers.py",
      "line_number": 13,
      "end_line_number": 19,
      "source_code": "def test_headers_produces(simple_app):\n    app_client = simple_app.test_client()\n\n    response = app_client.post(\"/v1.0/goodevening/dan\", data={})\n    assert response.status_code == 201\n    # Default Werkzeug behavior was changed in 2.1 (https://github.com/pallets/werkzeug/issues/2352)\n    assert response.headers[\"Location\"] in [\"http://localhost/my/uri\", \"/my/uri\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 201",
        "assert response.headers['Location'] in ['http://localhost/my/uri', '/my/uri']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        }
      ]
    },
    {
      "name": "test_header_not_returned",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_headers.py",
      "line_number": 22,
      "end_line_number": 37,
      "source_code": "def test_header_not_returned(simple_openapi_app):\n    app_client = simple_openapi_app.test_client()\n\n    response = app_client.post(\"/v1.0/goodday/noheader\", data={})\n    assert (\n        response.status_code == 500\n    )  # view_func has not returned what was promised in spec\n    assert response.headers.get(\"content-type\") == \"application/problem+json\"\n    data = response.json()\n    assert data[\"type\"] == \"about:blank\"\n    assert data[\"title\"] == \"Internal Server Error\"\n    assert (\n        data[\"detail\"]\n        == \"Keys in response header don't match response specification. Difference: location\"\n    )\n    assert data[\"status\"] == 500",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_openapi_app"
      ],
      "imports": [
        "json"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 500",
        "assert response.headers.get('content-type') == 'application/problem+json'",
        "assert data['type'] == 'about:blank'",
        "assert data['title'] == 'Internal Server Error'",
        "assert data['detail'] == \"Keys in response header don't match response specification. Difference: location\"",
        "assert data['status'] == 500"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.post",
          "body": "def post(self, **kwargs):\n    kwargs.update({'name': 'post'})\n    return (kwargs, 201)"
        },
        {
          "name": "response.json",
          "body": "def json(self):\n    return json.loads(self.text)"
        },
        {
          "name": "response.headers.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_no_content_response_have_headers",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_headers.py",
      "line_number": 40,
      "end_line_number": 44,
      "source_code": "def test_no_content_response_have_headers(simple_app):\n    app_client = simple_app.test_client()\n    resp = app_client.get(\"/v1.0/test-204-with-headers\")\n    assert resp.status_code == 204\n    assert \"X-Something\" in resp.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 204",
        "assert 'X-Something' in resp.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_no_content_object_and_have_headers",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_headers.py",
      "line_number": 47,
      "end_line_number": 51,
      "source_code": "def test_no_content_object_and_have_headers(simple_app):\n    app_client = simple_app.test_client()\n    resp = app_client.get(\"/v1.0/test-204-with-headers-nocontent-obj\")\n    assert resp.status_code == 204\n    assert \"X-Something\" in resp.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "json"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 204",
        "assert 'X-Something' in resp.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    },
    {
      "name": "test_optional_header",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/connexion/tests/api/test_headers.py",
      "line_number": 54,
      "end_line_number": 58,
      "source_code": "def test_optional_header(simple_openapi_app):\n    app_client = simple_openapi_app.test_client()\n    resp = app_client.get(\"/v1.0/test-optional-headers\")\n    assert resp.status_code == 200\n    assert \"X-Optional-Header\" not in resp.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_openapi_app"
      ],
      "imports": [
        "json"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 200",
        "assert 'X-Optional-Header' not in resp.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_client.get",
          "body": "def get(self, **kwargs):\n    if kwargs:\n        kwargs.update({'name': 'get'})\n        return kwargs\n    else:\n        return [{'name': 'get'}]"
        }
      ]
    }
  ]
}