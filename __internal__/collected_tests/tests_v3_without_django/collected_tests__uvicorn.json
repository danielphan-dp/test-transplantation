{
  "tests": [
    {
      "name": "test_run_invalid_app_config_combination",
      "module": "test_main",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_main.py",
      "line_number": 75,
      "end_line_number": 83,
      "source_code": "def test_run_invalid_app_config_combination(caplog: pytest.LogCaptureFixture) -> None:\n    with pytest.raises(SystemExit) as exit_exception:\n        run(app, reload=True)\n    assert exit_exception.value.code == 1\n    assert caplog.records[-1].name == \"uvicorn.error\"\n    assert caplog.records[-1].levelno == WARNING\n    assert caplog.records[-1].message == (\n        \"You must pass the application as an import string to enable \" \"'reload' or 'workers'.\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "caplog"
      ],
      "imports": [
        "inspect",
        "socket",
        "logging.WARNING",
        "httpx",
        "pytest",
        "tests.utils.run_server",
        "uvicorn.Server",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Scope",
        "uvicorn.config.Config",
        "uvicorn.main.run"
      ],
      "fixtures": [],
      "assertions": [
        "assert exit_exception.value.code == 1",
        "assert caplog.records[-1].name == 'uvicorn.error'",
        "assert caplog.records[-1].levelno == WARNING",
        "assert caplog.records[-1].message == \"You must pass the application as an import string to enable 'reload' or 'workers'.\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "run",
          "body": "def run(sockets):\n    pass"
        }
      ]
    },
    {
      "name": "test_run_startup_failure",
      "module": "test_main",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_main.py",
      "line_number": 86,
      "end_line_number": 95,
      "source_code": "def test_run_startup_failure(caplog: pytest.LogCaptureFixture) -> None:\n    async def app(scope, receive, send):\n        assert scope[\"type\"] == \"lifespan\"\n        message = await receive()\n        if message[\"type\"] == \"lifespan.startup\":\n            raise RuntimeError(\"Startup failed\")\n\n    with pytest.raises(SystemExit) as exit_exception:\n        run(app, lifespan=\"on\")\n    assert exit_exception.value.code == 3",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "caplog"
      ],
      "imports": [
        "inspect",
        "socket",
        "logging.WARNING",
        "httpx",
        "pytest",
        "tests.utils.run_server",
        "uvicorn.Server",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Scope",
        "uvicorn.config.Config",
        "uvicorn.main.run"
      ],
      "fixtures": [],
      "assertions": [
        "assert exit_exception.value.code == 3",
        "assert scope['type'] == 'lifespan'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "run",
          "body": "def run(sockets):\n    pass"
        }
      ]
    },
    {
      "name": "test_run_match_config_params",
      "module": "test_main",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_main.py",
      "line_number": 98,
      "end_line_number": 107,
      "source_code": "def test_run_match_config_params() -> None:\n    config_params = {\n        key: repr(value)\n        for key, value in inspect.signature(Config.__init__).parameters.items()\n        if key not in (\"self\", \"timeout_notify\", \"callback_notify\")\n    }\n    run_params = {\n        key: repr(value) for key, value in inspect.signature(run).parameters.items() if key not in (\"app_dir\",)\n    }\n    assert config_params == run_params",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "inspect",
        "socket",
        "logging.WARNING",
        "httpx",
        "pytest",
        "tests.utils.run_server",
        "uvicorn.Server",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Scope",
        "uvicorn.config.Config",
        "uvicorn.main.run"
      ],
      "fixtures": [],
      "assertions": [
        "assert config_params == run_params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get_subprocess",
      "module": "test_subprocess",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_subprocess.py",
      "line_number": 19,
      "end_line_number": 28,
      "source_code": "def test_get_subprocess() -> None:\n    fdsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    fd = fdsock.fileno()\n    config = Config(app=app, fd=fd)\n    config.load()\n\n    process = get_subprocess(config, server_run, [fdsock])\n    assert isinstance(process, SpawnProcess)\n\n    fdsock.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "socket",
        "unittest.mock.patch",
        "uvicorn._subprocess.SpawnProcess",
        "uvicorn._subprocess.get_subprocess",
        "uvicorn._subprocess.subprocess_started",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Scope",
        "uvicorn.config.Config"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(process, SpawnProcess)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "fdsock.close",
          "body": "def close(self):\n    assert not self.closed\n    self.closed = True"
        }
      ]
    },
    {
      "name": "test_subprocess_started",
      "module": "test_subprocess",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_subprocess.py",
      "line_number": 31,
      "end_line_number": 43,
      "source_code": "def test_subprocess_started() -> None:\n    fdsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    fd = fdsock.fileno()\n    config = Config(app=app, fd=fd)\n    config.load()\n\n    with patch(\"tests.test_subprocess.server_run\") as mock_run:\n        with patch.object(config, \"configure_logging\") as mock_config_logging:\n            subprocess_started(config, server_run, [fdsock], None)\n            mock_run.assert_called_once()\n            mock_config_logging.assert_called_once()\n\n    fdsock.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "socket",
        "unittest.mock.patch",
        "uvicorn._subprocess.SpawnProcess",
        "uvicorn._subprocess.get_subprocess",
        "uvicorn._subprocess.subprocess_started",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Scope",
        "uvicorn.config.Config"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "fdsock.close",
          "body": "def close(self):\n    assert not self.closed\n    self.closed = True"
        }
      ]
    },
    {
      "name": "test_config_should_reload_is_set",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 61,
      "end_line_number": 64,
      "source_code": "def test_config_should_reload_is_set(app: ASGIApplication, expected_should_reload: bool) -> None:\n    config = Config(app=app, reload=True)\n    assert config.reload is True\n    assert config.should_reload is expected_should_reload",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('app, expected_should_reload', [(asgi_app, False), ('tests.test_config:asgi_app', True)])"
      ],
      "arguments": [
        "app",
        "expected_should_reload"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert config.reload is True",
        "assert config.should_reload is expected_should_reload"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_should_warn_on_invalid_reload_configuration",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 67,
      "end_line_number": 82,
      "source_code": "def test_should_warn_on_invalid_reload_configuration(tmp_path: Path, caplog: pytest.LogCaptureFixture) -> None:\n    config_class = Config(app=asgi_app, reload_dirs=[str(tmp_path)])\n    assert not config_class.should_reload\n    assert len(caplog.records) == 1\n    assert (\n        caplog.records[-1].message == \"Current configuration will not reload as not all conditions are met, \"\n        \"please refer to documentation.\"\n    )\n\n    config_no_reload = Config(app=\"tests.test_config:asgi_app\", reload_dirs=[str(tmp_path)])\n    assert not config_no_reload.should_reload\n    assert len(caplog.records) == 2\n    assert (\n        caplog.records[-1].message == \"Current configuration will not reload as not all conditions are met, \"\n        \"please refer to documentation.\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmp_path",
        "caplog"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert not config_class.should_reload",
        "assert len(caplog.records) == 1",
        "assert caplog.records[-1].message == 'Current configuration will not reload as not all conditions are met, please refer to documentation.'",
        "assert not config_no_reload.should_reload",
        "assert len(caplog.records) == 2",
        "assert caplog.records[-1].message == 'Current configuration will not reload as not all conditions are met, please refer to documentation.'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_reload_dir_is_set",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 85,
      "end_line_number": 93,
      "source_code": "def test_reload_dir_is_set(reload_directory_structure: Path, caplog: pytest.LogCaptureFixture) -> None:\n    app_dir = reload_directory_structure / \"app\"\n    with caplog.at_level(logging.INFO):\n        config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_dirs=[str(app_dir)])\n        assert len(caplog.records) == 1\n        assert caplog.records[-1].message == f\"Will watch for changes in these directories: {[str(app_dir)]}\"\n        assert config.reload_dirs == [app_dir]\n        config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_dirs=str(app_dir))\n        assert config.reload_dirs == [app_dir]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "reload_directory_structure",
        "caplog"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(caplog.records) == 1",
        "assert caplog.records[-1].message == f'Will watch for changes in these directories: {[str(app_dir)]}'",
        "assert config.reload_dirs == [app_dir]",
        "assert config.reload_dirs == [app_dir]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_non_existant_reload_dir_is_not_set",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 96,
      "end_line_number": 104,
      "source_code": "def test_non_existant_reload_dir_is_not_set(reload_directory_structure: Path, caplog: pytest.LogCaptureFixture) -> None:\n    with as_cwd(reload_directory_structure), caplog.at_level(logging.WARNING):\n        config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_dirs=[\"reload\"])\n        assert config.reload_dirs == [reload_directory_structure]\n        assert (\n            caplog.records[-1].message\n            == \"Provided reload directories ['reload'] did not contain valid \"\n            + \"directories, watching current working directory.\"\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "reload_directory_structure",
        "caplog"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert config.reload_dirs == [reload_directory_structure]",
        "assert caplog.records[-1].message == \"Provided reload directories ['reload'] did not contain valid \" + 'directories, watching current working directory.'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        }
      ]
    },
    {
      "name": "test_reload_subdir_removal",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 107,
      "end_line_number": 114,
      "source_code": "def test_reload_subdir_removal(reload_directory_structure: Path) -> None:\n    app_dir = reload_directory_structure / \"app\"\n\n    reload_dirs = [str(reload_directory_structure), \"app\", str(app_dir)]\n\n    with as_cwd(reload_directory_structure):\n        config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_dirs=reload_dirs)\n        assert config.reload_dirs == [reload_directory_structure]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "reload_directory_structure"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert config.reload_dirs == [reload_directory_structure]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        }
      ]
    },
    {
      "name": "test_reload_included_dir_is_added_to_reload_dirs",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 117,
      "end_line_number": 131,
      "source_code": "def test_reload_included_dir_is_added_to_reload_dirs(\n    reload_directory_structure: Path,\n) -> None:\n    app_dir = reload_directory_structure / \"app\"\n    ext_dir = reload_directory_structure / \"ext\"\n\n    with as_cwd(reload_directory_structure):\n        config = Config(\n            app=\"tests.test_config:asgi_app\",\n            reload=True,\n            reload_dirs=[str(app_dir)],\n            reload_includes=[\"*.js\", str(ext_dir)],\n        )\n        assert frozenset(config.reload_dirs), frozenset([app_dir, ext_dir])\n        assert frozenset(config.reload_includes) == frozenset([\"*.js\", str(ext_dir)])",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "reload_directory_structure"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert frozenset(config.reload_dirs), frozenset([app_dir, ext_dir])",
        "assert frozenset(config.reload_includes) == frozenset(['*.js', str(ext_dir)])"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        }
      ]
    },
    {
      "name": "test_reload_dir_subdirectories_are_removed",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 134,
      "end_line_number": 153,
      "source_code": "def test_reload_dir_subdirectories_are_removed(\n    reload_directory_structure: Path,\n) -> None:\n    app_dir = reload_directory_structure / \"app\"\n    app_sub_dir = app_dir / \"sub\"\n    ext_dir = reload_directory_structure / \"ext\"\n    ext_sub_dir = ext_dir / \"sub\"\n\n    with as_cwd(reload_directory_structure):\n        config = Config(\n            app=\"tests.test_config:asgi_app\",\n            reload=True,\n            reload_dirs=[\n                str(app_dir),\n                str(app_sub_dir),\n                str(ext_sub_dir),\n                str(ext_dir),\n            ],\n        )\n        assert frozenset(config.reload_dirs) == frozenset([app_dir, ext_dir])",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "reload_directory_structure"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert frozenset(config.reload_dirs) == frozenset([app_dir, ext_dir])"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        }
      ]
    },
    {
      "name": "test_reload_excluded_subdirectories_are_removed",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 156,
      "end_line_number": 170,
      "source_code": "def test_reload_excluded_subdirectories_are_removed(\n    reload_directory_structure: Path,\n) -> None:\n    app_dir = reload_directory_structure / \"app\"\n    app_sub_dir = app_dir / \"sub\"\n\n    with as_cwd(reload_directory_structure):\n        config = Config(\n            app=\"tests.test_config:asgi_app\",\n            reload=True,\n            reload_excludes=[str(app_dir), str(app_sub_dir)],\n        )\n        assert frozenset(config.reload_dirs) == frozenset([reload_directory_structure])\n        assert frozenset(config.reload_dirs_excludes) == frozenset([app_dir])\n        assert frozenset(config.reload_excludes) == frozenset([str(app_dir), str(app_sub_dir)])",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "reload_directory_structure"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert frozenset(config.reload_dirs) == frozenset([reload_directory_structure])",
        "assert frozenset(config.reload_dirs_excludes) == frozenset([app_dir])",
        "assert frozenset(config.reload_excludes) == frozenset([str(app_dir), str(app_sub_dir)])"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        }
      ]
    },
    {
      "name": "test_reload_includes_exclude_dir_patterns_are_matched",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 173,
      "end_line_number": 193,
      "source_code": "def test_reload_includes_exclude_dir_patterns_are_matched(\n    reload_directory_structure: Path, caplog: pytest.LogCaptureFixture\n) -> None:\n    with caplog.at_level(logging.INFO):\n        first_app_dir = reload_directory_structure / \"app_first\" / \"src\"\n        second_app_dir = reload_directory_structure / \"app_second\" / \"src\"\n\n        with as_cwd(reload_directory_structure):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\"*/src\"],\n                reload_excludes=[\"app\", \"*third*\"],\n            )\n            assert len(caplog.records) == 1\n            assert (\n                caplog.records[-1].message == \"Will watch for changes in these directories: \"\n                f\"{sorted([str(first_app_dir), str(second_app_dir)])}\"\n            )\n            assert frozenset(config.reload_dirs) == frozenset([first_app_dir, second_app_dir])\n            assert config.reload_includes == [\"*/src\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "reload_directory_structure",
        "caplog"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(caplog.records) == 1",
        "assert caplog.records[-1].message == f'Will watch for changes in these directories: {sorted([str(first_app_dir), str(second_app_dir)])}'",
        "assert frozenset(config.reload_dirs) == frozenset([first_app_dir, second_app_dir])",
        "assert config.reload_includes == ['*/src']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        }
      ]
    },
    {
      "name": "test_wsgi_app",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 196,
      "end_line_number": 202,
      "source_code": "def test_wsgi_app() -> None:\n    config = Config(app=wsgi_app, interface=\"wsgi\", proxy_headers=False)\n    config.load()\n\n    assert isinstance(config.loaded_app, WSGIMiddleware)\n    assert config.interface == \"wsgi\"\n    assert config.asgi_version == \"3.0\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(config.loaded_app, WSGIMiddleware)",
        "assert config.interface == 'wsgi'",
        "assert config.asgi_version == '3.0'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_proxy_headers",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 205,
      "end_line_number": 210,
      "source_code": "def test_proxy_headers() -> None:\n    config = Config(app=asgi_app)\n    config.load()\n\n    assert config.proxy_headers is True\n    assert isinstance(config.loaded_app, ProxyHeadersMiddleware)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert config.proxy_headers is True",
        "assert isinstance(config.loaded_app, ProxyHeadersMiddleware)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_app_unimportable_module",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 213,
      "end_line_number": 216,
      "source_code": "def test_app_unimportable_module() -> None:\n    config = Config(app=\"no.such:app\")\n    with pytest.raises(ImportError):\n        config.load()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_app_unimportable_other",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 219,
      "end_line_number": 229,
      "source_code": "def test_app_unimportable_other(caplog: pytest.LogCaptureFixture) -> None:\n    config = Config(app=\"tests.test_config:app\")\n    with pytest.raises(SystemExit):\n        config.load()\n    error_messages = [\n        record.message for record in caplog.records if record.name == \"uvicorn.error\" and record.levelname == \"ERROR\"\n    ]\n    assert (\n        'Error loading ASGI app. Attribute \"app\" not found in module \"tests.test_config\".'  # noqa: E501\n        == error_messages.pop(0)\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "caplog"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'Error loading ASGI app. Attribute \"app\" not found in module \"tests.test_config\".' == error_messages.pop(0)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_app_factory",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 232,
      "end_line_number": 253,
      "source_code": "def test_app_factory(caplog: pytest.LogCaptureFixture) -> None:\n    def create_app() -> ASGIApplication:\n        return asgi_app\n\n    config = Config(app=create_app, factory=True, proxy_headers=False)\n    config.load()\n    assert config.loaded_app is asgi_app\n\n    # Flag not passed. In this case, successfully load the app, but issue a warning\n    # to indicate that an explicit flag is preferred.\n    caplog.clear()\n    config = Config(app=create_app, proxy_headers=False)\n    with caplog.at_level(logging.WARNING):\n        config.load()\n    assert config.loaded_app is asgi_app\n    assert len(caplog.records) == 1\n    assert \"--factory\" in caplog.records[0].message\n\n    # App not a no-arguments callable.\n    config = Config(app=asgi_app, factory=True)\n    with pytest.raises(SystemExit):\n        config.load()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "caplog"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert config.loaded_app is asgi_app",
        "assert config.loaded_app is asgi_app",
        "assert len(caplog.records) == 1",
        "assert '--factory' in caplog.records[0].message"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_concrete_http_class",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 256,
      "end_line_number": 259,
      "source_code": "def test_concrete_http_class() -> None:\n    config = Config(app=asgi_app, http=H11Protocol)\n    config.load()\n    assert config.http_protocol_class is H11Protocol",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert config.http_protocol_class is H11Protocol"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_socket_bind",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 262,
      "end_line_number": 267,
      "source_code": "def test_socket_bind() -> None:\n    config = Config(app=asgi_app)\n    config.load()\n    sock = config.bind_socket()\n    assert isinstance(sock, socket.socket)\n    sock.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(sock, socket.socket)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "sock.close",
          "body": "def close(self):\n    assert not self.closed\n    self.closed = True"
        }
      ]
    },
    {
      "name": "test_ssl_config",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 270,
      "end_line_number": 281,
      "source_code": "def test_ssl_config(\n    tls_ca_certificate_pem_path: str,\n    tls_ca_certificate_private_key_path: str,\n) -> None:\n    config = Config(\n        app=asgi_app,\n        ssl_certfile=tls_ca_certificate_pem_path,\n        ssl_keyfile=tls_ca_certificate_private_key_path,\n    )\n    config.load()\n\n    assert config.is_ssl is True",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tls_ca_certificate_pem_path",
        "tls_ca_certificate_private_key_path"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert config.is_ssl is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ssl_config_combined",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 284,
      "end_line_number": 291,
      "source_code": "def test_ssl_config_combined(tls_certificate_key_and_chain_path: str) -> None:\n    config = Config(\n        app=asgi_app,\n        ssl_certfile=tls_certificate_key_and_chain_path,\n    )\n    config.load()\n\n    assert config.is_ssl is True",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tls_certificate_key_and_chain_path"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert config.is_ssl is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_asgi_version",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 302,
      "end_line_number": 305,
      "source_code": "def test_asgi_version(app: ASGIApplication, expected_interface: Literal[\"2.0\", \"3.0\"]) -> None:\n    config = Config(app=app)\n    config.load()\n    assert config.asgi_version == expected_interface",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('app, expected_interface', [(asgi_app, '3.0'), (asgi2_app, '2.0')])"
      ],
      "arguments": [
        "app",
        "expected_interface"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert config.asgi_version == expected_interface"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_log_config_default",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 317,
      "end_line_number": 333,
      "source_code": "def test_log_config_default(\n    mocked_logging_config_module: MagicMock,\n    use_colors: bool | None,\n    expected: bool | None,\n    logging_config: dict[str, Any],\n) -> None:\n    \"\"\"\n    Test that one can specify the use_colors option when using the default logging\n    config.\n    \"\"\"\n    config = Config(app=asgi_app, use_colors=use_colors, log_config=logging_config)\n    config.load()\n\n    mocked_logging_config_module.dictConfig.assert_called_once_with(logging_config)\n\n    (provided_dict_config,), _ = mocked_logging_config_module.dictConfig.call_args\n    assert provided_dict_config[\"formatters\"][\"default\"][\"use_colors\"] == expected",
      "docstring": "Test that one can specify the use_colors option when using the default logging\nconfig.",
      "decorators": [
        "pytest.mark.parametrize('use_colors, expected', [pytest.param(None, None, id='use_colors_not_provided'), pytest.param('invalid', None, id='use_colors_invalid_value'), pytest.param(True, True, id='use_colors_enabled'), pytest.param(False, False, id='use_colors_disabled')])"
      ],
      "arguments": [
        "mocked_logging_config_module",
        "use_colors",
        "expected",
        "logging_config"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert provided_dict_config['formatters']['default']['use_colors'] == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_log_config_json",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 336,
      "end_line_number": 351,
      "source_code": "def test_log_config_json(\n    mocked_logging_config_module: MagicMock,\n    logging_config: dict[str, Any],\n    json_logging_config: str,\n    mocker: MockerFixture,\n) -> None:\n    \"\"\"\n    Test that one can load a json config from disk.\n    \"\"\"\n    mocked_open = mocker.patch(\"uvicorn.config.open\", mocker.mock_open(read_data=json_logging_config))\n\n    config = Config(app=asgi_app, log_config=\"log_config.json\")\n    config.load()\n\n    mocked_open.assert_called_once_with(\"log_config.json\")\n    mocked_logging_config_module.dictConfig.assert_called_once_with(logging_config)",
      "docstring": "Test that one can load a json config from disk.",
      "decorators": [],
      "arguments": [
        "mocked_logging_config_module",
        "logging_config",
        "json_logging_config",
        "mocker"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mocker.patch('uvicorn.config.open', mocker.mock_open(read_data=json_logging_config))"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_log_config_yaml",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 355,
      "end_line_number": 371,
      "source_code": "def test_log_config_yaml(\n    mocked_logging_config_module: MagicMock,\n    logging_config: dict[str, Any],\n    yaml_logging_config: str,\n    mocker: MockerFixture,\n    config_filename: str,\n) -> None:\n    \"\"\"\n    Test that one can load a yaml config from disk.\n    \"\"\"\n    mocked_open = mocker.patch(\"uvicorn.config.open\", mocker.mock_open(read_data=yaml_logging_config))\n\n    config = Config(app=asgi_app, log_config=config_filename)\n    config.load()\n\n    mocked_open.assert_called_once_with(config_filename)\n    mocked_logging_config_module.dictConfig.assert_called_once_with(logging_config)",
      "docstring": "Test that one can load a yaml config from disk.",
      "decorators": [
        "pytest.mark.parametrize('config_filename', ['log_config.yml', 'log_config.yaml'])"
      ],
      "arguments": [
        "mocked_logging_config_module",
        "logging_config",
        "yaml_logging_config",
        "mocker",
        "config_filename"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mocker.patch('uvicorn.config.open', mocker.mock_open(read_data=yaml_logging_config))"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_log_config_file",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 375,
      "end_line_number": 385,
      "source_code": "def test_log_config_file(\n    mocked_logging_config_module: MagicMock,\n    config_file: str | configparser.RawConfigParser | typing.IO[Any],\n) -> None:\n    \"\"\"\n    Test that one can load a configparser config from disk.\n    \"\"\"\n    config = Config(app=asgi_app, log_config=config_file)\n    config.load()\n\n    mocked_logging_config_module.fileConfig.assert_called_once_with(config_file, disable_existing_loggers=False)",
      "docstring": "Test that one can load a configparser config from disk.",
      "decorators": [
        "pytest.mark.parametrize('config_file', ['log_config.ini', configparser.ConfigParser(), io.StringIO()])"
      ],
      "arguments": [
        "mocked_logging_config_module",
        "config_file"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_env_file",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 402,
      "end_line_number": 421,
      "source_code": "def test_env_file(\n    web_concurrency: int,\n    forwarded_allow_ips: str,\n    caplog: pytest.LogCaptureFixture,\n    tmp_path: Path,\n) -> None:\n    \"\"\"\n    Test that one can load environment variables using an env file.\n    \"\"\"\n    fp = tmp_path / \".env\"\n    content = f\"WEB_CONCURRENCY={web_concurrency}\\n\" f\"FORWARDED_ALLOW_IPS={forwarded_allow_ips}\\n\"\n    fp.write_text(content)\n    with caplog.at_level(logging.INFO):\n        config = Config(app=asgi_app, env_file=fp)\n        config.load()\n\n    assert config.workers == int(str(os.getenv(\"WEB_CONCURRENCY\")))\n    assert config.forwarded_allow_ips == os.getenv(\"FORWARDED_ALLOW_IPS\")\n    assert len(caplog.records) == 1\n    assert f\"Loading environment from '{fp}'\" in caplog.records[0].message",
      "docstring": "Test that one can load environment variables using an env file.",
      "decorators": [],
      "arguments": [
        "web_concurrency",
        "forwarded_allow_ips",
        "caplog",
        "tmp_path"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert config.workers == int(str(os.getenv('WEB_CONCURRENCY')))",
        "assert config.forwarded_allow_ips == os.getenv('FORWARDED_ALLOW_IPS')",
        "assert len(caplog.records) == 1",
        "assert f\"Loading environment from '{fp}'\" in caplog.records[0].message"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_config_access_log",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 431,
      "end_line_number": 436,
      "source_code": "def test_config_access_log(access_log: bool, handlers: int) -> None:\n    config = Config(app=asgi_app, access_log=access_log)\n    config.load()\n\n    assert len(logging.getLogger(\"uvicorn.access\").handlers) == handlers\n    assert config.access_log == access_log",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('access_log, handlers', [pytest.param(True, 1, id='access log enabled should have single handler'), pytest.param(False, 0, id=\"access log disabled shouldn't have handlers\")])"
      ],
      "arguments": [
        "access_log",
        "handlers"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(logging.getLogger('uvicorn.access').handlers) == handlers",
        "assert config.access_log == access_log"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_config_log_level",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 440,
      "end_line_number": 447,
      "source_code": "def test_config_log_level(log_level: int) -> None:\n    config = Config(app=asgi_app, log_level=log_level)\n    config.load()\n\n    assert logging.getLogger(\"uvicorn.error\").level == log_level\n    assert logging.getLogger(\"uvicorn.access\").level == log_level\n    assert logging.getLogger(\"uvicorn.asgi\").level == log_level\n    assert config.log_level == log_level",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('log_level', [5, 10, 20, 30, 40, 50])"
      ],
      "arguments": [
        "log_level"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert logging.getLogger('uvicorn.error').level == log_level",
        "assert logging.getLogger('uvicorn.access').level == log_level",
        "assert logging.getLogger('uvicorn.asgi').level == log_level",
        "assert config.log_level == log_level"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_config_log_effective_level",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 452,
      "end_line_number": 467,
      "source_code": "def test_config_log_effective_level(log_level: int, uvicorn_logger_level: int) -> None:\n    default_level = 30\n    log_config = {\n        \"version\": 1,\n        \"disable_existing_loggers\": False,\n        \"loggers\": {\n            \"uvicorn\": {\"level\": uvicorn_logger_level},\n        },\n    }\n    config = Config(app=asgi_app, log_level=log_level, log_config=log_config)\n    config.load()\n\n    effective_level = log_level or uvicorn_logger_level or default_level\n    assert logging.getLogger(\"uvicorn.error\").getEffectiveLevel() == effective_level\n    assert logging.getLogger(\"uvicorn.access\").getEffectiveLevel() == effective_level\n    assert logging.getLogger(\"uvicorn.asgi\").getEffectiveLevel() == effective_level",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('log_level', [None, 0, 5, 10, 20, 30, 40, 50])",
        "pytest.mark.parametrize('uvicorn_logger_level', [0, 5, 10, 20, 30, 40, 50])"
      ],
      "arguments": [
        "log_level",
        "uvicorn_logger_level"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert logging.getLogger('uvicorn.error').getEffectiveLevel() == effective_level",
        "assert logging.getLogger('uvicorn.access').getEffectiveLevel() == effective_level",
        "assert logging.getLogger('uvicorn.asgi').getEffectiveLevel() == effective_level"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ws_max_size",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 470,
      "end_line_number": 473,
      "source_code": "def test_ws_max_size() -> None:\n    config = Config(app=asgi_app, ws_max_size=1000)\n    config.load()\n    assert config.ws_max_size == 1000",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert config.ws_max_size == 1000"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ws_max_queue",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 476,
      "end_line_number": 479,
      "source_code": "def test_ws_max_queue() -> None:\n    config = Config(app=asgi_app, ws_max_queue=64)\n    config.load()\n    assert config.ws_max_queue == 64",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert config.ws_max_queue == 64"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_bind_unix_socket_works_with_reload_or_workers",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 491,
      "end_line_number": 500,
      "source_code": "def test_bind_unix_socket_works_with_reload_or_workers(\n    tmp_path: Path, reload: bool, workers: int, short_socket_name: str\n):  # pragma: py-win32\n    config = Config(app=asgi_app, uds=short_socket_name, reload=reload, workers=workers)\n    config.load()\n    sock = config.bind_socket()\n    assert isinstance(sock, socket.socket)\n    assert sock.family == socket.AF_UNIX\n    assert sock.getsockname() == short_socket_name\n    sock.close()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reload, workers', [(True, 1), (False, 2)], ids=['--reload=True --workers=1', '--reload=False --workers=2'])",
        "pytest.mark.skipif(sys.platform == 'win32', reason='require unix-like system')"
      ],
      "arguments": [
        "tmp_path",
        "reload",
        "workers",
        "short_socket_name"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(sock, socket.socket)",
        "assert sock.family == socket.AF_UNIX",
        "assert sock.getsockname() == short_socket_name"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "sock.close",
          "body": "def close(self):\n    assert not self.closed\n    self.closed = True"
        },
        {
          "name": "sock.getsockname",
          "body": "def getsockname(self):\n    return self.sockname"
        }
      ]
    },
    {
      "name": "test_bind_fd_works_with_reload_or_workers",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 512,
      "end_line_number": 522,
      "source_code": "def test_bind_fd_works_with_reload_or_workers(reload: bool, workers: int):  # pragma: py-win32\n    fdsock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n    fd = fdsock.fileno()\n    config = Config(app=asgi_app, fd=fd, reload=reload, workers=workers)\n    config.load()\n    sock = config.bind_socket()\n    assert isinstance(sock, socket.socket)\n    assert sock.family == socket.AF_UNIX\n    assert sock.getsockname() == \"\"\n    sock.close()\n    fdsock.close()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reload, workers', [(True, 1), (False, 2)], ids=['--reload=True --workers=1', '--reload=False --workers=2'])",
        "pytest.mark.skipif(sys.platform == 'win32', reason='require unix-like system')"
      ],
      "arguments": [
        "reload",
        "workers"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(sock, socket.socket)",
        "assert sock.family == socket.AF_UNIX",
        "assert sock.getsockname() == ''"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "sock.close",
          "body": "def close(self):\n    assert not self.closed\n    self.closed = True"
        },
        {
          "name": "fdsock.close",
          "body": "def close(self):\n    assert not self.closed\n    self.closed = True"
        },
        {
          "name": "sock.getsockname",
          "body": "def getsockname(self):\n    return self.sockname"
        }
      ]
    },
    {
      "name": "test_config_use_subprocess",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 538,
      "end_line_number": 541,
      "source_code": "def test_config_use_subprocess(reload: bool, workers: int, expected: bool):\n    config = Config(app=asgi_app, reload=reload, workers=workers)\n    config.load()\n    assert config.use_subprocess == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reload, workers, expected', [(True, 1, True), (False, 2, True), (False, 1, False)], ids=['--reload=True --workers=1', '--reload=False --workers=2', '--reload=False --workers=1'])"
      ],
      "arguments": [
        "reload",
        "workers",
        "expected"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert config.use_subprocess == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_warn_when_using_reload_and_workers",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 544,
      "end_line_number": 547,
      "source_code": "def test_warn_when_using_reload_and_workers(caplog: pytest.LogCaptureFixture) -> None:\n    Config(app=asgi_app, reload=True, workers=2)\n    assert len(caplog.records) == 1\n    assert '\"workers\" flag is ignored when reloading is enabled.' in caplog.records[0].message",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "caplog"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(caplog.records) == 1",
        "assert '\"workers\" flag is ignored when reloading is enabled.' in caplog.records[0].message"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_lifespan_on",
      "module": "test_lifespan",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
      "line_number": 10,
      "end_line_number": 40,
      "source_code": "def test_lifespan_on():\n    startup_complete = False\n    shutdown_complete = False\n\n    async def app(scope, receive, send):\n        nonlocal startup_complete, shutdown_complete\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.startup\"\n        startup_complete = True\n        await send({\"type\": \"lifespan.startup.complete\"})\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.shutdown\"\n        shutdown_complete = True\n        await send({\"type\": \"lifespan.shutdown.complete\"})\n\n    async def test():\n        config = Config(app=app, lifespan=\"on\")\n        lifespan = LifespanOn(config)\n\n        assert not startup_complete\n        assert not shutdown_complete\n        await lifespan.startup()\n        assert startup_complete\n        assert not shutdown_complete\n        await lifespan.shutdown()\n        assert startup_complete\n        assert shutdown_complete\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "uvicorn.config.Config",
        "uvicorn.lifespan.off.LifespanOff",
        "uvicorn.lifespan.on.LifespanOn"
      ],
      "fixtures": [],
      "assertions": [
        "assert message['type'] == 'lifespan.startup'",
        "assert message['type'] == 'lifespan.shutdown'",
        "assert not startup_complete",
        "assert not shutdown_complete",
        "assert startup_complete",
        "assert not shutdown_complete",
        "assert startup_complete",
        "assert shutdown_complete"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "loop.close",
          "body": "def close(self):\n    assert not self.closed\n    self.closed = True"
        },
        {
          "name": "lifespan.startup",
          "body": "def startup(self):\n    calls.append('startup')"
        },
        {
          "name": "lifespan.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ]
    },
    {
      "name": "test_lifespan_off",
      "module": "test_lifespan",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
      "line_number": 43,
      "end_line_number": 56,
      "source_code": "def test_lifespan_off():\n    async def app(scope, receive, send):\n        pass  # pragma: no cover\n\n    async def test():\n        config = Config(app=app, lifespan=\"off\")\n        lifespan = LifespanOff(config)\n\n        await lifespan.startup()\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "uvicorn.config.Config",
        "uvicorn.lifespan.off.LifespanOff",
        "uvicorn.lifespan.on.LifespanOn"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "loop.close",
          "body": "def close(self):\n    assert not self.closed\n    self.closed = True"
        },
        {
          "name": "lifespan.startup",
          "body": "def startup(self):\n    calls.append('startup')"
        },
        {
          "name": "lifespan.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ]
    },
    {
      "name": "test_lifespan_auto",
      "module": "test_lifespan",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
      "line_number": 59,
      "end_line_number": 89,
      "source_code": "def test_lifespan_auto():\n    startup_complete = False\n    shutdown_complete = False\n\n    async def app(scope, receive, send):\n        nonlocal startup_complete, shutdown_complete\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.startup\"\n        startup_complete = True\n        await send({\"type\": \"lifespan.startup.complete\"})\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.shutdown\"\n        shutdown_complete = True\n        await send({\"type\": \"lifespan.shutdown.complete\"})\n\n    async def test():\n        config = Config(app=app, lifespan=\"auto\")\n        lifespan = LifespanOn(config)\n\n        assert not startup_complete\n        assert not shutdown_complete\n        await lifespan.startup()\n        assert startup_complete\n        assert not shutdown_complete\n        await lifespan.shutdown()\n        assert startup_complete\n        assert shutdown_complete\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "uvicorn.config.Config",
        "uvicorn.lifespan.off.LifespanOff",
        "uvicorn.lifespan.on.LifespanOn"
      ],
      "fixtures": [],
      "assertions": [
        "assert message['type'] == 'lifespan.startup'",
        "assert message['type'] == 'lifespan.shutdown'",
        "assert not startup_complete",
        "assert not shutdown_complete",
        "assert startup_complete",
        "assert not shutdown_complete",
        "assert startup_complete",
        "assert shutdown_complete"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "loop.close",
          "body": "def close(self):\n    assert not self.closed\n    self.closed = True"
        },
        {
          "name": "lifespan.startup",
          "body": "def startup(self):\n    calls.append('startup')"
        },
        {
          "name": "lifespan.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ]
    },
    {
      "name": "test_lifespan_auto_with_error",
      "module": "test_lifespan",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
      "line_number": 92,
      "end_line_number": 107,
      "source_code": "def test_lifespan_auto_with_error():\n    async def app(scope, receive, send):\n        assert scope[\"type\"] == \"http\"\n\n    async def test():\n        config = Config(app=app, lifespan=\"auto\")\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        assert lifespan.error_occured\n        assert not lifespan.should_exit\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "uvicorn.config.Config",
        "uvicorn.lifespan.off.LifespanOff",
        "uvicorn.lifespan.on.LifespanOn"
      ],
      "fixtures": [],
      "assertions": [
        "assert scope['type'] == 'http'",
        "assert lifespan.error_occured",
        "assert not lifespan.should_exit"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "loop.close",
          "body": "def close(self):\n    assert not self.closed\n    self.closed = True"
        },
        {
          "name": "lifespan.startup",
          "body": "def startup(self):\n    calls.append('startup')"
        },
        {
          "name": "lifespan.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ]
    },
    {
      "name": "test_lifespan_on_with_error",
      "module": "test_lifespan",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
      "line_number": 110,
      "end_line_number": 126,
      "source_code": "def test_lifespan_on_with_error():\n    async def app(scope, receive, send):\n        if scope[\"type\"] != \"http\":\n            raise RuntimeError()\n\n    async def test():\n        config = Config(app=app, lifespan=\"on\")\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        assert lifespan.error_occured\n        assert lifespan.should_exit\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "uvicorn.config.Config",
        "uvicorn.lifespan.off.LifespanOff",
        "uvicorn.lifespan.on.LifespanOn"
      ],
      "fixtures": [],
      "assertions": [
        "assert lifespan.error_occured",
        "assert lifespan.should_exit"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "loop.close",
          "body": "def close(self):\n    assert not self.closed\n    self.closed = True"
        },
        {
          "name": "lifespan.startup",
          "body": "def startup(self):\n    calls.append('startup')"
        },
        {
          "name": "lifespan.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ]
    },
    {
      "name": "test_lifespan_with_failed_startup",
      "module": "test_lifespan",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
      "line_number": 131,
      "end_line_number": 157,
      "source_code": "def test_lifespan_with_failed_startup(mode, raise_exception, caplog):\n    async def app(scope, receive, send):\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.startup\"\n        await send({\"type\": \"lifespan.startup.failed\", \"message\": \"the lifespan event failed\"})\n        if raise_exception:\n            # App should be able to re-raise an exception if startup failed.\n            raise RuntimeError()\n\n    async def test():\n        config = Config(app=app, lifespan=mode)\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        assert lifespan.startup_failed\n        assert lifespan.error_occured is raise_exception\n        assert lifespan.should_exit\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()\n    error_messages = [\n        record.message for record in caplog.records if record.name == \"uvicorn.error\" and record.levelname == \"ERROR\"\n    ]\n    assert \"the lifespan event failed\" in error_messages.pop(0)\n    assert \"Application startup failed. Exiting.\" in error_messages.pop(0)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('mode', ('auto', 'on'))",
        "pytest.mark.parametrize('raise_exception', (True, False))"
      ],
      "arguments": [
        "mode",
        "raise_exception",
        "caplog"
      ],
      "imports": [
        "asyncio",
        "pytest",
        "uvicorn.config.Config",
        "uvicorn.lifespan.off.LifespanOff",
        "uvicorn.lifespan.on.LifespanOn"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'the lifespan event failed' in error_messages.pop(0)",
        "assert 'Application startup failed. Exiting.' in error_messages.pop(0)",
        "assert message['type'] == 'lifespan.startup'",
        "assert lifespan.startup_failed",
        "assert lifespan.error_occured is raise_exception",
        "assert lifespan.should_exit"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "loop.close",
          "body": "def close(self):\n    assert not self.closed\n    self.closed = True"
        },
        {
          "name": "lifespan.startup",
          "body": "def startup(self):\n    calls.append('startup')"
        },
        {
          "name": "lifespan.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ]
    },
    {
      "name": "test_lifespan_scope_asgi3app",
      "module": "test_lifespan",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
      "line_number": 160,
      "end_line_number": 180,
      "source_code": "def test_lifespan_scope_asgi3app():\n    async def asgi3app(scope, receive, send):\n        assert scope == {\n            \"type\": \"lifespan\",\n            \"asgi\": {\"version\": \"3.0\", \"spec_version\": \"2.0\"},\n            \"state\": {},\n        }\n\n    async def test():\n        config = Config(app=asgi3app, lifespan=\"on\")\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        assert not lifespan.startup_failed\n        assert not lifespan.error_occured\n        assert not lifespan.should_exit\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "uvicorn.config.Config",
        "uvicorn.lifespan.off.LifespanOff",
        "uvicorn.lifespan.on.LifespanOn"
      ],
      "fixtures": [],
      "assertions": [
        "assert scope == {'type': 'lifespan', 'asgi': {'version': '3.0', 'spec_version': '2.0'}, 'state': {}}",
        "assert not lifespan.startup_failed",
        "assert not lifespan.error_occured",
        "assert not lifespan.should_exit"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "loop.close",
          "body": "def close(self):\n    assert not self.closed\n    self.closed = True"
        },
        {
          "name": "lifespan.startup",
          "body": "def startup(self):\n    calls.append('startup')"
        },
        {
          "name": "lifespan.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ]
    },
    {
      "name": "test_lifespan_scope_asgi2app",
      "module": "test_lifespan",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
      "line_number": 183,
      "end_line_number": 205,
      "source_code": "def test_lifespan_scope_asgi2app():\n    def asgi2app(scope):\n        assert scope == {\n            \"type\": \"lifespan\",\n            \"asgi\": {\"version\": \"2.0\", \"spec_version\": \"2.0\"},\n            \"state\": {},\n        }\n\n        async def asgi(receive, send):\n            pass\n\n        return asgi\n\n    async def test():\n        config = Config(app=asgi2app, lifespan=\"on\")\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "uvicorn.config.Config",
        "uvicorn.lifespan.off.LifespanOff",
        "uvicorn.lifespan.on.LifespanOn"
      ],
      "fixtures": [],
      "assertions": [
        "assert scope == {'type': 'lifespan', 'asgi': {'version': '2.0', 'spec_version': '2.0'}, 'state': {}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "loop.close",
          "body": "def close(self):\n    assert not self.closed\n    self.closed = True"
        },
        {
          "name": "lifespan.startup",
          "body": "def startup(self):\n    calls.append('startup')"
        },
        {
          "name": "lifespan.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ]
    },
    {
      "name": "test_lifespan_with_failed_shutdown",
      "module": "test_lifespan",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
      "line_number": 210,
      "end_line_number": 241,
      "source_code": "def test_lifespan_with_failed_shutdown(mode, raise_exception, caplog):\n    async def app(scope, receive, send):\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.startup\"\n        await send({\"type\": \"lifespan.startup.complete\"})\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.shutdown\"\n        await send({\"type\": \"lifespan.shutdown.failed\", \"message\": \"the lifespan event failed\"})\n\n        if raise_exception:\n            # App should be able to re-raise an exception if startup failed.\n            raise RuntimeError()\n\n    async def test():\n        config = Config(app=app, lifespan=mode)\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        assert not lifespan.startup_failed\n        await lifespan.shutdown()\n        assert lifespan.shutdown_failed\n        assert lifespan.error_occured is raise_exception\n        assert lifespan.should_exit\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    error_messages = [\n        record.message for record in caplog.records if record.name == \"uvicorn.error\" and record.levelname == \"ERROR\"\n    ]\n    assert \"the lifespan event failed\" in error_messages.pop(0)\n    assert \"Application shutdown failed. Exiting.\" in error_messages.pop(0)\n    loop.close()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('mode', ('auto', 'on'))",
        "pytest.mark.parametrize('raise_exception', (True, False))"
      ],
      "arguments": [
        "mode",
        "raise_exception",
        "caplog"
      ],
      "imports": [
        "asyncio",
        "pytest",
        "uvicorn.config.Config",
        "uvicorn.lifespan.off.LifespanOff",
        "uvicorn.lifespan.on.LifespanOn"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'the lifespan event failed' in error_messages.pop(0)",
        "assert 'Application shutdown failed. Exiting.' in error_messages.pop(0)",
        "assert message['type'] == 'lifespan.startup'",
        "assert message['type'] == 'lifespan.shutdown'",
        "assert not lifespan.startup_failed",
        "assert lifespan.shutdown_failed",
        "assert lifespan.error_occured is raise_exception",
        "assert lifespan.should_exit"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "loop.close",
          "body": "def close(self):\n    assert not self.closed\n    self.closed = True"
        },
        {
          "name": "lifespan.startup",
          "body": "def startup(self):\n    calls.append('startup')"
        },
        {
          "name": "lifespan.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ]
    },
    {
      "name": "test_lifespan_state",
      "module": "test_lifespan",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
      "line_number": 244,
      "end_line_number": 264,
      "source_code": "def test_lifespan_state():\n    async def app(scope, receive, send):\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.startup\"\n        await send({\"type\": \"lifespan.startup.complete\"})\n        scope[\"state\"][\"foo\"] = 123\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.shutdown\"\n        await send({\"type\": \"lifespan.shutdown.complete\"})\n\n    async def test():\n        config = Config(app=app, lifespan=\"on\")\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        assert lifespan.state == {\"foo\": 123}\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "uvicorn.config.Config",
        "uvicorn.lifespan.off.LifespanOff",
        "uvicorn.lifespan.on.LifespanOn"
      ],
      "fixtures": [],
      "assertions": [
        "assert message['type'] == 'lifespan.startup'",
        "assert message['type'] == 'lifespan.shutdown'",
        "assert lifespan.state == {'foo': 123}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "loop.close",
          "body": "def close(self):\n    assert not self.closed\n    self.closed = True"
        },
        {
          "name": "lifespan.startup",
          "body": "def startup(self):\n    calls.append('startup')"
        },
        {
          "name": "lifespan.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ]
    },
    {
      "name": "test_loop_auto",
      "module": "test_auto_detection",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_auto_detection.py",
      "line_number": 35,
      "end_line_number": 39,
      "source_code": "def test_loop_auto():\n    auto_loop_setup()\n    policy = asyncio.get_event_loop_policy()\n    assert isinstance(policy, asyncio.events.BaseDefaultEventLoopPolicy)\n    assert type(policy).__module__.startswith(expected_loop)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "importlib",
        "pytest",
        "uvicorn.config.Config",
        "uvicorn.loops.auto.auto_loop_setup",
        "uvicorn.main.ServerState",
        "uvicorn.protocols.http.auto.AutoHTTPProtocol",
        "uvicorn.protocols.websockets.auto.AutoWebSocketsProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(policy, asyncio.events.BaseDefaultEventLoopPolicy)",
        "assert type(policy).__module__.startswith(expected_loop)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_cli_print_version",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_cli.py",
      "line_number": 37,
      "end_line_number": 50,
      "source_code": "def test_cli_print_version() -> None:\n    runner = CliRunner()\n\n    result = runner.invoke(cli, [\"--version\"])\n\n    assert result.exit_code == 0\n    assert (\n        \"Running uvicorn {version} with {py_implementation} {py_version} on {system}\".format(  # noqa: UP032\n            version=uvicorn.__version__,\n            py_implementation=platform.python_implementation(),\n            py_version=platform.python_version(),\n            system=platform.system(),\n        )\n    ) in result.output",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "contextlib",
        "importlib",
        "os",
        "platform",
        "sys",
        "pathlib.Path",
        "textwrap.dedent",
        "typing.Iterator",
        "unittest.mock",
        "pytest",
        "click.testing.CliRunner",
        "uvicorn",
        "uvicorn.config.Config",
        "uvicorn.main.main",
        "uvicorn.server.Server",
        "uvicorn.supervisors.ChangeReload",
        "uvicorn.supervisors.Multiprocess"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 0",
        "assert 'Running uvicorn {version} with {py_implementation} {py_version} on {system}'.format(version=uvicorn.__version__, py_implementation=platform.python_implementation(), py_version=platform.python_version(), system=platform.system()) in result.output"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_cli_headers",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_cli.py",
      "line_number": 53,
      "end_line_number": 67,
      "source_code": "def test_cli_headers() -> None:\n    runner = CliRunner()\n\n    with mock.patch.object(main, \"run\") as mock_run:\n        result = runner.invoke(cli, [\"tests.test_cli:App\", \"--header\", HEADERS])\n\n    assert result.output == \"\"\n    assert result.exit_code == 0\n    mock_run.assert_called_once()\n    assert mock_run.call_args[1][\"headers\"] == [\n        [\n            \"Content-Security-Policy\",\n            \"default-src 'self'; script-src https://example.com\",\n        ]\n    ]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "contextlib",
        "importlib",
        "os",
        "platform",
        "sys",
        "pathlib.Path",
        "textwrap.dedent",
        "typing.Iterator",
        "unittest.mock",
        "pytest",
        "click.testing.CliRunner",
        "uvicorn",
        "uvicorn.config.Config",
        "uvicorn.main.main",
        "uvicorn.server.Server",
        "uvicorn.supervisors.ChangeReload",
        "uvicorn.supervisors.Multiprocess"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.output == ''",
        "assert result.exit_code == 0",
        "assert mock_run.call_args[1]['headers'] == [['Content-Security-Policy', \"default-src 'self'; script-src https://example.com\"]]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_cli_call_server_run",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_cli.py",
      "line_number": 70,
      "end_line_number": 77,
      "source_code": "def test_cli_call_server_run() -> None:\n    runner = CliRunner()\n\n    with mock.patch.object(Server, \"run\") as mock_run:\n        result = runner.invoke(cli, [\"tests.test_cli:App\"])\n\n    assert result.exit_code == 3\n    mock_run.assert_called_once()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "contextlib",
        "importlib",
        "os",
        "platform",
        "sys",
        "pathlib.Path",
        "textwrap.dedent",
        "typing.Iterator",
        "unittest.mock",
        "pytest",
        "click.testing.CliRunner",
        "uvicorn",
        "uvicorn.config.Config",
        "uvicorn.main.main",
        "uvicorn.server.Server",
        "uvicorn.supervisors.ChangeReload",
        "uvicorn.supervisors.Multiprocess"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 3"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_cli_call_change_reload_run",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_cli.py",
      "line_number": 80,
      "end_line_number": 89,
      "source_code": "def test_cli_call_change_reload_run() -> None:\n    runner = CliRunner()\n\n    with mock.patch.object(Config, \"bind_socket\") as mock_bind_socket:\n        with mock.patch.object(ChangeReload, \"run\") as mock_run:\n            result = runner.invoke(cli, [\"tests.test_cli:App\", \"--reload\"])\n\n    assert result.exit_code == 0\n    mock_bind_socket.assert_called_once()\n    mock_run.assert_called_once()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "contextlib",
        "importlib",
        "os",
        "platform",
        "sys",
        "pathlib.Path",
        "textwrap.dedent",
        "typing.Iterator",
        "unittest.mock",
        "pytest",
        "click.testing.CliRunner",
        "uvicorn",
        "uvicorn.config.Config",
        "uvicorn.main.main",
        "uvicorn.server.Server",
        "uvicorn.supervisors.ChangeReload",
        "uvicorn.supervisors.Multiprocess"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 0"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_cli_call_multiprocess_run",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_cli.py",
      "line_number": 92,
      "end_line_number": 101,
      "source_code": "def test_cli_call_multiprocess_run() -> None:\n    runner = CliRunner()\n\n    with mock.patch.object(Config, \"bind_socket\") as mock_bind_socket:\n        with mock.patch.object(Multiprocess, \"run\") as mock_run:\n            result = runner.invoke(cli, [\"tests.test_cli:App\", \"--workers=2\"])\n\n    assert result.exit_code == 0\n    mock_bind_socket.assert_called_once()\n    mock_run.assert_called_once()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "contextlib",
        "importlib",
        "os",
        "platform",
        "sys",
        "pathlib.Path",
        "textwrap.dedent",
        "typing.Iterator",
        "unittest.mock",
        "pytest",
        "click.testing.CliRunner",
        "uvicorn",
        "uvicorn.config.Config",
        "uvicorn.main.main",
        "uvicorn.server.Server",
        "uvicorn.supervisors.ChangeReload",
        "uvicorn.supervisors.Multiprocess"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 0"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_cli_uds",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_cli.py",
      "line_number": 114,
      "end_line_number": 125,
      "source_code": "def test_cli_uds(uds_file: Path) -> None:  # pragma: py-win32\n    runner = CliRunner()\n\n    with mock.patch.object(Config, \"bind_socket\") as mock_bind_socket:\n        with mock.patch.object(Multiprocess, \"run\") as mock_run:\n            result = runner.invoke(cli, [\"tests.test_cli:App\", \"--workers=2\", \"--uds\", str(uds_file)])\n\n    assert result.exit_code == 0\n    assert result.output == \"\"\n    mock_bind_socket.assert_called_once()\n    mock_run.assert_called_once()\n    assert not uds_file.exists()",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(sys.platform == 'win32', reason='require unix-like system')"
      ],
      "arguments": [
        "uds_file"
      ],
      "imports": [
        "contextlib",
        "importlib",
        "os",
        "platform",
        "sys",
        "pathlib.Path",
        "textwrap.dedent",
        "typing.Iterator",
        "unittest.mock",
        "pytest",
        "click.testing.CliRunner",
        "uvicorn",
        "uvicorn.config.Config",
        "uvicorn.main.main",
        "uvicorn.server.Server",
        "uvicorn.supervisors.ChangeReload",
        "uvicorn.supervisors.Multiprocess"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 0",
        "assert result.output == ''",
        "assert not uds_file.exists()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_cli_incomplete_app_parameter",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_cli.py",
      "line_number": 128,
      "end_line_number": 136,
      "source_code": "def test_cli_incomplete_app_parameter() -> None:\n    runner = CliRunner()\n\n    result = runner.invoke(cli, [\"tests.test_cli\"])\n\n    assert (\n        'Error loading ASGI app. Import string \"tests.test_cli\" ' 'must be in format \"<module>:<attribute>\".'\n    ) in result.output\n    assert result.exit_code == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "contextlib",
        "importlib",
        "os",
        "platform",
        "sys",
        "pathlib.Path",
        "textwrap.dedent",
        "typing.Iterator",
        "unittest.mock",
        "pytest",
        "click.testing.CliRunner",
        "uvicorn",
        "uvicorn.config.Config",
        "uvicorn.main.main",
        "uvicorn.server.Server",
        "uvicorn.supervisors.ChangeReload",
        "uvicorn.supervisors.Multiprocess"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'Error loading ASGI app. Import string \"tests.test_cli\" must be in format \"<module>:<attribute>\".' in result.output",
        "assert result.exit_code == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_cli_event_size",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_cli.py",
      "line_number": 139,
      "end_line_number": 151,
      "source_code": "def test_cli_event_size() -> None:\n    runner = CliRunner()\n\n    with mock.patch.object(main, \"run\") as mock_run:\n        result = runner.invoke(\n            cli,\n            [\"tests.test_cli:App\", \"--h11-max-incomplete-event-size\", str(32 * 1024)],\n        )\n\n    assert result.output == \"\"\n    assert result.exit_code == 0\n    mock_run.assert_called_once()\n    assert mock_run.call_args[1][\"h11_max_incomplete_event_size\"] == 32768",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "contextlib",
        "importlib",
        "os",
        "platform",
        "sys",
        "pathlib.Path",
        "textwrap.dedent",
        "typing.Iterator",
        "unittest.mock",
        "pytest",
        "click.testing.CliRunner",
        "uvicorn",
        "uvicorn.config.Config",
        "uvicorn.main.main",
        "uvicorn.server.Server",
        "uvicorn.supervisors.ChangeReload",
        "uvicorn.supervisors.Multiprocess"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.output == ''",
        "assert result.exit_code == 0",
        "assert mock_run.call_args[1]['h11_max_incomplete_event_size'] == 32768"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_env_variables",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_cli.py",
      "line_number": 155,
      "end_line_number": 161,
      "source_code": "def test_env_variables(http_protocol: str):\n    with load_env_var(\"UVICORN_HTTP\", http_protocol):\n        runner = CliRunner(env=os.environ)\n        with mock.patch.object(main, \"run\") as mock_run:\n            runner.invoke(cli, [\"tests.test_cli:App\"])\n            _, kwargs = mock_run.call_args\n            assert kwargs[\"http\"] == http_protocol",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('http_protocol', ['h11', 'httptools'])"
      ],
      "arguments": [
        "http_protocol"
      ],
      "imports": [
        "contextlib",
        "importlib",
        "os",
        "platform",
        "sys",
        "pathlib.Path",
        "textwrap.dedent",
        "typing.Iterator",
        "unittest.mock",
        "pytest",
        "click.testing.CliRunner",
        "uvicorn",
        "uvicorn.config.Config",
        "uvicorn.main.main",
        "uvicorn.server.Server",
        "uvicorn.supervisors.ChangeReload",
        "uvicorn.supervisors.Multiprocess"
      ],
      "fixtures": [],
      "assertions": [
        "assert kwargs['http'] == http_protocol"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "load_env_var",
          "body": "@contextlib.contextmanager\ndef load_env_var(key: str, value: str) -> Iterator[None]:\n    old_environ = dict(os.environ)\n    os.environ[key] = value\n    yield\n    os.environ.clear()\n    os.environ.update(old_environ)"
        }
      ]
    },
    {
      "name": "test_ignore_environment_variable_when_set_on_cli",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_cli.py",
      "line_number": 164,
      "end_line_number": 170,
      "source_code": "def test_ignore_environment_variable_when_set_on_cli():\n    with load_env_var(\"UVICORN_HTTP\", \"h11\"):\n        runner = CliRunner(env=os.environ)\n        with mock.patch.object(main, \"run\") as mock_run:\n            runner.invoke(cli, [\"tests.test_cli:App\", \"--http=httptools\"])\n            _, kwargs = mock_run.call_args\n            assert kwargs[\"http\"] == \"httptools\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "contextlib",
        "importlib",
        "os",
        "platform",
        "sys",
        "pathlib.Path",
        "textwrap.dedent",
        "typing.Iterator",
        "unittest.mock",
        "pytest",
        "click.testing.CliRunner",
        "uvicorn",
        "uvicorn.config.Config",
        "uvicorn.main.main",
        "uvicorn.server.Server",
        "uvicorn.supervisors.ChangeReload",
        "uvicorn.supervisors.Multiprocess"
      ],
      "fixtures": [],
      "assertions": [
        "assert kwargs['http'] == 'httptools'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "load_env_var",
          "body": "@contextlib.contextmanager\ndef load_env_var(key: str, value: str) -> Iterator[None]:\n    old_environ = dict(os.environ)\n    os.environ[key] = value\n    yield\n    os.environ.clear()\n    os.environ.update(old_environ)"
        }
      ]
    },
    {
      "name": "test_app_dir",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_cli.py",
      "line_number": 173,
      "end_line_number": 192,
      "source_code": "def test_app_dir(tmp_path: Path, caplog: pytest.LogCaptureFixture) -> None:\n    app_dir = tmp_path / \"dir\" / \"app_dir\"\n    app_file = app_dir / \"main.py\"\n    app_dir.mkdir(parents=True)\n    app_file.touch()\n    app_file.write_text(\n        dedent(\n            \"\"\"\n            async def app(scope, receive, send):\n                ...\n            \"\"\"\n        )\n    )\n    runner = CliRunner()\n    with mock.patch.object(Server, \"run\") as mock_run:\n        result = runner.invoke(cli, [\"main:app\", \"--app-dir\", f\"{str(app_dir)}\"])\n\n    assert result.exit_code == 3\n    mock_run.assert_called_once()\n    assert sys.path[0] == str(app_dir)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmp_path",
        "caplog"
      ],
      "imports": [
        "contextlib",
        "importlib",
        "os",
        "platform",
        "sys",
        "pathlib.Path",
        "textwrap.dedent",
        "typing.Iterator",
        "unittest.mock",
        "pytest",
        "click.testing.CliRunner",
        "uvicorn",
        "uvicorn.config.Config",
        "uvicorn.main.main",
        "uvicorn.server.Server",
        "uvicorn.supervisors.ChangeReload",
        "uvicorn.supervisors.Multiprocess"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 3",
        "assert sys.path[0] == str(app_dir)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_set_app_via_environment_variable",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_cli.py",
      "line_number": 195,
      "end_line_number": 203,
      "source_code": "def test_set_app_via_environment_variable():\n    app_path = \"tests.test_cli:App\"\n    with load_env_var(\"UVICORN_APP\", app_path):\n        runner = CliRunner(env=os.environ)\n        with mock.patch.object(main, \"run\") as mock_run:\n            result = runner.invoke(cli)\n            args, _ = mock_run.call_args\n            assert result.exit_code == 0\n            assert args == (app_path,)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "contextlib",
        "importlib",
        "os",
        "platform",
        "sys",
        "pathlib.Path",
        "textwrap.dedent",
        "typing.Iterator",
        "unittest.mock",
        "pytest",
        "click.testing.CliRunner",
        "uvicorn",
        "uvicorn.config.Config",
        "uvicorn.main.main",
        "uvicorn.server.Server",
        "uvicorn.supervisors.ChangeReload",
        "uvicorn.supervisors.Multiprocess"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 0",
        "assert args == (app_path,)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "load_env_var",
          "body": "@contextlib.contextmanager\ndef load_env_var(key: str, value: str) -> Iterator[None]:\n    old_environ = dict(os.environ)\n    os.environ[key] = value\n    yield\n    os.environ.clear()\n    os.environ.update(old_environ)"
        }
      ]
    },
    {
      "name": "test_reloader_should_initialize",
      "module": "test_reload",
      "class_name": "TestBaseReload",
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 77,
      "end_line_number": 87,
      "source_code": "def test_reloader_should_initialize(self) -> None:\n        \"\"\"\n        A basic sanity check.\n\n        Simply run the reloader against a no-op server, and signal for it to\n        quit immediately.\n        \"\"\"\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n            reloader.shutdown()",
      "docstring": "A basic sanity check.\n\nSimply run the reloader against a no-op server, and signal for it to\nquit immediately.",
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ]
    },
    {
      "name": "test_reload_when_python_file_is_changed",
      "module": "test_reload",
      "class_name": "TestBaseReload",
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 90,
      "end_line_number": 100,
      "source_code": "def test_reload_when_python_file_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            changes = self._reload_tester(touch_soon, reloader, file)\n            assert changes == [file]\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
      ],
      "arguments": [
        "self",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert changes == [file]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ]
    },
    {
      "name": "test_should_reload_when_python_file_in_subdir_is_changed",
      "module": "test_reload",
      "class_name": "TestBaseReload",
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 103,
      "end_line_number": 112,
      "source_code": "def test_should_reload_when_python_file_in_subdir_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \"app\" / \"sub\" / \"sub.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, file)\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
      ],
      "arguments": [
        "self",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert self._reload_tester(touch_soon, reloader, file)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ]
    },
    {
      "name": "test_should_not_reload_when_python_file_in_excluded_subdir_is_changed",
      "module": "test_reload",
      "class_name": "TestBaseReload",
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 115,
      "end_line_number": 129,
      "source_code": "def test_should_not_reload_when_python_file_in_excluded_subdir_is_changed(self, touch_soon) -> None:\n        sub_dir = self.reload_path / \"app\" / \"sub\"\n        sub_file = sub_dir / \"sub.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_excludes=[str(sub_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert not self._reload_tester(touch_soon, reloader, sub_file)\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [WatchFilesReload, WatchGodReload])"
      ],
      "arguments": [
        "self",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert not self._reload_tester(touch_soon, reloader, sub_file)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        }
      ]
    },
    {
      "name": "test_reload_when_pattern_matched_file_is_changed",
      "module": "test_reload",
      "class_name": "TestBaseReload",
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 132,
      "end_line_number": 141,
      "source_code": "def test_reload_when_pattern_matched_file_is_changed(self, result: bool, touch_soon) -> None:\n        file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_includes=[\"*.js\"])\n            reloader = self._setup_reloader(config)\n\n            assert bool(self._reload_tester(touch_soon, reloader, file)) == result\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class, result', [(StatReload, False), (WatchFilesReload, True)])"
      ],
      "arguments": [
        "self",
        "result",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert bool(self._reload_tester(touch_soon, reloader, file)) == result"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        }
      ]
    },
    {
      "name": "test_should_not_reload_when_exclude_pattern_match_file_is_changed",
      "module": "test_reload",
      "class_name": "TestBaseReload",
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 150,
      "end_line_number": 168,
      "source_code": "def test_should_not_reload_when_exclude_pattern_match_file_is_changed(self, touch_soon) -> None:\n        python_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        css_file = self.reload_path / \"app\" / \"css\" / \"main.css\"\n        js_file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\"*\"],\n                reload_excludes=[\"*.js\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, python_file)\n            assert self._reload_tester(touch_soon, reloader, css_file)\n            assert not self._reload_tester(touch_soon, reloader, js_file)\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
      ],
      "arguments": [
        "self",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert self._reload_tester(touch_soon, reloader, python_file)",
        "assert self._reload_tester(touch_soon, reloader, css_file)",
        "assert not self._reload_tester(touch_soon, reloader, js_file)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        }
      ]
    },
    {
      "name": "test_should_not_reload_when_dot_file_is_changed",
      "module": "test_reload",
      "class_name": "TestBaseReload",
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 171,
      "end_line_number": 180,
      "source_code": "def test_should_not_reload_when_dot_file_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \".dotted\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            assert not self._reload_tester(touch_soon, reloader, file)\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
      ],
      "arguments": [
        "self",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert not self._reload_tester(touch_soon, reloader, file)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        }
      ]
    },
    {
      "name": "test_should_reload_when_directories_have_same_prefix",
      "module": "test_reload",
      "class_name": "TestBaseReload",
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 183,
      "end_line_number": 200,
      "source_code": "def test_should_reload_when_directories_have_same_prefix(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_file = app_dir / \"src\" / \"main.py\"\n        app_first_dir = self.reload_path / \"app_first\"\n        app_first_file = app_first_dir / \"src\" / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_dirs=[str(app_dir), str(app_first_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, app_file)\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
      ],
      "arguments": [
        "self",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert self._reload_tester(touch_soon, reloader, app_file)",
        "assert self._reload_tester(touch_soon, reloader, app_first_file)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ]
    },
    {
      "name": "test_should_not_reload_when_only_subdirectory_is_watched",
      "module": "test_reload",
      "class_name": "TestBaseReload",
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 210,
      "end_line_number": 225,
      "source_code": "def test_should_not_reload_when_only_subdirectory_is_watched(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_dir_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        root_file = self.reload_path / \"main.py\"\n\n        config = Config(\n            app=\"tests.test_config:asgi_app\",\n            reload=True,\n            reload_dirs=[str(app_dir)],\n        )\n        reloader = self._setup_reloader(config)\n\n        assert self._reload_tester(touch_soon, reloader, app_dir_file)\n        assert not self._reload_tester(touch_soon, reloader, root_file, app_dir / \"~ignored\")\n\n        reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, pytest.param(WatchFilesReload, marks=skip_if_m1)])"
      ],
      "arguments": [
        "self",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert self._reload_tester(touch_soon, reloader, app_dir_file)",
        "assert not self._reload_tester(touch_soon, reloader, root_file, app_dir / '~ignored')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        }
      ]
    },
    {
      "name": "test_override_defaults",
      "module": "test_reload",
      "class_name": "TestBaseReload",
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 234,
      "end_line_number": 253,
      "source_code": "def test_override_defaults(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        dotted_dir_file = self.reload_path / \".dotted_dir\" / \"file.txt\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                # We need to add *.txt otherwise no regular files will match\n                reload_includes=[\".*\", \"*.txt\"],\n                reload_excludes=[\"*.py\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, dotted_dir_file)\n            assert not self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
      ],
      "arguments": [
        "self",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert self._reload_tester(touch_soon, reloader, dotted_file)",
        "assert self._reload_tester(touch_soon, reloader, dotted_dir_file)",
        "assert not self._reload_tester(touch_soon, reloader, python_file)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        }
      ]
    },
    {
      "name": "test_explicit_paths",
      "module": "test_reload",
      "class_name": "TestBaseReload",
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 262,
      "end_line_number": 279,
      "source_code": "def test_explicit_paths(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        non_dotted_file = self.reload_path / \"ext\" / \"ext.jpg\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\".dotted\", \"ext/ext.jpg\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, non_dotted_file)\n            assert self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
      ],
      "arguments": [
        "self",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert self._reload_tester(touch_soon, reloader, dotted_file)",
        "assert self._reload_tester(touch_soon, reloader, non_dotted_file)",
        "assert self._reload_tester(touch_soon, reloader, python_file)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ]
    },
    {
      "name": "test_watchfiles_no_changes",
      "module": "test_reload",
      "class_name": "TestBaseReload",
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 283,
      "end_line_number": 308,
      "source_code": "def test_watchfiles_no_changes(self) -> None:\n        sub_dir = self.reload_path / \"app\" / \"sub\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_excludes=[str(sub_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            from watchfiles import watch\n\n            assert isinstance(reloader, WatchFilesReload)\n            # just so we can make rust_timeout 100ms\n            reloader.watcher = watch(\n                sub_dir,\n                watch_filter=None,\n                stop_event=reloader.should_exit,\n                yield_on_timeout=True,\n                rust_timeout=100,\n            )\n\n            assert reloader.should_restart() is None\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(WatchFilesReload is None, reason='watchfiles not available')",
        "pytest.mark.parametrize('reloader_class', [WatchFilesReload])"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(reloader, WatchFilesReload)",
        "assert reloader.should_restart() is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        },
        {
          "name": "reloader.should_restart",
          "body": "def should_restart(self):\n    nonlocal step\n    step += 1\n    if step == 1:\n        return None\n    elif step == 2:\n        return [tmp_path / 'foobar.py']\n    else:\n        raise StopIteration()"
        }
      ]
    },
    {
      "name": "test_should_detect_new_reload_dirs",
      "module": "test_reload",
      "class_name": "TestBaseReload",
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 311,
      "end_line_number": 332,
      "source_code": "def test_should_detect_new_reload_dirs(self, touch_soon, caplog: pytest.LogCaptureFixture, tmp_path: Path) -> None:\n        app_dir = tmp_path / \"app\"\n        app_file = app_dir / \"file.py\"\n        app_dir.mkdir()\n        app_file.touch()\n        app_first_dir = tmp_path / \"app_first\"\n        app_first_file = app_first_dir / \"file.py\"\n\n        with as_cwd(tmp_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_includes=[\"app*\"])\n            reloader = self._setup_reloader(config)\n            assert self._reload_tester(touch_soon, reloader, app_file)\n\n            app_first_dir.mkdir()\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n            assert caplog.records[-2].levelno == logging.INFO\n            assert (\n                caplog.records[-1].message == \"WatchGodReload detected a new reload \"\n                f\"dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\"\n            )\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [WatchGodReload])"
      ],
      "arguments": [
        "self",
        "touch_soon",
        "caplog",
        "tmp_path"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert self._reload_tester(touch_soon, reloader, app_file)",
        "assert self._reload_tester(touch_soon, reloader, app_first_file)",
        "assert caplog.records[-2].levelno == logging.INFO",
        "assert caplog.records[-1].message == f\"WatchGodReload detected a new reload dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ]
    },
    {
      "name": "test_should_watch_one_dir_cwd",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 336,
      "end_line_number": 349,
      "source_code": "def test_should_watch_one_dir_cwd(mocker, reload_directory_structure):\n    mock_watch = mocker.patch(\"uvicorn.supervisors.watchfilesreload.watch\")\n    app_dir = reload_directory_structure / \"app\"\n    app_first_dir = reload_directory_structure / \"app_first\"\n\n    with as_cwd(reload_directory_structure):\n        config = Config(\n            app=\"tests.test_config:asgi_app\",\n            reload=True,\n            reload_dirs=[str(app_dir), str(app_first_dir)],\n        )\n        WatchFilesReload(config, target=run, sockets=[])\n        mock_watch.assert_called_once()\n        assert mock_watch.call_args[0] == (Path.cwd(),)",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(WatchFilesReload is None, reason='watchfiles not available')"
      ],
      "arguments": [
        "mocker",
        "reload_directory_structure"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert mock_watch.call_args[0] == (Path.cwd(),)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mocker.patch('uvicorn.supervisors.watchfilesreload.watch')"
      ],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        }
      ]
    },
    {
      "name": "test_should_watch_separate_dirs_outside_cwd",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 353,
      "end_line_number": 368,
      "source_code": "def test_should_watch_separate_dirs_outside_cwd(mocker, reload_directory_structure):\n    mock_watch = mocker.patch(\"uvicorn.supervisors.watchfilesreload.watch\")\n    app_dir = reload_directory_structure / \"app\"\n    app_first_dir = reload_directory_structure / \"app_first\"\n    config = Config(\n        app=\"tests.test_config:asgi_app\",\n        reload=True,\n        reload_dirs=[str(app_dir), str(app_first_dir)],\n    )\n    WatchFilesReload(config, target=run, sockets=[])\n    mock_watch.assert_called_once()\n    assert set(mock_watch.call_args[0]) == {\n        app_dir,\n        app_first_dir,\n        Path.cwd(),\n    }",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(WatchFilesReload is None, reason='watchfiles not available')"
      ],
      "arguments": [
        "mocker",
        "reload_directory_structure"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert set(mock_watch.call_args[0]) == {app_dir, app_first_dir, Path.cwd()}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mocker.patch('uvicorn.supervisors.watchfilesreload.watch')"
      ],
      "methods_under_test": []
    },
    {
      "name": "test_display_path_relative",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 371,
      "end_line_number": 375,
      "source_code": "def test_display_path_relative(tmp_path):\n    with as_cwd(tmp_path):\n        p = tmp_path / \"app\" / \"foobar.py\"\n        # accept windows paths as wells as posix\n        assert _display_path(p) in (\"'app/foobar.py'\", \"'app\\\\foobar.py'\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmp_path"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert _display_path(p) in (\"'app/foobar.py'\", \"'app\\\\foobar.py'\")"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        }
      ]
    },
    {
      "name": "test_display_path_non_relative",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 378,
      "end_line_number": 380,
      "source_code": "def test_display_path_non_relative():\n    p = Path(\"/foo/bar.py\")\n    assert _display_path(p) in (\"'/foo/bar.py'\", \"'\\\\foo\\\\bar.py'\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert _display_path(p) in (\"'/foo/bar.py'\", \"'\\\\foo\\\\bar.py'\")"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_base_reloader_run",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 383,
      "end_line_number": 411,
      "source_code": "def test_base_reloader_run(tmp_path):\n    calls = []\n    step = 0\n\n    class CustomReload(BaseReload):\n        def startup(self):\n            calls.append(\"startup\")\n\n        def restart(self):\n            calls.append(\"restart\")\n\n        def shutdown(self):\n            calls.append(\"shutdown\")\n\n        def should_restart(self):\n            nonlocal step\n            step += 1\n            if step == 1:\n                return None\n            elif step == 2:\n                return [tmp_path / \"foobar.py\"]\n            else:\n                raise StopIteration()\n\n    config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n    reloader = CustomReload(config, target=run, sockets=[])\n    reloader.run()\n\n    assert calls == [\"startup\", \"restart\", \"shutdown\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmp_path"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert calls == ['startup', 'restart', 'shutdown']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "reloader.run",
          "body": "def run(sockets):\n    pass"
        }
      ]
    },
    {
      "name": "test_base_reloader_should_exit",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 414,
      "end_line_number": 427,
      "source_code": "def test_base_reloader_should_exit(tmp_path):\n    config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n    reloader = BaseReload(config, target=run, sockets=[])\n    assert not reloader.should_exit.is_set()\n    reloader.pause()\n\n    if sys.platform == \"win32\":\n        reloader.signal_handler(signal.CTRL_C_EVENT, None)  # pragma: py-not-win32\n    else:\n        reloader.signal_handler(signal.SIGINT, None)  # pragma: py-win32\n\n    assert reloader.should_exit.is_set()\n    with pytest.raises(StopIteration):\n        reloader.pause()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmp_path"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert not reloader.should_exit.is_set()",
        "assert reloader.should_exit.is_set()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_base_reloader_closes_sockets_on_shutdown",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 430,
      "end_line_number": 437,
      "source_code": "def test_base_reloader_closes_sockets_on_shutdown():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n    reloader = BaseReload(config, target=run, sockets=[sock])\n    reloader.startup()\n    assert sock.fileno() != -1\n    reloader.shutdown()\n    assert sock.fileno() == -1",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert sock.fileno() != -1",
        "assert sock.fileno() == -1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "reloader.startup",
          "body": "def startup(self):\n    calls.append('startup')"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ]
    },
    {
      "name": "test_reloader_should_initialize",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 77,
      "end_line_number": 87,
      "source_code": "def test_reloader_should_initialize(self) -> None:\n        \"\"\"\n        A basic sanity check.\n\n        Simply run the reloader against a no-op server, and signal for it to\n        quit immediately.\n        \"\"\"\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n            reloader.shutdown()",
      "docstring": "A basic sanity check.\n\nSimply run the reloader against a no-op server, and signal for it to\nquit immediately.",
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ]
    },
    {
      "name": "test_reload_when_python_file_is_changed",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 90,
      "end_line_number": 100,
      "source_code": "def test_reload_when_python_file_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            changes = self._reload_tester(touch_soon, reloader, file)\n            assert changes == [file]\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
      ],
      "arguments": [
        "self",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert changes == [file]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ]
    },
    {
      "name": "test_should_reload_when_python_file_in_subdir_is_changed",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 103,
      "end_line_number": 112,
      "source_code": "def test_should_reload_when_python_file_in_subdir_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \"app\" / \"sub\" / \"sub.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, file)\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
      ],
      "arguments": [
        "self",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert self._reload_tester(touch_soon, reloader, file)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ]
    },
    {
      "name": "test_should_not_reload_when_python_file_in_excluded_subdir_is_changed",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 115,
      "end_line_number": 129,
      "source_code": "def test_should_not_reload_when_python_file_in_excluded_subdir_is_changed(self, touch_soon) -> None:\n        sub_dir = self.reload_path / \"app\" / \"sub\"\n        sub_file = sub_dir / \"sub.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_excludes=[str(sub_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert not self._reload_tester(touch_soon, reloader, sub_file)\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [WatchFilesReload, WatchGodReload])"
      ],
      "arguments": [
        "self",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert not self._reload_tester(touch_soon, reloader, sub_file)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        }
      ]
    },
    {
      "name": "test_reload_when_pattern_matched_file_is_changed",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 132,
      "end_line_number": 141,
      "source_code": "def test_reload_when_pattern_matched_file_is_changed(self, result: bool, touch_soon) -> None:\n        file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_includes=[\"*.js\"])\n            reloader = self._setup_reloader(config)\n\n            assert bool(self._reload_tester(touch_soon, reloader, file)) == result\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class, result', [(StatReload, False), (WatchFilesReload, True)])"
      ],
      "arguments": [
        "self",
        "result",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert bool(self._reload_tester(touch_soon, reloader, file)) == result"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        }
      ]
    },
    {
      "name": "test_should_not_reload_when_exclude_pattern_match_file_is_changed",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 150,
      "end_line_number": 168,
      "source_code": "def test_should_not_reload_when_exclude_pattern_match_file_is_changed(self, touch_soon) -> None:\n        python_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        css_file = self.reload_path / \"app\" / \"css\" / \"main.css\"\n        js_file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\"*\"],\n                reload_excludes=[\"*.js\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, python_file)\n            assert self._reload_tester(touch_soon, reloader, css_file)\n            assert not self._reload_tester(touch_soon, reloader, js_file)\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
      ],
      "arguments": [
        "self",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert self._reload_tester(touch_soon, reloader, python_file)",
        "assert self._reload_tester(touch_soon, reloader, css_file)",
        "assert not self._reload_tester(touch_soon, reloader, js_file)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        }
      ]
    },
    {
      "name": "test_should_not_reload_when_dot_file_is_changed",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 171,
      "end_line_number": 180,
      "source_code": "def test_should_not_reload_when_dot_file_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \".dotted\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            assert not self._reload_tester(touch_soon, reloader, file)\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
      ],
      "arguments": [
        "self",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert not self._reload_tester(touch_soon, reloader, file)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        }
      ]
    },
    {
      "name": "test_should_reload_when_directories_have_same_prefix",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 183,
      "end_line_number": 200,
      "source_code": "def test_should_reload_when_directories_have_same_prefix(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_file = app_dir / \"src\" / \"main.py\"\n        app_first_dir = self.reload_path / \"app_first\"\n        app_first_file = app_first_dir / \"src\" / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_dirs=[str(app_dir), str(app_first_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, app_file)\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
      ],
      "arguments": [
        "self",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert self._reload_tester(touch_soon, reloader, app_file)",
        "assert self._reload_tester(touch_soon, reloader, app_first_file)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ]
    },
    {
      "name": "test_should_not_reload_when_only_subdirectory_is_watched",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 210,
      "end_line_number": 225,
      "source_code": "def test_should_not_reload_when_only_subdirectory_is_watched(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_dir_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        root_file = self.reload_path / \"main.py\"\n\n        config = Config(\n            app=\"tests.test_config:asgi_app\",\n            reload=True,\n            reload_dirs=[str(app_dir)],\n        )\n        reloader = self._setup_reloader(config)\n\n        assert self._reload_tester(touch_soon, reloader, app_dir_file)\n        assert not self._reload_tester(touch_soon, reloader, root_file, app_dir / \"~ignored\")\n\n        reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, pytest.param(WatchFilesReload, marks=skip_if_m1)])"
      ],
      "arguments": [
        "self",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert self._reload_tester(touch_soon, reloader, app_dir_file)",
        "assert not self._reload_tester(touch_soon, reloader, root_file, app_dir / '~ignored')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        }
      ]
    },
    {
      "name": "test_override_defaults",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 234,
      "end_line_number": 253,
      "source_code": "def test_override_defaults(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        dotted_dir_file = self.reload_path / \".dotted_dir\" / \"file.txt\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                # We need to add *.txt otherwise no regular files will match\n                reload_includes=[\".*\", \"*.txt\"],\n                reload_excludes=[\"*.py\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, dotted_dir_file)\n            assert not self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
      ],
      "arguments": [
        "self",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert self._reload_tester(touch_soon, reloader, dotted_file)",
        "assert self._reload_tester(touch_soon, reloader, dotted_dir_file)",
        "assert not self._reload_tester(touch_soon, reloader, python_file)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        }
      ]
    },
    {
      "name": "test_explicit_paths",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 262,
      "end_line_number": 279,
      "source_code": "def test_explicit_paths(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        non_dotted_file = self.reload_path / \"ext\" / \"ext.jpg\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\".dotted\", \"ext/ext.jpg\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, non_dotted_file)\n            assert self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
      ],
      "arguments": [
        "self",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert self._reload_tester(touch_soon, reloader, dotted_file)",
        "assert self._reload_tester(touch_soon, reloader, non_dotted_file)",
        "assert self._reload_tester(touch_soon, reloader, python_file)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ]
    },
    {
      "name": "test_watchfiles_no_changes",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 283,
      "end_line_number": 308,
      "source_code": "def test_watchfiles_no_changes(self) -> None:\n        sub_dir = self.reload_path / \"app\" / \"sub\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_excludes=[str(sub_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            from watchfiles import watch\n\n            assert isinstance(reloader, WatchFilesReload)\n            # just so we can make rust_timeout 100ms\n            reloader.watcher = watch(\n                sub_dir,\n                watch_filter=None,\n                stop_event=reloader.should_exit,\n                yield_on_timeout=True,\n                rust_timeout=100,\n            )\n\n            assert reloader.should_restart() is None\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(WatchFilesReload is None, reason='watchfiles not available')",
        "pytest.mark.parametrize('reloader_class', [WatchFilesReload])"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(reloader, WatchFilesReload)",
        "assert reloader.should_restart() is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        },
        {
          "name": "reloader.should_restart",
          "body": "def should_restart(self):\n    nonlocal step\n    step += 1\n    if step == 1:\n        return None\n    elif step == 2:\n        return [tmp_path / 'foobar.py']\n    else:\n        raise StopIteration()"
        }
      ]
    },
    {
      "name": "test_should_detect_new_reload_dirs",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 311,
      "end_line_number": 332,
      "source_code": "def test_should_detect_new_reload_dirs(self, touch_soon, caplog: pytest.LogCaptureFixture, tmp_path: Path) -> None:\n        app_dir = tmp_path / \"app\"\n        app_file = app_dir / \"file.py\"\n        app_dir.mkdir()\n        app_file.touch()\n        app_first_dir = tmp_path / \"app_first\"\n        app_first_file = app_first_dir / \"file.py\"\n\n        with as_cwd(tmp_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_includes=[\"app*\"])\n            reloader = self._setup_reloader(config)\n            assert self._reload_tester(touch_soon, reloader, app_file)\n\n            app_first_dir.mkdir()\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n            assert caplog.records[-2].levelno == logging.INFO\n            assert (\n                caplog.records[-1].message == \"WatchGodReload detected a new reload \"\n                f\"dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\"\n            )\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [WatchGodReload])"
      ],
      "arguments": [
        "self",
        "touch_soon",
        "caplog",
        "tmp_path"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert self._reload_tester(touch_soon, reloader, app_file)",
        "assert self._reload_tester(touch_soon, reloader, app_first_file)",
        "assert caplog.records[-2].levelno == logging.INFO",
        "assert caplog.records[-1].message == f\"WatchGodReload detected a new reload dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ]
    },
    {
      "name": "test_process_ping_pong",
      "module": "test_multiprocess",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_multiprocess.py",
      "line_number": 52,
      "end_line_number": 55,
      "source_code": "def test_process_ping_pong() -> None:\n    process = Process(Config(app=app), target=lambda x: None, sockets=[])\n    threading.Thread(target=process.always_pong, daemon=True).start()\n    assert process.ping()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "functools",
        "os",
        "signal",
        "socket",
        "threading",
        "time",
        "typing.Any",
        "typing.Callable",
        "pytest",
        "uvicorn.Config",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Scope",
        "uvicorn.supervisors.Multiprocess",
        "uvicorn.supervisors.multiprocess.Process",
        "subprocess",
        "sys"
      ],
      "fixtures": [],
      "assertions": [
        "assert process.ping()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_process_ping_pong_timeout",
      "module": "test_multiprocess",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_multiprocess.py",
      "line_number": 58,
      "end_line_number": 60,
      "source_code": "def test_process_ping_pong_timeout() -> None:\n    process = Process(Config(app=app), target=lambda x: None, sockets=[])\n    assert not process.ping(0.1)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "functools",
        "os",
        "signal",
        "socket",
        "threading",
        "time",
        "typing.Any",
        "typing.Callable",
        "pytest",
        "uvicorn.Config",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Scope",
        "uvicorn.supervisors.Multiprocess",
        "uvicorn.supervisors.multiprocess.Process",
        "subprocess",
        "sys"
      ],
      "fixtures": [],
      "assertions": [
        "assert not process.ping(0.1)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_multiprocess_run",
      "module": "test_multiprocess",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_multiprocess.py",
      "line_number": 64,
      "end_line_number": 75,
      "source_code": "def test_multiprocess_run() -> None:\n    \"\"\"\n    A basic sanity check.\n\n    Simply run the supervisor against a no-op server, and signal for it to\n    quit immediately.\n    \"\"\"\n    config = Config(app=app, workers=2)\n    supervisor = Multiprocess(config, target=run, sockets=[])\n    threading.Thread(target=supervisor.run, daemon=True).start()\n    supervisor.signal_queue.append(signal.SIGINT)\n    supervisor.join_all()",
      "docstring": "A basic sanity check.\n\nSimply run the supervisor against a no-op server, and signal for it to\nquit immediately.",
      "decorators": [
        "new_console_in_windows"
      ],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "functools",
        "os",
        "signal",
        "socket",
        "threading",
        "time",
        "typing.Any",
        "typing.Callable",
        "pytest",
        "uvicorn.Config",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Scope",
        "uvicorn.supervisors.Multiprocess",
        "uvicorn.supervisors.multiprocess.Process",
        "subprocess",
        "sys"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_multiprocess_health_check",
      "module": "test_multiprocess",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_multiprocess.py",
      "line_number": 79,
      "end_line_number": 94,
      "source_code": "def test_multiprocess_health_check() -> None:\n    \"\"\"\n    Ensure that the health check works as expected.\n    \"\"\"\n    config = Config(app=app, workers=2)\n    supervisor = Multiprocess(config, target=run, sockets=[])\n    threading.Thread(target=supervisor.run, daemon=True).start()\n    time.sleep(1)\n    process = supervisor.processes[0]\n    process.kill()\n    assert not process.is_alive()\n    time.sleep(1)\n    for p in supervisor.processes:\n        assert p.is_alive()\n    supervisor.signal_queue.append(signal.SIGINT)\n    supervisor.join_all()",
      "docstring": "Ensure that the health check works as expected.",
      "decorators": [
        "new_console_in_windows"
      ],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "functools",
        "os",
        "signal",
        "socket",
        "threading",
        "time",
        "typing.Any",
        "typing.Callable",
        "pytest",
        "uvicorn.Config",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Scope",
        "uvicorn.supervisors.Multiprocess",
        "uvicorn.supervisors.multiprocess.Process",
        "subprocess",
        "sys"
      ],
      "fixtures": [],
      "assertions": [
        "assert not process.is_alive()",
        "assert p.is_alive()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_multiprocess_sigterm",
      "module": "test_multiprocess",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_multiprocess.py",
      "line_number": 98,
      "end_line_number": 107,
      "source_code": "def test_multiprocess_sigterm() -> None:\n    \"\"\"\n    Ensure that the SIGTERM signal is handled as expected.\n    \"\"\"\n    config = Config(app=app, workers=2)\n    supervisor = Multiprocess(config, target=run, sockets=[])\n    threading.Thread(target=supervisor.run, daemon=True).start()\n    time.sleep(1)\n    supervisor.signal_queue.append(signal.SIGTERM)\n    supervisor.join_all()",
      "docstring": "Ensure that the SIGTERM signal is handled as expected.",
      "decorators": [
        "new_console_in_windows"
      ],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "functools",
        "os",
        "signal",
        "socket",
        "threading",
        "time",
        "typing.Any",
        "typing.Callable",
        "pytest",
        "uvicorn.Config",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Scope",
        "uvicorn.supervisors.Multiprocess",
        "uvicorn.supervisors.multiprocess.Process",
        "subprocess",
        "sys"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_multiprocess_sigbreak",
      "module": "test_multiprocess",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_multiprocess.py",
      "line_number": 112,
      "end_line_number": 121,
      "source_code": "def test_multiprocess_sigbreak() -> None:  # pragma: py-not-win32\n    \"\"\"\n    Ensure that the SIGBREAK signal is handled as expected.\n    \"\"\"\n    config = Config(app=app, workers=2)\n    supervisor = Multiprocess(config, target=run, sockets=[])\n    threading.Thread(target=supervisor.run, daemon=True).start()\n    time.sleep(1)\n    supervisor.signal_queue.append(getattr(signal, \"SIGBREAK\"))\n    supervisor.join_all()",
      "docstring": "Ensure that the SIGBREAK signal is handled as expected.",
      "decorators": [
        "pytest.mark.skipif(not hasattr(signal, 'SIGBREAK'), reason='platform unsupports SIGBREAK')",
        "new_console_in_windows"
      ],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "functools",
        "os",
        "signal",
        "socket",
        "threading",
        "time",
        "typing.Any",
        "typing.Callable",
        "pytest",
        "uvicorn.Config",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Scope",
        "uvicorn.supervisors.Multiprocess",
        "uvicorn.supervisors.multiprocess.Process",
        "subprocess",
        "sys"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_multiprocess_sighup",
      "module": "test_multiprocess",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_multiprocess.py",
      "line_number": 125,
      "end_line_number": 138,
      "source_code": "def test_multiprocess_sighup() -> None:\n    \"\"\"\n    Ensure that the SIGHUP signal is handled as expected.\n    \"\"\"\n    config = Config(app=app, workers=2)\n    supervisor = Multiprocess(config, target=run, sockets=[])\n    threading.Thread(target=supervisor.run, daemon=True).start()\n    time.sleep(1)\n    pids = [p.pid for p in supervisor.processes]\n    supervisor.signal_queue.append(signal.SIGHUP)\n    time.sleep(1)\n    assert pids != [p.pid for p in supervisor.processes]\n    supervisor.signal_queue.append(signal.SIGINT)\n    supervisor.join_all()",
      "docstring": "Ensure that the SIGHUP signal is handled as expected.",
      "decorators": [
        "pytest.mark.skipif(not hasattr(signal, 'SIGHUP'), reason='platform unsupports SIGHUP')"
      ],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "functools",
        "os",
        "signal",
        "socket",
        "threading",
        "time",
        "typing.Any",
        "typing.Callable",
        "pytest",
        "uvicorn.Config",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Scope",
        "uvicorn.supervisors.Multiprocess",
        "uvicorn.supervisors.multiprocess.Process",
        "subprocess",
        "sys"
      ],
      "fixtures": [],
      "assertions": [
        "assert pids != [p.pid for p in supervisor.processes]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_multiprocess_sigttin",
      "module": "test_multiprocess",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_multiprocess.py",
      "line_number": 142,
      "end_line_number": 153,
      "source_code": "def test_multiprocess_sigttin() -> None:\n    \"\"\"\n    Ensure that the SIGTTIN signal is handled as expected.\n    \"\"\"\n    config = Config(app=app, workers=2)\n    supervisor = Multiprocess(config, target=run, sockets=[])\n    threading.Thread(target=supervisor.run, daemon=True).start()\n    supervisor.signal_queue.append(signal.SIGTTIN)\n    time.sleep(1)\n    assert len(supervisor.processes) == 3\n    supervisor.signal_queue.append(signal.SIGINT)\n    supervisor.join_all()",
      "docstring": "Ensure that the SIGTTIN signal is handled as expected.",
      "decorators": [
        "pytest.mark.skipif(not hasattr(signal, 'SIGTTIN'), reason='platform unsupports SIGTTIN')"
      ],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "functools",
        "os",
        "signal",
        "socket",
        "threading",
        "time",
        "typing.Any",
        "typing.Callable",
        "pytest",
        "uvicorn.Config",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Scope",
        "uvicorn.supervisors.Multiprocess",
        "uvicorn.supervisors.multiprocess.Process",
        "subprocess",
        "sys"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(supervisor.processes) == 3"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_multiprocess_sigttou",
      "module": "test_multiprocess",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_multiprocess.py",
      "line_number": 157,
      "end_line_number": 171,
      "source_code": "def test_multiprocess_sigttou() -> None:\n    \"\"\"\n    Ensure that the SIGTTOU signal is handled as expected.\n    \"\"\"\n    config = Config(app=app, workers=2)\n    supervisor = Multiprocess(config, target=run, sockets=[])\n    threading.Thread(target=supervisor.run, daemon=True).start()\n    supervisor.signal_queue.append(signal.SIGTTOU)\n    time.sleep(1)\n    assert len(supervisor.processes) == 1\n    supervisor.signal_queue.append(signal.SIGTTOU)\n    time.sleep(1)\n    assert len(supervisor.processes) == 1\n    supervisor.signal_queue.append(signal.SIGINT)\n    supervisor.join_all()",
      "docstring": "Ensure that the SIGTTOU signal is handled as expected.",
      "decorators": [
        "pytest.mark.skipif(not hasattr(signal, 'SIGTTOU'), reason='platform unsupports SIGTTOU')"
      ],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "functools",
        "os",
        "signal",
        "socket",
        "threading",
        "time",
        "typing.Any",
        "typing.Callable",
        "pytest",
        "uvicorn.Config",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Scope",
        "uvicorn.supervisors.Multiprocess",
        "uvicorn.supervisors.multiprocess.Process",
        "subprocess",
        "sys"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(supervisor.processes) == 1",
        "assert len(supervisor.processes) == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_forwarded_hosts",
      "module": "test_proxy_headers",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/middleware/test_proxy_headers.py",
      "line_number": 339,
      "end_line_number": 341,
      "source_code": "def test_forwarded_hosts(init_hosts: str | list[str], test_host: str, expected: bool) -> None:\n    trusted_hosts = _TrustedHosts(init_hosts)\n    assert (test_host in trusted_hosts) is expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize(('init_hosts', 'test_host', 'expected'), [(_TRUSTED_NOTHING, '127.0.0.0', False), (_TRUSTED_NOTHING, '127.0.0.1', False), (_TRUSTED_NOTHING, '127.1.1.1', False), (_TRUSTED_NOTHING, '127.255.255.255', False), (_TRUSTED_NOTHING, '10.0.0.0', False), (_TRUSTED_NOTHING, '10.0.0.1', False), (_TRUSTED_NOTHING, '10.1.1.1', False), (_TRUSTED_NOTHING, '10.255.255.255', False), (_TRUSTED_NOTHING, '192.168.0.0', False), (_TRUSTED_NOTHING, '192.168.0.1', False), (_TRUSTED_NOTHING, '1.1.1.1', False), (_TRUSTED_NOTHING, '2001:db8::', False), (_TRUSTED_NOTHING, '2001:db8:abcd:0012::0', False), (_TRUSTED_NOTHING, '2001:db8:abcd:0012::1:1', False), (_TRUSTED_NOTHING, '::', False), (_TRUSTED_NOTHING, '::1', False), (_TRUSTED_NOTHING, '2001:db8:3333:4444:5555:6666:102:304', False), (_TRUSTED_NOTHING, '::b16:212c', False), (_TRUSTED_NOTHING, 'a:b:c:d::', False), (_TRUSTED_NOTHING, '::a:b:c:d', False), (_TRUSTED_NOTHING, 'some-literal', False), (_TRUSTED_NOTHING, 'unix:///foo/bar', False), (_TRUSTED_NOTHING, '/foo/bar', False), (_TRUSTED_NOTHING, '*', False), (_TRUSTED_NOTHING, 'another-literal', False), (_TRUSTED_NOTHING, 'unix:///another/path', False), (_TRUSTED_NOTHING, '/another/path', False), (_TRUSTED_NOTHING, '', False), (_TRUSTED_EVERYTHING, '127.0.0.0', True), (_TRUSTED_EVERYTHING, '127.0.0.1', True), (_TRUSTED_EVERYTHING, '127.1.1.1', True), (_TRUSTED_EVERYTHING, '127.255.255.255', True), (_TRUSTED_EVERYTHING, '10.0.0.0', True), (_TRUSTED_EVERYTHING, '10.0.0.1', True), (_TRUSTED_EVERYTHING, '10.1.1.1', True), (_TRUSTED_EVERYTHING, '10.255.255.255', True), (_TRUSTED_EVERYTHING, '192.168.0.0', True), (_TRUSTED_EVERYTHING, '192.168.0.1', True), (_TRUSTED_EVERYTHING, '1.1.1.1', True), (_TRUSTED_EVERYTHING_LIST, '1.1.1.1', True), (_TRUSTED_EVERYTHING, '2001:db8::', True), (_TRUSTED_EVERYTHING, '2001:db8:abcd:0012::0', True), (_TRUSTED_EVERYTHING, '2001:db8:abcd:0012::1:1', True), (_TRUSTED_EVERYTHING, '::', True), (_TRUSTED_EVERYTHING, '::1', True), (_TRUSTED_EVERYTHING, '2001:db8:3333:4444:5555:6666:102:304', True), (_TRUSTED_EVERYTHING, '::b16:212c', True), (_TRUSTED_EVERYTHING, 'a:b:c:d::', True), (_TRUSTED_EVERYTHING, '::a:b:c:d', True), (_TRUSTED_EVERYTHING_LIST, '::a:b:c:d', True), (_TRUSTED_EVERYTHING, 'some-literal', True), (_TRUSTED_EVERYTHING, 'unix:///foo/bar', True), (_TRUSTED_EVERYTHING, '/foo/bar', True), (_TRUSTED_EVERYTHING, '*', True), (_TRUSTED_EVERYTHING, 'another-literal', True), (_TRUSTED_EVERYTHING, 'unix:///another/path', True), (_TRUSTED_EVERYTHING, '/another/path', True), (_TRUSTED_EVERYTHING, '', True), (_TRUSTED_EVERYTHING_LIST, '', True), (_TRUSTED_IPv4_ADDRESSES, '127.0.0.0', False), (_TRUSTED_IPv4_ADDRESSES, '127.0.0.1', True), (_TRUSTED_IPv4_ADDRESSES, '127.1.1.1', False), (_TRUSTED_IPv4_ADDRESSES, '127.255.255.255', False), (_TRUSTED_IPv4_ADDRESSES, '10.0.0.0', False), (_TRUSTED_IPv4_ADDRESSES, '10.0.0.1', True), (_TRUSTED_IPv4_ADDRESSES, '10.1.1.1', False), (_TRUSTED_IPv4_ADDRESSES, '10.255.255.255', False), (_TRUSTED_IPv4_ADDRESSES, '192.168.0.0', False), (_TRUSTED_IPv4_ADDRESSES, '192.168.0.1', False), (_TRUSTED_IPv4_ADDRESSES, '1.1.1.1', False), (_TRUSTED_IPv4_ADDRESSES, '2001:db8::', False), (_TRUSTED_IPv4_ADDRESSES, '2001:db8:abcd:0012::0', False), (_TRUSTED_IPv4_ADDRESSES, '2001:db8:abcd:0012::1:1', False), (_TRUSTED_IPv4_ADDRESSES, '::', False), (_TRUSTED_IPv4_ADDRESSES, '::1', False), (_TRUSTED_IPv4_ADDRESSES, '2001:db8:3333:4444:5555:6666:102:304', False), (_TRUSTED_IPv4_ADDRESSES, '::b16:212c', False), (_TRUSTED_IPv4_ADDRESSES, 'a:b:c:d::', False), (_TRUSTED_IPv4_ADDRESSES, '::a:b:c:d', False), (_TRUSTED_IPv4_ADDRESSES, 'some-literal', False), (_TRUSTED_IPv4_ADDRESSES, 'unix:///foo/bar', False), (_TRUSTED_IPv4_ADDRESSES, '*', False), (_TRUSTED_IPv4_ADDRESSES, '/foo/bar', False), (_TRUSTED_IPv4_ADDRESSES, 'another-literal', False), (_TRUSTED_IPv4_ADDRESSES, 'unix:///another/path', False), (_TRUSTED_IPv4_ADDRESSES, '/another/path', False), (_TRUSTED_IPv4_ADDRESSES, '', False), (_TRUSTED_IPv6_ADDRESSES, '127.0.0.0', False), (_TRUSTED_IPv6_ADDRESSES, '127.0.0.1', False), (_TRUSTED_IPv6_ADDRESSES, '127.1.1.1', False), (_TRUSTED_IPv6_ADDRESSES, '127.255.255.255', False), (_TRUSTED_IPv6_ADDRESSES, '10.0.0.0', False), (_TRUSTED_IPv6_ADDRESSES, '10.0.0.1', False), (_TRUSTED_IPv6_ADDRESSES, '10.1.1.1', False), (_TRUSTED_IPv6_ADDRESSES, '10.255.255.255', False), (_TRUSTED_IPv6_ADDRESSES, '192.168.0.0', False), (_TRUSTED_IPv6_ADDRESSES, '192.168.0.1', False), (_TRUSTED_IPv6_ADDRESSES, '1.1.1.1', False), (_TRUSTED_IPv6_ADDRESSES, '2001:db8::', True), (_TRUSTED_IPv6_ADDRESSES, '2001:db8:abcd:0012::0', False), (_TRUSTED_IPv6_ADDRESSES, '2001:db8:abcd:0012::1:1', False), (_TRUSTED_IPv6_ADDRESSES, '::', False), (_TRUSTED_IPv6_ADDRESSES, '::1', False), (_TRUSTED_IPv6_ADDRESSES, '2001:db8:3333:4444:5555:6666:102:304', True), (_TRUSTED_IPv6_ADDRESSES, '::b16:212c', True), (_TRUSTED_IPv6_ADDRESSES, 'a:b:c:d::', False), (_TRUSTED_IPv6_ADDRESSES, '::a:b:c:d', False), (_TRUSTED_IPv6_ADDRESSES, 'some-literal', False), (_TRUSTED_IPv6_ADDRESSES, 'unix:///foo/bar', False), (_TRUSTED_IPv6_ADDRESSES, '*', False), (_TRUSTED_IPv6_ADDRESSES, '/foo/bar', False), (_TRUSTED_IPv6_ADDRESSES, 'another-literal', False), (_TRUSTED_IPv6_ADDRESSES, 'unix:///another/path', False), (_TRUSTED_IPv6_ADDRESSES, '/another/path', False), (_TRUSTED_IPv6_ADDRESSES, '', False), (_TRUSTED_IPv4_NETWORKS, '127.0.0.0', True), (_TRUSTED_IPv4_NETWORKS, '127.0.0.1', True), (_TRUSTED_IPv4_NETWORKS, '127.1.1.1', True), (_TRUSTED_IPv4_NETWORKS, '127.255.255.255', True), (_TRUSTED_IPv4_NETWORKS, '10.0.0.0', True), (_TRUSTED_IPv4_NETWORKS, '10.0.0.1', True), (_TRUSTED_IPv4_NETWORKS, '10.1.1.1', True), (_TRUSTED_IPv4_NETWORKS, '10.255.255.255', True), (_TRUSTED_IPv4_NETWORKS, '192.168.0.0', False), (_TRUSTED_IPv4_NETWORKS, '192.168.0.1', False), (_TRUSTED_IPv4_NETWORKS, '1.1.1.1', False), (_TRUSTED_IPv4_NETWORKS, '2001:db8::', False), (_TRUSTED_IPv4_NETWORKS, '2001:db8:abcd:0012::0', False), (_TRUSTED_IPv4_NETWORKS, '2001:db8:abcd:0012::1:1', False), (_TRUSTED_IPv4_NETWORKS, '::', False), (_TRUSTED_IPv4_NETWORKS, '::1', False), (_TRUSTED_IPv4_NETWORKS, '2001:db8:3333:4444:5555:6666:102:304', False), (_TRUSTED_IPv4_NETWORKS, '::b16:212c', False), (_TRUSTED_IPv4_NETWORKS, 'a:b:c:d::', False), (_TRUSTED_IPv4_NETWORKS, '::a:b:c:d', False), (_TRUSTED_IPv4_NETWORKS, 'some-literal', False), (_TRUSTED_IPv4_NETWORKS, 'unix:///foo/bar', False), (_TRUSTED_IPv4_NETWORKS, '*', False), (_TRUSTED_IPv4_NETWORKS, '/foo/bar', False), (_TRUSTED_IPv4_NETWORKS, 'another-literal', False), (_TRUSTED_IPv4_NETWORKS, 'unix:///another/path', False), (_TRUSTED_IPv4_NETWORKS, '/another/path', False), (_TRUSTED_IPv4_NETWORKS, '', False), (_TRUSTED_IPv6_NETWORKS, '127.0.0.0', False), (_TRUSTED_IPv6_NETWORKS, '127.0.0.1', False), (_TRUSTED_IPv6_NETWORKS, '127.1.1.1', False), (_TRUSTED_IPv6_NETWORKS, '127.255.255.255', False), (_TRUSTED_IPv6_NETWORKS, '10.0.0.0', False), (_TRUSTED_IPv6_NETWORKS, '10.0.0.1', False), (_TRUSTED_IPv6_NETWORKS, '10.1.1.1', False), (_TRUSTED_IPv6_NETWORKS, '10.255.255.255', False), (_TRUSTED_IPv6_NETWORKS, '192.168.0.0', False), (_TRUSTED_IPv6_NETWORKS, '192.168.0.1', False), (_TRUSTED_IPv6_NETWORKS, '1.1.1.1', False), (_TRUSTED_IPv6_NETWORKS, '2001:db8::', False), (_TRUSTED_IPv6_NETWORKS, '2001:db8:abcd:0012::0', True), (_TRUSTED_IPv6_NETWORKS, '2001:db8:abcd:0012::1:1', True), (_TRUSTED_IPv6_NETWORKS, '::', False), (_TRUSTED_IPv6_NETWORKS, '::1', False), (_TRUSTED_IPv6_NETWORKS, '2001:db8:3333:4444:5555:6666:102:304', False), (_TRUSTED_IPv6_NETWORKS, '::b16:212c', False), (_TRUSTED_IPv6_NETWORKS, 'a:b:c:d::', False), (_TRUSTED_IPv6_NETWORKS, '::a:b:c:d', False), (_TRUSTED_IPv6_NETWORKS, 'some-literal', False), (_TRUSTED_IPv6_NETWORKS, 'unix:///foo/bar', False), (_TRUSTED_IPv6_NETWORKS, '*', False), (_TRUSTED_IPv6_NETWORKS, '/foo/bar', False), (_TRUSTED_IPv6_NETWORKS, 'another-literal', False), (_TRUSTED_IPv6_NETWORKS, 'unix:///another/path', False), (_TRUSTED_IPv6_NETWORKS, '/another/path', False), (_TRUSTED_IPv6_NETWORKS, '', False), (_TRUSTED_LITERALS, '127.0.0.0', False), (_TRUSTED_LITERALS, '127.0.0.1', False), (_TRUSTED_LITERALS, '127.1.1.1', False), (_TRUSTED_LITERALS, '127.255.255.255', False), (_TRUSTED_LITERALS, '10.0.0.0', False), (_TRUSTED_LITERALS, '10.0.0.1', False), (_TRUSTED_LITERALS, '10.1.1.1', False), (_TRUSTED_LITERALS, '10.255.255.255', False), (_TRUSTED_LITERALS, '192.168.0.0', False), (_TRUSTED_LITERALS, '192.168.0.1', False), (_TRUSTED_LITERALS, '1.1.1.1', False), (_TRUSTED_LITERALS, '2001:db8::', False), (_TRUSTED_LITERALS, '2001:db8:abcd:0012::0', False), (_TRUSTED_LITERALS, '2001:db8:abcd:0012::1:1', False), (_TRUSTED_LITERALS, '::', False), (_TRUSTED_LITERALS, '::1', False), (_TRUSTED_LITERALS, '2001:db8:3333:4444:5555:6666:102:304', False), (_TRUSTED_LITERALS, '::b16:212c', False), (_TRUSTED_LITERALS, 'a:b:c:d::', False), (_TRUSTED_LITERALS, '::a:b:c:d', False), (_TRUSTED_LITERALS, 'some-literal', True), (_TRUSTED_LITERALS, 'unix:///foo/bar', True), (_TRUSTED_LITERALS, '*', False), (_TRUSTED_LITERALS, '/foo/bar', True), (_TRUSTED_LITERALS, 'another-literal', False), (_TRUSTED_LITERALS, 'unix:///another/path', False), (_TRUSTED_LITERALS, '/another/path', False), (_TRUSTED_LITERALS, '', False)])"
      ],
      "arguments": [
        "init_hosts",
        "test_host",
        "expected"
      ],
      "imports": [
        "__future__.annotations",
        "typing.TYPE_CHECKING",
        "httpx",
        "httpx._transports.asgi",
        "pytest",
        "websockets.client",
        "tests.response.Response",
        "tests.utils.run_server",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Scope",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.proxy_headers._TrustedHosts",
        "uvicorn.protocols.http.h11_impl.H11Protocol",
        "uvicorn.protocols.http.httptools_impl.HttpToolsProtocol",
        "uvicorn.protocols.websockets.websockets_impl.WebSocketProtocol",
        "uvicorn.protocols.websockets.wsproto_impl.WSProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert (test_host in trusted_hosts) is expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_build_environ_encoding",
      "module": "test_wsgi",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/middleware/test_wsgi.py",
      "line_number": 114,
      "end_line_number": 138,
      "source_code": "def test_build_environ_encoding() -> None:\n    scope: HTTPScope = {\n        \"asgi\": {\"version\": \"3.0\", \"spec_version\": \"2.0\"},\n        \"scheme\": \"http\",\n        \"raw_path\": b\"/\\xe6\\x96\\x87%2Fall\",\n        \"type\": \"http\",\n        \"http_version\": \"1.1\",\n        \"method\": \"GET\",\n        \"path\": \"/\u6587/all\",\n        \"root_path\": \"/\u6587\",\n        \"client\": None,\n        \"server\": None,\n        \"query_string\": b\"a=123&b=456\",\n        \"headers\": [(b\"key\", b\"value1\"), (b\"key\", b\"value2\")],\n        \"extensions\": {},\n    }\n    message: HTTPRequestEvent = {\n        \"type\": \"http.request\",\n        \"body\": b\"\",\n        \"more_body\": False,\n    }\n    environ = wsgi.build_environ(scope, message, io.BytesIO(b\"\"))\n    assert environ[\"SCRIPT_NAME\"] == \"/\u6587\".encode().decode(\"latin-1\")\n    assert environ[\"PATH_INFO\"] == b\"/all\".decode(\"latin-1\")\n    assert environ[\"HTTP_KEY\"] == \"value1,value2\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "io",
        "sys",
        "typing.AsyncGenerator",
        "typing.Callable",
        "a2wsgi",
        "httpx",
        "pytest",
        "uvicorn._types.Environ",
        "uvicorn._types.HTTPRequestEvent",
        "uvicorn._types.HTTPScope",
        "uvicorn._types.StartResponse",
        "uvicorn.middleware.wsgi"
      ],
      "fixtures": [],
      "assertions": [
        "assert environ['SCRIPT_NAME'] == '/\u6587'.encode().decode('latin-1')",
        "assert environ['PATH_INFO'] == b'/all'.decode('latin-1')",
        "assert environ['HTTP_KEY'] == 'value1,value2'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_fragmentation",
      "module": "test_http",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/protocols/test_http.py",
      "line_number": 902,
      "end_line_number": 944,
      "source_code": "def test_fragmentation(unused_tcp_port: int):\n    def receive_all(sock: socket.socket):\n        chunks: list[bytes] = []\n        while True:\n            chunk = sock.recv(1024)\n            if not chunk:\n                break\n            chunks.append(chunk)\n        return b\"\".join(chunks)\n\n    app = Response(\"Hello, world\", media_type=\"text/plain\")\n\n    def send_fragmented_req(path: str):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect((\"127.0.0.1\", unused_tcp_port))\n        d = (f\"GET {path} HTTP/1.1\\r\\n\" \"Host: localhost\\r\\n\" \"Connection: close\\r\\n\\r\\n\").encode()\n        split = len(path) // 2\n        sock.sendall(d[:split])\n        time.sleep(0.01)\n        sock.sendall(d[split:])\n        resp = receive_all(sock)\n        # see https://github.com/kmonsoor/py-amqplib/issues/45\n        # we skip the error on bsd systems if python is too slow\n        try:\n            sock.shutdown(socket.SHUT_RDWR)\n        except Exception:  # pragma: no cover\n            pass\n        sock.close()\n        return resp\n\n    config = Config(app=app, http=\"httptools\", port=unused_tcp_port)\n    server = Server(config=config)\n    t = threading.Thread(target=server.run)\n    t.daemon = True\n    t.start()\n    time.sleep(1)  # wait for uvicorn to start\n\n    path = \"/?param=\" + \"q\" * 10\n    response = send_fragmented_req(path)\n    bad_response = b\"HTTP/1.1 400 Bad Request\"\n    assert bad_response != response[: len(bad_response)]\n    server.should_exit = True\n    t.join()",
      "docstring": null,
      "decorators": [
        "skip_if_no_httptools"
      ],
      "arguments": [
        "unused_tcp_port"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "socket",
        "threading",
        "time",
        "typing.TYPE_CHECKING",
        "typing.Any",
        "pytest",
        "tests.response.Response",
        "uvicorn.Server",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Scope",
        "uvicorn.config.WS_PROTOCOLS",
        "uvicorn.config.Config",
        "uvicorn.lifespan.off.LifespanOff",
        "uvicorn.lifespan.on.LifespanOn",
        "uvicorn.main.ServerState",
        "uvicorn.protocols.http.h11_impl.H11Protocol",
        "uvicorn.protocols.http.httptools_impl.HttpToolsProtocol",
        "sys",
        "uvicorn.protocols.http.httptools_impl.HttpToolsProtocol",
        "uvicorn.protocols.websockets.websockets_impl.WebSocketProtocol",
        "uvicorn.protocols.websockets.wsproto_impl.WSProtocol",
        "typing.TypeAlias",
        "typing_extensions.TypeAlias"
      ],
      "fixtures": [],
      "assertions": [
        "assert bad_response != response[:len(bad_response)]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "t.start",
          "body": "def start(*paths: Path):\n    thread = Thread(target=sleep_touch, args=paths)\n    thread.start()\n    threads.append(thread)"
        },
        {
          "name": "send_fragmented_req",
          "body": "def send_fragmented_req(path: str):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect(('127.0.0.1', unused_tcp_port))\n    d = f'GET {path} HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n'.encode()\n    split = len(path) // 2\n    sock.sendall(d[:split])\n    time.sleep(0.01)\n    sock.sendall(d[split:])\n    resp = receive_all(sock)\n    try:\n        sock.shutdown(socket.SHUT_RDWR)\n    except Exception:\n        pass\n    sock.close()\n    return resp"
        },
        {
          "name": "receive_all",
          "body": "def receive_all(sock: socket.socket):\n    chunks: list[bytes] = []\n    while True:\n        chunk = sock.recv(1024)\n        if not chunk:\n            break\n        chunks.append(chunk)\n    return b''.join(chunks)"
        },
        {
          "name": "sock.close",
          "body": "def close(self):\n    assert not self.closed\n    self.closed = True"
        },
        {
          "name": "sock.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ]
    },
    {
      "name": "test_get_local_addr_with_socket",
      "module": "test_utils",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/protocols/test_utils.py",
      "line_number": 33,
      "end_line_number": 45,
      "source_code": "def test_get_local_addr_with_socket():\n    transport = MockTransport({\"socket\": MockSocket(family=socket.AF_IPX)})\n    assert get_local_addr(transport) is None\n\n    transport = MockTransport({\"socket\": MockSocket(family=socket.AF_INET6, sockname=(\"::1\", 123))})\n    assert get_local_addr(transport) == (\"::1\", 123)\n\n    transport = MockTransport({\"socket\": MockSocket(family=socket.AF_INET, sockname=(\"123.45.6.7\", 123))})\n    assert get_local_addr(transport) == (\"123.45.6.7\", 123)\n\n    if hasattr(socket, \"AF_UNIX\"):  # pragma: no cover\n        transport = MockTransport({\"socket\": MockSocket(family=socket.AF_UNIX, sockname=(\"127.0.0.1\", 8000))})\n        assert get_local_addr(transport) == (\"127.0.0.1\", 8000)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "socket",
        "asyncio.Transport",
        "typing.Any",
        "pytest",
        "uvicorn.protocols.utils.get_client_addr",
        "uvicorn.protocols.utils.get_local_addr",
        "uvicorn.protocols.utils.get_remote_addr"
      ],
      "fixtures": [],
      "assertions": [
        "assert get_local_addr(transport) is None",
        "assert get_local_addr(transport) == ('::1', 123)",
        "assert get_local_addr(transport) == ('123.45.6.7', 123)",
        "assert get_local_addr(transport) == ('127.0.0.1', 8000)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get_remote_addr_with_socket",
      "module": "test_utils",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/protocols/test_utils.py",
      "line_number": 48,
      "end_line_number": 60,
      "source_code": "def test_get_remote_addr_with_socket():\n    transport = MockTransport({\"socket\": MockSocket(family=socket.AF_IPX)})\n    assert get_remote_addr(transport) is None\n\n    transport = MockTransport({\"socket\": MockSocket(family=socket.AF_INET6, peername=(\"::1\", 123))})\n    assert get_remote_addr(transport) == (\"::1\", 123)\n\n    transport = MockTransport({\"socket\": MockSocket(family=socket.AF_INET, peername=(\"123.45.6.7\", 123))})\n    assert get_remote_addr(transport) == (\"123.45.6.7\", 123)\n\n    if hasattr(socket, \"AF_UNIX\"):  # pragma: no cover\n        transport = MockTransport({\"socket\": MockSocket(family=socket.AF_UNIX, peername=(\"127.0.0.1\", 8000))})\n        assert get_remote_addr(transport) == (\"127.0.0.1\", 8000)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "socket",
        "asyncio.Transport",
        "typing.Any",
        "pytest",
        "uvicorn.protocols.utils.get_client_addr",
        "uvicorn.protocols.utils.get_local_addr",
        "uvicorn.protocols.utils.get_remote_addr"
      ],
      "fixtures": [],
      "assertions": [
        "assert get_remote_addr(transport) is None",
        "assert get_remote_addr(transport) == ('::1', 123)",
        "assert get_remote_addr(transport) == ('123.45.6.7', 123)",
        "assert get_remote_addr(transport) == ('127.0.0.1', 8000)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get_local_addr",
      "module": "test_utils",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/protocols/test_utils.py",
      "line_number": 63,
      "end_line_number": 68,
      "source_code": "def test_get_local_addr():\n    transport = MockTransport({\"sockname\": \"path/to/unix-domain-socket\"})\n    assert get_local_addr(transport) is None\n\n    transport = MockTransport({\"sockname\": (\"123.45.6.7\", 123)})\n    assert get_local_addr(transport) == (\"123.45.6.7\", 123)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "socket",
        "asyncio.Transport",
        "typing.Any",
        "pytest",
        "uvicorn.protocols.utils.get_client_addr",
        "uvicorn.protocols.utils.get_local_addr",
        "uvicorn.protocols.utils.get_remote_addr"
      ],
      "fixtures": [],
      "assertions": [
        "assert get_local_addr(transport) is None",
        "assert get_local_addr(transport) == ('123.45.6.7', 123)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get_remote_addr",
      "module": "test_utils",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/protocols/test_utils.py",
      "line_number": 71,
      "end_line_number": 76,
      "source_code": "def test_get_remote_addr():\n    transport = MockTransport({\"peername\": None})\n    assert get_remote_addr(transport) is None\n\n    transport = MockTransport({\"peername\": (\"123.45.6.7\", 123)})\n    assert get_remote_addr(transport) == (\"123.45.6.7\", 123)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "socket",
        "asyncio.Transport",
        "typing.Any",
        "pytest",
        "uvicorn.protocols.utils.get_client_addr",
        "uvicorn.protocols.utils.get_local_addr",
        "uvicorn.protocols.utils.get_remote_addr"
      ],
      "fixtures": [],
      "assertions": [
        "assert get_remote_addr(transport) is None",
        "assert get_remote_addr(transport) == ('123.45.6.7', 123)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get_client_addr",
      "module": "test_utils",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/protocols/test_utils.py",
      "line_number": 84,
      "end_line_number": 85,
      "source_code": "def test_get_client_addr(scope, expected_client):\n    assert get_client_addr(scope) == expected_client",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('scope, expected_client', [({'client': ('127.0.0.1', 36000)}, '127.0.0.1:36000'), ({'client': None}, '')], ids=['ip:port client', 'None client'])"
      ],
      "arguments": [
        "scope",
        "expected_client"
      ],
      "imports": [
        "__future__.annotations",
        "socket",
        "asyncio.Transport",
        "typing.Any",
        "pytest",
        "uvicorn.protocols.utils.get_client_addr",
        "uvicorn.protocols.utils.get_local_addr",
        "uvicorn.protocols.utils.get_remote_addr"
      ],
      "fixtures": [],
      "assertions": [
        "assert get_client_addr(scope) == expected_client"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_invalid_format",
      "module": "test_importer",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/importer/test_importer.py",
      "line_number": 6,
      "end_line_number": 10,
      "source_code": "def test_invalid_format() -> None:\n    with pytest.raises(ImportFromStringError) as exc_info:\n        import_from_string(\"example:\")\n    expected = 'Import string \"example:\" must be in format \"<module>:<attribute>\".'\n    assert expected in str(exc_info.value)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "uvicorn.importer.ImportFromStringError",
        "uvicorn.importer.import_from_string",
        "tempfile.TemporaryFile",
        "tempfile.TemporaryFile"
      ],
      "fixtures": [],
      "assertions": [
        "assert expected in str(exc_info.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_invalid_module",
      "module": "test_importer",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/importer/test_importer.py",
      "line_number": 13,
      "end_line_number": 17,
      "source_code": "def test_invalid_module() -> None:\n    with pytest.raises(ImportFromStringError) as exc_info:\n        import_from_string(\"module_does_not_exist:myattr\")\n    expected = 'Could not import module \"module_does_not_exist\".'\n    assert expected in str(exc_info.value)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "uvicorn.importer.ImportFromStringError",
        "uvicorn.importer.import_from_string",
        "tempfile.TemporaryFile",
        "tempfile.TemporaryFile"
      ],
      "fixtures": [],
      "assertions": [
        "assert expected in str(exc_info.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_invalid_attr",
      "module": "test_importer",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/importer/test_importer.py",
      "line_number": 20,
      "end_line_number": 24,
      "source_code": "def test_invalid_attr() -> None:\n    with pytest.raises(ImportFromStringError) as exc_info:\n        import_from_string(\"tempfile:attr_does_not_exist\")\n    expected = 'Attribute \"attr_does_not_exist\" not found in module \"tempfile\".'\n    assert expected in str(exc_info.value)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "uvicorn.importer.ImportFromStringError",
        "uvicorn.importer.import_from_string",
        "tempfile.TemporaryFile",
        "tempfile.TemporaryFile"
      ],
      "fixtures": [],
      "assertions": [
        "assert expected in str(exc_info.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_internal_import_error",
      "module": "test_importer",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/importer/test_importer.py",
      "line_number": 27,
      "end_line_number": 29,
      "source_code": "def test_internal_import_error() -> None:\n    with pytest.raises(ImportError):\n        import_from_string(\"tests.importer.raise_import_error:myattr\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "uvicorn.importer.ImportFromStringError",
        "uvicorn.importer.import_from_string",
        "tempfile.TemporaryFile",
        "tempfile.TemporaryFile"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_valid_import",
      "module": "test_importer",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/importer/test_importer.py",
      "line_number": 32,
      "end_line_number": 36,
      "source_code": "def test_valid_import() -> None:\n    instance = import_from_string(\"tempfile:TemporaryFile\")\n    from tempfile import TemporaryFile\n\n    assert instance == TemporaryFile",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "uvicorn.importer.ImportFromStringError",
        "uvicorn.importer.import_from_string",
        "tempfile.TemporaryFile",
        "tempfile.TemporaryFile"
      ],
      "fixtures": [],
      "assertions": [
        "assert instance == TemporaryFile"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_no_import_needed",
      "module": "test_importer",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/importer/test_importer.py",
      "line_number": 39,
      "end_line_number": 43,
      "source_code": "def test_no_import_needed() -> None:\n    from tempfile import TemporaryFile\n\n    instance = import_from_string(TemporaryFile)\n    assert instance == TemporaryFile",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "uvicorn.importer.ImportFromStringError",
        "uvicorn.importer.import_from_string",
        "tempfile.TemporaryFile",
        "tempfile.TemporaryFile"
      ],
      "fixtures": [],
      "assertions": [
        "assert instance == TemporaryFile"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_circular_import_error",
      "module": "test_importer",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/importer/test_importer.py",
      "line_number": 46,
      "end_line_number": 53,
      "source_code": "def test_circular_import_error() -> None:\n    with pytest.raises(ImportError) as exc_info:\n        import_from_string(\"tests.importer.circular_import_a:bar\")\n    expected = (\n        \"cannot import name 'bar' from partially initialized module \"\n        \"'tests.importer.circular_import_a' (most likely due to a circular import)\"\n    )\n    assert expected in str(exc_info.value)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "uvicorn.importer.ImportFromStringError",
        "uvicorn.importer.import_from_string",
        "tempfile.TemporaryFile",
        "tempfile.TemporaryFile"
      ],
      "fixtures": [],
      "assertions": [
        "assert expected in str(exc_info.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    }
  ]
}