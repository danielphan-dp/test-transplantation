{
    "tests": [
        {
            "repo_name": "fastapi",
            "name": "test_dummy_webhook",
            "module": "test_webhooks_security",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_webhooks_security.py",
            "line_number": 33,
            "end_line_number": 35,
            "source_code": "def test_dummy_webhook():\n    # Just for coverage\n    new_subscription(body={}, token=\"Bearer 123\")",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "datetime.datetime",
                "fastapi.FastAPI",
                "fastapi.Security",
                "fastapi.security.HTTPBearer",
                "fastapi.testclient.TestClient",
                "pydantic.BaseModel",
                "typing_extensions.Annotated"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "new_subscription",
                    "body": "@app.webhooks.post('new-subscription')\ndef new_subscription(body: Subscription, token: Annotated[str, Security(bearer_scheme)]):\n    \"\"\"\n    When a new user subscribes to your service we'll send you a POST request with this\n    data to the URL that you register for the event `new-subscription` in the dashboard.\n    \"\"\"",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `new_subscription` method is designed to handle incoming POST requests when a new user subscribes to a service. It processes the subscription data sent in the request body, which includes the user's username, monthly fee, and subscription start date.\n\n**How It Works**:\nThe method is decorated with `@app.webhooks.post('new-subscription')`, indicating that it listens for POST requests at the specified endpoint. It accepts two parameters: `body`, which is expected to be an instance of the `Subscription` model (validated against the defined schema), and `token`, which is a security token for authentication. When a new subscription event occurs, the service sends a POST request to this endpoint with the relevant subscription data, allowing the application to handle the subscription logic accordingly."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_custom_enum_encoders",
            "module": "test_jsonable_encoder",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_jsonable_encoder.py",
            "line_number": 224,
            "end_line_number": 236,
            "source_code": "def test_custom_enum_encoders():\n    def custom_enum_encoder(v: Enum):\n        return v.value.lower()\n\n    class MyEnum(Enum):\n        ENUM_VAL_1 = \"ENUM_VAL_1\"\n\n    instance = MyEnum.ENUM_VAL_1\n\n    encoded_instance = jsonable_encoder(\n        instance, custom_encoder={MyEnum: custom_enum_encoder}\n    )\n    assert encoded_instance == custom_enum_encoder(instance)",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "collections.deque",
                "dataclasses.dataclass",
                "datetime.datetime",
                "datetime.timezone",
                "decimal.Decimal",
                "enum.Enum",
                "pathlib.PurePath",
                "pathlib.PurePosixPath",
                "pathlib.PureWindowsPath",
                "typing.Optional",
                "pytest",
                "fastapi._compat.PYDANTIC_V2",
                "fastapi._compat.Undefined",
                "fastapi.encoders.jsonable_encoder",
                "pydantic.BaseModel",
                "pydantic.Field",
                "pydantic.ValidationError",
                "utils.needs_pydanticv1",
                "utils.needs_pydanticv2",
                "pydantic.field_serializer"
            ],
            "fixtures": [],
            "assertions": [
                "assert encoded_instance == custom_enum_encoder(instance)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "custom_enum_encoder",
                    "body": "def custom_enum_encoder(v: Enum):\n    return v.value.lower()",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `custom_enum_encoder` method is designed to convert an instance of an `Enum` into a string representation by returning the lowercase value of the enum member.\n\n**How It Works**:  \nThe method takes a single argument `v`, which is expected to be an instance of an `Enum`. It accesses the `value` attribute of the enum member and applies the `lower()` method to convert it to lowercase. This is particularly useful when encoding enum values for JSON serialization, ensuring a consistent and standardized string format. The method can be used as a custom encoder in functions like `jsonable_encoder`, allowing for tailored serialization of enum types."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_call_api",
            "module": "test_schema_extra_examples",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_schema_extra_examples.py",
            "line_number": 223,
            "end_line_number": 257,
            "source_code": "def test_call_api():\n    app = create_app()\n    client = TestClient(app)\n    response = client.post(\"/schema_extra/\", json={\"data\": \"Foo\"})\n    assert response.status_code == 200, response.text\n    response = client.post(\"/example/\", json={\"data\": \"Foo\"})\n    assert response.status_code == 200, response.text\n    response = client.post(\"/examples/\", json={\"data\": \"Foo\"})\n    assert response.status_code == 200, response.text\n    response = client.post(\"/example_examples/\", json={\"data\": \"Foo\"})\n    assert response.status_code == 200, response.text\n    response = client.get(\"/path_example/foo\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/path_examples/foo\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/path_example_examples/foo\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/query_example/\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/query_examples/\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/query_example_examples/\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/header_example/\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/header_examples/\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/header_example_examples/\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/cookie_example/\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/cookie_examples/\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/cookie_example_examples/\")\n    assert response.status_code == 200, response.text",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "typing.Union",
                "pytest",
                "dirty_equals.IsDict",
                "fastapi.Body",
                "fastapi.Cookie",
                "fastapi.FastAPI",
                "fastapi.Header",
                "fastapi.Path",
                "fastapi.Query",
                "fastapi._compat.PYDANTIC_V2",
                "fastapi.testclient.TestClient",
                "pydantic.BaseModel",
                "pydantic.ConfigDict"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 200, response.text",
                "assert response.status_code == 200, response.text",
                "assert response.status_code == 200, response.text",
                "assert response.status_code == 200, response.text",
                "assert response.status_code == 200, response.text",
                "assert response.status_code == 200, response.text",
                "assert response.status_code == 200, response.text",
                "assert response.status_code == 200, response.text",
                "assert response.status_code == 200, response.text",
                "assert response.status_code == 200, response.text",
                "assert response.status_code == 200, response.text",
                "assert response.status_code == 200, response.text",
                "assert response.status_code == 200, response.text",
                "assert response.status_code == 200, response.text",
                "assert response.status_code == 200, response.text",
                "assert response.status_code == 200, response.text"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "create_app",
                    "body": "def create_app():\n    app = FastAPI()\n\n    class Item(BaseModel):\n        data: str\n        if PYDANTIC_V2:\n            model_config = ConfigDict(json_schema_extra={'example': {'data': 'Data in schema_extra'}})\n        else:\n\n            class Config:\n                schema_extra = {'example': {'data': 'Data in schema_extra'}}\n\n    @app.post('/schema_extra/')\n    def schema_extra(item: Item):\n        return item\n    with pytest.warns(DeprecationWarning):\n\n        @app.post('/example/')\n        def example(item: Item=Body(example={'data': 'Data in Body example'})):\n            return item\n\n    @app.post('/examples/')\n    def examples(item: Item=Body(examples=[{'data': 'Data in Body examples, example1'}, {'data': 'Data in Body examples, example2'}])):\n        return item\n    with pytest.warns(DeprecationWarning):\n\n        @app.post('/example_examples/')\n        def example_examples(item: Item=Body(example={'data': 'Overridden example'}, examples=[{'data': 'examples example_examples 1'}, {'data': 'examples example_examples 2'}])):\n            return item\n    with pytest.warns(DeprecationWarning):\n\n        @app.get('/path_example/{item_id}')\n        def path_example(item_id: str=Path(example='item_1')):\n            return item_id\n\n    @app.get('/path_examples/{item_id}')\n    def path_examples(item_id: str=Path(examples=['item_1', 'item_2'])):\n        return item_id\n    with pytest.warns(DeprecationWarning):\n\n        @app.get('/path_example_examples/{item_id}')\n        def path_example_examples(item_id: str=Path(example='item_overridden', examples=['item_1', 'item_2'])):\n            return item_id\n    with pytest.warns(DeprecationWarning):\n\n        @app.get('/query_example/')\n        def query_example(data: Union[str, None]=Query(default=None, example='query1')):\n            return data\n\n    @app.get('/query_examples/')\n    def query_examples(data: Union[str, None]=Query(default=None, examples=['query1', 'query2'])):\n        return data\n    with pytest.warns(DeprecationWarning):\n\n        @app.get('/query_example_examples/')\n        def query_example_examples(data: Union[str, None]=Query(default=None, example='query_overridden', examples=['query1', 'query2'])):\n            return data\n    with pytest.warns(DeprecationWarning):\n\n        @app.get('/header_example/')\n        def header_example(data: Union[str, None]=Header(default=None, example='header1')):\n            return data\n\n    @app.get('/header_examples/')\n    def header_examples(data: Union[str, None]=Header(default=None, examples=['header1', 'header2'])):\n        return data\n    with pytest.warns(DeprecationWarning):\n\n        @app.get('/header_example_examples/')\n        def header_example_examples(data: Union[str, None]=Header(default=None, example='header_overridden', examples=['header1', 'header2'])):\n            return data\n    with pytest.warns(DeprecationWarning):\n\n        @app.get('/cookie_example/')\n        def cookie_example(data: Union[str, None]=Cookie(default=None, example='cookie1')):\n            return data\n\n    @app.get('/cookie_examples/')\n    def cookie_examples(data: Union[str, None]=Cookie(default=None, examples=['cookie1', 'cookie2'])):\n        return data\n    with pytest.warns(DeprecationWarning):\n\n        @app.get('/cookie_example_examples/')\n        def cookie_example_examples(data: Union[str, None]=Cookie(default=None, example='cookie_overridden', examples=['cookie1', 'cookie2'])):\n            return data\n    return app",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `create_app` method is designed to initialize a FastAPI application, define data models using Pydantic, and set up various API endpoints that demonstrate the use of request and response examples, including handling of different types of input (body, path, query, header, and cookie).\n\n**How It Works**:\n1. **FastAPI Initialization**: The method starts by creating an instance of the FastAPI application.\n2. **Data Model Definition**: It defines a Pydantic model `Item` with a `data` field, and configures it to include example data for JSON schema generation, depending on whether Pydantic v2 is used.\n3. **Endpoint Creation**: Several POST and GET endpoints are defined:\n   - `/schema_extra/`: Accepts an `Item` and returns it.\n   - `/example/`, `/examples/`, and similar endpoints: Demonstrate how to provide examples in request bodies, path parameters, query parameters, headers, and cookies, while also issuing deprecation warnings for certain patterns.\n4. **Deprecation Warnings**: The use of `pytest.warns(DeprecationWarning)` indicates that some of the patterns used in the endpoints are deprecated, signaling to developers that they should consider alternative approaches in future implementations.\n5. **Return the App**: Finally, the method returns the configured FastAPI application instance, ready to handle incoming requests. \n\nThis structure allows developers to see practical examples of how to use FastAPI with Pydantic for data validation and API documentation."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_openapi_schema",
            "module": "test_schema_extra_examples",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_schema_extra_examples.py",
            "line_number": 260,
            "end_line_number": 966,
            "source_code": "def test_openapi_schema():\n    \"\"\"\n    Test that example overrides work:\n\n    * pydantic model schema_extra is included\n    * Body(example={}) overrides schema_extra in pydantic model\n    * Body(examples{}) overrides Body(example={}) and schema_extra in pydantic model\n    \"\"\"\n    app = create_app()\n    client = TestClient(app)\n    response = client.get(\"/openapi.json\")\n    assert response.status_code == 200, response.text\n    assert response.json() == {\n        \"openapi\": \"3.1.0\",\n        \"info\": {\"title\": \"FastAPI\", \"version\": \"0.1.0\"},\n        \"paths\": {\n            \"/schema_extra/\": {\n                \"post\": {\n                    \"summary\": \"Schema Extra\",\n                    \"operationId\": \"schema_extra_schema_extra__post\",\n                    \"requestBody\": {\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\"$ref\": \"#/components/schemas/Item\"}\n                            }\n                        },\n                        \"required\": True,\n                    },\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            },\n            \"/example/\": {\n                \"post\": {\n                    \"summary\": \"Example\",\n                    \"operationId\": \"example_example__post\",\n                    \"requestBody\": {\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\"$ref\": \"#/components/schemas/Item\"},\n                                \"example\": {\"data\": \"Data in Body example\"},\n                            }\n                        },\n                        \"required\": True,\n                    },\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            },\n            \"/examples/\": {\n                \"post\": {\n                    \"summary\": \"Examples\",\n                    \"operationId\": \"examples_examples__post\",\n                    \"requestBody\": {\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": IsDict(\n                                    {\n                                        \"$ref\": \"#/components/schemas/Item\",\n                                        \"examples\": [\n                                            {\"data\": \"Data in Body examples, example1\"},\n                                            {\"data\": \"Data in Body examples, example2\"},\n                                        ],\n                                    }\n                                )\n                                | IsDict(\n                                    # TODO: remove this when deprecating Pydantic v1\n                                    {\n                                        \"allOf\": [\n                                            {\"$ref\": \"#/components/schemas/Item\"}\n                                        ],\n                                        \"title\": \"Item\",\n                                        \"examples\": [\n                                            {\"data\": \"Data in Body examples, example1\"},\n                                            {\"data\": \"Data in Body examples, example2\"},\n                                        ],\n                                    }\n                                )\n                            }\n                        },\n                        \"required\": True,\n                    },\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            },\n            \"/example_examples/\": {\n                \"post\": {\n                    \"summary\": \"Example Examples\",\n                    \"operationId\": \"example_examples_example_examples__post\",\n                    \"requestBody\": {\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": IsDict(\n                                    {\n                                        \"$ref\": \"#/components/schemas/Item\",\n                                        \"examples\": [\n                                            {\"data\": \"examples example_examples 1\"},\n                                            {\"data\": \"examples example_examples 2\"},\n                                        ],\n                                    }\n                                )\n                                | IsDict(\n                                    # TODO: remove this when deprecating Pydantic v1\n                                    {\n                                        \"allOf\": [\n                                            {\"$ref\": \"#/components/schemas/Item\"}\n                                        ],\n                                        \"title\": \"Item\",\n                                        \"examples\": [\n                                            {\"data\": \"examples example_examples 1\"},\n                                            {\"data\": \"examples example_examples 2\"},\n                                        ],\n                                    },\n                                ),\n                                \"example\": {\"data\": \"Overridden example\"},\n                            }\n                        },\n                        \"required\": True,\n                    },\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            },\n            \"/path_example/{item_id}\": {\n                \"get\": {\n                    \"summary\": \"Path Example\",\n                    \"operationId\": \"path_example_path_example__item_id__get\",\n                    \"parameters\": [\n                        {\n                            \"required\": True,\n                            \"schema\": {\"title\": \"Item Id\", \"type\": \"string\"},\n                            \"example\": \"item_1\",\n                            \"name\": \"item_id\",\n                            \"in\": \"path\",\n                        }\n                    ],\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            },\n            \"/path_examples/{item_id}\": {\n                \"get\": {\n                    \"summary\": \"Path Examples\",\n                    \"operationId\": \"path_examples_path_examples__item_id__get\",\n                    \"parameters\": [\n                        {\n                            \"required\": True,\n                            \"schema\": {\n                                \"title\": \"Item Id\",\n                                \"type\": \"string\",\n                                \"examples\": [\"item_1\", \"item_2\"],\n                            },\n                            \"name\": \"item_id\",\n                            \"in\": \"path\",\n                        }\n                    ],\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            },\n            \"/path_example_examples/{item_id}\": {\n                \"get\": {\n                    \"summary\": \"Path Example Examples\",\n                    \"operationId\": \"path_example_examples_path_example_examples__item_id__get\",\n                    \"parameters\": [\n                        {\n                            \"required\": True,\n                            \"schema\": {\n                                \"title\": \"Item Id\",\n                                \"type\": \"string\",\n                                \"examples\": [\"item_1\", \"item_2\"],\n                            },\n                            \"example\": \"item_overridden\",\n                            \"name\": \"item_id\",\n                            \"in\": \"path\",\n                        }\n                    ],\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            },\n            \"/query_example/\": {\n                \"get\": {\n                    \"summary\": \"Query Example\",\n                    \"operationId\": \"query_example_query_example__get\",\n                    \"parameters\": [\n                        {\n                            \"required\": False,\n                            \"schema\": IsDict(\n                                {\n                                    \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n                                    \"title\": \"Data\",\n                                }\n                            )\n                            | IsDict(\n                                # TODO: Remove this when deprecating Pydantic v1\n                                {\"title\": \"Data\", \"type\": \"string\"}\n                            ),\n                            \"example\": \"query1\",\n                            \"name\": \"data\",\n                            \"in\": \"query\",\n                        }\n                    ],\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            },\n            \"/query_examples/\": {\n                \"get\": {\n                    \"summary\": \"Query Examples\",\n                    \"operationId\": \"query_examples_query_examples__get\",\n                    \"parameters\": [\n                        {\n                            \"required\": False,\n                            \"schema\": IsDict(\n                                {\n                                    \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n                                    \"title\": \"Data\",\n                                    \"examples\": [\"query1\", \"query2\"],\n                                }\n                            )\n                            | IsDict(\n                                # TODO: Remove this when deprecating Pydantic v1\n                                {\n                                    \"type\": \"string\",\n                                    \"title\": \"Data\",\n                                    \"examples\": [\"query1\", \"query2\"],\n                                }\n                            ),\n                            \"name\": \"data\",\n                            \"in\": \"query\",\n                        }\n                    ],\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            },\n            \"/query_example_examples/\": {\n                \"get\": {\n                    \"summary\": \"Query Example Examples\",\n                    \"operationId\": \"query_example_examples_query_example_examples__get\",\n                    \"parameters\": [\n                        {\n                            \"required\": False,\n                            \"schema\": IsDict(\n                                {\n                                    \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n                                    \"title\": \"Data\",\n                                    \"examples\": [\"query1\", \"query2\"],\n                                }\n                            )\n                            | IsDict(\n                                # TODO: Remove this when deprecating Pydantic v1\n                                {\n                                    \"type\": \"string\",\n                                    \"title\": \"Data\",\n                                    \"examples\": [\"query1\", \"query2\"],\n                                }\n                            ),\n                            \"example\": \"query_overridden\",\n                            \"name\": \"data\",\n                            \"in\": \"query\",\n                        }\n                    ],\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            },\n            \"/header_example/\": {\n                \"get\": {\n                    \"summary\": \"Header Example\",\n                    \"operationId\": \"header_example_header_example__get\",\n                    \"parameters\": [\n                        {\n                            \"required\": False,\n                            \"schema\": IsDict(\n                                {\n                                    \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n                                    \"title\": \"Data\",\n                                }\n                            )\n                            | IsDict(\n                                # TODO: Remove this when deprecating Pydantic v1\n                                {\"title\": \"Data\", \"type\": \"string\"}\n                            ),\n                            \"example\": \"header1\",\n                            \"name\": \"data\",\n                            \"in\": \"header\",\n                        }\n                    ],\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            },\n            \"/header_examples/\": {\n                \"get\": {\n                    \"summary\": \"Header Examples\",\n                    \"operationId\": \"header_examples_header_examples__get\",\n                    \"parameters\": [\n                        {\n                            \"required\": False,\n                            \"schema\": IsDict(\n                                {\n                                    \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n                                    \"title\": \"Data\",\n                                    \"examples\": [\"header1\", \"header2\"],\n                                }\n                            )\n                            | IsDict(\n                                # TODO: Remove this when deprecating Pydantic v1\n                                {\n                                    \"type\": \"string\",\n                                    \"title\": \"Data\",\n                                    \"examples\": [\"header1\", \"header2\"],\n                                }\n                            ),\n                            \"name\": \"data\",\n                            \"in\": \"header\",\n                        }\n                    ],\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            },\n            \"/header_example_examples/\": {\n                \"get\": {\n                    \"summary\": \"Header Example Examples\",\n                    \"operationId\": \"header_example_examples_header_example_examples__get\",\n                    \"parameters\": [\n                        {\n                            \"required\": False,\n                            \"schema\": IsDict(\n                                {\n                                    \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n                                    \"title\": \"Data\",\n                                    \"examples\": [\"header1\", \"header2\"],\n                                }\n                            )\n                            | IsDict(\n                                # TODO: Remove this when deprecating Pydantic v1\n                                {\n                                    \"title\": \"Data\",\n                                    \"type\": \"string\",\n                                    \"examples\": [\"header1\", \"header2\"],\n                                }\n                            ),\n                            \"example\": \"header_overridden\",\n                            \"name\": \"data\",\n                            \"in\": \"header\",\n                        }\n                    ],\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            },\n            \"/cookie_example/\": {\n                \"get\": {\n                    \"summary\": \"Cookie Example\",\n                    \"operationId\": \"cookie_example_cookie_example__get\",\n                    \"parameters\": [\n                        {\n                            \"required\": False,\n                            \"schema\": IsDict(\n                                {\n                                    \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n                                    \"title\": \"Data\",\n                                }\n                            )\n                            | IsDict(\n                                # TODO: Remove this when deprecating Pydantic v1\n                                {\"title\": \"Data\", \"type\": \"string\"}\n                            ),\n                            \"example\": \"cookie1\",\n                            \"name\": \"data\",\n                            \"in\": \"cookie\",\n                        }\n                    ],\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            },\n            \"/cookie_examples/\": {\n                \"get\": {\n                    \"summary\": \"Cookie Examples\",\n                    \"operationId\": \"cookie_examples_cookie_examples__get\",\n                    \"parameters\": [\n                        {\n                            \"required\": False,\n                            \"schema\": IsDict(\n                                {\n                                    \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n                                    \"title\": \"Data\",\n                                    \"examples\": [\"cookie1\", \"cookie2\"],\n                                }\n                            )\n                            | IsDict(\n                                # TODO: Remove this when deprecating Pydantic v1\n                                {\n                                    \"title\": \"Data\",\n                                    \"type\": \"string\",\n                                    \"examples\": [\"cookie1\", \"cookie2\"],\n                                }\n                            ),\n                            \"name\": \"data\",\n                            \"in\": \"cookie\",\n                        }\n                    ],\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            },\n            \"/cookie_example_examples/\": {\n                \"get\": {\n                    \"summary\": \"Cookie Example Examples\",\n                    \"operationId\": \"cookie_example_examples_cookie_example_examples__get\",\n                    \"parameters\": [\n                        {\n                            \"required\": False,\n                            \"schema\": IsDict(\n                                {\n                                    \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n                                    \"title\": \"Data\",\n                                    \"examples\": [\"cookie1\", \"cookie2\"],\n                                }\n                            )\n                            | IsDict(\n                                # TODO: Remove this when deprecating Pydantic v1\n                                {\n                                    \"title\": \"Data\",\n                                    \"type\": \"string\",\n                                    \"examples\": [\"cookie1\", \"cookie2\"],\n                                }\n                            ),\n                            \"example\": \"cookie_overridden\",\n                            \"name\": \"data\",\n                            \"in\": \"cookie\",\n                        }\n                    ],\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            },\n        },\n        \"components\": {\n            \"schemas\": {\n                \"HTTPValidationError\": {\n                    \"title\": \"HTTPValidationError\",\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"detail\": {\n                            \"title\": \"Detail\",\n                            \"type\": \"array\",\n                            \"items\": {\"$ref\": \"#/components/schemas/ValidationError\"},\n                        }\n                    },\n                },\n                \"Item\": {\n                    \"title\": \"Item\",\n                    \"required\": [\"data\"],\n                    \"type\": \"object\",\n                    \"properties\": {\"data\": {\"title\": \"Data\", \"type\": \"string\"}},\n                    \"example\": {\"data\": \"Data in schema_extra\"},\n                },\n                \"ValidationError\": {\n                    \"title\": \"ValidationError\",\n                    \"required\": [\"loc\", \"msg\", \"type\"],\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"loc\": {\n                            \"title\": \"Location\",\n                            \"type\": \"array\",\n                            \"items\": {\n                                \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"integer\"}]\n                            },\n                        },\n                        \"msg\": {\"title\": \"Message\", \"type\": \"string\"},\n                        \"type\": {\"title\": \"Error Type\", \"type\": \"string\"},\n                    },\n                },\n            }\n        },\n    }",
            "docstring": "Test that example overrides work:\n\n* pydantic model schema_extra is included\n* Body(example={}) overrides schema_extra in pydantic model\n* Body(examples{}) overrides Body(example={}) and schema_extra in pydantic model",
            "decorators": [],
            "arguments": [],
            "imports": [
                "typing.Union",
                "pytest",
                "dirty_equals.IsDict",
                "fastapi.Body",
                "fastapi.Cookie",
                "fastapi.FastAPI",
                "fastapi.Header",
                "fastapi.Path",
                "fastapi.Query",
                "fastapi._compat.PYDANTIC_V2",
                "fastapi.testclient.TestClient",
                "pydantic.BaseModel",
                "pydantic.ConfigDict"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 200, response.text",
                "assert response.json() == {'openapi': '3.1.0', 'info': {'title': 'FastAPI', 'version': '0.1.0'}, 'paths': {'/schema_extra/': {'post': {'summary': 'Schema Extra', 'operationId': 'schema_extra_schema_extra__post', 'requestBody': {'content': {'application/json': {'schema': {'$ref': '#/components/schemas/Item'}}}, 'required': True}, 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}, '/example/': {'post': {'summary': 'Example', 'operationId': 'example_example__post', 'requestBody': {'content': {'application/json': {'schema': {'$ref': '#/components/schemas/Item'}, 'example': {'data': 'Data in Body example'}}}, 'required': True}, 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}, '/examples/': {'post': {'summary': 'Examples', 'operationId': 'examples_examples__post', 'requestBody': {'content': {'application/json': {'schema': IsDict({'$ref': '#/components/schemas/Item', 'examples': [{'data': 'Data in Body examples, example1'}, {'data': 'Data in Body examples, example2'}]}) | IsDict({'allOf': [{'$ref': '#/components/schemas/Item'}], 'title': 'Item', 'examples': [{'data': 'Data in Body examples, example1'}, {'data': 'Data in Body examples, example2'}]})}}, 'required': True}, 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}, '/example_examples/': {'post': {'summary': 'Example Examples', 'operationId': 'example_examples_example_examples__post', 'requestBody': {'content': {'application/json': {'schema': IsDict({'$ref': '#/components/schemas/Item', 'examples': [{'data': 'examples example_examples 1'}, {'data': 'examples example_examples 2'}]}) | IsDict({'allOf': [{'$ref': '#/components/schemas/Item'}], 'title': 'Item', 'examples': [{'data': 'examples example_examples 1'}, {'data': 'examples example_examples 2'}]}), 'example': {'data': 'Overridden example'}}}, 'required': True}, 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}, '/path_example/{item_id}': {'get': {'summary': 'Path Example', 'operationId': 'path_example_path_example__item_id__get', 'parameters': [{'required': True, 'schema': {'title': 'Item Id', 'type': 'string'}, 'example': 'item_1', 'name': 'item_id', 'in': 'path'}], 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}, '/path_examples/{item_id}': {'get': {'summary': 'Path Examples', 'operationId': 'path_examples_path_examples__item_id__get', 'parameters': [{'required': True, 'schema': {'title': 'Item Id', 'type': 'string', 'examples': ['item_1', 'item_2']}, 'name': 'item_id', 'in': 'path'}], 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}, '/path_example_examples/{item_id}': {'get': {'summary': 'Path Example Examples', 'operationId': 'path_example_examples_path_example_examples__item_id__get', 'parameters': [{'required': True, 'schema': {'title': 'Item Id', 'type': 'string', 'examples': ['item_1', 'item_2']}, 'example': 'item_overridden', 'name': 'item_id', 'in': 'path'}], 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}, '/query_example/': {'get': {'summary': 'Query Example', 'operationId': 'query_example_query_example__get', 'parameters': [{'required': False, 'schema': IsDict({'anyOf': [{'type': 'string'}, {'type': 'null'}], 'title': 'Data'}) | IsDict({'title': 'Data', 'type': 'string'}), 'example': 'query1', 'name': 'data', 'in': 'query'}], 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}, '/query_examples/': {'get': {'summary': 'Query Examples', 'operationId': 'query_examples_query_examples__get', 'parameters': [{'required': False, 'schema': IsDict({'anyOf': [{'type': 'string'}, {'type': 'null'}], 'title': 'Data', 'examples': ['query1', 'query2']}) | IsDict({'type': 'string', 'title': 'Data', 'examples': ['query1', 'query2']}), 'name': 'data', 'in': 'query'}], 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}, '/query_example_examples/': {'get': {'summary': 'Query Example Examples', 'operationId': 'query_example_examples_query_example_examples__get', 'parameters': [{'required': False, 'schema': IsDict({'anyOf': [{'type': 'string'}, {'type': 'null'}], 'title': 'Data', 'examples': ['query1', 'query2']}) | IsDict({'type': 'string', 'title': 'Data', 'examples': ['query1', 'query2']}), 'example': 'query_overridden', 'name': 'data', 'in': 'query'}], 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}, '/header_example/': {'get': {'summary': 'Header Example', 'operationId': 'header_example_header_example__get', 'parameters': [{'required': False, 'schema': IsDict({'anyOf': [{'type': 'string'}, {'type': 'null'}], 'title': 'Data'}) | IsDict({'title': 'Data', 'type': 'string'}), 'example': 'header1', 'name': 'data', 'in': 'header'}], 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}, '/header_examples/': {'get': {'summary': 'Header Examples', 'operationId': 'header_examples_header_examples__get', 'parameters': [{'required': False, 'schema': IsDict({'anyOf': [{'type': 'string'}, {'type': 'null'}], 'title': 'Data', 'examples': ['header1', 'header2']}) | IsDict({'type': 'string', 'title': 'Data', 'examples': ['header1', 'header2']}), 'name': 'data', 'in': 'header'}], 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}, '/header_example_examples/': {'get': {'summary': 'Header Example Examples', 'operationId': 'header_example_examples_header_example_examples__get', 'parameters': [{'required': False, 'schema': IsDict({'anyOf': [{'type': 'string'}, {'type': 'null'}], 'title': 'Data', 'examples': ['header1', 'header2']}) | IsDict({'title': 'Data', 'type': 'string', 'examples': ['header1', 'header2']}), 'example': 'header_overridden', 'name': 'data', 'in': 'header'}], 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}, '/cookie_example/': {'get': {'summary': 'Cookie Example', 'operationId': 'cookie_example_cookie_example__get', 'parameters': [{'required': False, 'schema': IsDict({'anyOf': [{'type': 'string'}, {'type': 'null'}], 'title': 'Data'}) | IsDict({'title': 'Data', 'type': 'string'}), 'example': 'cookie1', 'name': 'data', 'in': 'cookie'}], 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}, '/cookie_examples/': {'get': {'summary': 'Cookie Examples', 'operationId': 'cookie_examples_cookie_examples__get', 'parameters': [{'required': False, 'schema': IsDict({'anyOf': [{'type': 'string'}, {'type': 'null'}], 'title': 'Data', 'examples': ['cookie1', 'cookie2']}) | IsDict({'title': 'Data', 'type': 'string', 'examples': ['cookie1', 'cookie2']}), 'name': 'data', 'in': 'cookie'}], 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}, '/cookie_example_examples/': {'get': {'summary': 'Cookie Example Examples', 'operationId': 'cookie_example_examples_cookie_example_examples__get', 'parameters': [{'required': False, 'schema': IsDict({'anyOf': [{'type': 'string'}, {'type': 'null'}], 'title': 'Data', 'examples': ['cookie1', 'cookie2']}) | IsDict({'title': 'Data', 'type': 'string', 'examples': ['cookie1', 'cookie2']}), 'example': 'cookie_overridden', 'name': 'data', 'in': 'cookie'}], 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}}, 'components': {'schemas': {'HTTPValidationError': {'title': 'HTTPValidationError', 'type': 'object', 'properties': {'detail': {'title': 'Detail', 'type': 'array', 'items': {'$ref': '#/components/schemas/ValidationError'}}}}, 'Item': {'title': 'Item', 'required': ['data'], 'type': 'object', 'properties': {'data': {'title': 'Data', 'type': 'string'}}, 'example': {'data': 'Data in schema_extra'}}, 'ValidationError': {'title': 'ValidationError', 'required': ['loc', 'msg', 'type'], 'type': 'object', 'properties': {'loc': {'title': 'Location', 'type': 'array', 'items': {'anyOf': [{'type': 'string'}, {'type': 'integer'}]}}, 'msg': {'title': 'Message', 'type': 'string'}, 'type': {'title': 'Error Type', 'type': 'string'}}}}}}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "create_app",
                    "body": "def create_app():\n    app = FastAPI()\n\n    class Item(BaseModel):\n        data: str\n        if PYDANTIC_V2:\n            model_config = ConfigDict(json_schema_extra={'example': {'data': 'Data in schema_extra'}})\n        else:\n\n            class Config:\n                schema_extra = {'example': {'data': 'Data in schema_extra'}}\n\n    @app.post('/schema_extra/')\n    def schema_extra(item: Item):\n        return item\n    with pytest.warns(DeprecationWarning):\n\n        @app.post('/example/')\n        def example(item: Item=Body(example={'data': 'Data in Body example'})):\n            return item\n\n    @app.post('/examples/')\n    def examples(item: Item=Body(examples=[{'data': 'Data in Body examples, example1'}, {'data': 'Data in Body examples, example2'}])):\n        return item\n    with pytest.warns(DeprecationWarning):\n\n        @app.post('/example_examples/')\n        def example_examples(item: Item=Body(example={'data': 'Overridden example'}, examples=[{'data': 'examples example_examples 1'}, {'data': 'examples example_examples 2'}])):\n            return item\n    with pytest.warns(DeprecationWarning):\n\n        @app.get('/path_example/{item_id}')\n        def path_example(item_id: str=Path(example='item_1')):\n            return item_id\n\n    @app.get('/path_examples/{item_id}')\n    def path_examples(item_id: str=Path(examples=['item_1', 'item_2'])):\n        return item_id\n    with pytest.warns(DeprecationWarning):\n\n        @app.get('/path_example_examples/{item_id}')\n        def path_example_examples(item_id: str=Path(example='item_overridden', examples=['item_1', 'item_2'])):\n            return item_id\n    with pytest.warns(DeprecationWarning):\n\n        @app.get('/query_example/')\n        def query_example(data: Union[str, None]=Query(default=None, example='query1')):\n            return data\n\n    @app.get('/query_examples/')\n    def query_examples(data: Union[str, None]=Query(default=None, examples=['query1', 'query2'])):\n        return data\n    with pytest.warns(DeprecationWarning):\n\n        @app.get('/query_example_examples/')\n        def query_example_examples(data: Union[str, None]=Query(default=None, example='query_overridden', examples=['query1', 'query2'])):\n            return data\n    with pytest.warns(DeprecationWarning):\n\n        @app.get('/header_example/')\n        def header_example(data: Union[str, None]=Header(default=None, example='header1')):\n            return data\n\n    @app.get('/header_examples/')\n    def header_examples(data: Union[str, None]=Header(default=None, examples=['header1', 'header2'])):\n        return data\n    with pytest.warns(DeprecationWarning):\n\n        @app.get('/header_example_examples/')\n        def header_example_examples(data: Union[str, None]=Header(default=None, example='header_overridden', examples=['header1', 'header2'])):\n            return data\n    with pytest.warns(DeprecationWarning):\n\n        @app.get('/cookie_example/')\n        def cookie_example(data: Union[str, None]=Cookie(default=None, example='cookie1')):\n            return data\n\n    @app.get('/cookie_examples/')\n    def cookie_examples(data: Union[str, None]=Cookie(default=None, examples=['cookie1', 'cookie2'])):\n        return data\n    with pytest.warns(DeprecationWarning):\n\n        @app.get('/cookie_example_examples/')\n        def cookie_example_examples(data: Union[str, None]=Cookie(default=None, example='cookie_overridden', examples=['cookie1', 'cookie2'])):\n            return data\n    return app",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `create_app` method is designed to instantiate a FastAPI application, define a Pydantic model for data validation, and set up various API endpoints that demonstrate the use of examples and schemas in request and response bodies, query parameters, headers, and cookies.\n\n**How It Works**:\n1. **FastAPI Initialization**: The method starts by creating an instance of the FastAPI application.\n2. **Pydantic Model Definition**: A class `Item` is defined using Pydantic's `BaseModel`, which includes a string field `data`. Depending on the version of Pydantic (V2 or not), it configures JSON schema examples differently.\n3. **API Endpoints**: Several POST and GET endpoints are defined:\n   - `/schema_extra/`: Accepts an `Item` and returns it.\n   - `/example/`, `/examples/`, `/example_examples/`: Demonstrate how to use examples in request bodies.\n   - `/path_example/{item_id}`, `/path_examples/{item_id}`, etc.: Show how to use examples in path parameters.\n   - `/query_example/`, `/query_examples/`: Illustrate examples in query parameters.\n   - `/header_example/`, `/header_examples/`: Demonstrate examples in headers.\n   - `/cookie_example/`, `/cookie_examples/`: Show examples in cookies.\n4. **Deprecation Warnings**: The method uses `pytest.warns` to indicate that certain features are deprecated, signaling to developers that they should be cautious when using these endpoints.\n5. **Return Statement**: Finally, the method returns the configured FastAPI application instance, making it ready for use. \n\nThis structure allows developers to see practical examples of how to implement and document API endpoints effectively using FastAPI and Pydantic."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_depend_validation",
            "module": "test_ws_router",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_ws_router.py",
            "line_number": 210,
            "end_line_number": 233,
            "source_code": "def test_depend_validation():\n    \"\"\"\n    Verify that a validation in a dependency invokes the correct exception handler\n    \"\"\"\n    caught = []\n\n    @websocket_middleware\n    async def catcher(websocket, call_next):\n        try:\n            return await call_next()\n        except Exception as e:  # pragma: no cover\n            caught.append(e)\n            raise\n\n    myapp = make_app(middleware=[Middleware(catcher)])\n\n    client = TestClient(myapp)\n    with pytest.raises(WebSocketDisconnect) as e:\n        with client.websocket_connect(\"/depends-validate/\"):\n            pass  # pragma: no cover\n    # the validation error does produce a close message\n    assert e.value.code == status.WS_1008_POLICY_VIOLATION\n    # and no error is leaked\n    assert caught == []",
            "docstring": "Verify that a validation in a dependency invokes the correct exception handler",
            "decorators": [],
            "arguments": [],
            "imports": [
                "functools",
                "pytest",
                "fastapi.APIRouter",
                "fastapi.Depends",
                "fastapi.FastAPI",
                "fastapi.Header",
                "fastapi.WebSocket",
                "fastapi.WebSocketDisconnect",
                "fastapi.status",
                "fastapi.middleware.Middleware",
                "fastapi.testclient.TestClient"
            ],
            "fixtures": [],
            "assertions": [
                "assert e.value.code == status.WS_1008_POLICY_VIOLATION",
                "assert caught == []"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_app",
                    "body": "def make_app(app=None, **kwargs):\n    app = app or FastAPI(**kwargs)\n    app.include_router(router)\n    app.include_router(prefix_router, prefix='/prefix')\n    app.include_router(native_prefix_route)\n    return app",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_app` method is designed to create and configure a FastAPI application instance. It allows for optional customization through parameters and includes predefined routers for organizing application routes.\n\n**How It Works**:\n1. **Initialization**: The method accepts an optional `app` parameter. If `app` is not provided, it initializes a new FastAPI instance using any additional keyword arguments (`**kwargs`).\n2. **Router Inclusion**: It includes several routers into the FastAPI application:\n   - `router`: A default router.\n   - `prefix_router`: A router that is included with a specified URL prefix (`/prefix`).\n   - `native_prefix_route`: Another router that is included without a prefix.\n3. **Return Value**: Finally, the method returns the configured FastAPI application instance, which can then be used to handle incoming requests and define additional routes. \n\nThis method streamlines the setup of a FastAPI application by encapsulating common configuration steps."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_depend_err_middleware",
            "module": "test_ws_router",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_ws_router.py",
            "line_number": 236,
            "end_line_number": 254,
            "source_code": "def test_depend_err_middleware():\n    \"\"\"\n    Verify that it is possible to write custom WebSocket middleware to catch errors\n    \"\"\"\n\n    @websocket_middleware\n    async def errorhandler(websocket: WebSocket, call_next):\n        try:\n            return await call_next()\n        except Exception as e:\n            await websocket.close(code=status.WS_1006_ABNORMAL_CLOSURE, reason=repr(e))\n\n    myapp = make_app(middleware=[Middleware(errorhandler)])\n    client = TestClient(myapp)\n    with pytest.raises(WebSocketDisconnect) as e:\n        with client.websocket_connect(\"/depends-err/\"):\n            pass  # pragma: no cover\n    assert e.value.code == status.WS_1006_ABNORMAL_CLOSURE\n    assert \"NotImplementedError\" in e.value.reason",
            "docstring": "Verify that it is possible to write custom WebSocket middleware to catch errors",
            "decorators": [],
            "arguments": [],
            "imports": [
                "functools",
                "pytest",
                "fastapi.APIRouter",
                "fastapi.Depends",
                "fastapi.FastAPI",
                "fastapi.Header",
                "fastapi.WebSocket",
                "fastapi.WebSocketDisconnect",
                "fastapi.status",
                "fastapi.middleware.Middleware",
                "fastapi.testclient.TestClient"
            ],
            "fixtures": [],
            "assertions": [
                "assert e.value.code == status.WS_1006_ABNORMAL_CLOSURE",
                "assert 'NotImplementedError' in e.value.reason"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_app",
                    "body": "def make_app(app=None, **kwargs):\n    app = app or FastAPI(**kwargs)\n    app.include_router(router)\n    app.include_router(prefix_router, prefix='/prefix')\n    app.include_router(native_prefix_route)\n    return app",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_app` method is designed to create and configure a FastAPI application instance. It allows for optional customization through parameters and includes predefined routers for organizing application routes.\n\n**How It Works**:\n1. **Initialization**: The method accepts an optional `app` parameter. If `app` is not provided, it initializes a new FastAPI instance using any additional keyword arguments (`**kwargs`).\n2. **Router Inclusion**: It includes several routers into the FastAPI application:\n   - `router`: A default router that is included without a prefix.\n   - `prefix_router`: This router is included with a specified prefix (`/prefix`), allowing for namespacing of routes.\n   - `native_prefix_route`: Another router that is included without a prefix.\n3. **Return Value**: Finally, the method returns the configured FastAPI application instance, which can then be run or further modified as needed. \n\nThis method streamlines the setup of a FastAPI application by encapsulating common configuration patterns."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_depend_err_handler",
            "module": "test_ws_router",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_ws_router.py",
            "line_number": 257,
            "end_line_number": 271,
            "source_code": "def test_depend_err_handler():\n    \"\"\"\n    Verify that it is possible to write custom WebSocket middleware to catch errors\n    \"\"\"\n\n    async def custom_handler(websocket: WebSocket, exc: CustomError) -> None:\n        await websocket.close(1002, \"foo\")\n\n    myapp = make_app(exception_handlers={CustomError: custom_handler})\n    client = TestClient(myapp)\n    with pytest.raises(WebSocketDisconnect) as e:\n        with client.websocket_connect(\"/custom_error/\"):\n            pass  # pragma: no cover\n    assert e.value.code == 1002\n    assert \"foo\" in e.value.reason",
            "docstring": "Verify that it is possible to write custom WebSocket middleware to catch errors",
            "decorators": [],
            "arguments": [],
            "imports": [
                "functools",
                "pytest",
                "fastapi.APIRouter",
                "fastapi.Depends",
                "fastapi.FastAPI",
                "fastapi.Header",
                "fastapi.WebSocket",
                "fastapi.WebSocketDisconnect",
                "fastapi.status",
                "fastapi.middleware.Middleware",
                "fastapi.testclient.TestClient"
            ],
            "fixtures": [],
            "assertions": [
                "assert e.value.code == 1002",
                "assert 'foo' in e.value.reason"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "make_app",
                    "body": "def make_app(app=None, **kwargs):\n    app = app or FastAPI(**kwargs)\n    app.include_router(router)\n    app.include_router(prefix_router, prefix='/prefix')\n    app.include_router(native_prefix_route)\n    return app",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `make_app` method is designed to create and configure a FastAPI application instance. It allows for optional customization through parameters and includes predefined routers for organizing application routes.\n\n**How It Works**:\n1. **Initialization**: The method accepts an optional `app` parameter. If `app` is not provided, it initializes a new FastAPI instance using any additional keyword arguments (`**kwargs`).\n2. **Router Inclusion**: It includes several routers into the FastAPI application:\n   - `router`: A default router that is included without a prefix.\n   - `prefix_router`: This router is included with a specified prefix (`/prefix`), allowing for namespacing of routes.\n   - `native_prefix_route`: Another router that is included without a prefix.\n3. **Return Value**: Finally, the method returns the configured FastAPI application instance, which can then be run or further modified as needed. \n\nThis method streamlines the setup of a FastAPI application by encapsulating common configuration patterns."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_fastapi_cli_not_installed",
            "module": "test_fastapi_cli",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_fastapi_cli.py",
            "line_number": 28,
            "end_line_number": 32,
            "source_code": "def test_fastapi_cli_not_installed():\n    with patch.object(fastapi.cli, \"cli_main\", None):\n        with pytest.raises(RuntimeError) as exc_info:\n            fastapi.cli.main()\n        assert \"To use the fastapi command, please install\" in str(exc_info.value)",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "subprocess",
                "sys",
                "unittest.mock.patch",
                "fastapi.cli",
                "pytest"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'To use the fastapi command, please install' in str(exc_info.value)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "fastapi.cli.main",
                    "body": "def main(some_arg, q: Optional[str]=None):\n    return {'some_arg': some_arg, 'q': q}",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `main` method serves as a simple function that accepts a required argument `some_arg` and an optional query parameter `q`. It returns a dictionary containing these parameters, which can be useful for handling requests in a FastAPI application.\n\n**How It Works**:\nThe method takes two parameters: `some_arg`, which is mandatory, and `q`, which is optional and defaults to `None`. When called, it constructs and returns a dictionary with the values of `some_arg` and `q`. In the provided code snippets, this method is partially applied using `functools.partial` to create an endpoint that always uses \"foo\" as the value for `some_arg`. The FastAPI application then defines a GET endpoint that utilizes this partial function, allowing it to respond to requests with the specified parameters. The test client verifies that the endpoint correctly returns the expected dictionary when a query parameter `q` is provided."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_query_params_str_validations_no_query",
            "module": "test_regex_deprecated_params",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_regex_deprecated_params.py",
            "line_number": 28,
            "end_line_number": 32,
            "source_code": "def test_query_params_str_validations_no_query():\n    client = get_client()\n    response = client.get(\"/items/\")\n    assert response.status_code == 200\n    assert response.json() == \"Hello World\"",
            "docstring": null,
            "decorators": [
                "needs_py310"
            ],
            "arguments": [],
            "imports": [
                "pytest",
                "dirty_equals.IsDict",
                "fastapi.FastAPI",
                "fastapi.Query",
                "fastapi.testclient.TestClient",
                "typing_extensions.Annotated",
                "utils.needs_py310"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 200",
                "assert response.json() == 'Hello World'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_client",
                    "body": "@pytest.fixture(name='client')\ndef get_client():\n    app = FastAPI()\n    from pydantic import BaseModel, computed_field\n\n    class Rectangle(BaseModel):\n        width: int\n        length: int\n\n        @computed_field\n        @property\n        def area(self) -> int:\n            return self.width * self.length\n\n    @app.get('/')\n    def read_root() -> Rectangle:\n        return Rectangle(width=3, length=4)\n\n    @app.get('/responses', responses={200: {'model': Rectangle}})\n    def read_responses() -> Rectangle:\n        return Rectangle(width=3, length=4)\n    client = TestClient(app)\n    return client",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get_client` method is a pytest fixture that sets up a FastAPI application and returns a TestClient instance for testing API endpoints. It defines a simple API with endpoints that return a `Rectangle` model, allowing for easy testing of the API's functionality.\n\n**How It Works**:\n1. **FastAPI Application Creation**: The method initializes a FastAPI application instance.\n2. **Model Definition**: It defines a `Rectangle` class using Pydantic's `BaseModel`, which includes properties for `width`, `length`, and a computed property `area` that calculates the rectangle's area.\n3. **API Endpoints**: Two GET endpoints are defined:\n   - The root endpoint (`/`) returns a `Rectangle` instance with predefined dimensions.\n   - The `/responses` endpoint also returns a `Rectangle` instance, explicitly specifying the response model.\n4. **TestClient Initialization**: A `TestClient` is created using the FastAPI app, which allows for simulating requests to the API during tests.\n5. **Return Value**: The method returns the `TestClient`, enabling tests to interact with the API endpoints defined in the FastAPI application. \n\nThis setup is particularly useful for unit testing the API's behavior and ensuring that the endpoints return the expected results."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_query_params_str_validations_q_fixedquery",
            "module": "test_regex_deprecated_params",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_regex_deprecated_params.py",
            "line_number": 36,
            "end_line_number": 40,
            "source_code": "def test_query_params_str_validations_q_fixedquery():\n    client = get_client()\n    response = client.get(\"/items/\", params={\"q\": \"fixedquery\"})\n    assert response.status_code == 200\n    assert response.json() == \"Hello fixedquery\"",
            "docstring": null,
            "decorators": [
                "needs_py310"
            ],
            "arguments": [],
            "imports": [
                "pytest",
                "dirty_equals.IsDict",
                "fastapi.FastAPI",
                "fastapi.Query",
                "fastapi.testclient.TestClient",
                "typing_extensions.Annotated",
                "utils.needs_py310"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 200",
                "assert response.json() == 'Hello fixedquery'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_client",
                    "body": "@pytest.fixture(name='client')\ndef get_client():\n    app = FastAPI()\n    from pydantic import BaseModel, computed_field\n\n    class Rectangle(BaseModel):\n        width: int\n        length: int\n\n        @computed_field\n        @property\n        def area(self) -> int:\n            return self.width * self.length\n\n    @app.get('/')\n    def read_root() -> Rectangle:\n        return Rectangle(width=3, length=4)\n\n    @app.get('/responses', responses={200: {'model': Rectangle}})\n    def read_responses() -> Rectangle:\n        return Rectangle(width=3, length=4)\n    client = TestClient(app)\n    return client",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get_client` method is a pytest fixture that sets up a FastAPI application and returns a TestClient instance for testing API endpoints. It defines a simple API with endpoints that return a `Rectangle` model, allowing for easy testing of the API's functionality.\n\n**How It Works**:\n1. **FastAPI Application Creation**: The method initializes a FastAPI application instance.\n2. **Model Definition**: It defines a `Rectangle` class using Pydantic's `BaseModel`, which includes properties for `width`, `length`, and a computed property `area` that calculates the rectangle's area.\n3. **API Endpoints**: Two GET endpoints are defined:\n   - The root endpoint (`/`) returns a `Rectangle` instance with predefined dimensions.\n   - The `/responses` endpoint also returns a `Rectangle` instance, explicitly specifying the response model.\n4. **TestClient Initialization**: A `TestClient` is created using the FastAPI app, which allows for simulating requests to the API during tests.\n5. **Fixture Return**: The `client` fixture returns the `TestClient`, making it available for use in test functions to perform API requests and validate responses."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_query_params_str_validations_item_query_nonregexquery",
            "module": "test_regex_deprecated_params",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_regex_deprecated_params.py",
            "line_number": 44,
            "end_line_number": 72,
            "source_code": "def test_query_params_str_validations_item_query_nonregexquery():\n    client = get_client()\n    response = client.get(\"/items/\", params={\"q\": \"nonregexquery\"})\n    assert response.status_code == 422\n    assert response.json() == IsDict(\n        {\n            \"detail\": [\n                {\n                    \"type\": \"string_pattern_mismatch\",\n                    \"loc\": [\"query\", \"q\"],\n                    \"msg\": \"String should match pattern '^fixedquery$'\",\n                    \"input\": \"nonregexquery\",\n                    \"ctx\": {\"pattern\": \"^fixedquery$\"},\n                }\n            ]\n        }\n    ) | IsDict(\n        # TODO: remove when deprecating Pydantic v1\n        {\n            \"detail\": [\n                {\n                    \"ctx\": {\"pattern\": \"^fixedquery$\"},\n                    \"loc\": [\"query\", \"q\"],\n                    \"msg\": 'string does not match regex \"^fixedquery$\"',\n                    \"type\": \"value_error.str.regex\",\n                }\n            ]\n        }\n    )",
            "docstring": null,
            "decorators": [
                "needs_py310"
            ],
            "arguments": [],
            "imports": [
                "pytest",
                "dirty_equals.IsDict",
                "fastapi.FastAPI",
                "fastapi.Query",
                "fastapi.testclient.TestClient",
                "typing_extensions.Annotated",
                "utils.needs_py310"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 422",
                "assert response.json() == IsDict({'detail': [{'type': 'string_pattern_mismatch', 'loc': ['query', 'q'], 'msg': \"String should match pattern '^fixedquery$'\", 'input': 'nonregexquery', 'ctx': {'pattern': '^fixedquery$'}}]}) | IsDict({'detail': [{'ctx': {'pattern': '^fixedquery$'}, 'loc': ['query', 'q'], 'msg': 'string does not match regex \"^fixedquery$\"', 'type': 'value_error.str.regex'}]})"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_client",
                    "body": "@pytest.fixture(name='client')\ndef get_client():\n    app = FastAPI()\n    from pydantic import BaseModel, computed_field\n\n    class Rectangle(BaseModel):\n        width: int\n        length: int\n\n        @computed_field\n        @property\n        def area(self) -> int:\n            return self.width * self.length\n\n    @app.get('/')\n    def read_root() -> Rectangle:\n        return Rectangle(width=3, length=4)\n\n    @app.get('/responses', responses={200: {'model': Rectangle}})\n    def read_responses() -> Rectangle:\n        return Rectangle(width=3, length=4)\n    client = TestClient(app)\n    return client",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get_client` method is a pytest fixture that sets up a FastAPI application and returns a TestClient instance for testing API endpoints. It defines a simple API with endpoints that return a `Rectangle` model, allowing for easy testing of the API's functionality.\n\n**How It Works**:\n1. **FastAPI Application Creation**: The method initializes a FastAPI application instance.\n2. **Model Definition**: It defines a `Rectangle` class using Pydantic's `BaseModel`, which includes properties for `width`, `length`, and a computed property `area` that calculates the rectangle's area.\n3. **API Endpoints**: Two GET endpoints are defined:\n   - The root endpoint (`/`) returns a `Rectangle` instance with predefined dimensions.\n   - The `/responses` endpoint also returns a `Rectangle` instance, explicitly specifying the response model.\n4. **TestClient Initialization**: A `TestClient` is created using the FastAPI app, enabling the execution of HTTP requests against the defined endpoints.\n5. **Fixture Return**: The `client` fixture returns the `TestClient`, which can be used in test functions to simulate API calls and validate responses."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_openapi_schema",
            "module": "test_regex_deprecated_params",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_regex_deprecated_params.py",
            "line_number": 76,
            "end_line_number": 163,
            "source_code": "def test_openapi_schema():\n    client = get_client()\n    response = client.get(\"/openapi.json\")\n    assert response.status_code == 200, response.text\n    # insert_assert(response.json())\n    assert response.json() == {\n        \"openapi\": \"3.1.0\",\n        \"info\": {\"title\": \"FastAPI\", \"version\": \"0.1.0\"},\n        \"paths\": {\n            \"/items/\": {\n                \"get\": {\n                    \"summary\": \"Read Items\",\n                    \"operationId\": \"read_items_items__get\",\n                    \"parameters\": [\n                        {\n                            \"name\": \"q\",\n                            \"in\": \"query\",\n                            \"required\": False,\n                            \"schema\": IsDict(\n                                {\n                                    \"anyOf\": [\n                                        {\"type\": \"string\", \"pattern\": \"^fixedquery$\"},\n                                        {\"type\": \"null\"},\n                                    ],\n                                    \"title\": \"Q\",\n                                }\n                            )\n                            | IsDict(\n                                # TODO: remove when deprecating Pydantic v1\n                                {\n                                    \"type\": \"string\",\n                                    \"pattern\": \"^fixedquery$\",\n                                    \"title\": \"Q\",\n                                }\n                            ),\n                        }\n                    ],\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            }\n        },\n        \"components\": {\n            \"schemas\": {\n                \"HTTPValidationError\": {\n                    \"properties\": {\n                        \"detail\": {\n                            \"items\": {\"$ref\": \"#/components/schemas/ValidationError\"},\n                            \"type\": \"array\",\n                            \"title\": \"Detail\",\n                        }\n                    },\n                    \"type\": \"object\",\n                    \"title\": \"HTTPValidationError\",\n                },\n                \"ValidationError\": {\n                    \"properties\": {\n                        \"loc\": {\n                            \"items\": {\n                                \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"integer\"}]\n                            },\n                            \"type\": \"array\",\n                            \"title\": \"Location\",\n                        },\n                        \"msg\": {\"type\": \"string\", \"title\": \"Message\"},\n                        \"type\": {\"type\": \"string\", \"title\": \"Error Type\"},\n                    },\n                    \"type\": \"object\",\n                    \"required\": [\"loc\", \"msg\", \"type\"],\n                    \"title\": \"ValidationError\",\n                },\n            }\n        },\n    }",
            "docstring": null,
            "decorators": [
                "needs_py310"
            ],
            "arguments": [],
            "imports": [
                "pytest",
                "dirty_equals.IsDict",
                "fastapi.FastAPI",
                "fastapi.Query",
                "fastapi.testclient.TestClient",
                "typing_extensions.Annotated",
                "utils.needs_py310"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 200, response.text",
                "assert response.json() == {'openapi': '3.1.0', 'info': {'title': 'FastAPI', 'version': '0.1.0'}, 'paths': {'/items/': {'get': {'summary': 'Read Items', 'operationId': 'read_items_items__get', 'parameters': [{'name': 'q', 'in': 'query', 'required': False, 'schema': IsDict({'anyOf': [{'type': 'string', 'pattern': '^fixedquery$'}, {'type': 'null'}], 'title': 'Q'}) | IsDict({'type': 'string', 'pattern': '^fixedquery$', 'title': 'Q'})}], 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}}, 'components': {'schemas': {'HTTPValidationError': {'properties': {'detail': {'items': {'$ref': '#/components/schemas/ValidationError'}, 'type': 'array', 'title': 'Detail'}}, 'type': 'object', 'title': 'HTTPValidationError'}, 'ValidationError': {'properties': {'loc': {'items': {'anyOf': [{'type': 'string'}, {'type': 'integer'}]}, 'type': 'array', 'title': 'Location'}, 'msg': {'type': 'string', 'title': 'Message'}, 'type': {'type': 'string', 'title': 'Error Type'}}, 'type': 'object', 'required': ['loc', 'msg', 'type'], 'title': 'ValidationError'}}}}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_client",
                    "body": "@pytest.fixture(name='client')\ndef get_client():\n    app = FastAPI()\n    from pydantic import BaseModel, computed_field\n\n    class Rectangle(BaseModel):\n        width: int\n        length: int\n\n        @computed_field\n        @property\n        def area(self) -> int:\n            return self.width * self.length\n\n    @app.get('/')\n    def read_root() -> Rectangle:\n        return Rectangle(width=3, length=4)\n\n    @app.get('/responses', responses={200: {'model': Rectangle}})\n    def read_responses() -> Rectangle:\n        return Rectangle(width=3, length=4)\n    client = TestClient(app)\n    return client",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get_client` method is a pytest fixture that sets up a FastAPI application and returns a TestClient instance for testing API endpoints. It defines a simple API with endpoints that return a `Rectangle` model, allowing for easy testing of the API's functionality.\n\n**How It Works**:\n1. **FastAPI Application Creation**: The method initializes a FastAPI application instance.\n2. **Model Definition**: It defines a `Rectangle` class using Pydantic's `BaseModel`, which includes properties for `width`, `length`, and a computed property `area` that calculates the rectangle's area.\n3. **API Endpoints**: Two GET endpoints are defined:\n   - The root endpoint (`/`) returns a `Rectangle` instance with predefined dimensions.\n   - The `/responses` endpoint also returns a `Rectangle` instance, explicitly specifying the response model.\n4. **TestClient Initialization**: A `TestClient` is created using the FastAPI app, which allows for simulating requests to the API during tests.\n5. **Fixture Return**: The `client` fixture returns the `TestClient`, making it available for use in test functions to perform API requests and validate responses."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_no_query",
            "module": "test_regex_deprecated_body",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_regex_deprecated_body.py",
            "line_number": 28,
            "end_line_number": 32,
            "source_code": "def test_no_query():\n    client = get_client()\n    response = client.post(\"/items/\")\n    assert response.status_code == 200\n    assert response.json() == \"Hello World\"",
            "docstring": null,
            "decorators": [
                "needs_py310"
            ],
            "arguments": [],
            "imports": [
                "pytest",
                "dirty_equals.IsDict",
                "fastapi.FastAPI",
                "fastapi.Form",
                "fastapi.testclient.TestClient",
                "typing_extensions.Annotated",
                "utils.needs_py310"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 200",
                "assert response.json() == 'Hello World'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_client",
                    "body": "@pytest.fixture(name='client')\ndef get_client():\n    app = FastAPI()\n    from pydantic import BaseModel, computed_field\n\n    class Rectangle(BaseModel):\n        width: int\n        length: int\n\n        @computed_field\n        @property\n        def area(self) -> int:\n            return self.width * self.length\n\n    @app.get('/')\n    def read_root() -> Rectangle:\n        return Rectangle(width=3, length=4)\n\n    @app.get('/responses', responses={200: {'model': Rectangle}})\n    def read_responses() -> Rectangle:\n        return Rectangle(width=3, length=4)\n    client = TestClient(app)\n    return client",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get_client` method is a pytest fixture that sets up a FastAPI application and returns a TestClient instance for testing API endpoints. It defines a simple API with endpoints that return a `Rectangle` model, allowing for easy testing of the API's functionality.\n\n**How It Works**:\n1. **FastAPI Application Creation**: The method initializes a FastAPI application instance.\n2. **Pydantic Model Definition**: It defines a `Rectangle` model using Pydantic, which includes properties for `width`, `length`, and a computed property `area` that calculates the rectangle's area.\n3. **API Endpoints**: Two GET endpoints are defined:\n   - The root endpoint (`/`) returns a `Rectangle` instance with predefined dimensions.\n   - The `/responses` endpoint also returns a `Rectangle` instance, explicitly specifying the response model.\n4. **TestClient Initialization**: A `TestClient` is created using the FastAPI app, which allows for simulating requests to the API during tests.\n5. **Fixture Return**: The `client` fixture returns the `TestClient`, making it available for use in test functions to perform API requests and assertions."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_q_fixedquery",
            "module": "test_regex_deprecated_body",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_regex_deprecated_body.py",
            "line_number": 36,
            "end_line_number": 40,
            "source_code": "def test_q_fixedquery():\n    client = get_client()\n    response = client.post(\"/items/\", data={\"q\": \"fixedquery\"})\n    assert response.status_code == 200\n    assert response.json() == \"Hello fixedquery\"",
            "docstring": null,
            "decorators": [
                "needs_py310"
            ],
            "arguments": [],
            "imports": [
                "pytest",
                "dirty_equals.IsDict",
                "fastapi.FastAPI",
                "fastapi.Form",
                "fastapi.testclient.TestClient",
                "typing_extensions.Annotated",
                "utils.needs_py310"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 200",
                "assert response.json() == 'Hello fixedquery'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_client",
                    "body": "@pytest.fixture(name='client')\ndef get_client():\n    app = FastAPI()\n    from pydantic import BaseModel, computed_field\n\n    class Rectangle(BaseModel):\n        width: int\n        length: int\n\n        @computed_field\n        @property\n        def area(self) -> int:\n            return self.width * self.length\n\n    @app.get('/')\n    def read_root() -> Rectangle:\n        return Rectangle(width=3, length=4)\n\n    @app.get('/responses', responses={200: {'model': Rectangle}})\n    def read_responses() -> Rectangle:\n        return Rectangle(width=3, length=4)\n    client = TestClient(app)\n    return client",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get_client` method is a pytest fixture that sets up a FastAPI application and returns a TestClient instance for testing API endpoints. It defines a simple API with endpoints that return a `Rectangle` model, allowing for easy testing of the API's functionality.\n\n**How It Works**:\n1. **FastAPI Application Creation**: The method initializes a FastAPI application instance.\n2. **Model Definition**: It defines a `Rectangle` class using Pydantic's `BaseModel`, which includes properties for `width`, `length`, and a computed property `area` that calculates the rectangle's area.\n3. **API Endpoints**: Two GET endpoints are defined:\n   - The root endpoint (`/`) returns a `Rectangle` instance with predefined dimensions.\n   - The `/responses` endpoint also returns a `Rectangle` instance, explicitly specifying the response model.\n4. **TestClient Initialization**: A `TestClient` is created using the FastAPI app, which allows for simulating requests to the API during tests.\n5. **Fixture Return**: The `client` fixture returns the `TestClient`, making it available for use in test functions to perform API requests and validate responses."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_query_nonregexquery",
            "module": "test_regex_deprecated_body",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_regex_deprecated_body.py",
            "line_number": 44,
            "end_line_number": 72,
            "source_code": "def test_query_nonregexquery():\n    client = get_client()\n    response = client.post(\"/items/\", data={\"q\": \"nonregexquery\"})\n    assert response.status_code == 422\n    assert response.json() == IsDict(\n        {\n            \"detail\": [\n                {\n                    \"type\": \"string_pattern_mismatch\",\n                    \"loc\": [\"body\", \"q\"],\n                    \"msg\": \"String should match pattern '^fixedquery$'\",\n                    \"input\": \"nonregexquery\",\n                    \"ctx\": {\"pattern\": \"^fixedquery$\"},\n                }\n            ]\n        }\n    ) | IsDict(\n        # TODO: remove when deprecating Pydantic v1\n        {\n            \"detail\": [\n                {\n                    \"ctx\": {\"pattern\": \"^fixedquery$\"},\n                    \"loc\": [\"body\", \"q\"],\n                    \"msg\": 'string does not match regex \"^fixedquery$\"',\n                    \"type\": \"value_error.str.regex\",\n                }\n            ]\n        }\n    )",
            "docstring": null,
            "decorators": [
                "needs_py310"
            ],
            "arguments": [],
            "imports": [
                "pytest",
                "dirty_equals.IsDict",
                "fastapi.FastAPI",
                "fastapi.Form",
                "fastapi.testclient.TestClient",
                "typing_extensions.Annotated",
                "utils.needs_py310"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 422",
                "assert response.json() == IsDict({'detail': [{'type': 'string_pattern_mismatch', 'loc': ['body', 'q'], 'msg': \"String should match pattern '^fixedquery$'\", 'input': 'nonregexquery', 'ctx': {'pattern': '^fixedquery$'}}]}) | IsDict({'detail': [{'ctx': {'pattern': '^fixedquery$'}, 'loc': ['body', 'q'], 'msg': 'string does not match regex \"^fixedquery$\"', 'type': 'value_error.str.regex'}]})"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_client",
                    "body": "@pytest.fixture(name='client')\ndef get_client():\n    app = FastAPI()\n    from pydantic import BaseModel, computed_field\n\n    class Rectangle(BaseModel):\n        width: int\n        length: int\n\n        @computed_field\n        @property\n        def area(self) -> int:\n            return self.width * self.length\n\n    @app.get('/')\n    def read_root() -> Rectangle:\n        return Rectangle(width=3, length=4)\n\n    @app.get('/responses', responses={200: {'model': Rectangle}})\n    def read_responses() -> Rectangle:\n        return Rectangle(width=3, length=4)\n    client = TestClient(app)\n    return client",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get_client` method is a pytest fixture that sets up a FastAPI application and returns a TestClient instance for testing API endpoints. It defines a simple API with endpoints that return a `Rectangle` model, allowing for easy testing of the API's functionality.\n\n**How It Works**:\n1. **FastAPI Application Creation**: The method initializes a FastAPI application instance.\n2. **Model Definition**: It defines a `Rectangle` class using Pydantic's `BaseModel`, which includes properties for `width`, `length`, and a computed property `area` that calculates the rectangle's area.\n3. **API Endpoints**: Two GET endpoints are defined:\n   - The root endpoint (`/`) returns a `Rectangle` instance with predefined dimensions.\n   - The `/responses` endpoint also returns a `Rectangle` instance, explicitly specifying the response model.\n4. **TestClient Initialization**: A `TestClient` is created using the FastAPI app, enabling the execution of HTTP requests against the defined endpoints.\n5. **Return Value**: The method returns the `TestClient`, which can be used in tests to interact with the API and assert expected behaviors."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_openapi_schema",
            "module": "test_regex_deprecated_body",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_regex_deprecated_body.py",
            "line_number": 76,
            "end_line_number": 180,
            "source_code": "def test_openapi_schema():\n    client = get_client()\n    response = client.get(\"/openapi.json\")\n    assert response.status_code == 200, response.text\n    # insert_assert(response.json())\n    assert response.json() == {\n        \"openapi\": \"3.1.0\",\n        \"info\": {\"title\": \"FastAPI\", \"version\": \"0.1.0\"},\n        \"paths\": {\n            \"/items/\": {\n                \"post\": {\n                    \"summary\": \"Read Items\",\n                    \"operationId\": \"read_items_items__post\",\n                    \"requestBody\": {\n                        \"content\": {\n                            \"application/x-www-form-urlencoded\": {\n                                \"schema\": IsDict(\n                                    {\n                                        \"allOf\": [\n                                            {\n                                                \"$ref\": \"#/components/schemas/Body_read_items_items__post\"\n                                            }\n                                        ],\n                                        \"title\": \"Body\",\n                                    }\n                                )\n                                | IsDict(\n                                    # TODO: remove when deprecating Pydantic v1\n                                    {\n                                        \"$ref\": \"#/components/schemas/Body_read_items_items__post\"\n                                    }\n                                )\n                            }\n                        }\n                    },\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            }\n        },\n        \"components\": {\n            \"schemas\": {\n                \"Body_read_items_items__post\": {\n                    \"properties\": {\n                        \"q\": IsDict(\n                            {\n                                \"anyOf\": [\n                                    {\"type\": \"string\", \"pattern\": \"^fixedquery$\"},\n                                    {\"type\": \"null\"},\n                                ],\n                                \"title\": \"Q\",\n                            }\n                        )\n                        | IsDict(\n                            # TODO: remove when deprecating Pydantic v1\n                            {\"type\": \"string\", \"pattern\": \"^fixedquery$\", \"title\": \"Q\"}\n                        )\n                    },\n                    \"type\": \"object\",\n                    \"title\": \"Body_read_items_items__post\",\n                },\n                \"HTTPValidationError\": {\n                    \"properties\": {\n                        \"detail\": {\n                            \"items\": {\"$ref\": \"#/components/schemas/ValidationError\"},\n                            \"type\": \"array\",\n                            \"title\": \"Detail\",\n                        }\n                    },\n                    \"type\": \"object\",\n                    \"title\": \"HTTPValidationError\",\n                },\n                \"ValidationError\": {\n                    \"properties\": {\n                        \"loc\": {\n                            \"items\": {\n                                \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"integer\"}]\n                            },\n                            \"type\": \"array\",\n                            \"title\": \"Location\",\n                        },\n                        \"msg\": {\"type\": \"string\", \"title\": \"Message\"},\n                        \"type\": {\"type\": \"string\", \"title\": \"Error Type\"},\n                    },\n                    \"type\": \"object\",\n                    \"required\": [\"loc\", \"msg\", \"type\"],\n                    \"title\": \"ValidationError\",\n                },\n            }\n        },\n    }",
            "docstring": null,
            "decorators": [
                "needs_py310"
            ],
            "arguments": [],
            "imports": [
                "pytest",
                "dirty_equals.IsDict",
                "fastapi.FastAPI",
                "fastapi.Form",
                "fastapi.testclient.TestClient",
                "typing_extensions.Annotated",
                "utils.needs_py310"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 200, response.text",
                "assert response.json() == {'openapi': '3.1.0', 'info': {'title': 'FastAPI', 'version': '0.1.0'}, 'paths': {'/items/': {'post': {'summary': 'Read Items', 'operationId': 'read_items_items__post', 'requestBody': {'content': {'application/x-www-form-urlencoded': {'schema': IsDict({'allOf': [{'$ref': '#/components/schemas/Body_read_items_items__post'}], 'title': 'Body'}) | IsDict({'$ref': '#/components/schemas/Body_read_items_items__post'})}}}, 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}}, 'components': {'schemas': {'Body_read_items_items__post': {'properties': {'q': IsDict({'anyOf': [{'type': 'string', 'pattern': '^fixedquery$'}, {'type': 'null'}], 'title': 'Q'}) | IsDict({'type': 'string', 'pattern': '^fixedquery$', 'title': 'Q'})}, 'type': 'object', 'title': 'Body_read_items_items__post'}, 'HTTPValidationError': {'properties': {'detail': {'items': {'$ref': '#/components/schemas/ValidationError'}, 'type': 'array', 'title': 'Detail'}}, 'type': 'object', 'title': 'HTTPValidationError'}, 'ValidationError': {'properties': {'loc': {'items': {'anyOf': [{'type': 'string'}, {'type': 'integer'}]}, 'type': 'array', 'title': 'Location'}, 'msg': {'type': 'string', 'title': 'Message'}, 'type': {'type': 'string', 'title': 'Error Type'}}, 'type': 'object', 'required': ['loc', 'msg', 'type'], 'title': 'ValidationError'}}}}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_client",
                    "body": "@pytest.fixture(name='client')\ndef get_client():\n    app = FastAPI()\n    from pydantic import BaseModel, computed_field\n\n    class Rectangle(BaseModel):\n        width: int\n        length: int\n\n        @computed_field\n        @property\n        def area(self) -> int:\n            return self.width * self.length\n\n    @app.get('/')\n    def read_root() -> Rectangle:\n        return Rectangle(width=3, length=4)\n\n    @app.get('/responses', responses={200: {'model': Rectangle}})\n    def read_responses() -> Rectangle:\n        return Rectangle(width=3, length=4)\n    client = TestClient(app)\n    return client",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get_client` method is a pytest fixture that sets up a FastAPI application and returns a TestClient instance for testing API endpoints. It defines a simple API with endpoints that return a `Rectangle` model, allowing for easy testing of the API's functionality.\n\n**How It Works**:\n1. **FastAPI Application Creation**: The method initializes a FastAPI application instance.\n2. **Model Definition**: It defines a `Rectangle` class using Pydantic's `BaseModel`, which includes properties for `width`, `length`, and a computed property `area` that calculates the rectangle's area.\n3. **API Endpoints**: Two GET endpoints are defined:\n   - The root endpoint (`/`) returns a `Rectangle` instance with predefined dimensions.\n   - The `/responses` endpoint also returns a `Rectangle` instance, explicitly specifying the response model.\n4. **TestClient Initialization**: A `TestClient` is created using the FastAPI app, enabling the execution of HTTP requests against the defined endpoints.\n5. **Return Value**: The method returns the `TestClient`, which can be used in tests to interact with the API and assert expected behaviors."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_create_item",
            "module": "test_openapi_separate_input_output_schemas",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_openapi_separate_input_output_schemas.py",
            "line_number": 52,
            "end_line_number": 62,
            "source_code": "def test_create_item():\n    client = get_app_client()\n    client_no = get_app_client(separate_input_output_schemas=False)\n    response = client.post(\"/items/\", json={\"name\": \"Plumbus\"})\n    response2 = client_no.post(\"/items/\", json={\"name\": \"Plumbus\"})\n    assert response.status_code == response2.status_code == 200, response.text\n    assert (\n        response.json()\n        == response2.json()\n        == {\"name\": \"Plumbus\", \"description\": None, \"sub\": None}\n    )",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "typing.List",
                "typing.Optional",
                "fastapi.FastAPI",
                "fastapi.testclient.TestClient",
                "pydantic.BaseModel",
                "utils.PYDANTIC_V2",
                "utils.needs_pydanticv2"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == response2.status_code == 200, response.text",
                "assert response.json() == response2.json() == {'name': 'Plumbus', 'description': None, 'sub': None}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_app_client",
                    "body": "def get_app_client(separate_input_output_schemas: bool=True) -> TestClient:\n    app = FastAPI(separate_input_output_schemas=separate_input_output_schemas)\n\n    @app.post('/items/', responses={402: {'model': Item}})\n    def create_item(item: Item) -> Item:\n        return item\n\n    @app.post('/items-list/')\n    def create_item_list(item: List[Item]):\n        return item\n\n    @app.get('/items/')\n    def read_items() -> List[Item]:\n        return [Item(name='Portal Gun', description='Device to travel through the multi-rick-verse', sub=SubItem(subname='subname')), Item(name='Plumbus')]\n    client = TestClient(app)\n    return client",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get_app_client` method creates and returns a FastAPI `TestClient` instance configured with specific API endpoints for testing purposes. It allows developers to simulate requests to the FastAPI application without needing to run the server.\n\n**How It Works**:\n1. **FastAPI Application Creation**: The method initializes a FastAPI application instance, optionally configuring it to separate input and output schemas based on the `separate_input_output_schemas` parameter.\n2. **Endpoint Definitions**: It defines three endpoints:\n   - `POST /items/`: Accepts an `Item` object and returns it.\n   - `POST /items-list/`: Accepts a list of `Item` objects and returns the same list.\n   - `GET /items/`: Returns a predefined list of `Item` objects.\n3. **TestClient Initialization**: A `TestClient` is created using the FastAPI app, enabling the execution of HTTP requests against the defined endpoints.\n4. **Return Value**: The method returns the `TestClient` instance, which can be used in tests to make requests and assert responses."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_create_item",
            "module": "test_openapi_separate_input_output_schemas",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_openapi_separate_input_output_schemas.py",
            "line_number": 52,
            "end_line_number": 62,
            "source_code": "def test_create_item():\n    client = get_app_client()\n    client_no = get_app_client(separate_input_output_schemas=False)\n    response = client.post(\"/items/\", json={\"name\": \"Plumbus\"})\n    response2 = client_no.post(\"/items/\", json={\"name\": \"Plumbus\"})\n    assert response.status_code == response2.status_code == 200, response.text\n    assert (\n        response.json()\n        == response2.json()\n        == {\"name\": \"Plumbus\", \"description\": None, \"sub\": None}\n    )",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "typing.List",
                "typing.Optional",
                "fastapi.FastAPI",
                "fastapi.testclient.TestClient",
                "pydantic.BaseModel",
                "utils.PYDANTIC_V2",
                "utils.needs_pydanticv2"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == response2.status_code == 200, response.text",
                "assert response.json() == response2.json() == {'name': 'Plumbus', 'description': None, 'sub': None}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_app_client",
                    "body": "def get_app_client(separate_input_output_schemas: bool=True) -> TestClient:\n    app = FastAPI(separate_input_output_schemas=separate_input_output_schemas)\n\n    @app.post('/items/', responses={402: {'model': Item}})\n    def create_item(item: Item) -> Item:\n        return item\n\n    @app.post('/items-list/')\n    def create_item_list(item: List[Item]):\n        return item\n\n    @app.get('/items/')\n    def read_items() -> List[Item]:\n        return [Item(name='Portal Gun', description='Device to travel through the multi-rick-verse', sub=SubItem(subname='subname')), Item(name='Plumbus')]\n    client = TestClient(app)\n    return client",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get_app_client` method creates and returns a FastAPI `TestClient` instance configured with specific API endpoints for testing purposes. It allows developers to simulate requests to the API without needing to run the server.\n\n**How It Works**:\n1. **FastAPI Application Creation**: The method initializes a FastAPI application, optionally configuring it to separate input and output schemas based on the `separate_input_output_schemas` parameter.\n2. **Endpoint Definitions**: It defines three endpoints:\n   - `POST /items/`: Accepts an `Item` object and returns it.\n   - `POST /items-list/`: Accepts a list of `Item` objects and returns the same list.\n   - `GET /items/`: Returns a predefined list of `Item` objects.\n3. **TestClient Initialization**: A `TestClient` instance is created using the FastAPI app, enabling the execution of HTTP requests against the defined endpoints.\n4. **Return Value**: The method returns the `TestClient`, which can be used in tests to make requests and assert responses. \n\nThis setup is particularly useful for unit testing API endpoints in a controlled environment."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_create_item_with_sub",
            "module": "test_openapi_separate_input_output_schemas",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_openapi_separate_input_output_schemas.py",
            "line_number": 65,
            "end_line_number": 83,
            "source_code": "def test_create_item_with_sub():\n    client = get_app_client()\n    client_no = get_app_client(separate_input_output_schemas=False)\n    data = {\n        \"name\": \"Plumbus\",\n        \"sub\": {\"subname\": \"SubPlumbus\", \"sub_description\": \"Sub WTF\"},\n    }\n    response = client.post(\"/items/\", json=data)\n    response2 = client_no.post(\"/items/\", json=data)\n    assert response.status_code == response2.status_code == 200, response.text\n    assert (\n        response.json()\n        == response2.json()\n        == {\n            \"name\": \"Plumbus\",\n            \"description\": None,\n            \"sub\": {\"subname\": \"SubPlumbus\", \"sub_description\": \"Sub WTF\", \"tags\": []},\n        }\n    )",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "typing.List",
                "typing.Optional",
                "fastapi.FastAPI",
                "fastapi.testclient.TestClient",
                "pydantic.BaseModel",
                "utils.PYDANTIC_V2",
                "utils.needs_pydanticv2"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == response2.status_code == 200, response.text",
                "assert response.json() == response2.json() == {'name': 'Plumbus', 'description': None, 'sub': {'subname': 'SubPlumbus', 'sub_description': 'Sub WTF', 'tags': []}}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_app_client",
                    "body": "def get_app_client(separate_input_output_schemas: bool=True) -> TestClient:\n    app = FastAPI(separate_input_output_schemas=separate_input_output_schemas)\n\n    @app.post('/items/', responses={402: {'model': Item}})\n    def create_item(item: Item) -> Item:\n        return item\n\n    @app.post('/items-list/')\n    def create_item_list(item: List[Item]):\n        return item\n\n    @app.get('/items/')\n    def read_items() -> List[Item]:\n        return [Item(name='Portal Gun', description='Device to travel through the multi-rick-verse', sub=SubItem(subname='subname')), Item(name='Plumbus')]\n    client = TestClient(app)\n    return client",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `get_app_client` method creates and returns a FastAPI `TestClient` instance configured with specific API endpoints for testing purposes. It allows developers to simulate requests to the FastAPI application without needing to run the server.\n\n**How It Works**:  \n1. **Initialization**: The method accepts a boolean parameter `separate_input_output_schemas`, which determines whether to separate input and output schemas in the OpenAPI documentation.\n2. **FastAPI App Creation**: A FastAPI application instance is created with the specified schema configuration.\n3. **Endpoint Definitions**: Three endpoints are defined:\n   - `POST /items/`: Accepts an `Item` object and returns it.\n   - `POST /items-list/`: Accepts a list of `Item` objects and returns the same list.\n   - `GET /items/`: Returns a predefined list of `Item` objects.\n4. **TestClient Creation**: A `TestClient` instance is created using the FastAPI app, enabling the execution of HTTP requests against the defined endpoints.\n5. **Return**: The method returns the `TestClient`, which can be used in tests to make requests and assert responses. \n\nThis setup is particularly useful for unit testing FastAPI applications, allowing developers to verify the behavior of their API endpoints in isolation."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_create_item_with_sub",
            "module": "test_openapi_separate_input_output_schemas",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_openapi_separate_input_output_schemas.py",
            "line_number": 65,
            "end_line_number": 83,
            "source_code": "def test_create_item_with_sub():\n    client = get_app_client()\n    client_no = get_app_client(separate_input_output_schemas=False)\n    data = {\n        \"name\": \"Plumbus\",\n        \"sub\": {\"subname\": \"SubPlumbus\", \"sub_description\": \"Sub WTF\"},\n    }\n    response = client.post(\"/items/\", json=data)\n    response2 = client_no.post(\"/items/\", json=data)\n    assert response.status_code == response2.status_code == 200, response.text\n    assert (\n        response.json()\n        == response2.json()\n        == {\n            \"name\": \"Plumbus\",\n            \"description\": None,\n            \"sub\": {\"subname\": \"SubPlumbus\", \"sub_description\": \"Sub WTF\", \"tags\": []},\n        }\n    )",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "typing.List",
                "typing.Optional",
                "fastapi.FastAPI",
                "fastapi.testclient.TestClient",
                "pydantic.BaseModel",
                "utils.PYDANTIC_V2",
                "utils.needs_pydanticv2"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == response2.status_code == 200, response.text",
                "assert response.json() == response2.json() == {'name': 'Plumbus', 'description': None, 'sub': {'subname': 'SubPlumbus', 'sub_description': 'Sub WTF', 'tags': []}}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_app_client",
                    "body": "def get_app_client(separate_input_output_schemas: bool=True) -> TestClient:\n    app = FastAPI(separate_input_output_schemas=separate_input_output_schemas)\n\n    @app.post('/items/', responses={402: {'model': Item}})\n    def create_item(item: Item) -> Item:\n        return item\n\n    @app.post('/items-list/')\n    def create_item_list(item: List[Item]):\n        return item\n\n    @app.get('/items/')\n    def read_items() -> List[Item]:\n        return [Item(name='Portal Gun', description='Device to travel through the multi-rick-verse', sub=SubItem(subname='subname')), Item(name='Plumbus')]\n    client = TestClient(app)\n    return client",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `get_app_client` method creates and returns a FastAPI `TestClient` instance configured with specific API endpoints for testing purposes. It allows developers to simulate requests to the FastAPI application without needing to run the server.\n\n**How It Works**:  \n1. **Initialization**: The method accepts a boolean parameter `separate_input_output_schemas`, which determines whether to separate input and output schemas in the OpenAPI documentation.\n2. **FastAPI App Creation**: A FastAPI application instance is created with the specified schema configuration.\n3. **Endpoint Definitions**: Three endpoints are defined:\n   - `POST /items/`: Accepts an `Item` object and returns it.\n   - `POST /items-list/`: Accepts a list of `Item` objects and returns the same list.\n   - `GET /items/`: Returns a predefined list of `Item` objects.\n4. **TestClient Creation**: A `TestClient` instance is created using the FastAPI app, enabling the execution of HTTP requests against the defined endpoints.\n5. **Return**: The method returns the `TestClient`, which can be used in tests to make requests and assert responses. \n\nThis setup is particularly useful for unit testing FastAPI applications, allowing developers to verify the behavior of their API endpoints in isolation."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_create_item_list",
            "module": "test_openapi_separate_input_output_schemas",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_openapi_separate_input_output_schemas.py",
            "line_number": 86,
            "end_line_number": 110,
            "source_code": "def test_create_item_list():\n    client = get_app_client()\n    client_no = get_app_client(separate_input_output_schemas=False)\n    data = [\n        {\"name\": \"Plumbus\"},\n        {\n            \"name\": \"Portal Gun\",\n            \"description\": \"Device to travel through the multi-rick-verse\",\n        },\n    ]\n    response = client.post(\"/items-list/\", json=data)\n    response2 = client_no.post(\"/items-list/\", json=data)\n    assert response.status_code == response2.status_code == 200, response.text\n    assert (\n        response.json()\n        == response2.json()\n        == [\n            {\"name\": \"Plumbus\", \"description\": None, \"sub\": None},\n            {\n                \"name\": \"Portal Gun\",\n                \"description\": \"Device to travel through the multi-rick-verse\",\n                \"sub\": None,\n            },\n        ]\n    )",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "typing.List",
                "typing.Optional",
                "fastapi.FastAPI",
                "fastapi.testclient.TestClient",
                "pydantic.BaseModel",
                "utils.PYDANTIC_V2",
                "utils.needs_pydanticv2"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == response2.status_code == 200, response.text",
                "assert response.json() == response2.json() == [{'name': 'Plumbus', 'description': None, 'sub': None}, {'name': 'Portal Gun', 'description': 'Device to travel through the multi-rick-verse', 'sub': None}]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_app_client",
                    "body": "def get_app_client(separate_input_output_schemas: bool=True) -> TestClient:\n    app = FastAPI(separate_input_output_schemas=separate_input_output_schemas)\n\n    @app.post('/items/', responses={402: {'model': Item}})\n    def create_item(item: Item) -> Item:\n        return item\n\n    @app.post('/items-list/')\n    def create_item_list(item: List[Item]):\n        return item\n\n    @app.get('/items/')\n    def read_items() -> List[Item]:\n        return [Item(name='Portal Gun', description='Device to travel through the multi-rick-verse', sub=SubItem(subname='subname')), Item(name='Plumbus')]\n    client = TestClient(app)\n    return client",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `get_app_client` method creates and returns a FastAPI `TestClient` instance configured with specific API endpoints for testing purposes. It allows developers to simulate requests to the FastAPI application without needing to run the server.\n\n**How It Works**:  \n1. **Initialization**: The method accepts a boolean parameter `separate_input_output_schemas`, which determines whether to separate input and output schemas in the OpenAPI documentation.\n2. **FastAPI App Creation**: A FastAPI application instance is created with the specified schema configuration.\n3. **Endpoint Definitions**: Three endpoints are defined:\n   - `POST /items/`: Accepts an `Item` object and returns it.\n   - `POST /items-list/`: Accepts a list of `Item` objects and returns the same list.\n   - `GET /items/`: Returns a predefined list of `Item` objects.\n4. **TestClient Creation**: A `TestClient` instance is created using the FastAPI app, enabling the execution of HTTP requests against the defined endpoints.\n5. **Return**: The method returns the `TestClient`, which can be used in tests to interact with the API. \n\nThis setup is particularly useful for unit testing API endpoints in a controlled environment."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_create_item_list",
            "module": "test_openapi_separate_input_output_schemas",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_openapi_separate_input_output_schemas.py",
            "line_number": 86,
            "end_line_number": 110,
            "source_code": "def test_create_item_list():\n    client = get_app_client()\n    client_no = get_app_client(separate_input_output_schemas=False)\n    data = [\n        {\"name\": \"Plumbus\"},\n        {\n            \"name\": \"Portal Gun\",\n            \"description\": \"Device to travel through the multi-rick-verse\",\n        },\n    ]\n    response = client.post(\"/items-list/\", json=data)\n    response2 = client_no.post(\"/items-list/\", json=data)\n    assert response.status_code == response2.status_code == 200, response.text\n    assert (\n        response.json()\n        == response2.json()\n        == [\n            {\"name\": \"Plumbus\", \"description\": None, \"sub\": None},\n            {\n                \"name\": \"Portal Gun\",\n                \"description\": \"Device to travel through the multi-rick-verse\",\n                \"sub\": None,\n            },\n        ]\n    )",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "typing.List",
                "typing.Optional",
                "fastapi.FastAPI",
                "fastapi.testclient.TestClient",
                "pydantic.BaseModel",
                "utils.PYDANTIC_V2",
                "utils.needs_pydanticv2"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == response2.status_code == 200, response.text",
                "assert response.json() == response2.json() == [{'name': 'Plumbus', 'description': None, 'sub': None}, {'name': 'Portal Gun', 'description': 'Device to travel through the multi-rick-verse', 'sub': None}]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_app_client",
                    "body": "def get_app_client(separate_input_output_schemas: bool=True) -> TestClient:\n    app = FastAPI(separate_input_output_schemas=separate_input_output_schemas)\n\n    @app.post('/items/', responses={402: {'model': Item}})\n    def create_item(item: Item) -> Item:\n        return item\n\n    @app.post('/items-list/')\n    def create_item_list(item: List[Item]):\n        return item\n\n    @app.get('/items/')\n    def read_items() -> List[Item]:\n        return [Item(name='Portal Gun', description='Device to travel through the multi-rick-verse', sub=SubItem(subname='subname')), Item(name='Plumbus')]\n    client = TestClient(app)\n    return client",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get_app_client` method creates and returns a FastAPI `TestClient` instance configured with specific API endpoints for testing purposes. It allows developers to simulate requests to the FastAPI application without needing to run the server.\n\n**How It Works**:\n1. **Initialization**: The method accepts a boolean parameter `separate_input_output_schemas`, which determines whether to separate input and output schemas in the OpenAPI documentation.\n2. **FastAPI App Creation**: A FastAPI application instance is created with the specified schema configuration.\n3. **Endpoint Definitions**:\n   - A POST endpoint `/items/` is defined to create an item, returning the item as a response.\n   - A POST endpoint `/items-list/` is defined to create a list of items, returning the list.\n   - A GET endpoint `/items/` is defined to retrieve a predefined list of items.\n4. **TestClient Creation**: A `TestClient` instance is created using the FastAPI app, enabling the execution of HTTP requests against the defined endpoints.\n5. **Return**: The method returns the `TestClient`, which can be used in tests to send requests and validate responses."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_read_items",
            "module": "test_openapi_separate_input_output_schemas",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_openapi_separate_input_output_schemas.py",
            "line_number": 113,
            "end_line_number": 130,
            "source_code": "def test_read_items():\n    client = get_app_client()\n    client_no = get_app_client(separate_input_output_schemas=False)\n    response = client.get(\"/items/\")\n    response2 = client_no.get(\"/items/\")\n    assert response.status_code == response2.status_code == 200, response.text\n    assert (\n        response.json()\n        == response2.json()\n        == [\n            {\n                \"name\": \"Portal Gun\",\n                \"description\": \"Device to travel through the multi-rick-verse\",\n                \"sub\": {\"subname\": \"subname\", \"sub_description\": None, \"tags\": []},\n            },\n            {\"name\": \"Plumbus\", \"description\": None, \"sub\": None},\n        ]\n    )",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "typing.List",
                "typing.Optional",
                "fastapi.FastAPI",
                "fastapi.testclient.TestClient",
                "pydantic.BaseModel",
                "utils.PYDANTIC_V2",
                "utils.needs_pydanticv2"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == response2.status_code == 200, response.text",
                "assert response.json() == response2.json() == [{'name': 'Portal Gun', 'description': 'Device to travel through the multi-rick-verse', 'sub': {'subname': 'subname', 'sub_description': None, 'tags': []}}, {'name': 'Plumbus', 'description': None, 'sub': None}]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_app_client",
                    "body": "def get_app_client(separate_input_output_schemas: bool=True) -> TestClient:\n    app = FastAPI(separate_input_output_schemas=separate_input_output_schemas)\n\n    @app.post('/items/', responses={402: {'model': Item}})\n    def create_item(item: Item) -> Item:\n        return item\n\n    @app.post('/items-list/')\n    def create_item_list(item: List[Item]):\n        return item\n\n    @app.get('/items/')\n    def read_items() -> List[Item]:\n        return [Item(name='Portal Gun', description='Device to travel through the multi-rick-verse', sub=SubItem(subname='subname')), Item(name='Plumbus')]\n    client = TestClient(app)\n    return client",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `get_app_client` method creates and returns a FastAPI `TestClient` instance configured with specific API endpoints for testing purposes. It allows developers to simulate requests to the FastAPI application without needing to run a server.\n\n**How It Works**:  \n1. **Initialization**: The method accepts a boolean parameter `separate_input_output_schemas`, which determines whether to separate input and output schemas in the OpenAPI documentation.\n2. **FastAPI App Creation**: A FastAPI application instance is created with the specified schema configuration.\n3. **Endpoint Definitions**: Three endpoints are defined:\n   - `POST /items/`: Accepts an `Item` object and returns it.\n   - `POST /items-list/`: Accepts a list of `Item` objects and returns the same list.\n   - `GET /items/`: Returns a predefined list of `Item` objects.\n4. **TestClient Creation**: A `TestClient` instance is created using the FastAPI app, enabling the execution of HTTP requests against the defined endpoints.\n5. **Return**: The `TestClient` instance is returned for use in tests, allowing developers to easily test the API's functionality."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_read_items",
            "module": "test_openapi_separate_input_output_schemas",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_openapi_separate_input_output_schemas.py",
            "line_number": 113,
            "end_line_number": 130,
            "source_code": "def test_read_items():\n    client = get_app_client()\n    client_no = get_app_client(separate_input_output_schemas=False)\n    response = client.get(\"/items/\")\n    response2 = client_no.get(\"/items/\")\n    assert response.status_code == response2.status_code == 200, response.text\n    assert (\n        response.json()\n        == response2.json()\n        == [\n            {\n                \"name\": \"Portal Gun\",\n                \"description\": \"Device to travel through the multi-rick-verse\",\n                \"sub\": {\"subname\": \"subname\", \"sub_description\": None, \"tags\": []},\n            },\n            {\"name\": \"Plumbus\", \"description\": None, \"sub\": None},\n        ]\n    )",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "typing.List",
                "typing.Optional",
                "fastapi.FastAPI",
                "fastapi.testclient.TestClient",
                "pydantic.BaseModel",
                "utils.PYDANTIC_V2",
                "utils.needs_pydanticv2"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == response2.status_code == 200, response.text",
                "assert response.json() == response2.json() == [{'name': 'Portal Gun', 'description': 'Device to travel through the multi-rick-verse', 'sub': {'subname': 'subname', 'sub_description': None, 'tags': []}}, {'name': 'Plumbus', 'description': None, 'sub': None}]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_app_client",
                    "body": "def get_app_client(separate_input_output_schemas: bool=True) -> TestClient:\n    app = FastAPI(separate_input_output_schemas=separate_input_output_schemas)\n\n    @app.post('/items/', responses={402: {'model': Item}})\n    def create_item(item: Item) -> Item:\n        return item\n\n    @app.post('/items-list/')\n    def create_item_list(item: List[Item]):\n        return item\n\n    @app.get('/items/')\n    def read_items() -> List[Item]:\n        return [Item(name='Portal Gun', description='Device to travel through the multi-rick-verse', sub=SubItem(subname='subname')), Item(name='Plumbus')]\n    client = TestClient(app)\n    return client",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get_app_client` method creates and returns a FastAPI `TestClient` instance configured with specific API endpoints for testing purposes. It allows developers to simulate requests to the API without needing to run the server.\n\n**How It Works**:\n1. **FastAPI Application Creation**: The method initializes a FastAPI application, optionally configuring it to separate input and output schemas based on the `separate_input_output_schemas` parameter.\n2. **Endpoint Definitions**: It defines three endpoints:\n   - `POST /items/`: Accepts an `Item` object and returns it.\n   - `POST /items-list/`: Accepts a list of `Item` objects and returns the same list.\n   - `GET /items/`: Returns a predefined list of `Item` objects.\n3. **TestClient Initialization**: A `TestClient` instance is created using the FastAPI app, enabling the execution of HTTP requests against the defined endpoints.\n4. **Return Value**: The method returns the `TestClient`, which can be used in tests to send requests and validate responses."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_openapi_schema",
            "module": "test_openapi_separate_input_output_schemas",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_openapi_separate_input_output_schemas.py",
            "line_number": 134,
            "end_line_number": 348,
            "source_code": "def test_openapi_schema():\n    client = get_app_client()\n    response = client.get(\"/openapi.json\")\n    assert response.status_code == 200, response.text\n    assert response.json() == {\n        \"openapi\": \"3.1.0\",\n        \"info\": {\"title\": \"FastAPI\", \"version\": \"0.1.0\"},\n        \"paths\": {\n            \"/items/\": {\n                \"get\": {\n                    \"summary\": \"Read Items\",\n                    \"operationId\": \"read_items_items__get\",\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"items\": {\n                                            \"$ref\": \"#/components/schemas/Item-Output\"\n                                        },\n                                        \"type\": \"array\",\n                                        \"title\": \"Response Read Items Items  Get\",\n                                    }\n                                }\n                            },\n                        }\n                    },\n                },\n                \"post\": {\n                    \"summary\": \"Create Item\",\n                    \"operationId\": \"create_item_items__post\",\n                    \"requestBody\": {\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\"$ref\": \"#/components/schemas/Item-Input\"}\n                            }\n                        },\n                        \"required\": True,\n                    },\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/Item-Output\"\n                                    }\n                                }\n                            },\n                        },\n                        \"402\": {\n                            \"description\": \"Payment Required\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/Item-Output\"\n                                    }\n                                }\n                            },\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                },\n            },\n            \"/items-list/\": {\n                \"post\": {\n                    \"summary\": \"Create Item List\",\n                    \"operationId\": \"create_item_list_items_list__post\",\n                    \"requestBody\": {\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"items\": {\n                                        \"$ref\": \"#/components/schemas/Item-Input\"\n                                    },\n                                    \"type\": \"array\",\n                                    \"title\": \"Item\",\n                                }\n                            }\n                        },\n                        \"required\": True,\n                    },\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            },\n        },\n        \"components\": {\n            \"schemas\": {\n                \"HTTPValidationError\": {\n                    \"properties\": {\n                        \"detail\": {\n                            \"items\": {\"$ref\": \"#/components/schemas/ValidationError\"},\n                            \"type\": \"array\",\n                            \"title\": \"Detail\",\n                        }\n                    },\n                    \"type\": \"object\",\n                    \"title\": \"HTTPValidationError\",\n                },\n                \"Item-Input\": {\n                    \"properties\": {\n                        \"name\": {\"type\": \"string\", \"title\": \"Name\"},\n                        \"description\": {\n                            \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n                            \"title\": \"Description\",\n                        },\n                        \"sub\": {\n                            \"anyOf\": [\n                                {\"$ref\": \"#/components/schemas/SubItem-Input\"},\n                                {\"type\": \"null\"},\n                            ]\n                        },\n                    },\n                    \"type\": \"object\",\n                    \"required\": [\"name\"],\n                    \"title\": \"Item\",\n                },\n                \"Item-Output\": {\n                    \"properties\": {\n                        \"name\": {\"type\": \"string\", \"title\": \"Name\"},\n                        \"description\": {\n                            \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n                            \"title\": \"Description\",\n                        },\n                        \"sub\": {\n                            \"anyOf\": [\n                                {\"$ref\": \"#/components/schemas/SubItem-Output\"},\n                                {\"type\": \"null\"},\n                            ]\n                        },\n                    },\n                    \"type\": \"object\",\n                    \"required\": [\"name\", \"description\", \"sub\"],\n                    \"title\": \"Item\",\n                },\n                \"SubItem-Input\": {\n                    \"properties\": {\n                        \"subname\": {\"type\": \"string\", \"title\": \"Subname\"},\n                        \"sub_description\": {\n                            \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n                            \"title\": \"Sub Description\",\n                        },\n                        \"tags\": {\n                            \"items\": {\"type\": \"string\"},\n                            \"type\": \"array\",\n                            \"title\": \"Tags\",\n                            \"default\": [],\n                        },\n                    },\n                    \"type\": \"object\",\n                    \"required\": [\"subname\"],\n                    \"title\": \"SubItem\",\n                },\n                \"SubItem-Output\": {\n                    \"properties\": {\n                        \"subname\": {\"type\": \"string\", \"title\": \"Subname\"},\n                        \"sub_description\": {\n                            \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n                            \"title\": \"Sub Description\",\n                        },\n                        \"tags\": {\n                            \"items\": {\"type\": \"string\"},\n                            \"type\": \"array\",\n                            \"title\": \"Tags\",\n                            \"default\": [],\n                        },\n                    },\n                    \"type\": \"object\",\n                    \"required\": [\"subname\", \"sub_description\", \"tags\"],\n                    \"title\": \"SubItem\",\n                },\n                \"ValidationError\": {\n                    \"properties\": {\n                        \"loc\": {\n                            \"items\": {\n                                \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"integer\"}]\n                            },\n                            \"type\": \"array\",\n                            \"title\": \"Location\",\n                        },\n                        \"msg\": {\"type\": \"string\", \"title\": \"Message\"},\n                        \"type\": {\"type\": \"string\", \"title\": \"Error Type\"},\n                    },\n                    \"type\": \"object\",\n                    \"required\": [\"loc\", \"msg\", \"type\"],\n                    \"title\": \"ValidationError\",\n                },\n            }\n        },\n    }",
            "docstring": null,
            "decorators": [
                "needs_pydanticv2"
            ],
            "arguments": [],
            "imports": [
                "typing.List",
                "typing.Optional",
                "fastapi.FastAPI",
                "fastapi.testclient.TestClient",
                "pydantic.BaseModel",
                "utils.PYDANTIC_V2",
                "utils.needs_pydanticv2"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 200, response.text",
                "assert response.json() == {'openapi': '3.1.0', 'info': {'title': 'FastAPI', 'version': '0.1.0'}, 'paths': {'/items/': {'get': {'summary': 'Read Items', 'operationId': 'read_items_items__get', 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {'items': {'$ref': '#/components/schemas/Item-Output'}, 'type': 'array', 'title': 'Response Read Items Items  Get'}}}}}}, 'post': {'summary': 'Create Item', 'operationId': 'create_item_items__post', 'requestBody': {'content': {'application/json': {'schema': {'$ref': '#/components/schemas/Item-Input'}}}, 'required': True}, 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/Item-Output'}}}}, '402': {'description': 'Payment Required', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/Item-Output'}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}, '/items-list/': {'post': {'summary': 'Create Item List', 'operationId': 'create_item_list_items_list__post', 'requestBody': {'content': {'application/json': {'schema': {'items': {'$ref': '#/components/schemas/Item-Input'}, 'type': 'array', 'title': 'Item'}}}, 'required': True}, 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}}, 'components': {'schemas': {'HTTPValidationError': {'properties': {'detail': {'items': {'$ref': '#/components/schemas/ValidationError'}, 'type': 'array', 'title': 'Detail'}}, 'type': 'object', 'title': 'HTTPValidationError'}, 'Item-Input': {'properties': {'name': {'type': 'string', 'title': 'Name'}, 'description': {'anyOf': [{'type': 'string'}, {'type': 'null'}], 'title': 'Description'}, 'sub': {'anyOf': [{'$ref': '#/components/schemas/SubItem-Input'}, {'type': 'null'}]}}, 'type': 'object', 'required': ['name'], 'title': 'Item'}, 'Item-Output': {'properties': {'name': {'type': 'string', 'title': 'Name'}, 'description': {'anyOf': [{'type': 'string'}, {'type': 'null'}], 'title': 'Description'}, 'sub': {'anyOf': [{'$ref': '#/components/schemas/SubItem-Output'}, {'type': 'null'}]}}, 'type': 'object', 'required': ['name', 'description', 'sub'], 'title': 'Item'}, 'SubItem-Input': {'properties': {'subname': {'type': 'string', 'title': 'Subname'}, 'sub_description': {'anyOf': [{'type': 'string'}, {'type': 'null'}], 'title': 'Sub Description'}, 'tags': {'items': {'type': 'string'}, 'type': 'array', 'title': 'Tags', 'default': []}}, 'type': 'object', 'required': ['subname'], 'title': 'SubItem'}, 'SubItem-Output': {'properties': {'subname': {'type': 'string', 'title': 'Subname'}, 'sub_description': {'anyOf': [{'type': 'string'}, {'type': 'null'}], 'title': 'Sub Description'}, 'tags': {'items': {'type': 'string'}, 'type': 'array', 'title': 'Tags', 'default': []}}, 'type': 'object', 'required': ['subname', 'sub_description', 'tags'], 'title': 'SubItem'}, 'ValidationError': {'properties': {'loc': {'items': {'anyOf': [{'type': 'string'}, {'type': 'integer'}]}, 'type': 'array', 'title': 'Location'}, 'msg': {'type': 'string', 'title': 'Message'}, 'type': {'type': 'string', 'title': 'Error Type'}}, 'type': 'object', 'required': ['loc', 'msg', 'type'], 'title': 'ValidationError'}}}}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_app_client",
                    "body": "def get_app_client(separate_input_output_schemas: bool=True) -> TestClient:\n    app = FastAPI(separate_input_output_schemas=separate_input_output_schemas)\n\n    @app.post('/items/', responses={402: {'model': Item}})\n    def create_item(item: Item) -> Item:\n        return item\n\n    @app.post('/items-list/')\n    def create_item_list(item: List[Item]):\n        return item\n\n    @app.get('/items/')\n    def read_items() -> List[Item]:\n        return [Item(name='Portal Gun', description='Device to travel through the multi-rick-verse', sub=SubItem(subname='subname')), Item(name='Plumbus')]\n    client = TestClient(app)\n    return client",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get_app_client` method creates and returns a FastAPI `TestClient` instance configured with specific API endpoints for testing purposes. It allows developers to simulate requests to the API without needing to run the server.\n\n**How It Works**:\n1. **FastAPI Application Creation**: The method initializes a FastAPI application, optionally configuring it to separate input and output schemas based on the `separate_input_output_schemas` parameter.\n2. **Endpoint Definitions**: It defines three endpoints:\n   - `POST /items/`: Accepts an `Item` object and returns it.\n   - `POST /items-list/`: Accepts a list of `Item` objects and returns the same list.\n   - `GET /items/`: Returns a predefined list of `Item` objects.\n3. **TestClient Initialization**: A `TestClient` is created using the FastAPI app, enabling the execution of HTTP requests against the defined endpoints.\n4. **Return Value**: The method returns the `TestClient`, which can be used in tests to send requests and assert responses. \n\nThis setup is particularly useful for unit testing API endpoints in a controlled environment."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_openapi_schema_no_separate",
            "module": "test_openapi_separate_input_output_schemas",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_openapi_separate_input_output_schemas.py",
            "line_number": 352,
            "end_line_number": 522,
            "source_code": "def test_openapi_schema_no_separate():\n    client = get_app_client(separate_input_output_schemas=False)\n    response = client.get(\"/openapi.json\")\n    assert response.status_code == 200, response.text\n    assert response.json() == {\n        \"openapi\": \"3.1.0\",\n        \"info\": {\"title\": \"FastAPI\", \"version\": \"0.1.0\"},\n        \"paths\": {\n            \"/items/\": {\n                \"get\": {\n                    \"summary\": \"Read Items\",\n                    \"operationId\": \"read_items_items__get\",\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"items\": {\"$ref\": \"#/components/schemas/Item\"},\n                                        \"type\": \"array\",\n                                        \"title\": \"Response Read Items Items  Get\",\n                                    }\n                                }\n                            },\n                        }\n                    },\n                },\n                \"post\": {\n                    \"summary\": \"Create Item\",\n                    \"operationId\": \"create_item_items__post\",\n                    \"requestBody\": {\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\"$ref\": \"#/components/schemas/Item\"}\n                            }\n                        },\n                        \"required\": True,\n                    },\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\"$ref\": \"#/components/schemas/Item\"}\n                                }\n                            },\n                        },\n                        \"402\": {\n                            \"description\": \"Payment Required\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\"$ref\": \"#/components/schemas/Item\"}\n                                }\n                            },\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                },\n            },\n            \"/items-list/\": {\n                \"post\": {\n                    \"summary\": \"Create Item List\",\n                    \"operationId\": \"create_item_list_items_list__post\",\n                    \"requestBody\": {\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"items\": {\"$ref\": \"#/components/schemas/Item\"},\n                                    \"type\": \"array\",\n                                    \"title\": \"Item\",\n                                }\n                            }\n                        },\n                        \"required\": True,\n                    },\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                }\n            },\n        },\n        \"components\": {\n            \"schemas\": {\n                \"HTTPValidationError\": {\n                    \"properties\": {\n                        \"detail\": {\n                            \"items\": {\"$ref\": \"#/components/schemas/ValidationError\"},\n                            \"type\": \"array\",\n                            \"title\": \"Detail\",\n                        }\n                    },\n                    \"type\": \"object\",\n                    \"title\": \"HTTPValidationError\",\n                },\n                \"Item\": {\n                    \"properties\": {\n                        \"name\": {\"type\": \"string\", \"title\": \"Name\"},\n                        \"description\": {\n                            \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n                            \"title\": \"Description\",\n                        },\n                        \"sub\": {\n                            \"anyOf\": [\n                                {\"$ref\": \"#/components/schemas/SubItem\"},\n                                {\"type\": \"null\"},\n                            ]\n                        },\n                    },\n                    \"type\": \"object\",\n                    \"required\": [\"name\"],\n                    \"title\": \"Item\",\n                },\n                \"SubItem\": {\n                    \"properties\": {\n                        \"subname\": {\"type\": \"string\", \"title\": \"Subname\"},\n                        \"sub_description\": {\n                            \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n                            \"title\": \"Sub Description\",\n                        },\n                        \"tags\": {\n                            \"items\": {\"type\": \"string\"},\n                            \"type\": \"array\",\n                            \"title\": \"Tags\",\n                            \"default\": [],\n                        },\n                    },\n                    \"type\": \"object\",\n                    \"required\": [\"subname\"],\n                    \"title\": \"SubItem\",\n                },\n                \"ValidationError\": {\n                    \"properties\": {\n                        \"loc\": {\n                            \"items\": {\n                                \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"integer\"}]\n                            },\n                            \"type\": \"array\",\n                            \"title\": \"Location\",\n                        },\n                        \"msg\": {\"type\": \"string\", \"title\": \"Message\"},\n                        \"type\": {\"type\": \"string\", \"title\": \"Error Type\"},\n                    },\n                    \"type\": \"object\",\n                    \"required\": [\"loc\", \"msg\", \"type\"],\n                    \"title\": \"ValidationError\",\n                },\n            }\n        },\n    }",
            "docstring": null,
            "decorators": [
                "needs_pydanticv2"
            ],
            "arguments": [],
            "imports": [
                "typing.List",
                "typing.Optional",
                "fastapi.FastAPI",
                "fastapi.testclient.TestClient",
                "pydantic.BaseModel",
                "utils.PYDANTIC_V2",
                "utils.needs_pydanticv2"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 200, response.text",
                "assert response.json() == {'openapi': '3.1.0', 'info': {'title': 'FastAPI', 'version': '0.1.0'}, 'paths': {'/items/': {'get': {'summary': 'Read Items', 'operationId': 'read_items_items__get', 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {'items': {'$ref': '#/components/schemas/Item'}, 'type': 'array', 'title': 'Response Read Items Items  Get'}}}}}}, 'post': {'summary': 'Create Item', 'operationId': 'create_item_items__post', 'requestBody': {'content': {'application/json': {'schema': {'$ref': '#/components/schemas/Item'}}}, 'required': True}, 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/Item'}}}}, '402': {'description': 'Payment Required', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/Item'}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}, '/items-list/': {'post': {'summary': 'Create Item List', 'operationId': 'create_item_list_items_list__post', 'requestBody': {'content': {'application/json': {'schema': {'items': {'$ref': '#/components/schemas/Item'}, 'type': 'array', 'title': 'Item'}}}, 'required': True}, 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}, '422': {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': '#/components/schemas/HTTPValidationError'}}}}}}}}, 'components': {'schemas': {'HTTPValidationError': {'properties': {'detail': {'items': {'$ref': '#/components/schemas/ValidationError'}, 'type': 'array', 'title': 'Detail'}}, 'type': 'object', 'title': 'HTTPValidationError'}, 'Item': {'properties': {'name': {'type': 'string', 'title': 'Name'}, 'description': {'anyOf': [{'type': 'string'}, {'type': 'null'}], 'title': 'Description'}, 'sub': {'anyOf': [{'$ref': '#/components/schemas/SubItem'}, {'type': 'null'}]}}, 'type': 'object', 'required': ['name'], 'title': 'Item'}, 'SubItem': {'properties': {'subname': {'type': 'string', 'title': 'Subname'}, 'sub_description': {'anyOf': [{'type': 'string'}, {'type': 'null'}], 'title': 'Sub Description'}, 'tags': {'items': {'type': 'string'}, 'type': 'array', 'title': 'Tags', 'default': []}}, 'type': 'object', 'required': ['subname'], 'title': 'SubItem'}, 'ValidationError': {'properties': {'loc': {'items': {'anyOf': [{'type': 'string'}, {'type': 'integer'}]}, 'type': 'array', 'title': 'Location'}, 'msg': {'type': 'string', 'title': 'Message'}, 'type': {'type': 'string', 'title': 'Error Type'}}, 'type': 'object', 'required': ['loc', 'msg', 'type'], 'title': 'ValidationError'}}}}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_app_client",
                    "body": "def get_app_client(separate_input_output_schemas: bool=True) -> TestClient:\n    app = FastAPI(separate_input_output_schemas=separate_input_output_schemas)\n\n    @app.post('/items/', responses={402: {'model': Item}})\n    def create_item(item: Item) -> Item:\n        return item\n\n    @app.post('/items-list/')\n    def create_item_list(item: List[Item]):\n        return item\n\n    @app.get('/items/')\n    def read_items() -> List[Item]:\n        return [Item(name='Portal Gun', description='Device to travel through the multi-rick-verse', sub=SubItem(subname='subname')), Item(name='Plumbus')]\n    client = TestClient(app)\n    return client",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get_app_client` method creates and returns a FastAPI `TestClient` instance configured with specific API endpoints for testing purposes. It allows developers to simulate requests to the FastAPI application without needing to run the server.\n\n**How It Works**:\n1. **Initialization**: The method accepts a boolean parameter `separate_input_output_schemas`, which determines whether to separate input and output schemas in the OpenAPI documentation.\n2. **FastAPI App Creation**: A FastAPI application instance is created with the specified schema configuration.\n3. **Endpoint Definitions**:\n   - A POST endpoint `/items/` is defined to create an `Item` and return it.\n   - A POST endpoint `/items-list/` is defined to accept a list of `Item` objects and return them.\n   - A GET endpoint `/items/` is defined to return a predefined list of `Item` objects.\n4. **TestClient Creation**: A `TestClient` instance is created using the FastAPI app, enabling the execution of HTTP requests against the defined endpoints.\n5. **Return**: The method returns the `TestClient`, which can be used in tests to interact with the API. \n\nThis setup is particularly useful for unit testing API endpoints in a controlled environment."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_ws",
            "module": "test_tutorial002",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_testing/test_tutorial002.py",
            "line_number": 8,
            "end_line_number": 9,
            "source_code": "def test_ws():\n    test_websocket()",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "docs_src.app_testing.tutorial002.test_read_main",
                "docs_src.app_testing.tutorial002.test_websocket"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "test_websocket",
                    "body": "def test_websocket():\n    with client.websocket_connect('/items/portal-gun') as websocket:\n        data = websocket.receive_json()\n        assert data == {'item_id': 'portal-gun', 'path': '/items/{item_id}'}",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `test_websocket` method is designed to test the WebSocket connection functionality of a FastAPI application. It verifies that when a WebSocket connection is established to a specific endpoint, the server sends back the expected JSON response.\n\n**How It Works**:  \n1. A `TestClient` instance is created to simulate requests to the FastAPI application.\n2. The method establishes a WebSocket connection to the `/ws` endpoint using `client.websocket_connect()`.\n3. It then waits to receive a JSON message from the server using `websocket.receive_json()`.\n4. Finally, it asserts that the received data matches the expected JSON object `{\"msg\": \"Hello WebSocket\"}`, ensuring that the WebSocket communication is functioning correctly."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_app",
            "module": "test_main_b_an_py39",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_testing/test_main_b_an_py39.py",
            "line_number": 5,
            "end_line_number": 13,
            "source_code": "def test_app():\n    from docs_src.app_testing.app_b_an_py39 import test_main\n\n    test_main.test_create_existing_item()\n    test_main.test_create_item()\n    test_main.test_create_item_bad_token()\n    test_main.test_read_nonexistent_item()\n    test_main.test_read_item()\n    test_main.test_read_item_bad_token()",
            "docstring": null,
            "decorators": [
                "needs_py39"
            ],
            "arguments": [],
            "imports": [
                "utils.needs_py39",
                "docs_src.app_testing.app_b_an_py39.test_main"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "test_main.test_create_item",
                    "body": "def test_create_item():\n    client = get_app_client()\n    client_no = get_app_client(separate_input_output_schemas=False)\n    response = client.post('/items/', json={'name': 'Plumbus'})\n    response2 = client_no.post('/items/', json={'name': 'Plumbus'})\n    assert response.status_code == response2.status_code == 200, response.text\n    assert response.json() == response2.json() == {'name': 'Plumbus', 'description': None, 'sub': None}",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `test_create_item` method is designed to verify the functionality of creating an item through a web API. It checks that the API correctly processes a POST request to create an item and returns the expected status and response data.\n\n**How It Works**:\n1. The method initializes two clients using `get_app_client()`, one for standard input/output schema handling and another with `separate_input_output_schemas` set to `False`.\n2. It sends a POST request to the `/items/` endpoint with a JSON payload containing the item name \"Plumbus\".\n3. A second POST request is sent using the second client with the same payload.\n4. The method asserts that both responses have a status code of 200, indicating success.\n5. It also checks that the JSON responses from both requests are identical, confirming that the API behaves consistently regardless of the client configuration. The expected response includes the item name and default values for description and sub."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_app",
            "module": "test_main_b_an",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_testing/test_main_b_an.py",
            "line_number": 4,
            "end_line_number": 10,
            "source_code": "def test_app():\n    test_main.test_create_existing_item()\n    test_main.test_create_item()\n    test_main.test_create_item_bad_token()\n    test_main.test_read_nonexistent_item()\n    test_main.test_read_item()\n    test_main.test_read_item_bad_token()",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "docs_src.app_testing.app_b_an.test_main"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "test_main.test_create_item",
                    "body": "def test_create_item():\n    client = get_app_client()\n    client_no = get_app_client(separate_input_output_schemas=False)\n    response = client.post('/items/', json={'name': 'Plumbus'})\n    response2 = client_no.post('/items/', json={'name': 'Plumbus'})\n    assert response.status_code == response2.status_code == 200, response.text\n    assert response.json() == response2.json() == {'name': 'Plumbus', 'description': None, 'sub': None}",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `test_create_item` method is designed to verify the functionality of creating an item through a web API endpoint. It ensures that the API correctly processes a request to create an item and returns the expected response.\n\n**How It Works**:\n1. The method initializes two clients using `get_app_client()`, one for standard input/output schema handling and another with `separate_input_output_schemas` set to `False`.\n2. It sends a POST request to the `/items/` endpoint with a JSON payload containing the item name \"Plumbus\".\n3. A second POST request is sent using the second client with the same payload.\n4. The method asserts that both responses have a status code of 200, indicating success.\n5. It also checks that the JSON responses from both requests are identical, confirming that the API behaves consistently regardless of the client configuration. The expected response includes the item name and default values for description and sub."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_app",
            "module": "test_main_b",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_testing/test_main_b.py",
            "line_number": 4,
            "end_line_number": 10,
            "source_code": "def test_app():\n    test_main.test_create_existing_item()\n    test_main.test_create_item()\n    test_main.test_create_item_bad_token()\n    test_main.test_read_nonexistent_item()\n    test_main.test_read_item()\n    test_main.test_read_item_bad_token()",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "docs_src.app_testing.app_b.test_main"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "test_main.test_create_item",
                    "body": "def test_create_item():\n    client = get_app_client()\n    client_no = get_app_client(separate_input_output_schemas=False)\n    response = client.post('/items/', json={'name': 'Plumbus'})\n    response2 = client_no.post('/items/', json={'name': 'Plumbus'})\n    assert response.status_code == response2.status_code == 200, response.text\n    assert response.json() == response2.json() == {'name': 'Plumbus', 'description': None, 'sub': None}",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `test_create_item` method is designed to verify the functionality of creating an item through a web API endpoint. It ensures that the API correctly processes a request to create an item and returns the expected response.\n\n**How It Works**:\n1. The method initializes two clients using `get_app_client()`, one for standard input/output schema handling and another with `separate_input_output_schemas` set to `False`.\n2. It sends a POST request to the `/items/` endpoint with a JSON payload containing the item name \"Plumbus\".\n3. A second POST request is sent using the second client with the same payload.\n4. The method asserts that both responses have a status code of 200, indicating success.\n5. It also checks that the JSON responses from both requests are identical, confirming that the API behaves consistently regardless of the client configuration. The expected response includes the item name and default values for description and sub."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_main",
            "module": "test_tutorial003",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_testing/test_tutorial003.py",
            "line_number": 4,
            "end_line_number": 7,
            "source_code": "def test_main():\n    with pytest.warns(DeprecationWarning):\n        from docs_src.app_testing.tutorial003 import test_read_items\n    test_read_items()",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "pytest",
                "docs_src.app_testing.tutorial003.test_read_items"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "test_read_items",
                    "body": "def test_read_items():\n    client = get_app_client()\n    client_no = get_app_client(separate_input_output_schemas=False)\n    response = client.get('/items/')\n    response2 = client_no.get('/items/')\n    assert response.status_code == response2.status_code == 200, response.text\n    assert response.json() == response2.json() == [{'name': 'Portal Gun', 'description': 'Device to travel through the multi-rick-verse', 'sub': {'subname': 'subname', 'sub_description': None, 'tags': []}}, {'name': 'Plumbus', 'description': None, 'sub': None}]",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `test_read_items` method is designed to verify that the API endpoint `/items/` returns the expected HTTP status code and JSON response structure when accessed by two different clients. It ensures that both clients, regardless of their configuration, receive consistent results.\n\n**How It Works**:\n1. Two clients are created using the `get_app_client()` function: `client` and `client_no`. The second client is configured with `separate_input_output_schemas=False`, which may affect how data is processed.\n2. Both clients send a GET request to the `/items/` endpoint.\n3. The method asserts that both responses have a status code of 200, indicating a successful request. If the status codes differ, the response text is provided for debugging.\n4. It then checks that the JSON responses from both clients are identical and match the expected list of items, which includes details about \"Portal Gun\" and \"Plumbus\". This ensures that the API behaves consistently across different client configurations."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_app",
            "module": "test_main_b_an_py310",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_testing/test_main_b_an_py310.py",
            "line_number": 5,
            "end_line_number": 13,
            "source_code": "def test_app():\n    from docs_src.app_testing.app_b_an_py310 import test_main\n\n    test_main.test_create_existing_item()\n    test_main.test_create_item()\n    test_main.test_create_item_bad_token()\n    test_main.test_read_nonexistent_item()\n    test_main.test_read_item()\n    test_main.test_read_item_bad_token()",
            "docstring": null,
            "decorators": [
                "needs_py310"
            ],
            "arguments": [],
            "imports": [
                "utils.needs_py310",
                "docs_src.app_testing.app_b_an_py310.test_main"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "test_main.test_create_item",
                    "body": "def test_create_item():\n    client = get_app_client()\n    client_no = get_app_client(separate_input_output_schemas=False)\n    response = client.post('/items/', json={'name': 'Plumbus'})\n    response2 = client_no.post('/items/', json={'name': 'Plumbus'})\n    assert response.status_code == response2.status_code == 200, response.text\n    assert response.json() == response2.json() == {'name': 'Plumbus', 'description': None, 'sub': None}",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `test_create_item` method is designed to verify the functionality of creating an item through a web API. It checks that the API correctly processes a POST request to create an item and returns the expected status and response data.\n\n**How It Works**:\n1. The method initializes two clients using `get_app_client()`, one for standard input/output schema handling and another with `separate_input_output_schemas` set to `False`.\n2. It sends a POST request to the `/items/` endpoint with a JSON payload containing the item name \"Plumbus\".\n3. A second POST request is sent using the second client with the same payload.\n4. The method asserts that both responses have a status code of 200, indicating success.\n5. It also checks that the JSON responses from both requests are identical, confirming that the API behaves consistently regardless of the client configuration. The expected response includes the item name and default values for description and sub."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_app",
            "module": "test_main_b_py310",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_testing/test_main_b_py310.py",
            "line_number": 5,
            "end_line_number": 13,
            "source_code": "def test_app():\n    from docs_src.app_testing.app_b_py310 import test_main\n\n    test_main.test_create_existing_item()\n    test_main.test_create_item()\n    test_main.test_create_item_bad_token()\n    test_main.test_read_nonexistent_item()\n    test_main.test_read_item()\n    test_main.test_read_item_bad_token()",
            "docstring": null,
            "decorators": [
                "needs_py310"
            ],
            "arguments": [],
            "imports": [
                "utils.needs_py310",
                "docs_src.app_testing.app_b_py310.test_main"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "test_main.test_create_item",
                    "body": "def test_create_item():\n    client = get_app_client()\n    client_no = get_app_client(separate_input_output_schemas=False)\n    response = client.post('/items/', json={'name': 'Plumbus'})\n    response2 = client_no.post('/items/', json={'name': 'Plumbus'})\n    assert response.status_code == response2.status_code == 200, response.text\n    assert response.json() == response2.json() == {'name': 'Plumbus', 'description': None, 'sub': None}",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `test_create_item` method is designed to verify the functionality of creating an item through a web API endpoint. It ensures that the API correctly processes a request to create an item and returns the expected response.\n\n**How It Works**:\n1. The method initializes two clients using `get_app_client()`, one for standard input/output schema handling and another with `separate_input_output_schemas` set to `False`.\n2. It sends a POST request to the `/items/` endpoint with a JSON payload containing the item name \"Plumbus\".\n3. A second POST request is sent using the second client with the same payload.\n4. The method asserts that both responses have a status code of 200, indicating success.\n5. It also checks that the JSON responses from both requests are identical, confirming that the API behaves consistently regardless of the client configuration. The expected response includes the item name and default values for description and sub."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_disable_openapi",
            "module": "test_tutorial001",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_conditional_openapi/test_tutorial001.py",
            "line_number": 18,
            "end_line_number": 27,
            "source_code": "def test_disable_openapi(monkeypatch):\n    monkeypatch.setenv(\"OPENAPI_URL\", \"\")\n    # Load the client after setting the env var\n    client = get_client()\n    response = client.get(\"/openapi.json\")\n    assert response.status_code == 404, response.text\n    response = client.get(\"/docs\")\n    assert response.status_code == 404, response.text\n    response = client.get(\"/redoc\")\n    assert response.status_code == 404, response.text",
            "docstring": null,
            "decorators": [
                "needs_pydanticv2"
            ],
            "arguments": [
                "monkeypatch"
            ],
            "imports": [
                "importlib",
                "fastapi.testclient.TestClient",
                "utils.needs_pydanticv2",
                "docs_src.conditional_openapi.tutorial001"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 404, response.text",
                "assert response.status_code == 404, response.text",
                "assert response.status_code == 404, response.text"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_client",
                    "body": "@pytest.fixture(name='client')\ndef get_client():\n    app = FastAPI()\n    from pydantic import BaseModel, computed_field\n\n    class Rectangle(BaseModel):\n        width: int\n        length: int\n\n        @computed_field\n        @property\n        def area(self) -> int:\n            return self.width * self.length\n\n    @app.get('/')\n    def read_root() -> Rectangle:\n        return Rectangle(width=3, length=4)\n\n    @app.get('/responses', responses={200: {'model': Rectangle}})\n    def read_responses() -> Rectangle:\n        return Rectangle(width=3, length=4)\n    client = TestClient(app)\n    return client",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get_client` method is a pytest fixture that sets up a FastAPI application and returns a TestClient instance for testing API endpoints. It defines a simple API with endpoints that return a `Rectangle` model, allowing for easy testing of the API's functionality.\n\n**How It Works**:\n1. **FastAPI Application Creation**: The method initializes a FastAPI application instance.\n2. **Model Definition**: It defines a `Rectangle` class using Pydantic's `BaseModel`, which includes properties for `width`, `length`, and a computed property `area` that calculates the rectangle's area.\n3. **API Endpoints**: Two GET endpoints are defined:\n   - The root endpoint (`/`) returns a `Rectangle` instance with predefined dimensions.\n   - The `/responses` endpoint also returns a `Rectangle` instance, explicitly specifying the response model.\n4. **TestClient Initialization**: A `TestClient` is created using the FastAPI app, which allows for simulating requests to the API during tests.\n5. **Return Value**: The method returns the `TestClient`, enabling tests to interact with the API endpoints defined in the FastAPI application. \n\nThis setup is useful for unit testing the API's behavior and ensuring that the endpoints return the expected results."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_root",
            "module": "test_tutorial001",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_conditional_openapi/test_tutorial001.py",
            "line_number": 31,
            "end_line_number": 35,
            "source_code": "def test_root():\n    client = get_client()\n    response = client.get(\"/\")\n    assert response.status_code == 200\n    assert response.json() == {\"message\": \"Hello World\"}",
            "docstring": null,
            "decorators": [
                "needs_pydanticv2"
            ],
            "arguments": [],
            "imports": [
                "importlib",
                "fastapi.testclient.TestClient",
                "utils.needs_pydanticv2",
                "docs_src.conditional_openapi.tutorial001"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 200",
                "assert response.json() == {'message': 'Hello World'}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_client",
                    "body": "@pytest.fixture(name='client')\ndef get_client():\n    app = FastAPI()\n    from pydantic import BaseModel, computed_field\n\n    class Rectangle(BaseModel):\n        width: int\n        length: int\n\n        @computed_field\n        @property\n        def area(self) -> int:\n            return self.width * self.length\n\n    @app.get('/')\n    def read_root() -> Rectangle:\n        return Rectangle(width=3, length=4)\n\n    @app.get('/responses', responses={200: {'model': Rectangle}})\n    def read_responses() -> Rectangle:\n        return Rectangle(width=3, length=4)\n    client = TestClient(app)\n    return client",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get_client` method is a pytest fixture that sets up a FastAPI application and returns a TestClient instance for testing API endpoints. It defines a simple API with endpoints that return a `Rectangle` model, allowing for easy testing of the API's functionality.\n\n**How It Works**:\n1. **FastAPI Application Creation**: The method initializes a FastAPI application instance.\n2. **Model Definition**: It defines a `Rectangle` class using Pydantic's `BaseModel`, which includes properties for `width`, `length`, and a computed property `area` that calculates the rectangle's area.\n3. **API Endpoints**: Two GET endpoints are defined:\n   - The root endpoint (`/`) returns a `Rectangle` instance with predefined dimensions.\n   - The `/responses` endpoint also returns a `Rectangle` instance, explicitly specifying the response model.\n4. **TestClient Initialization**: A `TestClient` is created using the FastAPI app, enabling the execution of HTTP requests against the defined endpoints.\n5. **Return Value**: The method returns the `TestClient`, which can be used in tests to simulate requests and validate responses. \n\nThis setup allows developers to easily test the API's behavior and ensure that it returns the expected data structures."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_default_openapi",
            "module": "test_tutorial001",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_conditional_openapi/test_tutorial001.py",
            "line_number": 39,
            "end_line_number": 63,
            "source_code": "def test_default_openapi():\n    client = get_client()\n    response = client.get(\"/docs\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/redoc\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/openapi.json\")\n    assert response.json() == {\n        \"openapi\": \"3.1.0\",\n        \"info\": {\"title\": \"FastAPI\", \"version\": \"0.1.0\"},\n        \"paths\": {\n            \"/\": {\n                \"get\": {\n                    \"summary\": \"Root\",\n                    \"operationId\": \"root__get\",\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        }\n                    },\n                }\n            }\n        },\n    }",
            "docstring": null,
            "decorators": [
                "needs_pydanticv2"
            ],
            "arguments": [],
            "imports": [
                "importlib",
                "fastapi.testclient.TestClient",
                "utils.needs_pydanticv2",
                "docs_src.conditional_openapi.tutorial001"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 200, response.text",
                "assert response.status_code == 200, response.text",
                "assert response.json() == {'openapi': '3.1.0', 'info': {'title': 'FastAPI', 'version': '0.1.0'}, 'paths': {'/': {'get': {'summary': 'Root', 'operationId': 'root__get', 'responses': {'200': {'description': 'Successful Response', 'content': {'application/json': {'schema': {}}}}}}}}}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_client",
                    "body": "@pytest.fixture(name='client')\ndef get_client():\n    app = FastAPI()\n    from pydantic import BaseModel, computed_field\n\n    class Rectangle(BaseModel):\n        width: int\n        length: int\n\n        @computed_field\n        @property\n        def area(self) -> int:\n            return self.width * self.length\n\n    @app.get('/')\n    def read_root() -> Rectangle:\n        return Rectangle(width=3, length=4)\n\n    @app.get('/responses', responses={200: {'model': Rectangle}})\n    def read_responses() -> Rectangle:\n        return Rectangle(width=3, length=4)\n    client = TestClient(app)\n    return client",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get_client` method is a pytest fixture that sets up a FastAPI application and returns a TestClient instance for testing API endpoints. It defines a simple API with endpoints that return a `Rectangle` model, allowing for easy testing of the API's functionality.\n\n**How It Works**:\n1. **FastAPI Application Creation**: The method initializes a FastAPI application instance.\n2. **Model Definition**: It defines a `Rectangle` class using Pydantic's `BaseModel`, which includes properties for `width`, `length`, and a computed property `area` that calculates the rectangle's area.\n3. **API Endpoints**: Two GET endpoints are defined:\n   - The root endpoint (`/`) returns a `Rectangle` instance with predefined dimensions.\n   - The `/responses` endpoint also returns a `Rectangle` instance, explicitly specifying the response model.\n4. **TestClient Initialization**: A `TestClient` is created using the FastAPI app, which allows for simulating requests to the API during tests.\n5. **Return Value**: The method returns the `TestClient`, enabling tests to interact with the API endpoints defined in the FastAPI application. \n\nThis setup is particularly useful for unit testing the API's behavior and ensuring that the endpoints return the expected results."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_override_settings",
            "module": "test_app02",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_settings/test_app02.py",
            "line_number": 17,
            "end_line_number": 20,
            "source_code": "def test_override_settings():\n    from docs_src.settings.app02 import test_main\n\n    test_main.test_app()",
            "docstring": null,
            "decorators": [
                "needs_pydanticv2"
            ],
            "arguments": [],
            "imports": [
                "pytest.MonkeyPatch",
                "utils.needs_pydanticv2",
                "docs_src.settings.app02.main",
                "docs_src.settings.app02.test_main"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "test_main.test_app",
                    "body": "def test_app():\n    with client:\n        response = client.get('/')\n    assert response.json() == {'msg': 'Hello World'}\n    assert response.headers['content-type'] == json_type",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `test_app` method is designed to verify the functionality of the root endpoint (`/`) of a FastAPI application. It checks that the response is as expected, specifically that it returns a JSON object with a message and the correct content type.\n\n**How It Works**:\n1. The method uses a context manager (`with client:`) to ensure that the test client is properly set up for making requests to the FastAPI application.\n2. It sends a GET request to the root endpoint (`/`) using `client.get('/')`.\n3. The response is then validated with two assertions:\n   - It checks that the JSON response matches the expected dictionary `{'msg': 'Hello World'}`.\n   - It verifies that the `content-type` header of the response matches a predefined variable `json_type`, ensuring the response is in the correct format."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_token",
            "module": "test_tutorial005_an_py39",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an_py39.py",
            "line_number": 62,
            "end_line_number": 73,
            "source_code": "def test_token(client: TestClient):\n    access_token = get_access_token(scope=\"me\", client=client)\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == {\n        \"username\": \"johndoe\",\n        \"full_name\": \"John Doe\",\n        \"email\": \"johndoe@example.com\",\n        \"disabled\": False,\n    }",
            "docstring": null,
            "decorators": [
                "needs_py39"
            ],
            "arguments": [
                "client"
            ],
            "imports": [
                "pytest",
                "dirty_equals.IsDict",
                "dirty_equals.IsOneOf",
                "fastapi.testclient.TestClient",
                "utils.needs_py39",
                "docs_src.security.tutorial005_an_py39.app",
                "docs_src.security.tutorial005_an_py39.fake_users_db",
                "docs_src.security.tutorial005_an_py39.verify_password",
                "docs_src.security.tutorial005_an_py39.get_password_hash",
                "docs_src.security.tutorial005_an_py39.create_access_token"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 200, response.text",
                "assert response.json() == {'username': 'johndoe', 'full_name': 'John Doe', 'email': 'johndoe@example.com', 'disabled': False}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_access_token",
                    "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint (`/token`). This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, adding the scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the credentials. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating further API requests. If the credentials are invalid or the request fails, the method will not return a valid token."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_token_no_scope",
            "module": "test_tutorial005_an_py39",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an_py39.py",
            "line_number": 143,
            "end_line_number": 150,
            "source_code": "def test_token_no_scope(client: TestClient):\n    access_token = get_access_token(client=client)\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 401, response.text\n    assert response.json() == {\"detail\": \"Not enough permissions\"}\n    assert response.headers[\"WWW-Authenticate\"] == 'Bearer scope=\"me\"'",
            "docstring": null,
            "decorators": [
                "needs_py39"
            ],
            "arguments": [
                "client"
            ],
            "imports": [
                "pytest",
                "dirty_equals.IsDict",
                "dirty_equals.IsOneOf",
                "fastapi.testclient.TestClient",
                "utils.needs_py39",
                "docs_src.security.tutorial005_an_py39.app",
                "docs_src.security.tutorial005_an_py39.fake_users_db",
                "docs_src.security.tutorial005_an_py39.verify_password",
                "docs_src.security.tutorial005_an_py39.get_password_hash",
                "docs_src.security.tutorial005_an_py39.create_access_token"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 401, response.text",
                "assert response.json() == {'detail': 'Not enough permissions'}",
                "assert response.headers['WWW-Authenticate'] == 'Bearer scope=\"me\"'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_access_token",
                    "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally adds a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating further API requests."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_token_inactive_user",
            "module": "test_tutorial005_an_py39",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an_py39.py",
            "line_number": 167,
            "end_line_number": 175,
            "source_code": "def test_token_inactive_user(client: TestClient):\n    access_token = get_access_token(\n        username=\"alice\", password=\"secretalice\", scope=\"me\", client=client\n    )\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 400, response.text\n    assert response.json() == {\"detail\": \"Inactive user\"}",
            "docstring": null,
            "decorators": [
                "needs_py39"
            ],
            "arguments": [
                "client"
            ],
            "imports": [
                "pytest",
                "dirty_equals.IsDict",
                "dirty_equals.IsOneOf",
                "fastapi.testclient.TestClient",
                "utils.needs_py39",
                "docs_src.security.tutorial005_an_py39.app",
                "docs_src.security.tutorial005_an_py39.fake_users_db",
                "docs_src.security.tutorial005_an_py39.verify_password",
                "docs_src.security.tutorial005_an_py39.get_password_hash",
                "docs_src.security.tutorial005_an_py39.create_access_token"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 400, response.text",
                "assert response.json() == {'detail': 'Inactive user'}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_access_token",
                    "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally adds a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating further API requests. If the credentials are incorrect or the request fails, the method will not return a valid token."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_read_items",
            "module": "test_tutorial005_an_py39",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an_py39.py",
            "line_number": 179,
            "end_line_number": 185,
            "source_code": "def test_read_items(client: TestClient):\n    access_token = get_access_token(scope=\"me items\", client=client)\n    response = client.get(\n        \"/users/me/items/\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == [{\"item_id\": \"Foo\", \"owner\": \"johndoe\"}]",
            "docstring": null,
            "decorators": [
                "needs_py39"
            ],
            "arguments": [
                "client"
            ],
            "imports": [
                "pytest",
                "dirty_equals.IsDict",
                "dirty_equals.IsOneOf",
                "fastapi.testclient.TestClient",
                "utils.needs_py39",
                "docs_src.security.tutorial005_an_py39.app",
                "docs_src.security.tutorial005_an_py39.fake_users_db",
                "docs_src.security.tutorial005_an_py39.verify_password",
                "docs_src.security.tutorial005_an_py39.get_password_hash",
                "docs_src.security.tutorial005_an_py39.create_access_token"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 200, response.text",
                "assert response.json() == [{'item_id': 'Foo', 'owner': 'johndoe'}]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_access_token",
                    "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint (`/token`). This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, adding the scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the credentials. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating further API requests. If the credentials are invalid or the request fails, the method will not return a valid token."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_read_system_status",
            "module": "test_tutorial005_an_py39",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an_py39.py",
            "line_number": 189,
            "end_line_number": 195,
            "source_code": "def test_read_system_status(client: TestClient):\n    access_token = get_access_token(client=client)\n    response = client.get(\n        \"/status/\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == {\"status\": \"ok\"}",
            "docstring": null,
            "decorators": [
                "needs_py39"
            ],
            "arguments": [
                "client"
            ],
            "imports": [
                "pytest",
                "dirty_equals.IsDict",
                "dirty_equals.IsOneOf",
                "fastapi.testclient.TestClient",
                "utils.needs_py39",
                "docs_src.security.tutorial005_an_py39.app",
                "docs_src.security.tutorial005_an_py39.fake_users_db",
                "docs_src.security.tutorial005_an_py39.verify_password",
                "docs_src.security.tutorial005_an_py39.get_password_hash",
                "docs_src.security.tutorial005_an_py39.create_access_token"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 200, response.text",
                "assert response.json() == {'status': 'ok'}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_access_token",
                    "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint (`/token`). This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, adding the scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the credentials. Upon receiving the response, it parses the JSON content to extract the `access_token`, which is returned for use in authenticating further API requests."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_token",
            "module": "test_tutorial005_py39",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_py39.py",
            "line_number": 62,
            "end_line_number": 73,
            "source_code": "def test_token(client: TestClient):\n    access_token = get_access_token(scope=\"me\", client=client)\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == {\n        \"username\": \"johndoe\",\n        \"full_name\": \"John Doe\",\n        \"email\": \"johndoe@example.com\",\n        \"disabled\": False,\n    }",
            "docstring": null,
            "decorators": [
                "needs_py39"
            ],
            "arguments": [
                "client"
            ],
            "imports": [
                "pytest",
                "dirty_equals.IsDict",
                "dirty_equals.IsOneOf",
                "fastapi.testclient.TestClient",
                "utils.needs_py39",
                "docs_src.security.tutorial005_py39.app",
                "docs_src.security.tutorial005_py39.fake_users_db",
                "docs_src.security.tutorial005_py39.verify_password",
                "docs_src.security.tutorial005_py39.get_password_hash",
                "docs_src.security.tutorial005_py39.create_access_token"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 200, response.text",
                "assert response.json() == {'username': 'johndoe', 'full_name': 'John Doe', 'email': 'johndoe@example.com', 'disabled': False}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_access_token",
                    "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally adds a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating further API requests."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_token_no_scope",
            "module": "test_tutorial005_py39",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_py39.py",
            "line_number": 143,
            "end_line_number": 150,
            "source_code": "def test_token_no_scope(client: TestClient):\n    access_token = get_access_token(client=client)\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 401, response.text\n    assert response.json() == {\"detail\": \"Not enough permissions\"}\n    assert response.headers[\"WWW-Authenticate\"] == 'Bearer scope=\"me\"'",
            "docstring": null,
            "decorators": [
                "needs_py39"
            ],
            "arguments": [
                "client"
            ],
            "imports": [
                "pytest",
                "dirty_equals.IsDict",
                "dirty_equals.IsOneOf",
                "fastapi.testclient.TestClient",
                "utils.needs_py39",
                "docs_src.security.tutorial005_py39.app",
                "docs_src.security.tutorial005_py39.fake_users_db",
                "docs_src.security.tutorial005_py39.verify_password",
                "docs_src.security.tutorial005_py39.get_password_hash",
                "docs_src.security.tutorial005_py39.create_access_token"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 401, response.text",
                "assert response.json() == {'detail': 'Not enough permissions'}",
                "assert response.headers['WWW-Authenticate'] == 'Bearer scope=\"me\"'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_access_token",
                    "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:\nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally includes a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is expected to be in JSON format, from which it extracts the `access_token` and returns it. If the request is successful, the returned token can be used for authorization in further API calls."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_token_inactive_user",
            "module": "test_tutorial005_py39",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_py39.py",
            "line_number": 167,
            "end_line_number": 175,
            "source_code": "def test_token_inactive_user(client: TestClient):\n    access_token = get_access_token(\n        username=\"alice\", password=\"secretalice\", scope=\"me\", client=client\n    )\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 400, response.text\n    assert response.json() == {\"detail\": \"Inactive user\"}",
            "docstring": null,
            "decorators": [
                "needs_py39"
            ],
            "arguments": [
                "client"
            ],
            "imports": [
                "pytest",
                "dirty_equals.IsDict",
                "dirty_equals.IsOneOf",
                "fastapi.testclient.TestClient",
                "utils.needs_py39",
                "docs_src.security.tutorial005_py39.app",
                "docs_src.security.tutorial005_py39.fake_users_db",
                "docs_src.security.tutorial005_py39.verify_password",
                "docs_src.security.tutorial005_py39.get_password_hash",
                "docs_src.security.tutorial005_py39.create_access_token"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 400, response.text",
                "assert response.json() == {'detail': 'Inactive user'}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_access_token",
                    "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally adds a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating further API requests."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_read_items",
            "module": "test_tutorial005_py39",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_py39.py",
            "line_number": 179,
            "end_line_number": 185,
            "source_code": "def test_read_items(client: TestClient):\n    access_token = get_access_token(scope=\"me items\", client=client)\n    response = client.get(\n        \"/users/me/items/\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == [{\"item_id\": \"Foo\", \"owner\": \"johndoe\"}]",
            "docstring": null,
            "decorators": [
                "needs_py39"
            ],
            "arguments": [
                "client"
            ],
            "imports": [
                "pytest",
                "dirty_equals.IsDict",
                "dirty_equals.IsOneOf",
                "fastapi.testclient.TestClient",
                "utils.needs_py39",
                "docs_src.security.tutorial005_py39.app",
                "docs_src.security.tutorial005_py39.fake_users_db",
                "docs_src.security.tutorial005_py39.verify_password",
                "docs_src.security.tutorial005_py39.get_password_hash",
                "docs_src.security.tutorial005_py39.create_access_token"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 200, response.text",
                "assert response.json() == [{'item_id': 'Foo', 'owner': 'johndoe'}]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_access_token",
                    "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:\nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally adds a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is expected to be in JSON format, from which it extracts the `access_token` and returns it. This token can then be used in authorization headers for accessing protected routes in the application."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_read_system_status",
            "module": "test_tutorial005_py39",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_py39.py",
            "line_number": 189,
            "end_line_number": 195,
            "source_code": "def test_read_system_status(client: TestClient):\n    access_token = get_access_token(client=client)\n    response = client.get(\n        \"/status/\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == {\"status\": \"ok\"}",
            "docstring": null,
            "decorators": [
                "needs_py39"
            ],
            "arguments": [
                "client"
            ],
            "imports": [
                "pytest",
                "dirty_equals.IsDict",
                "dirty_equals.IsOneOf",
                "fastapi.testclient.TestClient",
                "utils.needs_py39",
                "docs_src.security.tutorial005_py39.app",
                "docs_src.security.tutorial005_py39.fake_users_db",
                "docs_src.security.tutorial005_py39.verify_password",
                "docs_src.security.tutorial005_py39.get_password_hash",
                "docs_src.security.tutorial005_py39.create_access_token"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 200, response.text",
                "assert response.json() == {'status': 'ok'}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_access_token",
                    "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally adds a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating further API calls. If the credentials are invalid or the request fails, the method will not return a valid token."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_token",
            "module": "test_tutorial005_an",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an.py",
            "line_number": 54,
            "end_line_number": 65,
            "source_code": "def test_token():\n    access_token = get_access_token(scope=\"me\")\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == {\n        \"username\": \"johndoe\",\n        \"full_name\": \"John Doe\",\n        \"email\": \"johndoe@example.com\",\n        \"disabled\": False,\n    }",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "dirty_equals.IsDict",
                "dirty_equals.IsOneOf",
                "fastapi.testclient.TestClient",
                "docs_src.security.tutorial005_an.app",
                "docs_src.security.tutorial005_an.create_access_token",
                "docs_src.security.tutorial005_an.fake_users_db",
                "docs_src.security.tutorial005_an.get_password_hash",
                "docs_src.security.tutorial005_an.verify_password"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 200, response.text",
                "assert response.json() == {'username': 'johndoe', 'full_name': 'John Doe', 'email': 'johndoe@example.com', 'disabled': False}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_access_token",
                    "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally includes a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is expected to be in JSON format, from which it extracts the `access_token` and returns it. If the credentials are valid, the returned token can be used for authorization in subsequent API calls."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_token_no_scope",
            "module": "test_tutorial005_an",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an.py",
            "line_number": 121,
            "end_line_number": 128,
            "source_code": "def test_token_no_scope():\n    access_token = get_access_token()\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 401, response.text\n    assert response.json() == {\"detail\": \"Not enough permissions\"}\n    assert response.headers[\"WWW-Authenticate\"] == 'Bearer scope=\"me\"'",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "dirty_equals.IsDict",
                "dirty_equals.IsOneOf",
                "fastapi.testclient.TestClient",
                "docs_src.security.tutorial005_an.app",
                "docs_src.security.tutorial005_an.create_access_token",
                "docs_src.security.tutorial005_an.fake_users_db",
                "docs_src.security.tutorial005_an.get_password_hash",
                "docs_src.security.tutorial005_an.verify_password"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 401, response.text",
                "assert response.json() == {'detail': 'Not enough permissions'}",
                "assert response.headers['WWW-Authenticate'] == 'Bearer scope=\"me\"'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_access_token",
                    "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint (`/token`). This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` of type `TestClient`. It constructs a data dictionary with the username and password, and optionally includes a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. Upon receiving a response, it parses the JSON content to extract the `access_token`, which it returns. If the request is successful, this token can be used in the `Authorization` header for accessing protected routes."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_token_inactive_user",
            "module": "test_tutorial005_an",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an.py",
            "line_number": 143,
            "end_line_number": 151,
            "source_code": "def test_token_inactive_user():\n    access_token = get_access_token(\n        username=\"alice\", password=\"secretalice\", scope=\"me\"\n    )\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 400, response.text\n    assert response.json() == {\"detail\": \"Inactive user\"}",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "dirty_equals.IsDict",
                "dirty_equals.IsOneOf",
                "fastapi.testclient.TestClient",
                "docs_src.security.tutorial005_an.app",
                "docs_src.security.tutorial005_an.create_access_token",
                "docs_src.security.tutorial005_an.fake_users_db",
                "docs_src.security.tutorial005_an.get_password_hash",
                "docs_src.security.tutorial005_an.verify_password"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 400, response.text",
                "assert response.json() == {'detail': 'Inactive user'}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_access_token",
                    "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally adds a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating further API requests."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_read_items",
            "module": "test_tutorial005_an",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an.py",
            "line_number": 154,
            "end_line_number": 160,
            "source_code": "def test_read_items():\n    access_token = get_access_token(scope=\"me items\")\n    response = client.get(\n        \"/users/me/items/\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == [{\"item_id\": \"Foo\", \"owner\": \"johndoe\"}]",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "dirty_equals.IsDict",
                "dirty_equals.IsOneOf",
                "fastapi.testclient.TestClient",
                "docs_src.security.tutorial005_an.app",
                "docs_src.security.tutorial005_an.create_access_token",
                "docs_src.security.tutorial005_an.fake_users_db",
                "docs_src.security.tutorial005_an.get_password_hash",
                "docs_src.security.tutorial005_an.verify_password"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 200, response.text",
                "assert response.json() == [{'item_id': 'Foo', 'owner': 'johndoe'}]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_access_token",
                    "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, adding the scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the credentials. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating further API calls. If the credentials are invalid or the request fails, the method will not return a valid token."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_read_system_status",
            "module": "test_tutorial005_an",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an.py",
            "line_number": 163,
            "end_line_number": 169,
            "source_code": "def test_read_system_status():\n    access_token = get_access_token()\n    response = client.get(\n        \"/status/\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == {\"status\": \"ok\"}",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "dirty_equals.IsDict",
                "dirty_equals.IsOneOf",
                "fastapi.testclient.TestClient",
                "docs_src.security.tutorial005_an.app",
                "docs_src.security.tutorial005_an.create_access_token",
                "docs_src.security.tutorial005_an.fake_users_db",
                "docs_src.security.tutorial005_an.get_password_hash",
                "docs_src.security.tutorial005_an.verify_password"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 200, response.text",
                "assert response.json() == {'status': 'ok'}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_access_token",
                    "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:\nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally adds a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the credentials. The response is parsed to extract the `access_token`, which is returned for use in authenticating future requests. If the credentials are invalid or the request fails, the method will not return a valid token."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_token",
            "module": "test_tutorial005_py310",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_py310.py",
            "line_number": 62,
            "end_line_number": 73,
            "source_code": "def test_token(client: TestClient):\n    access_token = get_access_token(scope=\"me\", client=client)\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == {\n        \"username\": \"johndoe\",\n        \"full_name\": \"John Doe\",\n        \"email\": \"johndoe@example.com\",\n        \"disabled\": False,\n    }",
            "docstring": null,
            "decorators": [
                "needs_py310"
            ],
            "arguments": [
                "client"
            ],
            "imports": [
                "pytest",
                "dirty_equals.IsDict",
                "dirty_equals.IsOneOf",
                "fastapi.testclient.TestClient",
                "utils.needs_py310",
                "docs_src.security.tutorial005_py310.app",
                "docs_src.security.tutorial005_py310.fake_users_db",
                "docs_src.security.tutorial005_py310.verify_password",
                "docs_src.security.tutorial005_py310.get_password_hash",
                "docs_src.security.tutorial005_py310.create_access_token"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 200, response.text",
                "assert response.json() == {'username': 'johndoe', 'full_name': 'John Doe', 'email': 'johndoe@example.com', 'disabled': False}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_access_token",
                    "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally adds a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating further API calls. If the credentials are incorrect or the request fails, the method will not return a valid token."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_token_no_scope",
            "module": "test_tutorial005_py310",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_py310.py",
            "line_number": 143,
            "end_line_number": 150,
            "source_code": "def test_token_no_scope(client: TestClient):\n    access_token = get_access_token(client=client)\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 401, response.text\n    assert response.json() == {\"detail\": \"Not enough permissions\"}\n    assert response.headers[\"WWW-Authenticate\"] == 'Bearer scope=\"me\"'",
            "docstring": null,
            "decorators": [
                "needs_py310"
            ],
            "arguments": [
                "client"
            ],
            "imports": [
                "pytest",
                "dirty_equals.IsDict",
                "dirty_equals.IsOneOf",
                "fastapi.testclient.TestClient",
                "utils.needs_py310",
                "docs_src.security.tutorial005_py310.app",
                "docs_src.security.tutorial005_py310.fake_users_db",
                "docs_src.security.tutorial005_py310.verify_password",
                "docs_src.security.tutorial005_py310.get_password_hash",
                "docs_src.security.tutorial005_py310.create_access_token"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 401, response.text",
                "assert response.json() == {'detail': 'Not enough permissions'}",
                "assert response.headers['WWW-Authenticate'] == 'Bearer scope=\"me\"'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_access_token",
                    "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally includes a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating further API requests. If the credentials are incorrect or the request fails, the method will not return a valid token."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_token_inactive_user",
            "module": "test_tutorial005_py310",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_py310.py",
            "line_number": 167,
            "end_line_number": 175,
            "source_code": "def test_token_inactive_user(client: TestClient):\n    access_token = get_access_token(\n        username=\"alice\", password=\"secretalice\", scope=\"me\", client=client\n    )\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 400, response.text\n    assert response.json() == {\"detail\": \"Inactive user\"}",
            "docstring": null,
            "decorators": [
                "needs_py310"
            ],
            "arguments": [
                "client"
            ],
            "imports": [
                "pytest",
                "dirty_equals.IsDict",
                "dirty_equals.IsOneOf",
                "fastapi.testclient.TestClient",
                "utils.needs_py310",
                "docs_src.security.tutorial005_py310.app",
                "docs_src.security.tutorial005_py310.fake_users_db",
                "docs_src.security.tutorial005_py310.verify_password",
                "docs_src.security.tutorial005_py310.get_password_hash",
                "docs_src.security.tutorial005_py310.create_access_token"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 400, response.text",
                "assert response.json() == {'detail': 'Inactive user'}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_access_token",
                    "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, adding the scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the credentials. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating further API calls."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_read_items",
            "module": "test_tutorial005_py310",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_py310.py",
            "line_number": 179,
            "end_line_number": 185,
            "source_code": "def test_read_items(client: TestClient):\n    access_token = get_access_token(scope=\"me items\", client=client)\n    response = client.get(\n        \"/users/me/items/\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == [{\"item_id\": \"Foo\", \"owner\": \"johndoe\"}]",
            "docstring": null,
            "decorators": [
                "needs_py310"
            ],
            "arguments": [
                "client"
            ],
            "imports": [
                "pytest",
                "dirty_equals.IsDict",
                "dirty_equals.IsOneOf",
                "fastapi.testclient.TestClient",
                "utils.needs_py310",
                "docs_src.security.tutorial005_py310.app",
                "docs_src.security.tutorial005_py310.fake_users_db",
                "docs_src.security.tutorial005_py310.verify_password",
                "docs_src.security.tutorial005_py310.get_password_hash",
                "docs_src.security.tutorial005_py310.create_access_token"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 200, response.text",
                "assert response.json() == [{'item_id': 'Foo', 'owner': 'johndoe'}]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_access_token",
                    "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally adds a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating further API requests."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_read_system_status",
            "module": "test_tutorial005_py310",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_py310.py",
            "line_number": 189,
            "end_line_number": 195,
            "source_code": "def test_read_system_status(client: TestClient):\n    access_token = get_access_token(client=client)\n    response = client.get(\n        \"/status/\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == {\"status\": \"ok\"}",
            "docstring": null,
            "decorators": [
                "needs_py310"
            ],
            "arguments": [
                "client"
            ],
            "imports": [
                "pytest",
                "dirty_equals.IsDict",
                "dirty_equals.IsOneOf",
                "fastapi.testclient.TestClient",
                "utils.needs_py310",
                "docs_src.security.tutorial005_py310.app",
                "docs_src.security.tutorial005_py310.fake_users_db",
                "docs_src.security.tutorial005_py310.verify_password",
                "docs_src.security.tutorial005_py310.get_password_hash",
                "docs_src.security.tutorial005_py310.create_access_token"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 200, response.text",
                "assert response.json() == {'status': 'ok'}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_access_token",
                    "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally adds a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating API requests. If the credentials are invalid or the request fails, the method will not return a valid token."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_token",
            "module": "test_tutorial005_an_py310",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an_py310.py",
            "line_number": 62,
            "end_line_number": 73,
            "source_code": "def test_token(client: TestClient):\n    access_token = get_access_token(scope=\"me\", client=client)\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == {\n        \"username\": \"johndoe\",\n        \"full_name\": \"John Doe\",\n        \"email\": \"johndoe@example.com\",\n        \"disabled\": False,\n    }",
            "docstring": null,
            "decorators": [
                "needs_py310"
            ],
            "arguments": [
                "client"
            ],
            "imports": [
                "pytest",
                "dirty_equals.IsDict",
                "dirty_equals.IsOneOf",
                "fastapi.testclient.TestClient",
                "utils.needs_py310",
                "docs_src.security.tutorial005_an_py310.app",
                "docs_src.security.tutorial005_an_py310.fake_users_db",
                "docs_src.security.tutorial005_an_py310.verify_password",
                "docs_src.security.tutorial005_an_py310.get_password_hash",
                "docs_src.security.tutorial005_an_py310.create_access_token"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 200, response.text",
                "assert response.json() == {'username': 'johndoe', 'full_name': 'John Doe', 'email': 'johndoe@example.com', 'disabled': False}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_access_token",
                    "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, adding the scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the credentials. The response is parsed to extract the `access_token`, which is returned for use in authenticating future requests. If the credentials are invalid or the request fails, the method will not return a valid token."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_token_no_scope",
            "module": "test_tutorial005_an_py310",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an_py310.py",
            "line_number": 143,
            "end_line_number": 150,
            "source_code": "def test_token_no_scope(client: TestClient):\n    access_token = get_access_token(client=client)\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 401, response.text\n    assert response.json() == {\"detail\": \"Not enough permissions\"}\n    assert response.headers[\"WWW-Authenticate\"] == 'Bearer scope=\"me\"'",
            "docstring": null,
            "decorators": [
                "needs_py310"
            ],
            "arguments": [
                "client"
            ],
            "imports": [
                "pytest",
                "dirty_equals.IsDict",
                "dirty_equals.IsOneOf",
                "fastapi.testclient.TestClient",
                "utils.needs_py310",
                "docs_src.security.tutorial005_an_py310.app",
                "docs_src.security.tutorial005_an_py310.fake_users_db",
                "docs_src.security.tutorial005_an_py310.verify_password",
                "docs_src.security.tutorial005_an_py310.get_password_hash",
                "docs_src.security.tutorial005_an_py310.create_access_token"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 401, response.text",
                "assert response.json() == {'detail': 'Not enough permissions'}",
                "assert response.headers['WWW-Authenticate'] == 'Bearer scope=\"me\"'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_access_token",
                    "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, adding the scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the credentials. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating further API requests."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_token_inactive_user",
            "module": "test_tutorial005_an_py310",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an_py310.py",
            "line_number": 167,
            "end_line_number": 175,
            "source_code": "def test_token_inactive_user(client: TestClient):\n    access_token = get_access_token(\n        username=\"alice\", password=\"secretalice\", scope=\"me\", client=client\n    )\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 400, response.text\n    assert response.json() == {\"detail\": \"Inactive user\"}",
            "docstring": null,
            "decorators": [
                "needs_py310"
            ],
            "arguments": [
                "client"
            ],
            "imports": [
                "pytest",
                "dirty_equals.IsDict",
                "dirty_equals.IsOneOf",
                "fastapi.testclient.TestClient",
                "utils.needs_py310",
                "docs_src.security.tutorial005_an_py310.app",
                "docs_src.security.tutorial005_an_py310.fake_users_db",
                "docs_src.security.tutorial005_an_py310.verify_password",
                "docs_src.security.tutorial005_an_py310.get_password_hash",
                "docs_src.security.tutorial005_an_py310.create_access_token"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 400, response.text",
                "assert response.json() == {'detail': 'Inactive user'}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_access_token",
                    "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token by sending a POST request to the `/token` endpoint with user credentials (username and password) and an optional scope. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` of type `TestClient`. It constructs a data dictionary containing the username and password, and if a scope is provided, it adds that to the dictionary. It then sends a POST request to the `/token` endpoint using the provided `client`, passing the data as form data. The response is expected to be in JSON format, from which it extracts the `access_token` and returns it. If the request is successful, this token can be used for authorization in subsequent API calls."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_read_items",
            "module": "test_tutorial005_an_py310",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an_py310.py",
            "line_number": 179,
            "end_line_number": 185,
            "source_code": "def test_read_items(client: TestClient):\n    access_token = get_access_token(scope=\"me items\", client=client)\n    response = client.get(\n        \"/users/me/items/\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == [{\"item_id\": \"Foo\", \"owner\": \"johndoe\"}]",
            "docstring": null,
            "decorators": [
                "needs_py310"
            ],
            "arguments": [
                "client"
            ],
            "imports": [
                "pytest",
                "dirty_equals.IsDict",
                "dirty_equals.IsOneOf",
                "fastapi.testclient.TestClient",
                "utils.needs_py310",
                "docs_src.security.tutorial005_an_py310.app",
                "docs_src.security.tutorial005_an_py310.fake_users_db",
                "docs_src.security.tutorial005_an_py310.verify_password",
                "docs_src.security.tutorial005_an_py310.get_password_hash",
                "docs_src.security.tutorial005_an_py310.create_access_token"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 200, response.text",
                "assert response.json() == [{'item_id': 'Foo', 'owner': 'johndoe'}]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_access_token",
                    "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:\nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally adds a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is parsed to extract the `access_token`, which is returned for use in authenticating future requests. If the credentials are invalid or the request fails, the method will not return a valid token."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_read_system_status",
            "module": "test_tutorial005_an_py310",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005_an_py310.py",
            "line_number": 189,
            "end_line_number": 195,
            "source_code": "def test_read_system_status(client: TestClient):\n    access_token = get_access_token(client=client)\n    response = client.get(\n        \"/status/\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == {\"status\": \"ok\"}",
            "docstring": null,
            "decorators": [
                "needs_py310"
            ],
            "arguments": [
                "client"
            ],
            "imports": [
                "pytest",
                "dirty_equals.IsDict",
                "dirty_equals.IsOneOf",
                "fastapi.testclient.TestClient",
                "utils.needs_py310",
                "docs_src.security.tutorial005_an_py310.app",
                "docs_src.security.tutorial005_an_py310.fake_users_db",
                "docs_src.security.tutorial005_an_py310.verify_password",
                "docs_src.security.tutorial005_an_py310.get_password_hash",
                "docs_src.security.tutorial005_an_py310.create_access_token"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 200, response.text",
                "assert response.json() == {'status': 'ok'}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_access_token",
                    "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, adding the scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the credentials. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating further API calls. If the credentials are invalid or the request fails, the method will not return a valid token."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_token",
            "module": "test_tutorial005",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005.py",
            "line_number": 54,
            "end_line_number": 65,
            "source_code": "def test_token():\n    access_token = get_access_token(scope=\"me\")\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == {\n        \"username\": \"johndoe\",\n        \"full_name\": \"John Doe\",\n        \"email\": \"johndoe@example.com\",\n        \"disabled\": False,\n    }",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "dirty_equals.IsDict",
                "dirty_equals.IsOneOf",
                "fastapi.testclient.TestClient",
                "docs_src.security.tutorial005.app",
                "docs_src.security.tutorial005.create_access_token",
                "docs_src.security.tutorial005.fake_users_db",
                "docs_src.security.tutorial005.get_password_hash",
                "docs_src.security.tutorial005.verify_password"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 200, response.text",
                "assert response.json() == {'username': 'johndoe', 'full_name': 'John Doe', 'email': 'johndoe@example.com', 'disabled': False}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_access_token",
                    "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint (`/token`). It optionally allows for a scope to be specified, which can define the permissions associated with the token.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` of type `TestClient`. It constructs a data dictionary with the username and password, adding the scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is expected to be in JSON format, from which it extracts the `access_token` and returns it. This token can then be used for authenticated requests to other endpoints, ensuring that the user has the necessary permissions based on the provided scope."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_token_no_scope",
            "module": "test_tutorial005",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005.py",
            "line_number": 121,
            "end_line_number": 128,
            "source_code": "def test_token_no_scope():\n    access_token = get_access_token()\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 401, response.text\n    assert response.json() == {\"detail\": \"Not enough permissions\"}\n    assert response.headers[\"WWW-Authenticate\"] == 'Bearer scope=\"me\"'",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "dirty_equals.IsDict",
                "dirty_equals.IsOneOf",
                "fastapi.testclient.TestClient",
                "docs_src.security.tutorial005.app",
                "docs_src.security.tutorial005.create_access_token",
                "docs_src.security.tutorial005.fake_users_db",
                "docs_src.security.tutorial005.get_password_hash",
                "docs_src.security.tutorial005.verify_password"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 401, response.text",
                "assert response.json() == {'detail': 'Not enough permissions'}",
                "assert response.headers['WWW-Authenticate'] == 'Bearer scope=\"me\"'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_access_token",
                    "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally adds a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is parsed as JSON to extract the `access_token`, which is returned for use in authenticating API requests. If the credentials are invalid or the request fails, the method will not return a valid token."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_token_inactive_user",
            "module": "test_tutorial005",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005.py",
            "line_number": 143,
            "end_line_number": 151,
            "source_code": "def test_token_inactive_user():\n    access_token = get_access_token(\n        username=\"alice\", password=\"secretalice\", scope=\"me\"\n    )\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 400, response.text\n    assert response.json() == {\"detail\": \"Inactive user\"}",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "dirty_equals.IsDict",
                "dirty_equals.IsOneOf",
                "fastapi.testclient.TestClient",
                "docs_src.security.tutorial005.app",
                "docs_src.security.tutorial005.create_access_token",
                "docs_src.security.tutorial005.fake_users_db",
                "docs_src.security.tutorial005.get_password_hash",
                "docs_src.security.tutorial005.verify_password"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 400, response.text",
                "assert response.json() == {'detail': 'Inactive user'}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_access_token",
                    "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally adds a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is expected to be in JSON format, from which it extracts the `access_token` and returns it. If the request is successful, the returned token can be used for authorization in further API calls."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_read_items",
            "module": "test_tutorial005",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005.py",
            "line_number": 154,
            "end_line_number": 160,
            "source_code": "def test_read_items():\n    access_token = get_access_token(scope=\"me items\")\n    response = client.get(\n        \"/users/me/items/\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == [{\"item_id\": \"Foo\", \"owner\": \"johndoe\"}]",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "dirty_equals.IsDict",
                "dirty_equals.IsOneOf",
                "fastapi.testclient.TestClient",
                "docs_src.security.tutorial005.app",
                "docs_src.security.tutorial005.create_access_token",
                "docs_src.security.tutorial005.fake_users_db",
                "docs_src.security.tutorial005.get_password_hash",
                "docs_src.security.tutorial005.verify_password"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 200, response.text",
                "assert response.json() == [{'item_id': 'Foo', 'owner': 'johndoe'}]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_access_token",
                    "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token by sending a POST request to the `/token` endpoint with user credentials (username and password) and an optional scope. This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \n1. The method accepts keyword arguments for `username`, `password`, `scope`, and a `client` of type `TestClient`.\n2. It constructs a dictionary `data` containing the `username` and `password`. If a `scope` is provided, it adds this to the `data` dictionary.\n3. It sends a POST request to the `/token` endpoint using the provided `client`, passing the `data` as the request body.\n4. The response is parsed as JSON to extract the `access_token`.\n5. Finally, it returns the `access_token`, which can be used for authenticating further API requests."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_read_system_status",
            "module": "test_tutorial005",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_security/test_tutorial005.py",
            "line_number": 163,
            "end_line_number": 169,
            "source_code": "def test_read_system_status():\n    access_token = get_access_token()\n    response = client.get(\n        \"/status/\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == {\"status\": \"ok\"}",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "dirty_equals.IsDict",
                "dirty_equals.IsOneOf",
                "fastapi.testclient.TestClient",
                "docs_src.security.tutorial005.app",
                "docs_src.security.tutorial005.create_access_token",
                "docs_src.security.tutorial005.fake_users_db",
                "docs_src.security.tutorial005.get_password_hash",
                "docs_src.security.tutorial005.verify_password"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 200, response.text",
                "assert response.json() == {'status': 'ok'}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "get_access_token",
                    "body": "def get_access_token(*, username='johndoe', password='secret', scope=None, client: TestClient):\n    data = {'username': username, 'password': password}\n    if scope:\n        data['scope'] = scope\n    response = client.post('/token', data=data)\n    content = response.json()\n    access_token = content.get('access_token')\n    return access_token",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `get_access_token` method is designed to obtain an access token for a user by sending their credentials (username and password) to a specified endpoint (`/token`). This token is typically used for authenticating subsequent requests to protected resources.\n\n**How It Works**:  \nThe method accepts keyword arguments for `username`, `password`, `scope`, and a `client` instance of `TestClient`. It constructs a data dictionary with the username and password, and optionally adds a scope if provided. It then makes a POST request to the `/token` endpoint using the `client`, sending the data. The response is expected to be in JSON format, from which it extracts the `access_token` and returns it. If the request is successful, the returned token can be used for authorization in subsequent API calls."
                }
            ]
        },
        {
            "repo_name": "fastapi",
            "name": "test_dummy_callback",
            "module": "test_tutorial001",
            "class_name": null,
            "file_path": "__internal__/data/fastapi/tests/test_tutorial/test_openapi_callbacks/test_tutorial001.py",
            "line_number": 17,
            "end_line_number": 19,
            "source_code": "def test_dummy_callback():\n    # Just for coverage\n    invoice_notification({})",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "dirty_equals.IsDict",
                "fastapi.testclient.TestClient",
                "docs_src.openapi_callbacks.tutorial001.app",
                "docs_src.openapi_callbacks.tutorial001.invoice_notification"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "invoice_notification",
                    "body": "@invoices_callback_router.post('{$callback_url}/invoices/{$request.body.id}', response_model=InvoiceEventReceived)\ndef invoice_notification(body: InvoiceEvent):\n    pass",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `invoice_notification` method is designed to handle incoming POST requests that notify the API about events related to invoices, such as payment status updates. It serves as a callback endpoint that external systems can use to inform the API of changes in invoice status.\n\n**How It Works**:  \nThe method is defined as a POST endpoint within the `invoices_callback_router`, which is part of a FastAPI application. It expects a request body that conforms to the `InvoiceEvent` model, which includes details about the invoice event (e.g., whether it has been paid). Upon receiving a valid request, the method is intended to process the notification (though the actual implementation is currently a placeholder). The response model for this endpoint is `InvoiceEventReceived`, which indicates whether the notification was successfully processed. The URL for this endpoint is dynamically constructed using the callback URL and the invoice ID from the request body."
                }
            ]
        }
    ]
}