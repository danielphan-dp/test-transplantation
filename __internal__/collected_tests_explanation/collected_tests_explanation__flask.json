{
    "tests": [
        {
            "repo_name": "flask",
            "name": "test_dump_load_unchanged",
            "module": "test_json_tag",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_json_tag.py",
            "line_number": 27,
            "end_line_number": 29,
            "source_code": "def test_dump_load_unchanged(data):\n    s = TaggedJSONSerializer()\n    assert s.loads(s.dumps(data)) == data",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('data', ({' t': (1, 2, 3)}, {' t__': b'a'}, {' di': ' di'}, {'x': (1, 2, 3), 'y': 4}, (1, 2, 3), [(1, 2, 3)], b'\\xff', Markup('<html>'), uuid4(), datetime.now(tz=timezone.utc).replace(microsecond=0)))"
            ],
            "arguments": [
                "data"
            ],
            "imports": [
                "datetime.datetime",
                "datetime.timezone",
                "uuid.uuid4",
                "pytest",
                "markupsafe.Markup",
                "flask.json.tag.JSONTag",
                "flask.json.tag.TaggedJSONSerializer"
            ],
            "fixtures": [],
            "assertions": [
                "assert s.loads(s.dumps(data)) == data"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "s.loads",
                    "body": "def loads(self, s, **kwargs):\n    kwargs.setdefault('object_hook', self.object_hook)\n    return super().loads(s, **kwargs)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `loads` method is designed to deserialize a JSON-formatted string into a Python object. It allows for customization of the deserialization process through the use of an `object_hook`, which can be specified in the `kwargs`.\n\n**How It Works**:  \nThe method first sets a default value for the `object_hook` in `kwargs` by using the instance's `object_hook` attribute. It then calls the parent class's `loads` method (via `super()`) with the provided string `s` and the modified `kwargs`. This allows the method to leverage the existing deserialization logic while enabling custom behavior through the `object_hook`."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_custom_tag",
            "module": "test_json_tag",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_json_tag.py",
            "line_number": 43,
            "end_line_number": 63,
            "source_code": "def test_custom_tag():\n    class Foo:  # noqa: B903, for Python2 compatibility\n        def __init__(self, data):\n            self.data = data\n\n    class TagFoo(JSONTag):\n        __slots__ = ()\n        key = \" f\"\n\n        def check(self, value):\n            return isinstance(value, Foo)\n\n        def to_json(self, value):\n            return self.serializer.tag(value.data)\n\n        def to_python(self, value):\n            return Foo(value)\n\n    s = TaggedJSONSerializer()\n    s.register(TagFoo)\n    assert s.loads(s.dumps(Foo(\"bar\"))).data == \"bar\"",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "datetime.datetime",
                "datetime.timezone",
                "uuid.uuid4",
                "pytest",
                "markupsafe.Markup",
                "flask.json.tag.JSONTag",
                "flask.json.tag.TaggedJSONSerializer"
            ],
            "fixtures": [],
            "assertions": [
                "assert s.loads(s.dumps(Foo('bar'))).data == 'bar'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "s.loads",
                    "body": "def loads(self, s, **kwargs):\n    kwargs.setdefault('object_hook', self.object_hook)\n    return super().loads(s, **kwargs)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `loads` method is designed to deserialize a JSON-formatted string into a Python object. It allows for customization of the deserialization process through the use of an `object_hook`, which can be specified in the `kwargs`.\n\n**How It Works**:  \nThe method first sets a default value for the `object_hook` in `kwargs` by using the instance's `object_hook` attribute. It then calls the parent class's `loads` method (via `super()`) with the provided string `s` and the modified `kwargs`. This allows for the deserialization to occur with any custom behavior defined by the `object_hook`, while still leveraging the functionality of the superclass's `loads` method."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_environ_defaults_from_config",
            "module": "test_testing",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_testing.py",
            "line_number": 15,
            "end_line_number": 27,
            "source_code": "def test_environ_defaults_from_config(app, client):\n    app.config[\"SERVER_NAME\"] = \"example.com:1234\"\n    app.config[\"APPLICATION_ROOT\"] = \"/foo\"\n\n    @app.route(\"/\")\n    def index():\n        return flask.request.url\n\n    ctx = app.test_request_context()\n    assert ctx.request.url == \"http://example.com:1234/foo/\"\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"http://example.com:1234/foo/\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "importlib.metadata",
                "click",
                "pytest",
                "flask",
                "flask.appcontext_popped",
                "flask.cli.ScriptInfo",
                "flask.globals._cv_request",
                "flask.json.jsonify",
                "flask.testing.EnvironBuilder",
                "flask.testing.FlaskCliRunner"
            ],
            "fixtures": [],
            "assertions": [
                "assert ctx.request.url == 'http://example.com:1234/foo/'",
                "assert rv.data == b'http://example.com:1234/foo/'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_environ_defaults",
            "module": "test_testing",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_testing.py",
            "line_number": 30,
            "end_line_number": 39,
            "source_code": "def test_environ_defaults(app, client, app_ctx, req_ctx):\n    @app.route(\"/\")\n    def index():\n        return flask.request.url\n\n    ctx = app.test_request_context()\n    assert ctx.request.url == \"http://localhost/\"\n    with client:\n        rv = client.get(\"/\")\n        assert rv.data == b\"http://localhost/\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client",
                "app_ctx",
                "req_ctx"
            ],
            "imports": [
                "importlib.metadata",
                "click",
                "pytest",
                "flask",
                "flask.appcontext_popped",
                "flask.cli.ScriptInfo",
                "flask.globals._cv_request",
                "flask.json.jsonify",
                "flask.testing.EnvironBuilder",
                "flask.testing.FlaskCliRunner"
            ],
            "fixtures": [],
            "assertions": [
                "assert ctx.request.url == 'http://localhost/'",
                "assert rv.data == b'http://localhost/'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_environ_base_default",
            "module": "test_testing",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_testing.py",
            "line_number": 42,
            "end_line_number": 54,
            "source_code": "def test_environ_base_default(app, client):\n    @app.route(\"/\")\n    def index():\n        flask.g.remote_addr = flask.request.remote_addr\n        flask.g.user_agent = flask.request.user_agent.string\n        return \"\"\n\n    with client:\n        client.get(\"/\")\n        assert flask.g.remote_addr == \"127.0.0.1\"\n        assert flask.g.user_agent == (\n            f\"Werkzeug/{importlib.metadata.version('werkzeug')}\"\n        )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "importlib.metadata",
                "click",
                "pytest",
                "flask",
                "flask.appcontext_popped",
                "flask.cli.ScriptInfo",
                "flask.globals._cv_request",
                "flask.json.jsonify",
                "flask.testing.EnvironBuilder",
                "flask.testing.FlaskCliRunner"
            ],
            "fixtures": [],
            "assertions": [
                "assert flask.g.remote_addr == '127.0.0.1'",
                "assert flask.g.user_agent == f\"Werkzeug/{importlib.metadata.version('werkzeug')}\""
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_environ_base_modified",
            "module": "test_testing",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_testing.py",
            "line_number": 57,
            "end_line_number": 70,
            "source_code": "def test_environ_base_modified(app, client):\n    @app.route(\"/\")\n    def index():\n        flask.g.remote_addr = flask.request.remote_addr\n        flask.g.user_agent = flask.request.user_agent.string\n        return \"\"\n\n    client.environ_base[\"REMOTE_ADDR\"] = \"192.168.0.22\"\n    client.environ_base[\"HTTP_USER_AGENT\"] = \"Foo\"\n\n    with client:\n        client.get(\"/\")\n        assert flask.g.remote_addr == \"192.168.0.22\"\n        assert flask.g.user_agent == \"Foo\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "importlib.metadata",
                "click",
                "pytest",
                "flask",
                "flask.appcontext_popped",
                "flask.cli.ScriptInfo",
                "flask.globals._cv_request",
                "flask.json.jsonify",
                "flask.testing.EnvironBuilder",
                "flask.testing.FlaskCliRunner"
            ],
            "fixtures": [],
            "assertions": [
                "assert flask.g.remote_addr == '192.168.0.22'",
                "assert flask.g.user_agent == 'Foo'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_specify_url_scheme",
            "module": "test_testing",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_testing.py",
            "line_number": 90,
            "end_line_number": 99,
            "source_code": "def test_specify_url_scheme(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.request.url\n\n    ctx = app.test_request_context(url_scheme=\"https\")\n    assert ctx.request.url == \"https://localhost/\"\n\n    rv = client.get(\"/\", url_scheme=\"https\")\n    assert rv.data == b\"https://localhost/\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "importlib.metadata",
                "click",
                "pytest",
                "flask",
                "flask.appcontext_popped",
                "flask.cli.ScriptInfo",
                "flask.globals._cv_request",
                "flask.json.jsonify",
                "flask.testing.EnvironBuilder",
                "flask.testing.FlaskCliRunner"
            ],
            "fixtures": [],
            "assertions": [
                "assert ctx.request.url == 'https://localhost/'",
                "assert rv.data == b'https://localhost/'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_environbuilder_json_dumps",
            "module": "test_testing",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_testing.py",
            "line_number": 110,
            "end_line_number": 114,
            "source_code": "def test_environbuilder_json_dumps(app):\n    \"\"\"EnvironBuilder.json_dumps() takes settings from the app.\"\"\"\n    app.json.ensure_ascii = False\n    eb = EnvironBuilder(app, json=\"\\u20ac\")\n    assert eb.input_stream.read().decode(\"utf8\") == '\"\\u20ac\"'",
            "docstring": "EnvironBuilder.json_dumps() takes settings from the app.",
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "importlib.metadata",
                "click",
                "pytest",
                "flask",
                "flask.appcontext_popped",
                "flask.cli.ScriptInfo",
                "flask.globals._cv_request",
                "flask.json.jsonify",
                "flask.testing.EnvironBuilder",
                "flask.testing.FlaskCliRunner"
            ],
            "fixtures": [],
            "assertions": [
                "assert eb.input_stream.read().decode('utf8') == '\"\u20ac\"'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "eb.input_stream.read",
                    "body": "@app.route('/read')\ndef read():\n    return str(flask.session.get('foo', 0))",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `eb.input_stream.read` method is designed to handle HTTP GET requests to the `/read` endpoint, returning the value associated with the key `'foo'` from the Flask session. If the key does not exist, it defaults to returning `0`.\n\n**How It Works**:  \nWhen a GET request is made to the `/read` route, the `read` function is invoked. It accesses the Flask session using `flask.session.get('foo', 0)`, which retrieves the value of `'foo'` if it exists; otherwise, it returns `0`. The result is then converted to a string and returned as the HTTP response. This method relies on Flask's session management to store and retrieve user-specific data across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_blueprint_with_subdomain",
            "module": "test_testing",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_testing.py",
            "line_number": 117,
            "end_line_number": 138,
            "source_code": "def test_blueprint_with_subdomain():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"example.com:1234\"\n    app.config[\"APPLICATION_ROOT\"] = \"/foo\"\n    client = app.test_client()\n\n    bp = flask.Blueprint(\"company\", __name__, subdomain=\"xxx\")\n\n    @bp.route(\"/\")\n    def index():\n        return flask.request.url\n\n    app.register_blueprint(bp)\n\n    ctx = app.test_request_context(\"/\", subdomain=\"xxx\")\n    assert ctx.request.url == \"http://xxx.example.com:1234/foo/\"\n\n    with ctx:\n        assert ctx.request.blueprint == bp.name\n\n    rv = client.get(\"/\", subdomain=\"xxx\")\n    assert rv.data == b\"http://xxx.example.com:1234/foo/\"",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "importlib.metadata",
                "click",
                "pytest",
                "flask",
                "flask.appcontext_popped",
                "flask.cli.ScriptInfo",
                "flask.globals._cv_request",
                "flask.json.jsonify",
                "flask.testing.EnvironBuilder",
                "flask.testing.FlaskCliRunner"
            ],
            "fixtures": [],
            "assertions": [
                "assert ctx.request.url == 'http://xxx.example.com:1234/foo/'",
                "assert rv.data == b'http://xxx.example.com:1234/foo/'",
                "assert ctx.request.blueprint == bp.name"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_redirect_keep_session",
            "module": "test_testing",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_testing.py",
            "line_number": 141,
            "end_line_number": 166,
            "source_code": "def test_redirect_keep_session(app, client, app_ctx):\n    @app.route(\"/\", methods=[\"GET\", \"POST\"])\n    def index():\n        if flask.request.method == \"POST\":\n            return flask.redirect(\"/getsession\")\n        flask.session[\"data\"] = \"foo\"\n        return \"index\"\n\n    @app.route(\"/getsession\")\n    def get_session():\n        return flask.session.get(\"data\", \"<missing>\")\n\n    with client:\n        rv = client.get(\"/getsession\")\n        assert rv.data == b\"<missing>\"\n\n        rv = client.get(\"/\")\n        assert rv.data == b\"index\"\n        assert flask.session.get(\"data\") == \"foo\"\n\n        rv = client.post(\"/\", data={}, follow_redirects=True)\n        assert rv.data == b\"foo\"\n        assert flask.session.get(\"data\") == \"foo\"\n\n        rv = client.get(\"/getsession\")\n        assert rv.data == b\"foo\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client",
                "app_ctx"
            ],
            "imports": [
                "importlib.metadata",
                "click",
                "pytest",
                "flask",
                "flask.appcontext_popped",
                "flask.cli.ScriptInfo",
                "flask.globals._cv_request",
                "flask.json.jsonify",
                "flask.testing.EnvironBuilder",
                "flask.testing.FlaskCliRunner"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'<missing>'",
                "assert rv.data == b'index'",
                "assert flask.session.get('data') == 'foo'",
                "assert rv.data == b'foo'",
                "assert flask.session.get('data') == 'foo'",
                "assert rv.data == b'foo'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_redirect_keep_session",
            "module": "test_testing",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_testing.py",
            "line_number": 141,
            "end_line_number": 166,
            "source_code": "def test_redirect_keep_session(app, client, app_ctx):\n    @app.route(\"/\", methods=[\"GET\", \"POST\"])\n    def index():\n        if flask.request.method == \"POST\":\n            return flask.redirect(\"/getsession\")\n        flask.session[\"data\"] = \"foo\"\n        return \"index\"\n\n    @app.route(\"/getsession\")\n    def get_session():\n        return flask.session.get(\"data\", \"<missing>\")\n\n    with client:\n        rv = client.get(\"/getsession\")\n        assert rv.data == b\"<missing>\"\n\n        rv = client.get(\"/\")\n        assert rv.data == b\"index\"\n        assert flask.session.get(\"data\") == \"foo\"\n\n        rv = client.post(\"/\", data={}, follow_redirects=True)\n        assert rv.data == b\"foo\"\n        assert flask.session.get(\"data\") == \"foo\"\n\n        rv = client.get(\"/getsession\")\n        assert rv.data == b\"foo\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client",
                "app_ctx"
            ],
            "imports": [
                "importlib.metadata",
                "click",
                "pytest",
                "flask",
                "flask.appcontext_popped",
                "flask.cli.ScriptInfo",
                "flask.globals._cv_request",
                "flask.json.jsonify",
                "flask.testing.EnvironBuilder",
                "flask.testing.FlaskCliRunner"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'<missing>'",
                "assert rv.data == b'index'",
                "assert flask.session.get('data') == 'foo'",
                "assert rv.data == b'foo'",
                "assert flask.session.get('data') == 'foo'",
                "assert rv.data == b'foo'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_redirect_keep_session",
            "module": "test_testing",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_testing.py",
            "line_number": 141,
            "end_line_number": 166,
            "source_code": "def test_redirect_keep_session(app, client, app_ctx):\n    @app.route(\"/\", methods=[\"GET\", \"POST\"])\n    def index():\n        if flask.request.method == \"POST\":\n            return flask.redirect(\"/getsession\")\n        flask.session[\"data\"] = \"foo\"\n        return \"index\"\n\n    @app.route(\"/getsession\")\n    def get_session():\n        return flask.session.get(\"data\", \"<missing>\")\n\n    with client:\n        rv = client.get(\"/getsession\")\n        assert rv.data == b\"<missing>\"\n\n        rv = client.get(\"/\")\n        assert rv.data == b\"index\"\n        assert flask.session.get(\"data\") == \"foo\"\n\n        rv = client.post(\"/\", data={}, follow_redirects=True)\n        assert rv.data == b\"foo\"\n        assert flask.session.get(\"data\") == \"foo\"\n\n        rv = client.get(\"/getsession\")\n        assert rv.data == b\"foo\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client",
                "app_ctx"
            ],
            "imports": [
                "importlib.metadata",
                "click",
                "pytest",
                "flask",
                "flask.appcontext_popped",
                "flask.cli.ScriptInfo",
                "flask.globals._cv_request",
                "flask.json.jsonify",
                "flask.testing.EnvironBuilder",
                "flask.testing.FlaskCliRunner"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'<missing>'",
                "assert rv.data == b'index'",
                "assert flask.session.get('data') == 'foo'",
                "assert rv.data == b'foo'",
                "assert flask.session.get('data') == 'foo'",
                "assert rv.data == b'foo'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.post",
                    "body": "def post(self):\n    return 'Create'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is designed to simulate an HTTP POST request to a specified endpoint, allowing developers to send data to the server, typically for creating or updating resources.\n\n**How It Works**:\nWhen invoked, `client.post` sends a request to the server at the specified URL with the provided data. In the context of the provided code snippets, it is used to test various functionalities such as creating a new post, updating an existing post, and deleting a post. The method returns a response indicating the result of the operation, which can be further validated in tests to ensure the expected behavior of the application. The method body currently returns a simple string 'Create', but in a complete implementation, it would handle the request and return an appropriate response based on the server's logic."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_redirect_keep_session",
            "module": "test_testing",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_testing.py",
            "line_number": 141,
            "end_line_number": 166,
            "source_code": "def test_redirect_keep_session(app, client, app_ctx):\n    @app.route(\"/\", methods=[\"GET\", \"POST\"])\n    def index():\n        if flask.request.method == \"POST\":\n            return flask.redirect(\"/getsession\")\n        flask.session[\"data\"] = \"foo\"\n        return \"index\"\n\n    @app.route(\"/getsession\")\n    def get_session():\n        return flask.session.get(\"data\", \"<missing>\")\n\n    with client:\n        rv = client.get(\"/getsession\")\n        assert rv.data == b\"<missing>\"\n\n        rv = client.get(\"/\")\n        assert rv.data == b\"index\"\n        assert flask.session.get(\"data\") == \"foo\"\n\n        rv = client.post(\"/\", data={}, follow_redirects=True)\n        assert rv.data == b\"foo\"\n        assert flask.session.get(\"data\") == \"foo\"\n\n        rv = client.get(\"/getsession\")\n        assert rv.data == b\"foo\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client",
                "app_ctx"
            ],
            "imports": [
                "importlib.metadata",
                "click",
                "pytest",
                "flask",
                "flask.appcontext_popped",
                "flask.cli.ScriptInfo",
                "flask.globals._cv_request",
                "flask.json.jsonify",
                "flask.testing.EnvironBuilder",
                "flask.testing.FlaskCliRunner"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'<missing>'",
                "assert rv.data == b'index'",
                "assert flask.session.get('data') == 'foo'",
                "assert rv.data == b'foo'",
                "assert flask.session.get('data') == 'foo'",
                "assert rv.data == b'foo'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_transactions",
            "module": "test_testing",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_testing.py",
            "line_number": 169,
            "end_line_number": 183,
            "source_code": "def test_session_transactions(app, client):\n    @app.route(\"/\")\n    def index():\n        return str(flask.session[\"foo\"])\n\n    with client:\n        with client.session_transaction() as sess:\n            assert len(sess) == 0\n            sess[\"foo\"] = [42]\n            assert len(sess) == 1\n        rv = client.get(\"/\")\n        assert rv.data == b\"[42]\"\n        with client.session_transaction() as sess:\n            assert len(sess) == 1\n            assert sess[\"foo\"] == [42]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "importlib.metadata",
                "click",
                "pytest",
                "flask",
                "flask.appcontext_popped",
                "flask.cli.ScriptInfo",
                "flask.globals._cv_request",
                "flask.json.jsonify",
                "flask.testing.EnvironBuilder",
                "flask.testing.FlaskCliRunner"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'[42]'",
                "assert len(sess) == 0",
                "assert len(sess) == 1",
                "assert len(sess) == 1",
                "assert sess['foo'] == [42]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_transactions_keep_context",
            "module": "test_testing",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_testing.py",
            "line_number": 196,
            "end_line_number": 201,
            "source_code": "def test_session_transactions_keep_context(app, client, req_ctx):\n    client.get(\"/\")\n    req = flask.request._get_current_object()\n    assert req is not None\n    with client.session_transaction():\n        assert req is flask.request._get_current_object()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client",
                "req_ctx"
            ],
            "imports": [
                "importlib.metadata",
                "click",
                "pytest",
                "flask",
                "flask.appcontext_popped",
                "flask.cli.ScriptInfo",
                "flask.globals._cv_request",
                "flask.json.jsonify",
                "flask.testing.EnvironBuilder",
                "flask.testing.FlaskCliRunner"
            ],
            "fixtures": [],
            "assertions": [
                "assert req is not None",
                "assert req is flask.request._get_current_object()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is used to define a route in a Flask web application that retrieves a value stored in the session. If the session does not contain the specified value, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nThe method is decorated with `@app.route('/get')`, which maps the URL path `/get` to the `get` function. Inside the function, `flask.session.get('value', 'None')` attempts to retrieve the value associated with the key `'value'` from the session. If the key does not exist, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request made to the `/get` endpoint. This allows clients to access session data easily through a simple GET request."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_test_client_context_binding",
            "module": "test_testing",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_testing.py",
            "line_number": 212,
            "end_line_number": 238,
            "source_code": "def test_test_client_context_binding(app, client):\n    app.testing = False\n\n    @app.route(\"/\")\n    def index():\n        flask.g.value = 42\n        return \"Hello World!\"\n\n    @app.route(\"/other\")\n    def other():\n        raise ZeroDivisionError\n\n    with client:\n        resp = client.get(\"/\")\n        assert flask.g.value == 42\n        assert resp.data == b\"Hello World!\"\n        assert resp.status_code == 200\n\n    with client:\n        resp = client.get(\"/other\")\n        assert not hasattr(flask.g, \"value\")\n        assert b\"Internal Server Error\" in resp.data\n        assert resp.status_code == 500\n        flask.g.value = 23\n\n    with pytest.raises(RuntimeError):\n        flask.g.value",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "importlib.metadata",
                "click",
                "pytest",
                "flask",
                "flask.appcontext_popped",
                "flask.cli.ScriptInfo",
                "flask.globals._cv_request",
                "flask.json.jsonify",
                "flask.testing.EnvironBuilder",
                "flask.testing.FlaskCliRunner"
            ],
            "fixtures": [],
            "assertions": [
                "assert flask.g.value == 42",
                "assert resp.data == b'Hello World!'",
                "assert resp.status_code == 200",
                "assert not hasattr(flask.g, 'value')",
                "assert b'Internal Server Error' in resp.data",
                "assert resp.status_code == 500"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_test_client_context_binding",
            "module": "test_testing",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_testing.py",
            "line_number": 212,
            "end_line_number": 238,
            "source_code": "def test_test_client_context_binding(app, client):\n    app.testing = False\n\n    @app.route(\"/\")\n    def index():\n        flask.g.value = 42\n        return \"Hello World!\"\n\n    @app.route(\"/other\")\n    def other():\n        raise ZeroDivisionError\n\n    with client:\n        resp = client.get(\"/\")\n        assert flask.g.value == 42\n        assert resp.data == b\"Hello World!\"\n        assert resp.status_code == 200\n\n    with client:\n        resp = client.get(\"/other\")\n        assert not hasattr(flask.g, \"value\")\n        assert b\"Internal Server Error\" in resp.data\n        assert resp.status_code == 500\n        flask.g.value = 23\n\n    with pytest.raises(RuntimeError):\n        flask.g.value",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "importlib.metadata",
                "click",
                "pytest",
                "flask",
                "flask.appcontext_popped",
                "flask.cli.ScriptInfo",
                "flask.globals._cv_request",
                "flask.json.jsonify",
                "flask.testing.EnvironBuilder",
                "flask.testing.FlaskCliRunner"
            ],
            "fixtures": [],
            "assertions": [
                "assert flask.g.value == 42",
                "assert resp.data == b'Hello World!'",
                "assert resp.status_code == 200",
                "assert not hasattr(flask.g, 'value')",
                "assert b'Internal Server Error' in resp.data",
                "assert resp.status_code == 500"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it as a response.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` attempts to fetch the value stored in the session under the key `'value'`. If this key does not exist, it defaults to returning the string `'None'`. The retrieved value is then returned as the HTTP response. This method relies on Flask's session management to store and retrieve user-specific data across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_reuse_client",
            "module": "test_testing",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_testing.py",
            "line_number": 241,
            "end_line_number": 248,
            "source_code": "def test_reuse_client(client):\n    c = client\n\n    with c:\n        assert client.get(\"/\").status_code == 404\n\n    with c:\n        assert client.get(\"/\").status_code == 404",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "client"
            ],
            "imports": [
                "importlib.metadata",
                "click",
                "pytest",
                "flask",
                "flask.appcontext_popped",
                "flask.cli.ScriptInfo",
                "flask.globals._cv_request",
                "flask.json.jsonify",
                "flask.testing.EnvironBuilder",
                "flask.testing.FlaskCliRunner"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').status_code == 404",
                "assert client.get('/').status_code == 404"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_reuse_client",
            "module": "test_testing",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_testing.py",
            "line_number": 241,
            "end_line_number": 248,
            "source_code": "def test_reuse_client(client):\n    c = client\n\n    with c:\n        assert client.get(\"/\").status_code == 404\n\n    with c:\n        assert client.get(\"/\").status_code == 404",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "client"
            ],
            "imports": [
                "importlib.metadata",
                "click",
                "pytest",
                "flask",
                "flask.appcontext_popped",
                "flask.cli.ScriptInfo",
                "flask.globals._cv_request",
                "flask.json.jsonify",
                "flask.testing.EnvironBuilder",
                "flask.testing.FlaskCliRunner"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').status_code == 404",
                "assert client.get('/').status_code == 404"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_full_url_request",
            "module": "test_testing",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_testing.py",
            "line_number": 251,
            "end_line_number": 260,
            "source_code": "def test_full_url_request(app, client):\n    @app.route(\"/action\", methods=[\"POST\"])\n    def action():\n        return \"x\"\n\n    with client:\n        rv = client.post(\"http://domain.com/action?vodka=42\", data={\"gin\": 43})\n        assert rv.status_code == 200\n        assert \"gin\" in flask.request.form\n        assert \"vodka\" in flask.request.args",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "importlib.metadata",
                "click",
                "pytest",
                "flask",
                "flask.appcontext_popped",
                "flask.cli.ScriptInfo",
                "flask.globals._cv_request",
                "flask.json.jsonify",
                "flask.testing.EnvironBuilder",
                "flask.testing.FlaskCliRunner"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.status_code == 200",
                "assert 'gin' in flask.request.form",
                "assert 'vodka' in flask.request.args"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.post",
                    "body": "def post(self):\n    return 'Create'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is designed to simulate an HTTP POST request to a specified endpoint, allowing developers to send data to the server, typically for creating or updating resources.\n\n**How It Works**:\nWhen invoked, `client.post` sends a request to the server at the specified path with the provided data. In the context of the provided code snippets, it is used to test various functionalities such as creating a new post, updating an existing post, and validating input data. The method returns a response that can be checked for status codes and content, enabling assertions in tests to verify that the server behaves as expected."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_json_request_and_response",
            "module": "test_testing",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_testing.py",
            "line_number": 263,
            "end_line_number": 279,
            "source_code": "def test_json_request_and_response(app, client):\n    @app.route(\"/echo\", methods=[\"POST\"])\n    def echo():\n        return jsonify(flask.request.get_json())\n\n    with client:\n        json_data = {\"drink\": {\"gin\": 1, \"tonic\": True}, \"price\": 10}\n        rv = client.post(\"/echo\", json=json_data)\n\n        # Request should be in JSON\n        assert flask.request.is_json\n        assert flask.request.get_json() == json_data\n\n        # Response should be in JSON\n        assert rv.status_code == 200\n        assert rv.is_json\n        assert rv.get_json() == json_data",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "importlib.metadata",
                "click",
                "pytest",
                "flask",
                "flask.appcontext_popped",
                "flask.cli.ScriptInfo",
                "flask.globals._cv_request",
                "flask.json.jsonify",
                "flask.testing.EnvironBuilder",
                "flask.testing.FlaskCliRunner"
            ],
            "fixtures": [],
            "assertions": [
                "assert flask.request.is_json",
                "assert flask.request.get_json() == json_data",
                "assert rv.status_code == 200",
                "assert rv.is_json",
                "assert rv.get_json() == json_data"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.post",
                    "body": "def post(self):\n    return 'Create'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is designed to simulate an HTTP POST request to a specified endpoint, allowing developers to send data to the server, typically for creating or updating resources.\n\n**How It Works**:\nWhen invoked, `client.post` sends a request to the server at the specified URL with the provided data. In the context of the provided code snippets, it is used to update a post's title or create a new resource. The method returns a response indicating the result of the operation, which can be further validated in tests to ensure the expected behavior, such as checking for status codes or verifying database changes."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_client_json_no_app_context",
            "module": "test_testing",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_testing.py",
            "line_number": 282,
            "end_line_number": 299,
            "source_code": "def test_client_json_no_app_context(app, client):\n    @app.route(\"/hello\", methods=[\"POST\"])\n    def hello():\n        return f\"Hello, {flask.request.json['name']}!\"\n\n    class Namespace:\n        count = 0\n\n        def add(self, app):\n            self.count += 1\n\n    ns = Namespace()\n\n    with appcontext_popped.connected_to(ns.add, app):\n        rv = client.post(\"/hello\", json={\"name\": \"Flask\"})\n\n    assert rv.get_data(as_text=True) == \"Hello, Flask!\"\n    assert ns.count == 1",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "importlib.metadata",
                "click",
                "pytest",
                "flask",
                "flask.appcontext_popped",
                "flask.cli.ScriptInfo",
                "flask.globals._cv_request",
                "flask.json.jsonify",
                "flask.testing.EnvironBuilder",
                "flask.testing.FlaskCliRunner"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.get_data(as_text=True) == 'Hello, Flask!'",
                "assert ns.count == 1"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.post",
                    "body": "def post(self):\n    return 'Create'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is designed to simulate an HTTP POST request to a specified endpoint, allowing developers to send data to the server, typically for creating or updating resources.\n\n**How It Works**:\nWhen invoked, `client.post` sends a request to the server at the specified URL with the provided data. In the context of the provided code snippets, it is used to test various functionalities such as creating a new post, updating an existing post, and deleting a post. The method returns a response indicating the result of the operation, which can be further validated in tests to ensure the expected behavior of the application. The method's implementation in the example simply returns the string 'Create', but in a real application, it would handle the logic for processing the request and returning an appropriate response."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_subdomain",
            "module": "test_testing",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_testing.py",
            "line_number": 302,
            "end_line_number": 318,
            "source_code": "def test_subdomain():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"example.com\"\n    client = app.test_client()\n\n    @app.route(\"/\", subdomain=\"<company_id>\")\n    def view(company_id):\n        return company_id\n\n    with app.test_request_context():\n        url = flask.url_for(\"view\", company_id=\"xxx\")\n\n    with client:\n        response = client.get(url)\n\n    assert 200 == response.status_code\n    assert b\"xxx\" == response.data",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "importlib.metadata",
                "click",
                "pytest",
                "flask",
                "flask.appcontext_popped",
                "flask.cli.ScriptInfo",
                "flask.globals._cv_request",
                "flask.json.jsonify",
                "flask.testing.EnvironBuilder",
                "flask.testing.FlaskCliRunner"
            ],
            "fixtures": [],
            "assertions": [
                "assert 200 == response.status_code",
                "assert b'xxx' == response.data"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_nosubdomain",
            "module": "test_testing",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_testing.py",
            "line_number": 321,
            "end_line_number": 335,
            "source_code": "def test_nosubdomain(app, client):\n    app.config[\"SERVER_NAME\"] = \"example.com\"\n\n    @app.route(\"/<company_id>\")\n    def view(company_id):\n        return company_id\n\n    with app.test_request_context():\n        url = flask.url_for(\"view\", company_id=\"xxx\")\n\n    with client:\n        response = client.get(url)\n\n    assert 200 == response.status_code\n    assert b\"xxx\" == response.data",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "importlib.metadata",
                "click",
                "pytest",
                "flask",
                "flask.appcontext_popped",
                "flask.cli.ScriptInfo",
                "flask.globals._cv_request",
                "flask.json.jsonify",
                "flask.testing.EnvironBuilder",
                "flask.testing.FlaskCliRunner"
            ],
            "fixtures": [],
            "assertions": [
                "assert 200 == response.status_code",
                "assert b'xxx' == response.data"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_cli_invoke",
            "module": "test_testing",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_testing.py",
            "line_number": 350,
            "end_line_number": 361,
            "source_code": "def test_cli_invoke(app):\n    @app.cli.command(\"hello\")\n    def hello_command():\n        click.echo(\"Hello, World!\")\n\n    runner = app.test_cli_runner()\n    # invoke with command name\n    result = runner.invoke(args=[\"hello\"])\n    assert \"Hello\" in result.output\n    # invoke with command object\n    result = runner.invoke(hello_command)\n    assert \"Hello\" in result.output",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "importlib.metadata",
                "click",
                "pytest",
                "flask",
                "flask.appcontext_popped",
                "flask.cli.ScriptInfo",
                "flask.globals._cv_request",
                "flask.json.jsonify",
                "flask.testing.EnvironBuilder",
                "flask.testing.FlaskCliRunner"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'Hello' in result.output",
                "assert 'Hello' in result.output"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "runner.invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `invoke` method is a pytest fixture that creates a callable for invoking CLI commands on a Flask application using the `CliRunner`. It allows for testing of command-line interface (CLI) commands defined in the Flask application.\n\n**How It Works**:  \nThe `invoke` method uses the `FlaskGroup` class to create a CLI group associated with the provided Flask application. It leverages `functools.partial` to bind the `runner.invoke` method to this CLI group, enabling the execution of CLI commands with the specified application context. When called, it returns a function that can be used to run CLI commands and capture their output, making it easier to test various command-line functionalities of the Flask app."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_cli_invoke",
            "module": "test_testing",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_testing.py",
            "line_number": 350,
            "end_line_number": 361,
            "source_code": "def test_cli_invoke(app):\n    @app.cli.command(\"hello\")\n    def hello_command():\n        click.echo(\"Hello, World!\")\n\n    runner = app.test_cli_runner()\n    # invoke with command name\n    result = runner.invoke(args=[\"hello\"])\n    assert \"Hello\" in result.output\n    # invoke with command object\n    result = runner.invoke(hello_command)\n    assert \"Hello\" in result.output",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "importlib.metadata",
                "click",
                "pytest",
                "flask",
                "flask.appcontext_popped",
                "flask.cli.ScriptInfo",
                "flask.globals._cv_request",
                "flask.json.jsonify",
                "flask.testing.EnvironBuilder",
                "flask.testing.FlaskCliRunner"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'Hello' in result.output",
                "assert 'Hello' in result.output"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "runner.invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `invoke` method is a pytest fixture that facilitates the testing of Flask CLI commands by creating a command-line interface (CLI) group associated with a Flask application. It allows developers to easily invoke CLI commands in their tests.\n\n**How It Works**:  \nThe `invoke` method uses the `FlaskGroup` class to create a CLI instance for the provided Flask application. It leverages `functools.partial` to bind the `runner.invoke` method to this CLI instance, enabling the execution of CLI commands with the specified application context. When called, it returns a callable that can be used in tests to simulate command-line interactions, capturing the output and exit status of the commands executed. This setup is particularly useful for testing various CLI functionalities, such as command options and output formatting."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_cli_custom_obj",
            "module": "test_testing",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_testing.py",
            "line_number": 364,
            "end_line_number": 379,
            "source_code": "def test_cli_custom_obj(app):\n    class NS:\n        called = False\n\n    def create_app():\n        NS.called = True\n        return app\n\n    @app.cli.command(\"hello\")\n    def hello_command():\n        click.echo(\"Hello, World!\")\n\n    script_info = ScriptInfo(create_app=create_app)\n    runner = app.test_cli_runner()\n    runner.invoke(hello_command, obj=script_info)\n    assert NS.called",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "importlib.metadata",
                "click",
                "pytest",
                "flask",
                "flask.appcontext_popped",
                "flask.cli.ScriptInfo",
                "flask.globals._cv_request",
                "flask.json.jsonify",
                "flask.testing.EnvironBuilder",
                "flask.testing.FlaskCliRunner"
            ],
            "fixtures": [],
            "assertions": [
                "assert NS.called"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "runner.invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `invoke` method is a pytest fixture that creates a callable for invoking CLI commands on a Flask application using the `CliRunner`. It allows for testing of command-line interface (CLI) commands defined in the Flask app.\n\n**How It Works**:  \nThe `invoke` method uses the `FlaskGroup` class to create a CLI group associated with the provided Flask application. It leverages `functools.partial` to bind the `runner.invoke` method to this CLI group, enabling the execution of CLI commands with the specified app context. When called, it returns a function that can be used to run CLI commands and capture their output, making it easier to test various command behaviors and outputs in the context of the Flask application."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_client_pop_all_preserved",
            "module": "test_testing",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_testing.py",
            "line_number": 382,
            "end_line_number": 396,
            "source_code": "def test_client_pop_all_preserved(app, req_ctx, client):\n    @app.route(\"/\")\n    def index():\n        # stream_with_context pushes a third context, preserved by response\n        return flask.stream_with_context(\"hello\")\n\n    # req_ctx fixture pushed an initial context\n    with client:\n        # request pushes a second request context, preserved by client\n        rv = client.get(\"/\")\n\n    # close the response, releasing the context held by stream_with_context\n    rv.close()\n    # only req_ctx fixture should still be pushed\n    assert _cv_request.get(None) is req_ctx",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "req_ctx",
                "client"
            ],
            "imports": [
                "importlib.metadata",
                "click",
                "pytest",
                "flask",
                "flask.appcontext_popped",
                "flask.cli.ScriptInfo",
                "flask.globals._cv_request",
                "flask.json.jsonify",
                "flask.testing.EnvironBuilder",
                "flask.testing.FlaskCliRunner"
            ],
            "fixtures": [],
            "assertions": [
                "assert _cv_request.get(None) is req_ctx"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "rv.close",
                    "body": "def close(self):\n    called.append(42)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed or released. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes a single line of code that appends the integer `42` to the `called` list. This indicates that the method has been called, which can be useful for debugging or verifying that the cleanup process is executed as expected. The method does not return any value and relies on the external `called` list to track its invocation."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_client_pop_all_preserved",
            "module": "test_testing",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_testing.py",
            "line_number": 382,
            "end_line_number": 396,
            "source_code": "def test_client_pop_all_preserved(app, req_ctx, client):\n    @app.route(\"/\")\n    def index():\n        # stream_with_context pushes a third context, preserved by response\n        return flask.stream_with_context(\"hello\")\n\n    # req_ctx fixture pushed an initial context\n    with client:\n        # request pushes a second request context, preserved by client\n        rv = client.get(\"/\")\n\n    # close the response, releasing the context held by stream_with_context\n    rv.close()\n    # only req_ctx fixture should still be pushed\n    assert _cv_request.get(None) is req_ctx",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "req_ctx",
                "client"
            ],
            "imports": [
                "importlib.metadata",
                "click",
                "pytest",
                "flask",
                "flask.appcontext_popped",
                "flask.cli.ScriptInfo",
                "flask.globals._cv_request",
                "flask.json.jsonify",
                "flask.testing.EnvironBuilder",
                "flask.testing.FlaskCliRunner"
            ],
            "fixtures": [],
            "assertions": [
                "assert _cv_request.get(None) is req_ctx"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_client_pop_all_preserved",
            "module": "test_testing",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_testing.py",
            "line_number": 382,
            "end_line_number": 396,
            "source_code": "def test_client_pop_all_preserved(app, req_ctx, client):\n    @app.route(\"/\")\n    def index():\n        # stream_with_context pushes a third context, preserved by response\n        return flask.stream_with_context(\"hello\")\n\n    # req_ctx fixture pushed an initial context\n    with client:\n        # request pushes a second request context, preserved by client\n        rv = client.get(\"/\")\n\n    # close the response, releasing the context held by stream_with_context\n    rv.close()\n    # only req_ctx fixture should still be pushed\n    assert _cv_request.get(None) is req_ctx",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "req_ctx",
                "client"
            ],
            "imports": [
                "importlib.metadata",
                "click",
                "pytest",
                "flask",
                "flask.appcontext_popped",
                "flask.cli.ScriptInfo",
                "flask.globals._cv_request",
                "flask.json.jsonify",
                "flask.testing.EnvironBuilder",
                "flask.testing.FlaskCliRunner"
            ],
            "fixtures": [],
            "assertions": [
                "assert _cv_request.get(None) is req_ctx"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "_cv_request.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `_cv_request.get` method is designed to retrieve a value from the Flask session, specifically looking for a key named 'value'. If this key does not exist, it returns the string 'None' as a default.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` route, the method accesses the Flask session using `flask.session.get()`. This method checks for the presence of the 'value' key in the session data. If found, it returns the associated value; if not, it returns 'None'. This allows for easy retrieval of session data while providing a fallback for cases where the data is not set."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_uninstalled_module_paths",
            "module": "test_instance_config",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_instance_config.py",
            "line_number": 16,
            "end_line_number": 27,
            "source_code": "def test_uninstalled_module_paths(modules_tmp_path, purge_module):\n    (modules_tmp_path / \"config_module_app.py\").write_text(\n        \"import os\\n\"\n        \"import flask\\n\"\n        \"here = os.path.abspath(os.path.dirname(__file__))\\n\"\n        \"app = flask.Flask(__name__)\\n\"\n    )\n    purge_module(\"config_module_app\")\n\n    from config_module_app import app\n\n    assert app.instance_path == os.fspath(modules_tmp_path / \"instance\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "modules_tmp_path",
                "purge_module"
            ],
            "imports": [
                "os",
                "pytest",
                "flask",
                "config_module_app.app",
                "config_package_app.app",
                "namespace.package2.app",
                "site_app.app",
                "installed_package.app",
                "site_package"
            ],
            "fixtures": [],
            "assertions": [
                "assert app.instance_path == os.fspath(modules_tmp_path / 'instance')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "purge_module",
                    "body": "@pytest.fixture\ndef purge_module(request):\n\n    def inner(name):\n        request.addfinalizer(lambda : sys.modules.pop(name, None))\n    return inner",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `purge_module` method is a pytest fixture designed to remove a specified module from `sys.modules` after a test completes. This is useful for ensuring that tests do not interfere with each other by leaving behind loaded modules.\n\n**How It Works**:\nThe method defines an inner function that takes the name of a module as an argument. It uses `request.addfinalizer` to register a cleanup function that will be executed after the test finishes. This cleanup function attempts to pop the specified module from `sys.modules`, effectively unloading it. This helps maintain a clean testing environment, especially when tests involve dynamic module loading or reloading."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_uninstalled_package_paths",
            "module": "test_instance_config",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_instance_config.py",
            "line_number": 30,
            "end_line_number": 43,
            "source_code": "def test_uninstalled_package_paths(modules_tmp_path, purge_module):\n    app = modules_tmp_path / \"config_package_app\"\n    app.mkdir()\n    (app / \"__init__.py\").write_text(\n        \"import os\\n\"\n        \"import flask\\n\"\n        \"here = os.path.abspath(os.path.dirname(__file__))\\n\"\n        \"app = flask.Flask(__name__)\\n\"\n    )\n    purge_module(\"config_package_app\")\n\n    from config_package_app import app\n\n    assert app.instance_path == os.fspath(modules_tmp_path / \"instance\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "modules_tmp_path",
                "purge_module"
            ],
            "imports": [
                "os",
                "pytest",
                "flask",
                "config_module_app.app",
                "config_package_app.app",
                "namespace.package2.app",
                "site_app.app",
                "installed_package.app",
                "site_package"
            ],
            "fixtures": [],
            "assertions": [
                "assert app.instance_path == os.fspath(modules_tmp_path / 'instance')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "purge_module",
                    "body": "@pytest.fixture\ndef purge_module(request):\n\n    def inner(name):\n        request.addfinalizer(lambda : sys.modules.pop(name, None))\n    return inner",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `purge_module` method is a pytest fixture designed to remove a specified module from `sys.modules` after a test completes. This is useful for ensuring that tests do not interfere with each other by leaving behind loaded modules.\n\n**How It Works**:\nThe method defines an inner function that takes the name of the module to be purged. It uses `request.addfinalizer` to register a cleanup function that will be executed after the test finishes. This cleanup function attempts to pop the specified module from `sys.modules`, effectively unloading it. This helps maintain a clean testing environment, especially when tests involve dynamic module loading or reloading."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_uninstalled_namespace_paths",
            "module": "test_instance_config",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_instance_config.py",
            "line_number": 46,
            "end_line_number": 62,
            "source_code": "def test_uninstalled_namespace_paths(tmp_path, monkeypatch, purge_module):\n    def create_namespace(package):\n        project = tmp_path / f\"project-{package}\"\n        monkeypatch.syspath_prepend(os.fspath(project))\n        ns = project / \"namespace\" / package\n        ns.mkdir(parents=True)\n        (ns / \"__init__.py\").write_text(\"import flask\\napp = flask.Flask(__name__)\\n\")\n        return project\n\n    _ = create_namespace(\"package1\")\n    project2 = create_namespace(\"package2\")\n    purge_module(\"namespace.package2\")\n    purge_module(\"namespace\")\n\n    from namespace.package2 import app\n\n    assert app.instance_path == os.fspath(project2 / \"instance\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "tmp_path",
                "monkeypatch",
                "purge_module"
            ],
            "imports": [
                "os",
                "pytest",
                "flask",
                "config_module_app.app",
                "config_package_app.app",
                "namespace.package2.app",
                "site_app.app",
                "installed_package.app",
                "site_package"
            ],
            "fixtures": [],
            "assertions": [
                "assert app.instance_path == os.fspath(project2 / 'instance')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "create_namespace",
                    "body": "def create_namespace(package):\n    project = tmp_path / f'project-{package}'\n    monkeypatch.syspath_prepend(os.fspath(project))\n    ns = project / 'namespace' / package\n    ns.mkdir(parents=True)\n    (ns / '__init__.py').write_text('import flask\\napp = flask.Flask(__name__)\\n')\n    return project",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `create_namespace` method is designed to create a temporary project directory structure for a specified package, which includes setting up a namespace package with an `__init__.py` file that initializes a Flask application.\n\n**How It Works**:  \n1. It constructs a path for a temporary project directory based on the provided package name.\n2. It modifies the Python system path to include this new project directory, allowing for module imports from it.\n3. It creates a directory structure for the namespace package, specifically a subdirectory named after the package.\n4. An `__init__.py` file is created within this directory, containing code to import Flask and instantiate a Flask application.\n5. Finally, it returns the path to the created project directory, enabling further operations or imports from this namespace."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_uninstalled_namespace_paths",
            "module": "test_instance_config",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_instance_config.py",
            "line_number": 46,
            "end_line_number": 62,
            "source_code": "def test_uninstalled_namespace_paths(tmp_path, monkeypatch, purge_module):\n    def create_namespace(package):\n        project = tmp_path / f\"project-{package}\"\n        monkeypatch.syspath_prepend(os.fspath(project))\n        ns = project / \"namespace\" / package\n        ns.mkdir(parents=True)\n        (ns / \"__init__.py\").write_text(\"import flask\\napp = flask.Flask(__name__)\\n\")\n        return project\n\n    _ = create_namespace(\"package1\")\n    project2 = create_namespace(\"package2\")\n    purge_module(\"namespace.package2\")\n    purge_module(\"namespace\")\n\n    from namespace.package2 import app\n\n    assert app.instance_path == os.fspath(project2 / \"instance\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "tmp_path",
                "monkeypatch",
                "purge_module"
            ],
            "imports": [
                "os",
                "pytest",
                "flask",
                "config_module_app.app",
                "config_package_app.app",
                "namespace.package2.app",
                "site_app.app",
                "installed_package.app",
                "site_package"
            ],
            "fixtures": [],
            "assertions": [
                "assert app.instance_path == os.fspath(project2 / 'instance')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "create_namespace",
                    "body": "def create_namespace(package):\n    project = tmp_path / f'project-{package}'\n    monkeypatch.syspath_prepend(os.fspath(project))\n    ns = project / 'namespace' / package\n    ns.mkdir(parents=True)\n    (ns / '__init__.py').write_text('import flask\\napp = flask.Flask(__name__)\\n')\n    return project",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `create_namespace` method is designed to create a temporary project directory structure for a specified package, which includes setting up a namespace package with an `__init__.py` file that initializes a Flask application.\n\n**How It Works**:  \n1. It constructs a path for a temporary project directory based on the provided package name.\n2. It modifies the Python system path to include this new project directory, allowing for module imports from it.\n3. It creates a directory structure for the namespace package, specifically a subdirectory named after the package.\n4. An `__init__.py` file is created within this directory, containing code to import Flask and instantiate a Flask application.\n5. Finally, it returns the path to the created project directory, enabling further operations or imports from this namespace."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_uninstalled_namespace_paths",
            "module": "test_instance_config",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_instance_config.py",
            "line_number": 46,
            "end_line_number": 62,
            "source_code": "def test_uninstalled_namespace_paths(tmp_path, monkeypatch, purge_module):\n    def create_namespace(package):\n        project = tmp_path / f\"project-{package}\"\n        monkeypatch.syspath_prepend(os.fspath(project))\n        ns = project / \"namespace\" / package\n        ns.mkdir(parents=True)\n        (ns / \"__init__.py\").write_text(\"import flask\\napp = flask.Flask(__name__)\\n\")\n        return project\n\n    _ = create_namespace(\"package1\")\n    project2 = create_namespace(\"package2\")\n    purge_module(\"namespace.package2\")\n    purge_module(\"namespace\")\n\n    from namespace.package2 import app\n\n    assert app.instance_path == os.fspath(project2 / \"instance\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "tmp_path",
                "monkeypatch",
                "purge_module"
            ],
            "imports": [
                "os",
                "pytest",
                "flask",
                "config_module_app.app",
                "config_package_app.app",
                "namespace.package2.app",
                "site_app.app",
                "installed_package.app",
                "site_package"
            ],
            "fixtures": [],
            "assertions": [
                "assert app.instance_path == os.fspath(project2 / 'instance')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "purge_module",
                    "body": "@pytest.fixture\ndef purge_module(request):\n\n    def inner(name):\n        request.addfinalizer(lambda : sys.modules.pop(name, None))\n    return inner",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `purge_module` method is a pytest fixture designed to remove a specified module from `sys.modules` after a test completes. This is useful for ensuring that tests do not interfere with each other by leaving behind loaded modules.\n\n**How It Works**:\nThe method defines an inner function that takes the name of a module as an argument. It uses `request.addfinalizer` to register a cleanup function that will be executed after the test finishes. This cleanup function attempts to pop the specified module from `sys.modules`, effectively unloading it. The fixture returns this inner function, allowing tests to call it with the name of the module they wish to purge."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_uninstalled_namespace_paths",
            "module": "test_instance_config",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_instance_config.py",
            "line_number": 46,
            "end_line_number": 62,
            "source_code": "def test_uninstalled_namespace_paths(tmp_path, monkeypatch, purge_module):\n    def create_namespace(package):\n        project = tmp_path / f\"project-{package}\"\n        monkeypatch.syspath_prepend(os.fspath(project))\n        ns = project / \"namespace\" / package\n        ns.mkdir(parents=True)\n        (ns / \"__init__.py\").write_text(\"import flask\\napp = flask.Flask(__name__)\\n\")\n        return project\n\n    _ = create_namespace(\"package1\")\n    project2 = create_namespace(\"package2\")\n    purge_module(\"namespace.package2\")\n    purge_module(\"namespace\")\n\n    from namespace.package2 import app\n\n    assert app.instance_path == os.fspath(project2 / \"instance\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "tmp_path",
                "monkeypatch",
                "purge_module"
            ],
            "imports": [
                "os",
                "pytest",
                "flask",
                "config_module_app.app",
                "config_package_app.app",
                "namespace.package2.app",
                "site_app.app",
                "installed_package.app",
                "site_package"
            ],
            "fixtures": [],
            "assertions": [
                "assert app.instance_path == os.fspath(project2 / 'instance')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "purge_module",
                    "body": "@pytest.fixture\ndef purge_module(request):\n\n    def inner(name):\n        request.addfinalizer(lambda : sys.modules.pop(name, None))\n    return inner",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `purge_module` method is a pytest fixture designed to remove a specified module from `sys.modules` after a test completes. This is useful for ensuring that tests do not interfere with each other by leaving behind loaded modules.\n\n**How It Works**:\nThe method defines an inner function that takes the name of a module as an argument. It uses `request.addfinalizer` to register a cleanup function that will be executed after the test finishes. This cleanup function attempts to pop the specified module from `sys.modules`, effectively unloading it. The fixture returns this inner function, allowing tests to call it with the name of the module they wish to purge."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_installed_module_paths",
            "module": "test_instance_config",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_instance_config.py",
            "line_number": 65,
            "end_line_number": 77,
            "source_code": "def test_installed_module_paths(\n    modules_tmp_path, modules_tmp_path_prefix, purge_module, site_packages, limit_loader\n):\n    (site_packages / \"site_app.py\").write_text(\n        \"import flask\\napp = flask.Flask(__name__)\\n\"\n    )\n    purge_module(\"site_app\")\n\n    from site_app import app\n\n    assert app.instance_path == os.fspath(\n        modules_tmp_path / \"var\" / \"site_app-instance\"\n    )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "modules_tmp_path",
                "modules_tmp_path_prefix",
                "purge_module",
                "site_packages",
                "limit_loader"
            ],
            "imports": [
                "os",
                "pytest",
                "flask",
                "config_module_app.app",
                "config_package_app.app",
                "namespace.package2.app",
                "site_app.app",
                "installed_package.app",
                "site_package"
            ],
            "fixtures": [],
            "assertions": [
                "assert app.instance_path == os.fspath(modules_tmp_path / 'var' / 'site_app-instance')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "purge_module",
                    "body": "@pytest.fixture\ndef purge_module(request):\n\n    def inner(name):\n        request.addfinalizer(lambda : sys.modules.pop(name, None))\n    return inner",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `purge_module` method is a pytest fixture designed to remove a specified module from `sys.modules` after a test completes. This is useful for ensuring that tests do not interfere with each other by leaving behind loaded modules.\n\n**How It Works**:\nThe method defines an inner function that takes the name of a module as an argument. It uses `request.addfinalizer` to register a cleanup function that will be executed after the test finishes. This cleanup function attempts to pop the specified module from `sys.modules`, effectively unloading it. This helps maintain a clean testing environment, especially when tests involve dynamic module loading or reloading."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_installed_package_paths",
            "module": "test_instance_config",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_instance_config.py",
            "line_number": 80,
            "end_line_number": 96,
            "source_code": "def test_installed_package_paths(\n    limit_loader, modules_tmp_path, modules_tmp_path_prefix, purge_module, monkeypatch\n):\n    installed_path = modules_tmp_path / \"path\"\n    installed_path.mkdir()\n    monkeypatch.syspath_prepend(installed_path)\n\n    app = installed_path / \"installed_package\"\n    app.mkdir()\n    (app / \"__init__.py\").write_text(\"import flask\\napp = flask.Flask(__name__)\\n\")\n    purge_module(\"installed_package\")\n\n    from installed_package import app\n\n    assert app.instance_path == os.fspath(\n        modules_tmp_path / \"var\" / \"installed_package-instance\"\n    )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "limit_loader",
                "modules_tmp_path",
                "modules_tmp_path_prefix",
                "purge_module",
                "monkeypatch"
            ],
            "imports": [
                "os",
                "pytest",
                "flask",
                "config_module_app.app",
                "config_package_app.app",
                "namespace.package2.app",
                "site_app.app",
                "installed_package.app",
                "site_package"
            ],
            "fixtures": [],
            "assertions": [
                "assert app.instance_path == os.fspath(modules_tmp_path / 'var' / 'installed_package-instance')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "purge_module",
                    "body": "@pytest.fixture\ndef purge_module(request):\n\n    def inner(name):\n        request.addfinalizer(lambda : sys.modules.pop(name, None))\n    return inner",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `purge_module` method is a pytest fixture designed to remove a specified module from `sys.modules` after a test completes. This is useful for ensuring that tests do not interfere with each other by leaving behind loaded modules.\n\n**How It Works**:\nThe method defines an inner function that takes the name of a module as an argument. It uses `request.addfinalizer` to register a cleanup function that will be executed after the test finishes. This cleanup function attempts to pop the specified module from `sys.modules`, effectively unloading it. The fixture returns this inner function, allowing tests to call it with the name of the module they wish to purge."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_prefix_package_paths",
            "module": "test_instance_config",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_instance_config.py",
            "line_number": 99,
            "end_line_number": 111,
            "source_code": "def test_prefix_package_paths(\n    limit_loader, modules_tmp_path, modules_tmp_path_prefix, purge_module, site_packages\n):\n    app = site_packages / \"site_package\"\n    app.mkdir()\n    (app / \"__init__.py\").write_text(\"import flask\\napp = flask.Flask(__name__)\\n\")\n    purge_module(\"site_package\")\n\n    import site_package\n\n    assert site_package.app.instance_path == os.fspath(\n        modules_tmp_path / \"var\" / \"site_package-instance\"\n    )",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "limit_loader",
                "modules_tmp_path",
                "modules_tmp_path_prefix",
                "purge_module",
                "site_packages"
            ],
            "imports": [
                "os",
                "pytest",
                "flask",
                "config_module_app.app",
                "config_package_app.app",
                "namespace.package2.app",
                "site_app.app",
                "installed_package.app",
                "site_package"
            ],
            "fixtures": [],
            "assertions": [
                "assert site_package.app.instance_path == os.fspath(modules_tmp_path / 'var' / 'site_package-instance')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "purge_module",
                    "body": "@pytest.fixture\ndef purge_module(request):\n\n    def inner(name):\n        request.addfinalizer(lambda : sys.modules.pop(name, None))\n    return inner",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `purge_module` method is a pytest fixture designed to remove a specified module from `sys.modules` after a test completes. This is useful for ensuring that tests do not interfere with each other by leaving behind loaded modules.\n\n**How It Works**:\nThe method defines an inner function that takes a module name as an argument. It uses `request.addfinalizer` to register a cleanup function that will be executed after the test finishes. This cleanup function attempts to pop the specified module from `sys.modules`, effectively unloading it. This helps maintain a clean testing environment, especially when tests involve dynamic module loading or reloading."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_context_binding",
            "module": "test_reqctx",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_reqctx.py",
            "line_number": 107,
            "end_line_number": 120,
            "source_code": "def test_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    @app.route(\"/meh\")\n    def meh():\n        return flask.request.url\n\n    with app.test_request_context(\"/?name=World\"):\n        assert index() == \"Hello World!\"\n    with app.test_request_context(\"/meh\"):\n        assert meh() == \"http://localhost/meh\"\n    assert not flask.request",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "warnings",
                "pytest",
                "flask",
                "flask.globals.request_ctx",
                "flask.sessions.SecureCookieSessionInterface",
                "flask.sessions.SessionInterface",
                "greenlet.greenlet",
                "flask.testing.EnvironBuilder",
                "flask.testing.EnvironBuilder"
            ],
            "fixtures": [],
            "assertions": [
                "assert not flask.request",
                "assert index() == 'Hello World!'",
                "assert meh() == 'http://localhost/meh'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "index",
                    "body": "@app.route('/')\ndef index():\n    return flask.request.url",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `index` method serves as a route handler for the root URL (`/`) of a Flask web application. It returns the current request's URL when accessed.\n\n**How It Works**:\nWhen a client makes a request to the root URL, the `index` function is invoked. It utilizes `flask.request.url` to retrieve the full URL of the incoming request, which includes the scheme (http or https), host, and path. This URL is then returned as the response to the client. The method is decorated with `@app.route('/')`, which registers it as the handler for the root path of the application."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_context_binding",
            "module": "test_reqctx",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_reqctx.py",
            "line_number": 107,
            "end_line_number": 120,
            "source_code": "def test_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    @app.route(\"/meh\")\n    def meh():\n        return flask.request.url\n\n    with app.test_request_context(\"/?name=World\"):\n        assert index() == \"Hello World!\"\n    with app.test_request_context(\"/meh\"):\n        assert meh() == \"http://localhost/meh\"\n    assert not flask.request",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "warnings",
                "pytest",
                "flask",
                "flask.globals.request_ctx",
                "flask.sessions.SecureCookieSessionInterface",
                "flask.sessions.SessionInterface",
                "greenlet.greenlet",
                "flask.testing.EnvironBuilder",
                "flask.testing.EnvironBuilder"
            ],
            "fixtures": [],
            "assertions": [
                "assert not flask.request",
                "assert index() == 'Hello World!'",
                "assert meh() == 'http://localhost/meh'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "meh",
                    "body": "@app.route('/meh')\ndef meh():\n    return flask.request.url",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `meh` method is a Flask route handler that responds to HTTP requests made to the `/meh` endpoint. Its primary function is to return the full URL of the current request.\n\n**How It Works**:\nWhen a request is made to the `/meh` route, the `meh` function is invoked. It utilizes `flask.request.url` to retrieve the complete URL of the incoming request, including the scheme (http or https), host, and path. This URL is then returned as the response to the client. The method is part of a Flask application, which is initialized using the `Flask` class, allowing it to handle web requests and define routes."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_manual_context_binding",
            "module": "test_reqctx",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_reqctx.py",
            "line_number": 135,
            "end_line_number": 145,
            "source_code": "def test_manual_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    ctx = app.test_request_context(\"/?name=World\")\n    ctx.push()\n    assert index() == \"Hello World!\"\n    ctx.pop()\n    with pytest.raises(RuntimeError):\n        index()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "warnings",
                "pytest",
                "flask",
                "flask.globals.request_ctx",
                "flask.sessions.SecureCookieSessionInterface",
                "flask.sessions.SessionInterface",
                "greenlet.greenlet",
                "flask.testing.EnvironBuilder",
                "flask.testing.EnvironBuilder"
            ],
            "fixtures": [],
            "assertions": [
                "assert index() == 'Hello World!'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "index",
                    "body": "@app.route('/')\ndef index():\n    return flask.request.url",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `index` method serves as a route handler for the root URL (`/`) of a Flask web application. It returns the current request's URL, which can be useful for debugging or logging purposes.\n\n**How It Works**:\nWhen a client makes a request to the root URL, Flask invokes the `index` function. Inside this function, `flask.request.url` retrieves the full URL of the incoming request, including the scheme (http or https), host, and path. The method then returns this URL as a string, which is sent back to the client as the HTTP response. This method can be useful for applications that need to know the exact URL being accessed."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_manual_context_binding",
            "module": "test_reqctx",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_reqctx.py",
            "line_number": 135,
            "end_line_number": 145,
            "source_code": "def test_manual_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    ctx = app.test_request_context(\"/?name=World\")\n    ctx.push()\n    assert index() == \"Hello World!\"\n    ctx.pop()\n    with pytest.raises(RuntimeError):\n        index()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "warnings",
                "pytest",
                "flask",
                "flask.globals.request_ctx",
                "flask.sessions.SecureCookieSessionInterface",
                "flask.sessions.SessionInterface",
                "greenlet.greenlet",
                "flask.testing.EnvironBuilder",
                "flask.testing.EnvironBuilder"
            ],
            "fixtures": [],
            "assertions": [
                "assert index() == 'Hello World!'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "index",
                    "body": "@app.route('/')\ndef index():\n    return flask.request.url",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `index` method serves as a route handler for the root URL (`/`) of a Flask web application. It returns the current request's URL, which can be useful for debugging or logging purposes.\n\n**How It Works**:\nWhen a user accesses the root URL of the application, the `index` function is invoked. It utilizes `flask.request.url` to retrieve the full URL of the incoming request, including the scheme (http/https), host, and path. This URL is then returned as the response to the client. The method is decorated with `@app.route('/')`, which registers it as the handler for requests to the root path."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_greenlet_context_copying",
            "module": "test_reqctx",
            "class_name": "TestGreenletContextCopying",
            "file_path": "__internal__/data/flask/tests/test_reqctx.py",
            "line_number": 150,
            "end_line_number": 177,
            "source_code": "def test_greenlet_context_copying(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n            reqctx = request_ctx.copy()\n\n            def g():\n                assert not flask.request\n                assert not flask.current_app\n                with reqctx:\n                    assert flask.request\n                    assert flask.current_app == app\n                    assert flask.request.path == \"/\"\n                    assert flask.request.args[\"foo\"] == \"bar\"\n                    assert flask.session.get(\"fizz\") == \"buzz\"\n                assert not flask.request\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "client"
            ],
            "imports": [
                "warnings",
                "pytest",
                "flask",
                "flask.globals.request_ctx",
                "flask.sessions.SecureCookieSessionInterface",
                "flask.sessions.SessionInterface",
                "greenlet.greenlet",
                "flask.testing.EnvironBuilder",
                "flask.testing.EnvironBuilder"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'Hello World!'",
                "assert result == 42",
                "assert not flask.request",
                "assert not flask.current_app",
                "assert not flask.request",
                "assert flask.request",
                "assert flask.current_app == app",
                "assert flask.request.path == '/'",
                "assert flask.request.args['foo'] == 'bar'",
                "assert flask.session.get('fizz') == 'buzz'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_greenlet_context_copying_api",
            "module": "test_reqctx",
            "class_name": "TestGreenletContextCopying",
            "file_path": "__internal__/data/flask/tests/test_reqctx.py",
            "line_number": 179,
            "end_line_number": 202,
            "source_code": "def test_greenlet_context_copying_api(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n\n            @flask.copy_current_request_context\n            def g():\n                assert flask.request\n                assert flask.current_app == app\n                assert flask.request.path == \"/\"\n                assert flask.request.args[\"foo\"] == \"bar\"\n                assert flask.session.get(\"fizz\") == \"buzz\"\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "client"
            ],
            "imports": [
                "warnings",
                "pytest",
                "flask",
                "flask.globals.request_ctx",
                "flask.sessions.SecureCookieSessionInterface",
                "flask.sessions.SessionInterface",
                "greenlet.greenlet",
                "flask.testing.EnvironBuilder",
                "flask.testing.EnvironBuilder"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'Hello World!'",
                "assert result == 42",
                "assert flask.request",
                "assert flask.current_app == app",
                "assert flask.request.path == '/'",
                "assert flask.request.args['foo'] == 'bar'",
                "assert flask.session.get('fizz') == 'buzz'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called, which attempts to fetch the value stored in the session under the key `'value'`. If this key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve user-specific data across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_dynamic_cookie_name",
            "module": "test_reqctx",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_reqctx.py",
            "line_number": 229,
            "end_line_number": 277,
            "source_code": "def test_session_dynamic_cookie_name():\n    # This session interface will use a cookie with a different name if the\n    # requested url ends with the string \"dynamic_cookie\"\n    class PathAwareSessionInterface(SecureCookieSessionInterface):\n        def get_cookie_name(self, app):\n            if flask.request.url.endswith(\"dynamic_cookie\"):\n                return \"dynamic_cookie_name\"\n            else:\n                return super().get_cookie_name(app)\n\n    class CustomFlask(flask.Flask):\n        session_interface = PathAwareSessionInterface()\n\n    app = CustomFlask(__name__)\n    app.secret_key = \"secret_key\"\n\n    @app.route(\"/set\", methods=[\"POST\"])\n    def set():\n        flask.session[\"value\"] = flask.request.form[\"value\"]\n        return \"value set\"\n\n    @app.route(\"/get\")\n    def get():\n        v = flask.session.get(\"value\", \"None\")\n        return v\n\n    @app.route(\"/set_dynamic_cookie\", methods=[\"POST\"])\n    def set_dynamic_cookie():\n        flask.session[\"value\"] = flask.request.form[\"value\"]\n        return \"value set\"\n\n    @app.route(\"/get_dynamic_cookie\")\n    def get_dynamic_cookie():\n        v = flask.session.get(\"value\", \"None\")\n        return v\n\n    test_client = app.test_client()\n\n    # first set the cookie in both /set urls but each with a different value\n    assert test_client.post(\"/set\", data={\"value\": \"42\"}).data == b\"value set\"\n    assert (\n        test_client.post(\"/set_dynamic_cookie\", data={\"value\": \"616\"}).data\n        == b\"value set\"\n    )\n\n    # now check that the relevant values come back - meaning that different\n    # cookies are being used for the urls that end with \"dynamic cookie\"\n    assert test_client.get(\"/get\").data == b\"42\"\n    assert test_client.get(\"/get_dynamic_cookie\").data == b\"616\"",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "warnings",
                "pytest",
                "flask",
                "flask.globals.request_ctx",
                "flask.sessions.SecureCookieSessionInterface",
                "flask.sessions.SessionInterface",
                "greenlet.greenlet",
                "flask.testing.EnvironBuilder",
                "flask.testing.EnvironBuilder"
            ],
            "fixtures": [],
            "assertions": [
                "assert test_client.post('/set', data={'value': '42'}).data == b'value set'",
                "assert test_client.post('/set_dynamic_cookie', data={'value': '616'}).data == b'value set'",
                "assert test_client.get('/get').data == b'42'",
                "assert test_client.get('/get_dynamic_cookie').data == b'616'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "test_client.post",
                    "body": "def post(self):\n    return 'Create'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `test_client.post` method is used to simulate an HTTP POST request to a specified URL in a Flask application. It is typically employed in testing scenarios to send data to the server and verify the server's response.\n\n**How It Works**:\nWhen `test_client.post` is called, it sends a POST request to the specified endpoint (e.g., `/1/update`) along with any data provided (e.g., `data={\"title\": \"updated\", \"body\": \"\"}`). The method processes the request, triggering the corresponding route handler in the Flask application. The response from the server can then be inspected to ensure that the application behaves as expected, such as checking for status codes or validating changes in the database. In the provided code snippets, this method is used to test functionalities like updating a post, validating input, and deleting a post."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_dynamic_cookie_name",
            "module": "test_reqctx",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_reqctx.py",
            "line_number": 229,
            "end_line_number": 277,
            "source_code": "def test_session_dynamic_cookie_name():\n    # This session interface will use a cookie with a different name if the\n    # requested url ends with the string \"dynamic_cookie\"\n    class PathAwareSessionInterface(SecureCookieSessionInterface):\n        def get_cookie_name(self, app):\n            if flask.request.url.endswith(\"dynamic_cookie\"):\n                return \"dynamic_cookie_name\"\n            else:\n                return super().get_cookie_name(app)\n\n    class CustomFlask(flask.Flask):\n        session_interface = PathAwareSessionInterface()\n\n    app = CustomFlask(__name__)\n    app.secret_key = \"secret_key\"\n\n    @app.route(\"/set\", methods=[\"POST\"])\n    def set():\n        flask.session[\"value\"] = flask.request.form[\"value\"]\n        return \"value set\"\n\n    @app.route(\"/get\")\n    def get():\n        v = flask.session.get(\"value\", \"None\")\n        return v\n\n    @app.route(\"/set_dynamic_cookie\", methods=[\"POST\"])\n    def set_dynamic_cookie():\n        flask.session[\"value\"] = flask.request.form[\"value\"]\n        return \"value set\"\n\n    @app.route(\"/get_dynamic_cookie\")\n    def get_dynamic_cookie():\n        v = flask.session.get(\"value\", \"None\")\n        return v\n\n    test_client = app.test_client()\n\n    # first set the cookie in both /set urls but each with a different value\n    assert test_client.post(\"/set\", data={\"value\": \"42\"}).data == b\"value set\"\n    assert (\n        test_client.post(\"/set_dynamic_cookie\", data={\"value\": \"616\"}).data\n        == b\"value set\"\n    )\n\n    # now check that the relevant values come back - meaning that different\n    # cookies are being used for the urls that end with \"dynamic cookie\"\n    assert test_client.get(\"/get\").data == b\"42\"\n    assert test_client.get(\"/get_dynamic_cookie\").data == b\"616\"",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "warnings",
                "pytest",
                "flask",
                "flask.globals.request_ctx",
                "flask.sessions.SecureCookieSessionInterface",
                "flask.sessions.SessionInterface",
                "greenlet.greenlet",
                "flask.testing.EnvironBuilder",
                "flask.testing.EnvironBuilder"
            ],
            "fixtures": [],
            "assertions": [
                "assert test_client.post('/set', data={'value': '42'}).data == b'value set'",
                "assert test_client.post('/set_dynamic_cookie', data={'value': '616'}).data == b'value set'",
                "assert test_client.get('/get').data == b'42'",
                "assert test_client.get('/get_dynamic_cookie').data == b'616'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "test_client.post",
                    "body": "def post(self):\n    return 'Create'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `test_client.post` method is used to simulate an HTTP POST request to a specified URL in a Flask application. It is typically employed in testing scenarios to submit form data or trigger actions that modify server-side data.\n\n**How It Works**:\nWhen `test_client.post` is called, it sends a POST request to the specified endpoint (e.g., `/1/update` or `/create`) along with any provided data (like form fields). The method returns a response object that contains the server's response to the request. This response can be inspected for status codes, response data, and headers, allowing developers to verify that the application behaves as expected when handling POST requests. In the context of the provided code snippets, it is used to update posts, validate input, and delete resources, ensuring that the application correctly processes these actions."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_dynamic_cookie_name",
            "module": "test_reqctx",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_reqctx.py",
            "line_number": 229,
            "end_line_number": 277,
            "source_code": "def test_session_dynamic_cookie_name():\n    # This session interface will use a cookie with a different name if the\n    # requested url ends with the string \"dynamic_cookie\"\n    class PathAwareSessionInterface(SecureCookieSessionInterface):\n        def get_cookie_name(self, app):\n            if flask.request.url.endswith(\"dynamic_cookie\"):\n                return \"dynamic_cookie_name\"\n            else:\n                return super().get_cookie_name(app)\n\n    class CustomFlask(flask.Flask):\n        session_interface = PathAwareSessionInterface()\n\n    app = CustomFlask(__name__)\n    app.secret_key = \"secret_key\"\n\n    @app.route(\"/set\", methods=[\"POST\"])\n    def set():\n        flask.session[\"value\"] = flask.request.form[\"value\"]\n        return \"value set\"\n\n    @app.route(\"/get\")\n    def get():\n        v = flask.session.get(\"value\", \"None\")\n        return v\n\n    @app.route(\"/set_dynamic_cookie\", methods=[\"POST\"])\n    def set_dynamic_cookie():\n        flask.session[\"value\"] = flask.request.form[\"value\"]\n        return \"value set\"\n\n    @app.route(\"/get_dynamic_cookie\")\n    def get_dynamic_cookie():\n        v = flask.session.get(\"value\", \"None\")\n        return v\n\n    test_client = app.test_client()\n\n    # first set the cookie in both /set urls but each with a different value\n    assert test_client.post(\"/set\", data={\"value\": \"42\"}).data == b\"value set\"\n    assert (\n        test_client.post(\"/set_dynamic_cookie\", data={\"value\": \"616\"}).data\n        == b\"value set\"\n    )\n\n    # now check that the relevant values come back - meaning that different\n    # cookies are being used for the urls that end with \"dynamic cookie\"\n    assert test_client.get(\"/get\").data == b\"42\"\n    assert test_client.get(\"/get_dynamic_cookie\").data == b\"616\"",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "warnings",
                "pytest",
                "flask",
                "flask.globals.request_ctx",
                "flask.sessions.SecureCookieSessionInterface",
                "flask.sessions.SessionInterface",
                "greenlet.greenlet",
                "flask.testing.EnvironBuilder",
                "flask.testing.EnvironBuilder"
            ],
            "fixtures": [],
            "assertions": [
                "assert test_client.post('/set', data={'value': '42'}).data == b'value set'",
                "assert test_client.post('/set_dynamic_cookie', data={'value': '616'}).data == b'value set'",
                "assert test_client.get('/get').data == b'42'",
                "assert test_client.get('/get_dynamic_cookie').data == b'616'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "test_client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `test_client.get` method is used to simulate a GET request to a specified endpoint in a Flask application. It allows developers to test the behavior of their application routes and ensure that they return the expected responses.\n\n**How It Works**:  \nWhen `test_client.get` is called with a URL, it sends a GET request to that endpoint. The Flask application processes the request as if it were coming from a real client. In the provided code, the `get` function retrieves a value from the session (defaulting to 'None' if not set) and returns it. The test client can also be configured to handle sessions, cookies, and other request parameters, enabling comprehensive testing of the application's behavior under various conditions."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_dynamic_cookie_name",
            "module": "test_reqctx",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_reqctx.py",
            "line_number": 229,
            "end_line_number": 277,
            "source_code": "def test_session_dynamic_cookie_name():\n    # This session interface will use a cookie with a different name if the\n    # requested url ends with the string \"dynamic_cookie\"\n    class PathAwareSessionInterface(SecureCookieSessionInterface):\n        def get_cookie_name(self, app):\n            if flask.request.url.endswith(\"dynamic_cookie\"):\n                return \"dynamic_cookie_name\"\n            else:\n                return super().get_cookie_name(app)\n\n    class CustomFlask(flask.Flask):\n        session_interface = PathAwareSessionInterface()\n\n    app = CustomFlask(__name__)\n    app.secret_key = \"secret_key\"\n\n    @app.route(\"/set\", methods=[\"POST\"])\n    def set():\n        flask.session[\"value\"] = flask.request.form[\"value\"]\n        return \"value set\"\n\n    @app.route(\"/get\")\n    def get():\n        v = flask.session.get(\"value\", \"None\")\n        return v\n\n    @app.route(\"/set_dynamic_cookie\", methods=[\"POST\"])\n    def set_dynamic_cookie():\n        flask.session[\"value\"] = flask.request.form[\"value\"]\n        return \"value set\"\n\n    @app.route(\"/get_dynamic_cookie\")\n    def get_dynamic_cookie():\n        v = flask.session.get(\"value\", \"None\")\n        return v\n\n    test_client = app.test_client()\n\n    # first set the cookie in both /set urls but each with a different value\n    assert test_client.post(\"/set\", data={\"value\": \"42\"}).data == b\"value set\"\n    assert (\n        test_client.post(\"/set_dynamic_cookie\", data={\"value\": \"616\"}).data\n        == b\"value set\"\n    )\n\n    # now check that the relevant values come back - meaning that different\n    # cookies are being used for the urls that end with \"dynamic cookie\"\n    assert test_client.get(\"/get\").data == b\"42\"\n    assert test_client.get(\"/get_dynamic_cookie\").data == b\"616\"",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "warnings",
                "pytest",
                "flask",
                "flask.globals.request_ctx",
                "flask.sessions.SecureCookieSessionInterface",
                "flask.sessions.SessionInterface",
                "greenlet.greenlet",
                "flask.testing.EnvironBuilder",
                "flask.testing.EnvironBuilder"
            ],
            "fixtures": [],
            "assertions": [
                "assert test_client.post('/set', data={'value': '42'}).data == b'value set'",
                "assert test_client.post('/set_dynamic_cookie', data={'value': '616'}).data == b'value set'",
                "assert test_client.get('/get').data == b'42'",
                "assert test_client.get('/get_dynamic_cookie').data == b'616'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "test_client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `test_client.get` method is used to simulate a GET request to a specified endpoint in a Flask application. It allows developers to test the behavior of their application routes and verify the responses returned by those routes.\n\n**How It Works**:  \nWhen `test_client.get` is called, it sends a GET request to the specified URL. The Flask application processes this request as if it were coming from a real client. The method returns a response object that contains the status code, response data, and headers. This allows developers to assert expected outcomes, such as checking the response status or validating the returned data, facilitating automated testing of the application's endpoints."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_greenlet_context_copying",
            "module": "test_reqctx",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_reqctx.py",
            "line_number": 150,
            "end_line_number": 177,
            "source_code": "def test_greenlet_context_copying(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n            reqctx = request_ctx.copy()\n\n            def g():\n                assert not flask.request\n                assert not flask.current_app\n                with reqctx:\n                    assert flask.request\n                    assert flask.current_app == app\n                    assert flask.request.path == \"/\"\n                    assert flask.request.args[\"foo\"] == \"bar\"\n                    assert flask.session.get(\"fizz\") == \"buzz\"\n                assert not flask.request\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "client"
            ],
            "imports": [
                "warnings",
                "pytest",
                "flask",
                "flask.globals.request_ctx",
                "flask.sessions.SecureCookieSessionInterface",
                "flask.sessions.SessionInterface",
                "greenlet.greenlet",
                "flask.testing.EnvironBuilder",
                "flask.testing.EnvironBuilder"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'Hello World!'",
                "assert result == 42",
                "assert not flask.request",
                "assert not flask.current_app",
                "assert not flask.request",
                "assert flask.request",
                "assert flask.current_app == app",
                "assert flask.request.path == '/'",
                "assert flask.request.args['foo'] == 'bar'",
                "assert flask.session.get('fizz') == 'buzz'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is used to define a route in a Flask web application that retrieves a value stored in the session. If the session does not contain the specified value, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nThe method is decorated with `@app.route('/get')`, which maps the URL path `/get` to the `get` function. When a GET request is made to this endpoint, the function accesses the session using `flask.session.get('value', 'None')`. This retrieves the value associated with the key `'value'` from the session; if it does not exist, it returns `'None'`. The retrieved value is then returned as the response to the client. This allows for session data to be accessed and utilized in web applications."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_greenlet_context_copying_api",
            "module": "test_reqctx",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_reqctx.py",
            "line_number": 179,
            "end_line_number": 202,
            "source_code": "def test_greenlet_context_copying_api(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n\n            @flask.copy_current_request_context\n            def g():\n                assert flask.request\n                assert flask.current_app == app\n                assert flask.request.path == \"/\"\n                assert flask.request.args[\"foo\"] == \"bar\"\n                assert flask.session.get(\"fizz\") == \"buzz\"\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "client"
            ],
            "imports": [
                "warnings",
                "pytest",
                "flask",
                "flask.globals.request_ctx",
                "flask.sessions.SecureCookieSessionInterface",
                "flask.sessions.SessionInterface",
                "greenlet.greenlet",
                "flask.testing.EnvironBuilder",
                "flask.testing.EnvironBuilder"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'Hello World!'",
                "assert result == 42",
                "assert flask.request",
                "assert flask.current_app == app",
                "assert flask.request.path == '/'",
                "assert flask.request.args['foo'] == 'bar'",
                "assert flask.session.get('fizz') == 'buzz'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_template_rendered",
            "module": "test_signals",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_signals.py",
            "line_number": 4,
            "end_line_number": 22,
            "source_code": "def test_template_rendered(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"simple_template.html\", whiskey=42)\n\n    recorded = []\n\n    def record(sender, template, context):\n        recorded.append((template, context))\n\n    flask.template_rendered.connect(record, app)\n    try:\n        client.get(\"/\")\n        assert len(recorded) == 1\n        template, context = recorded[0]\n        assert template.name == \"simple_template.html\"\n        assert context[\"whiskey\"] == 42\n    finally:\n        flask.template_rendered.disconnect(record, app)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert len(recorded) == 1",
                "assert template.name == 'simple_template.html'",
                "assert context['whiskey'] == 42"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_appcontext_signals",
            "module": "test_signals",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_signals.py",
            "line_number": 115,
            "end_line_number": 136,
            "source_code": "def test_appcontext_signals(app, client):\n    recorded = []\n\n    def record_push(sender, **kwargs):\n        recorded.append(\"push\")\n\n    def record_pop(sender, **kwargs):\n        recorded.append(\"pop\")\n\n    @app.route(\"/\")\n    def index():\n        return \"Hello\"\n\n    flask.appcontext_pushed.connect(record_push, app)\n    flask.appcontext_popped.connect(record_pop, app)\n    try:\n        rv = client.get(\"/\")\n        assert rv.data == b\"Hello\"\n        assert recorded == [\"push\", \"pop\"]\n    finally:\n        flask.appcontext_pushed.disconnect(record_push, app)\n        flask.appcontext_popped.disconnect(record_pop, app)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'Hello'",
                "assert recorded == ['push', 'pop']"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_flash_signal",
            "module": "test_signals",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_signals.py",
            "line_number": 139,
            "end_line_number": 160,
            "source_code": "def test_flash_signal(app):\n    @app.route(\"/\")\n    def index():\n        flask.flash(\"This is a flash message\", category=\"notice\")\n        return flask.redirect(\"/other\")\n\n    recorded = []\n\n    def record(sender, message, category):\n        recorded.append((message, category))\n\n    flask.message_flashed.connect(record, app)\n    try:\n        client = app.test_client()\n        with client.session_transaction():\n            client.get(\"/\")\n            assert len(recorded) == 1\n            message, category = recorded[0]\n            assert message == \"This is a flash message\"\n            assert category == \"notice\"\n    finally:\n        flask.message_flashed.disconnect(record, app)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert len(recorded) == 1",
                "assert message == 'This is a flash message'",
                "assert category == 'notice'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_appcontext_tearing_down_signal",
            "module": "test_signals",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_signals.py",
            "line_number": 163,
            "end_line_number": 181,
            "source_code": "def test_appcontext_tearing_down_signal(app, client):\n    app.testing = False\n    recorded = []\n\n    def record_teardown(sender, exc):\n        recorded.append(exc)\n\n    @app.route(\"/\")\n    def index():\n        raise ZeroDivisionError\n\n    flask.appcontext_tearing_down.connect(record_teardown, app)\n    try:\n        rv = client.get(\"/\")\n        assert rv.status_code == 500\n        assert len(recorded) == 1\n        assert isinstance(recorded[0], ZeroDivisionError)\n    finally:\n        flask.appcontext_tearing_down.disconnect(record_teardown, app)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.status_code == 500",
                "assert len(recorded) == 1",
                "assert isinstance(recorded[0], ZeroDivisionError)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_send_file",
            "module": "test_helpers",
            "class_name": "TestSendfile",
            "file_path": "__internal__/data/flask/tests/test_helpers.py",
            "line_number": 34,
            "end_line_number": 43,
            "source_code": "def test_send_file(self, app, req_ctx):\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.direct_passthrough\n        assert rv.mimetype == \"text/html\"\n\n        with app.open_resource(\"static/index.html\") as f:\n            rv.direct_passthrough = False\n            assert rv.data == f.read()\n\n        rv.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "req_ctx"
            ],
            "imports": [
                "io",
                "os",
                "pytest",
                "werkzeug.exceptions",
                "flask",
                "flask.helpers.get_debug_flag",
                "flask.views.MethodView"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.direct_passthrough",
                "assert rv.mimetype == 'text/html'",
                "assert rv.data == f.read()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "rv.close",
                    "body": "def close(self):\n    called.append(42)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify that the cleanup process was triggered. The method does not return any value or perform any additional actions beyond this simple logging mechanism."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_send_file",
            "module": "test_helpers",
            "class_name": "TestSendfile",
            "file_path": "__internal__/data/flask/tests/test_helpers.py",
            "line_number": 34,
            "end_line_number": 43,
            "source_code": "def test_send_file(self, app, req_ctx):\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.direct_passthrough\n        assert rv.mimetype == \"text/html\"\n\n        with app.open_resource(\"static/index.html\") as f:\n            rv.direct_passthrough = False\n            assert rv.data == f.read()\n\n        rv.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "req_ctx"
            ],
            "imports": [
                "io",
                "os",
                "pytest",
                "werkzeug.exceptions",
                "flask",
                "flask.helpers.get_debug_flag",
                "flask.views.MethodView"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.direct_passthrough",
                "assert rv.mimetype == 'text/html'",
                "assert rv.data == f.read()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "f.read",
                    "body": "@app.route('/read')\ndef read():\n    return str(flask.session.get('foo', 0))",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `f.read` method is not explicitly defined in the provided code snippets, but the context suggests that it is related to reading session data in a Flask application. Specifically, the `read` function retrieves the value associated with the key `'foo'` from the session, defaulting to `0` if the key does not exist.\n\n**How It Works**:  \nThe `read` function is defined as a route handler for the `/read` endpoint in a Flask application. When a request is made to this endpoint, the function accesses the Flask session using `flask.session.get('foo', 0)`, which attempts to retrieve the value of `'foo'`. If `'foo'` is not set in the session, it returns `0`. The result is then converted to a string and returned as the HTTP response. This allows clients to read session data easily through a web request."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_static_file",
            "module": "test_helpers",
            "class_name": "TestSendfile",
            "file_path": "__internal__/data/flask/tests/test_helpers.py",
            "line_number": 45,
            "end_line_number": 90,
            "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "req_ctx"
            ],
            "imports": [
                "io",
                "os",
                "pytest",
                "werkzeug.exceptions",
                "flask",
                "flask.helpers.get_debug_flag",
                "flask.views.MethodView"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.cache_control.max_age is None",
                "assert rv.cache_control.max_age is None",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 10",
                "assert rv.cache_control.max_age == 10"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "rv.close",
                    "body": "def close(self):\n    called.append(42)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify that the cleanup process was triggered. The method does not return any value or perform any additional actions beyond this simple logging mechanism."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_static_file",
            "module": "test_helpers",
            "class_name": "TestSendfile",
            "file_path": "__internal__/data/flask/tests/test_helpers.py",
            "line_number": 45,
            "end_line_number": 90,
            "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "req_ctx"
            ],
            "imports": [
                "io",
                "os",
                "pytest",
                "werkzeug.exceptions",
                "flask",
                "flask.helpers.get_debug_flag",
                "flask.views.MethodView"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.cache_control.max_age is None",
                "assert rv.cache_control.max_age is None",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 10",
                "assert rv.cache_control.max_age == 10"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "rv.close",
                    "body": "def close(self):\n    called.append(42)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify that the cleanup process was triggered as expected. The method does not return any value or perform additional actions beyond this logging."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_static_file",
            "module": "test_helpers",
            "class_name": "TestSendfile",
            "file_path": "__internal__/data/flask/tests/test_helpers.py",
            "line_number": 45,
            "end_line_number": 90,
            "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "req_ctx"
            ],
            "imports": [
                "io",
                "os",
                "pytest",
                "werkzeug.exceptions",
                "flask",
                "flask.helpers.get_debug_flag",
                "flask.views.MethodView"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.cache_control.max_age is None",
                "assert rv.cache_control.max_age is None",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 10",
                "assert rv.cache_control.max_age == 10"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "rv.close",
                    "body": "def close(self):\n    called.append(42)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed or released. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify its execution in tests or other parts of the code. The method does not return any value or perform any additional actions, making it a simple yet effective way to signal that a closing operation has occurred."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_static_file",
            "module": "test_helpers",
            "class_name": "TestSendfile",
            "file_path": "__internal__/data/flask/tests/test_helpers.py",
            "line_number": 45,
            "end_line_number": 90,
            "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "req_ctx"
            ],
            "imports": [
                "io",
                "os",
                "pytest",
                "werkzeug.exceptions",
                "flask",
                "flask.helpers.get_debug_flag",
                "flask.views.MethodView"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.cache_control.max_age is None",
                "assert rv.cache_control.max_age is None",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 10",
                "assert rv.cache_control.max_age == 10"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "rv.close",
                    "body": "def close(self):\n    called.append(42)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify its execution in tests or other parts of the code. The method does not return any value or perform any additional actions, focusing solely on this tracking functionality."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_static_file",
            "module": "test_helpers",
            "class_name": "TestSendfile",
            "file_path": "__internal__/data/flask/tests/test_helpers.py",
            "line_number": 45,
            "end_line_number": 90,
            "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "req_ctx"
            ],
            "imports": [
                "io",
                "os",
                "pytest",
                "werkzeug.exceptions",
                "flask",
                "flask.helpers.get_debug_flag",
                "flask.views.MethodView"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.cache_control.max_age is None",
                "assert rv.cache_control.max_age is None",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 10",
                "assert rv.cache_control.max_age == 10"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "rv.close",
                    "body": "def close(self):\n    called.append(42)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically related to resource management, by appending a value (42) to a list named `called`. This suggests that it is part of a mechanism to track when the method is invoked, possibly indicating that a resource (like a database connection or file) has been closed.\n\n**How It Works**:  \nWhen the `close` method is called, it executes a single line of code that appends the integer 42 to the `called` list. This action serves as a simple logging or tracking mechanism to indicate that the `close` method has been executed. The method does not return any value or perform any additional operations, making it a straightforward implementation focused on signaling the closure of a resource."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_static_file",
            "module": "test_helpers",
            "class_name": "TestSendfile",
            "file_path": "__internal__/data/flask/tests/test_helpers.py",
            "line_number": 45,
            "end_line_number": 90,
            "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "req_ctx"
            ],
            "imports": [
                "io",
                "os",
                "pytest",
                "werkzeug.exceptions",
                "flask",
                "flask.helpers.get_debug_flag",
                "flask.views.MethodView"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.cache_control.max_age is None",
                "assert rv.cache_control.max_age is None",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 10",
                "assert rv.cache_control.max_age == 10"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "rv.close",
                    "body": "def close(self):\n    called.append(42)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed or released. In this specific implementation, it appends the value `42` to a list named `called`, indicating that the method has been invoked.\n\n**How It Works**:  \nWhen the `close` method is called, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This serves as a simple mechanism to track that the `close` method was executed. The method does not return any value or perform any additional actions, making it a straightforward way to signal that a closing operation has occurred."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_static_file",
            "module": "test_helpers",
            "class_name": "TestSendfile",
            "file_path": "__internal__/data/flask/tests/test_helpers.py",
            "line_number": 45,
            "end_line_number": 90,
            "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "req_ctx"
            ],
            "imports": [
                "io",
                "os",
                "pytest",
                "werkzeug.exceptions",
                "flask",
                "flask.helpers.get_debug_flag",
                "flask.views.MethodView"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.cache_control.max_age is None",
                "assert rv.cache_control.max_age is None",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 10",
                "assert rv.cache_control.max_age == 10"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "rv.close",
                    "body": "def close(self):\n    called.append(42)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify that the cleanup process was triggered. The method does not return any value or perform any additional actions, making it a simple yet effective way to signal that a closing operation has occurred."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_send_from_directory",
            "module": "test_helpers",
            "class_name": "TestSendfile",
            "file_path": "__internal__/data/flask/tests/test_helpers.py",
            "line_number": 92,
            "end_line_number": 99,
            "source_code": "def test_send_from_directory(self, app, req_ctx):\n        app.root_path = os.path.join(\n            os.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n        )\n        rv = flask.send_from_directory(\"static\", \"hello.txt\")\n        rv.direct_passthrough = False\n        assert rv.data.strip() == b\"Hello Subdomain\"\n        rv.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "req_ctx"
            ],
            "imports": [
                "io",
                "os",
                "pytest",
                "werkzeug.exceptions",
                "flask",
                "flask.helpers.get_debug_flag",
                "flask.views.MethodView"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data.strip() == b'Hello Subdomain'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "rv.close",
                    "body": "def close(self):\n    called.append(42)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically related to resource management, by appending a specific value (42) to a list named `called`. This indicates that the method has been invoked, which can be useful for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is called, it executes a single line of code that appends the integer 42 to the `called` list. This action serves as a simple signal that the method has been executed, allowing developers to verify that the cleanup process has occurred, especially in contexts where resource management is critical, such as database connections or file handlers."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_streaming_with_context",
            "module": "test_helpers",
            "class_name": "TestStreaming",
            "file_path": "__internal__/data/flask/tests/test_helpers.py",
            "line_number": 237,
            "end_line_number": 248,
            "source_code": "def test_streaming_with_context(self, app, client):\n        @app.route(\"/\")\n        def index():\n            def generate():\n                yield \"Hello \"\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(flask.stream_with_context(generate()))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "client"
            ],
            "imports": [
                "io",
                "os",
                "pytest",
                "werkzeug.exceptions",
                "flask",
                "flask.helpers.get_debug_flag",
                "flask.views.MethodView"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'Hello World!'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, defaulting to `'None'` if the key `'value'` does not exist.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. It uses `flask.session.get` to access the session data, specifically looking for the key `'value'`. If this key is found, its associated value is returned; if not, the string `'None'` is returned. This method is useful for retrieving session-specific data in a web application context."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_streaming_with_context",
            "module": "test_helpers",
            "class_name": "TestStreaming",
            "file_path": "__internal__/data/flask/tests/test_helpers.py",
            "line_number": 237,
            "end_line_number": 248,
            "source_code": "def test_streaming_with_context(self, app, client):\n        @app.route(\"/\")\n        def index():\n            def generate():\n                yield \"Hello \"\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(flask.stream_with_context(generate()))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "client"
            ],
            "imports": [
                "io",
                "os",
                "pytest",
                "werkzeug.exceptions",
                "flask",
                "flask.helpers.get_debug_flag",
                "flask.views.MethodView"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'Hello World!'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "generate",
                    "body": "def generate():\n    yield 'Hello '\n    yield flask.request.args['name']\n    yield '!'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `generate` method is designed to yield a sequence of strings, which can be used to create a dynamic response in a web application, particularly within the context of Flask. It allows for the construction of a message that includes a greeting and a name provided via the request's query parameters.\n\n**How It Works**:\nThe method uses the `yield` statement to produce a series of values one at a time. It first yields the string `'Hello '`, then retrieves the value associated with the key `'name'` from the request's query parameters (using `flask.request.args['name']`), and finally yields the string `'!'`. This creates a generator that can be iterated over to produce the complete greeting message, which can be streamed as a response in a Flask application."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_streaming_with_context_as_decorator",
            "module": "test_helpers",
            "class_name": "TestStreaming",
            "file_path": "__internal__/data/flask/tests/test_helpers.py",
            "line_number": 250,
            "end_line_number": 262,
            "source_code": "def test_streaming_with_context_as_decorator(self, app, client):\n        @app.route(\"/\")\n        def index():\n            @flask.stream_with_context\n            def generate(hello):\n                yield hello\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(generate(\"Hello \"))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "client"
            ],
            "imports": [
                "io",
                "os",
                "pytest",
                "werkzeug.exceptions",
                "flask",
                "flask.helpers.get_debug_flag",
                "flask.views.MethodView"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'Hello World!'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it as a response.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` attempts to fetch the value stored in the session under the key `'value'`. If this key does not exist, it defaults to returning the string `'None'`. The retrieved value is then returned as the HTTP response. This method relies on Flask's session management to store and retrieve user-specific data across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_streaming_with_context_as_decorator",
            "module": "test_helpers",
            "class_name": "TestStreaming",
            "file_path": "__internal__/data/flask/tests/test_helpers.py",
            "line_number": 250,
            "end_line_number": 262,
            "source_code": "def test_streaming_with_context_as_decorator(self, app, client):\n        @app.route(\"/\")\n        def index():\n            @flask.stream_with_context\n            def generate(hello):\n                yield hello\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(generate(\"Hello \"))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "client"
            ],
            "imports": [
                "io",
                "os",
                "pytest",
                "werkzeug.exceptions",
                "flask",
                "flask.helpers.get_debug_flag",
                "flask.views.MethodView"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'Hello World!'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "generate",
                    "body": "def generate():\n    yield 'Hello '\n    yield flask.request.args['name']\n    yield '!'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `generate` method is a generator function that yields a sequence of strings, specifically a greeting message that includes a name obtained from the request's query parameters.\n\n**How It Works**:\nThe method uses the `yield` statement to produce three parts of a greeting: the string `'Hello '`, the value of the `name` parameter from the incoming request (accessed via `flask.request.args['name']`), and the string `'!'`. This allows the function to return these values one at a time, making it suitable for streaming responses in a Flask application. When called, it can be used in conjunction with Flask's response handling to create dynamic content based on user input."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_streaming_with_context_and_custom_close",
            "module": "test_helpers",
            "class_name": "TestStreaming",
            "file_path": "__internal__/data/flask/tests/test_helpers.py",
            "line_number": 264,
            "end_line_number": 293,
            "source_code": "def test_streaming_with_context_and_custom_close(self, app, client):\n        called = []\n\n        class Wrapper:\n            def __init__(self, gen):\n                self._gen = gen\n\n            def __iter__(self):\n                return self\n\n            def close(self):\n                called.append(42)\n\n            def __next__(self):\n                return next(self._gen)\n\n            next = __next__\n\n        @app.route(\"/\")\n        def index():\n            def generate():\n                yield \"Hello \"\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(flask.stream_with_context(Wrapper(generate())))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\"\n        assert called == [42]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "client"
            ],
            "imports": [
                "io",
                "os",
                "pytest",
                "werkzeug.exceptions",
                "flask",
                "flask.helpers.get_debug_flag",
                "flask.views.MethodView"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'Hello World!'",
                "assert called == [42]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_streaming_with_context_and_custom_close",
            "module": "test_helpers",
            "class_name": "TestStreaming",
            "file_path": "__internal__/data/flask/tests/test_helpers.py",
            "line_number": 264,
            "end_line_number": 293,
            "source_code": "def test_streaming_with_context_and_custom_close(self, app, client):\n        called = []\n\n        class Wrapper:\n            def __init__(self, gen):\n                self._gen = gen\n\n            def __iter__(self):\n                return self\n\n            def close(self):\n                called.append(42)\n\n            def __next__(self):\n                return next(self._gen)\n\n            next = __next__\n\n        @app.route(\"/\")\n        def index():\n            def generate():\n                yield \"Hello \"\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(flask.stream_with_context(Wrapper(generate())))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\"\n        assert called == [42]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "client"
            ],
            "imports": [
                "io",
                "os",
                "pytest",
                "werkzeug.exceptions",
                "flask",
                "flask.helpers.get_debug_flag",
                "flask.views.MethodView"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'Hello World!'",
                "assert called == [42]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "generate",
                    "body": "def generate():\n    yield 'Hello '\n    yield flask.request.args['name']\n    yield '!'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `generate` method is a generator function that yields a sequence of strings, specifically a greeting message that includes a name obtained from the request's query parameters.\n\n**How It Works**:\nThe method uses the `yield` statement to produce three parts of a greeting: the string `'Hello '`, the value of the `name` parameter from the incoming request (accessed via `flask.request.args['name']`), and the string `'!'`. This allows the function to return these values one at a time, making it suitable for streaming responses in a Flask application. When called, it can be used in conjunction with Flask's response handling to create dynamic content based on user input."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_stream_keeps_session",
            "module": "test_helpers",
            "class_name": "TestStreaming",
            "file_path": "__internal__/data/flask/tests/test_helpers.py",
            "line_number": 295,
            "end_line_number": 307,
            "source_code": "def test_stream_keeps_session(self, app, client):\n        @app.route(\"/\")\n        def index():\n            flask.session[\"test\"] = \"flask\"\n\n            @flask.stream_with_context\n            def gen():\n                yield flask.session[\"test\"]\n\n            return flask.Response(gen())\n\n        rv = client.get(\"/\")\n        assert rv.data == b\"flask\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "client"
            ],
            "imports": [
                "io",
                "os",
                "pytest",
                "werkzeug.exceptions",
                "flask",
                "flask.helpers.get_debug_flag",
                "flask.views.MethodView"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'flask'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_stream_keeps_session",
            "module": "test_helpers",
            "class_name": "TestStreaming",
            "file_path": "__internal__/data/flask/tests/test_helpers.py",
            "line_number": 295,
            "end_line_number": 307,
            "source_code": "def test_stream_keeps_session(self, app, client):\n        @app.route(\"/\")\n        def index():\n            flask.session[\"test\"] = \"flask\"\n\n            @flask.stream_with_context\n            def gen():\n                yield flask.session[\"test\"]\n\n            return flask.Response(gen())\n\n        rv = client.get(\"/\")\n        assert rv.data == b\"flask\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "client"
            ],
            "imports": [
                "io",
                "os",
                "pytest",
                "werkzeug.exceptions",
                "flask",
                "flask.helpers.get_debug_flag",
                "flask.views.MethodView"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'flask'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "gen",
                    "body": "@flask.stream_with_context\ndef gen():\n    yield flask.session['test']",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `gen` method is designed to yield the value stored in the Flask session under the key `'test'`. It is intended for use in streaming responses, allowing the session data to be accessed even when the request context is not directly available.\n\n**How It Works**:  \nThe method is decorated with `@flask.stream_with_context`, which ensures that the request context is preserved while the generator is yielding values. This is crucial because, in a typical streaming response, the request context would be lost once the response starts. By using this decorator, the `gen` method can safely access `flask.session`, allowing it to yield the session value as part of a streamed response. This is particularly useful for scenarios where data needs to be sent to the client incrementally."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_open_resource",
            "module": "test_helpers",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_helpers.py",
            "line_number": 339,
            "end_line_number": 343,
            "source_code": "def test_open_resource(mode):\n    app = flask.Flask(__name__)\n\n    with app.open_resource(\"static/index.html\", mode) as f:\n        assert \"<h1>Hello World!</h1>\" in str(f.read())",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('mode', ('r', 'rb', 'rt'))"
            ],
            "arguments": [
                "mode"
            ],
            "imports": [
                "io",
                "os",
                "pytest",
                "werkzeug.exceptions",
                "flask",
                "flask.helpers.get_debug_flag",
                "flask.views.MethodView"
            ],
            "fixtures": [],
            "assertions": [
                "assert '<h1>Hello World!</h1>' in str(f.read())"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "f.read",
                    "body": "@app.route('/read')\ndef read():\n    return str(flask.session.get('foo', 0))",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `f.read` method is not explicitly defined in the provided code snippets, but the context suggests that it is related to reading session data in a Flask application. Specifically, the `read` function retrieves the value associated with the key `'foo'` from the session, defaulting to `0` if the key does not exist.\n\n**How It Works**:  \nThe `read` function is defined as a route handler for the `/read` endpoint in a Flask application. When a request is made to this endpoint, the function accesses the Flask session using `flask.session.get('foo', 0)`, which attempts to retrieve the value of `'foo'`. If `'foo'` is not set in the session, it returns `0`. The result is then converted to a string and returned as the HTTP response. This allows clients to read session data easily through a web request."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_open_resource_with_encoding",
            "module": "test_helpers",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_helpers.py",
            "line_number": 355,
            "end_line_number": 360,
            "source_code": "def test_open_resource_with_encoding(tmp_path, encoding):\n    app = flask.Flask(__name__, root_path=os.fspath(tmp_path))\n    (tmp_path / \"test\").write_text(\"test\", encoding=encoding)\n\n    with app.open_resource(\"test\", mode=\"rt\", encoding=encoding) as f:\n        assert f.read() == \"test\"",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('encoding', ('utf-8', 'utf-16-le'))"
            ],
            "arguments": [
                "tmp_path",
                "encoding"
            ],
            "imports": [
                "io",
                "os",
                "pytest",
                "werkzeug.exceptions",
                "flask",
                "flask.helpers.get_debug_flag",
                "flask.views.MethodView"
            ],
            "fixtures": [],
            "assertions": [
                "assert f.read() == 'test'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "f.read",
                    "body": "@app.route('/read')\ndef read():\n    return str(flask.session.get('foo', 0))",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `f.read` method is not explicitly defined in the provided code snippets, but the context suggests that it is related to reading session data in a Flask application. Specifically, the `read` function retrieves a value from the session, defaulting to `0` if the key `'foo'` does not exist.\n\n**How It Works**:  \nThe `read` function is defined as a route handler for the `/read` endpoint in a Flask application. When a request is made to this endpoint, it accesses the Flask session using `flask.session.get('foo', 0)`, which attempts to retrieve the value associated with the key `'foo'`. If the key is not found, it returns `0`. The result is then converted to a string and returned as the HTTP response. This allows the application to read session data and respond accordingly, facilitating state management across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_send_file",
            "module": "test_helpers",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_helpers.py",
            "line_number": 34,
            "end_line_number": 43,
            "source_code": "def test_send_file(self, app, req_ctx):\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.direct_passthrough\n        assert rv.mimetype == \"text/html\"\n\n        with app.open_resource(\"static/index.html\") as f:\n            rv.direct_passthrough = False\n            assert rv.data == f.read()\n\n        rv.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "req_ctx"
            ],
            "imports": [
                "io",
                "os",
                "pytest",
                "werkzeug.exceptions",
                "flask",
                "flask.helpers.get_debug_flag",
                "flask.views.MethodView"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.direct_passthrough",
                "assert rv.mimetype == 'text/html'",
                "assert rv.data == f.read()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "rv.close",
                    "body": "def close(self):\n    called.append(42)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify that the cleanup process was triggered as expected. The method does not return any value or perform any additional actions beyond this append operation."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_send_file",
            "module": "test_helpers",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_helpers.py",
            "line_number": 34,
            "end_line_number": 43,
            "source_code": "def test_send_file(self, app, req_ctx):\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.direct_passthrough\n        assert rv.mimetype == \"text/html\"\n\n        with app.open_resource(\"static/index.html\") as f:\n            rv.direct_passthrough = False\n            assert rv.data == f.read()\n\n        rv.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "req_ctx"
            ],
            "imports": [
                "io",
                "os",
                "pytest",
                "werkzeug.exceptions",
                "flask",
                "flask.helpers.get_debug_flag",
                "flask.views.MethodView"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.direct_passthrough",
                "assert rv.mimetype == 'text/html'",
                "assert rv.data == f.read()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "f.read",
                    "body": "@app.route('/read')\ndef read():\n    return str(flask.session.get('foo', 0))",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `f.read` method is not explicitly defined in the provided code snippets, but the context suggests that it is related to reading session data in a Flask application. Specifically, the `read` function retrieves the value associated with the key `'foo'` from the session, defaulting to `0` if the key does not exist.\n\n**How It Works**:  \nThe `read` function is defined as a route handler for the `/read` endpoint in a Flask application. When a request is made to this endpoint, the function accesses the Flask session using `flask.session.get('foo', 0)`, which attempts to retrieve the value of `'foo'`. If `'foo'` is not set in the session, it returns `0`. The result is then converted to a string and returned as the HTTP response. This allows clients to read session data easily through a web request."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_static_file",
            "module": "test_helpers",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_helpers.py",
            "line_number": 45,
            "end_line_number": 90,
            "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "req_ctx"
            ],
            "imports": [
                "io",
                "os",
                "pytest",
                "werkzeug.exceptions",
                "flask",
                "flask.helpers.get_debug_flag",
                "flask.views.MethodView"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.cache_control.max_age is None",
                "assert rv.cache_control.max_age is None",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 10",
                "assert rv.cache_control.max_age == 10"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "rv.close",
                    "body": "def close(self):\n    called.append(42)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed or released. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify its execution during testing or debugging. The method does not return any value and is likely part of a larger context where resource management is essential."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_static_file",
            "module": "test_helpers",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_helpers.py",
            "line_number": 45,
            "end_line_number": 90,
            "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "req_ctx"
            ],
            "imports": [
                "io",
                "os",
                "pytest",
                "werkzeug.exceptions",
                "flask",
                "flask.helpers.get_debug_flag",
                "flask.views.MethodView"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.cache_control.max_age is None",
                "assert rv.cache_control.max_age is None",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 10",
                "assert rv.cache_control.max_age == 10"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "rv.close",
                    "body": "def close(self):\n    called.append(42)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically related to resource management, such as closing connections or releasing resources when they are no longer needed.\n\n**How It Works**:  \nWhen the `close` method is called, it appends the integer `42` to a list named `called`. This indicates that the method has been executed, which can be useful for tracking or testing purposes. The method does not return any value and is likely part of a larger context where resource management is essential, such as in database connections or file handling."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_static_file",
            "module": "test_helpers",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_helpers.py",
            "line_number": 45,
            "end_line_number": 90,
            "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "req_ctx"
            ],
            "imports": [
                "io",
                "os",
                "pytest",
                "werkzeug.exceptions",
                "flask",
                "flask.helpers.get_debug_flag",
                "flask.views.MethodView"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.cache_control.max_age is None",
                "assert rv.cache_control.max_age is None",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 10",
                "assert rv.cache_control.max_age == 10"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "rv.close",
                    "body": "def close(self):\n    called.append(42)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically related to resource management, by appending a specific value (42) to a list named `called`. This indicates that the method has been invoked, which can be useful for tracking or debugging purposes.\n\n**How It Works**:  \nWhen the `close` method is called, it executes a single line of code that appends the integer 42 to the `called` list. This action serves as a simple signal that the method has been executed, allowing developers to verify that the cleanup process has occurred. The method does not return any value or perform any additional operations beyond this append action."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_static_file",
            "module": "test_helpers",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_helpers.py",
            "line_number": 45,
            "end_line_number": 90,
            "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "req_ctx"
            ],
            "imports": [
                "io",
                "os",
                "pytest",
                "werkzeug.exceptions",
                "flask",
                "flask.helpers.get_debug_flag",
                "flask.views.MethodView"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.cache_control.max_age is None",
                "assert rv.cache_control.max_age is None",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 10",
                "assert rv.cache_control.max_age == 10"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "rv.close",
                    "body": "def close(self):\n    called.append(42)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify its execution in tests or other parts of the code. The method does not return any value or perform additional actions, focusing solely on the side effect of modifying the `called` list."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_static_file",
            "module": "test_helpers",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_helpers.py",
            "line_number": 45,
            "end_line_number": 90,
            "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "req_ctx"
            ],
            "imports": [
                "io",
                "os",
                "pytest",
                "werkzeug.exceptions",
                "flask",
                "flask.helpers.get_debug_flag",
                "flask.views.MethodView"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.cache_control.max_age is None",
                "assert rv.cache_control.max_age is None",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 10",
                "assert rv.cache_control.max_age == 10"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "rv.close",
                    "body": "def close(self):\n    called.append(42)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify its execution in tests or other parts of the code. The method does not return any value or perform any additional actions, focusing solely on this tracking functionality."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_static_file",
            "module": "test_helpers",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_helpers.py",
            "line_number": 45,
            "end_line_number": 90,
            "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "req_ctx"
            ],
            "imports": [
                "io",
                "os",
                "pytest",
                "werkzeug.exceptions",
                "flask",
                "flask.helpers.get_debug_flag",
                "flask.views.MethodView"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.cache_control.max_age is None",
                "assert rv.cache_control.max_age is None",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 10",
                "assert rv.cache_control.max_age == 10"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "rv.close",
                    "body": "def close(self):\n    called.append(42)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed or released. In this specific implementation, it appends the value `42` to a list named `called`, indicating that the method has been invoked.\n\n**How It Works**:\nWhen the `close` method is called, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This can be used for tracking whether the method has been executed, which is useful in testing or debugging scenarios. The method does not return any value or perform any additional operations, making it a straightforward way to signal that a closure action has taken place."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_static_file",
            "module": "test_helpers",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_helpers.py",
            "line_number": 45,
            "end_line_number": 90,
            "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "req_ctx"
            ],
            "imports": [
                "io",
                "os",
                "pytest",
                "werkzeug.exceptions",
                "flask",
                "flask.helpers.get_debug_flag",
                "flask.views.MethodView"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.cache_control.max_age is None",
                "assert rv.cache_control.max_age is None",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 3600",
                "assert rv.cache_control.max_age == 10",
                "assert rv.cache_control.max_age == 10"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "rv.close",
                    "body": "def close(self):\n    called.append(42)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify that the cleanup process was triggered. The method does not return any value or perform any additional actions, making it a simple yet effective way to track method invocations in a testing or debugging context."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_send_from_directory",
            "module": "test_helpers",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_helpers.py",
            "line_number": 92,
            "end_line_number": 99,
            "source_code": "def test_send_from_directory(self, app, req_ctx):\n        app.root_path = os.path.join(\n            os.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n        )\n        rv = flask.send_from_directory(\"static\", \"hello.txt\")\n        rv.direct_passthrough = False\n        assert rv.data.strip() == b\"Hello Subdomain\"\n        rv.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "req_ctx"
            ],
            "imports": [
                "io",
                "os",
                "pytest",
                "werkzeug.exceptions",
                "flask",
                "flask.helpers.get_debug_flag",
                "flask.views.MethodView"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data.strip() == b'Hello Subdomain'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "rv.close",
                    "body": "def close(self):\n    called.append(42)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically related to resource management, by appending a specific value (42) to a list named `called`. This indicates that the method has been invoked, which can be useful for tracking or debugging purposes.\n\n**How It Works**:  \nWhen the `close` method is called, it executes a single line of code that appends the integer 42 to the `called` list. This action serves as a simple signal that the method has been executed, allowing developers to verify that the cleanup process has occurred. The method does not return any value or perform any additional operations beyond this append action."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_streaming_with_context",
            "module": "test_helpers",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_helpers.py",
            "line_number": 237,
            "end_line_number": 248,
            "source_code": "def test_streaming_with_context(self, app, client):\n        @app.route(\"/\")\n        def index():\n            def generate():\n                yield \"Hello \"\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(flask.stream_with_context(generate()))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "client"
            ],
            "imports": [
                "io",
                "os",
                "pytest",
                "werkzeug.exceptions",
                "flask",
                "flask.helpers.get_debug_flag",
                "flask.views.MethodView"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'Hello World!'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_streaming_with_context",
            "module": "test_helpers",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_helpers.py",
            "line_number": 237,
            "end_line_number": 248,
            "source_code": "def test_streaming_with_context(self, app, client):\n        @app.route(\"/\")\n        def index():\n            def generate():\n                yield \"Hello \"\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(flask.stream_with_context(generate()))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "client"
            ],
            "imports": [
                "io",
                "os",
                "pytest",
                "werkzeug.exceptions",
                "flask",
                "flask.helpers.get_debug_flag",
                "flask.views.MethodView"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'Hello World!'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "generate",
                    "body": "def generate():\n    yield 'Hello '\n    yield flask.request.args['name']\n    yield '!'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `generate` method is a generator function that yields a sequence of strings, specifically a greeting message that includes a name obtained from the request's query parameters.\n\n**How It Works**:\nThe method uses the `yield` statement to produce three parts of a greeting: the string `'Hello '`, the value of the `name` parameter from the incoming request (accessed via `flask.request.args['name']`), and the string `'!'`. This allows the function to return these values one at a time, making it suitable for streaming responses in a Flask application. When called, it can be used in a context where the response is generated incrementally, which is useful for handling large data or long-running processes without blocking the server."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_streaming_with_context_as_decorator",
            "module": "test_helpers",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_helpers.py",
            "line_number": 250,
            "end_line_number": 262,
            "source_code": "def test_streaming_with_context_as_decorator(self, app, client):\n        @app.route(\"/\")\n        def index():\n            @flask.stream_with_context\n            def generate(hello):\n                yield hello\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(generate(\"Hello \"))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "client"
            ],
            "imports": [
                "io",
                "os",
                "pytest",
                "werkzeug.exceptions",
                "flask",
                "flask.helpers.get_debug_flag",
                "flask.views.MethodView"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'Hello World!'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, returning it to the client.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` route, the `get` function is invoked. It uses `flask.session.get` to access the session data, specifically looking for a key named `'value'`. If this key does not exist, it defaults to returning the string `'None'`. The retrieved value is then sent back as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving session data."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_streaming_with_context_as_decorator",
            "module": "test_helpers",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_helpers.py",
            "line_number": 250,
            "end_line_number": 262,
            "source_code": "def test_streaming_with_context_as_decorator(self, app, client):\n        @app.route(\"/\")\n        def index():\n            @flask.stream_with_context\n            def generate(hello):\n                yield hello\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(generate(\"Hello \"))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "client"
            ],
            "imports": [
                "io",
                "os",
                "pytest",
                "werkzeug.exceptions",
                "flask",
                "flask.helpers.get_debug_flag",
                "flask.views.MethodView"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'Hello World!'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "generate",
                    "body": "def generate():\n    yield 'Hello '\n    yield flask.request.args['name']\n    yield '!'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `generate` method is a generator function that yields a sequence of strings, specifically a greeting message that includes a name obtained from the request's query parameters.\n\n**How It Works**:\nThe method uses the `yield` statement to produce three parts of a greeting: the string `'Hello '`, the value of the `name` parameter from the incoming request (accessed via `flask.request.args['name']`), and the string `'!'`. This allows the function to return these values one at a time, making it suitable for streaming responses in a Flask application. When called, it can be used in a context where the response is generated incrementally, which is useful for handling large data or long-running processes without blocking the server."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_streaming_with_context_and_custom_close",
            "module": "test_helpers",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_helpers.py",
            "line_number": 264,
            "end_line_number": 293,
            "source_code": "def test_streaming_with_context_and_custom_close(self, app, client):\n        called = []\n\n        class Wrapper:\n            def __init__(self, gen):\n                self._gen = gen\n\n            def __iter__(self):\n                return self\n\n            def close(self):\n                called.append(42)\n\n            def __next__(self):\n                return next(self._gen)\n\n            next = __next__\n\n        @app.route(\"/\")\n        def index():\n            def generate():\n                yield \"Hello \"\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(flask.stream_with_context(Wrapper(generate())))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\"\n        assert called == [42]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "client"
            ],
            "imports": [
                "io",
                "os",
                "pytest",
                "werkzeug.exceptions",
                "flask",
                "flask.helpers.get_debug_flag",
                "flask.views.MethodView"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'Hello World!'",
                "assert called == [42]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_streaming_with_context_and_custom_close",
            "module": "test_helpers",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_helpers.py",
            "line_number": 264,
            "end_line_number": 293,
            "source_code": "def test_streaming_with_context_and_custom_close(self, app, client):\n        called = []\n\n        class Wrapper:\n            def __init__(self, gen):\n                self._gen = gen\n\n            def __iter__(self):\n                return self\n\n            def close(self):\n                called.append(42)\n\n            def __next__(self):\n                return next(self._gen)\n\n            next = __next__\n\n        @app.route(\"/\")\n        def index():\n            def generate():\n                yield \"Hello \"\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(flask.stream_with_context(Wrapper(generate())))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\"\n        assert called == [42]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "client"
            ],
            "imports": [
                "io",
                "os",
                "pytest",
                "werkzeug.exceptions",
                "flask",
                "flask.helpers.get_debug_flag",
                "flask.views.MethodView"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'Hello World!'",
                "assert called == [42]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "generate",
                    "body": "def generate():\n    yield 'Hello '\n    yield flask.request.args['name']\n    yield '!'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `generate` method is a generator function designed to yield a sequence of strings, specifically a greeting message that includes a name obtained from the request's query parameters.\n\n**How It Works**:\nThe method uses the `yield` statement to produce three parts of a greeting: the string `'Hello '`, the value of the `name` parameter from the incoming request (accessed via `flask.request.args['name']`), and the string `'!'`. This allows the function to return these values one at a time, making it suitable for streaming responses in a Flask application. When called, it can be used in conjunction with Flask's response handling to dynamically generate content based on user input."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_stream_keeps_session",
            "module": "test_helpers",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_helpers.py",
            "line_number": 295,
            "end_line_number": 307,
            "source_code": "def test_stream_keeps_session(self, app, client):\n        @app.route(\"/\")\n        def index():\n            flask.session[\"test\"] = \"flask\"\n\n            @flask.stream_with_context\n            def gen():\n                yield flask.session[\"test\"]\n\n            return flask.Response(gen())\n\n        rv = client.get(\"/\")\n        assert rv.data == b\"flask\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "client"
            ],
            "imports": [
                "io",
                "os",
                "pytest",
                "werkzeug.exceptions",
                "flask",
                "flask.helpers.get_debug_flag",
                "flask.views.MethodView"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'flask'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. Finally, the retrieved value is returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_stream_keeps_session",
            "module": "test_helpers",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_helpers.py",
            "line_number": 295,
            "end_line_number": 307,
            "source_code": "def test_stream_keeps_session(self, app, client):\n        @app.route(\"/\")\n        def index():\n            flask.session[\"test\"] = \"flask\"\n\n            @flask.stream_with_context\n            def gen():\n                yield flask.session[\"test\"]\n\n            return flask.Response(gen())\n\n        rv = client.get(\"/\")\n        assert rv.data == b\"flask\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "client"
            ],
            "imports": [
                "io",
                "os",
                "pytest",
                "werkzeug.exceptions",
                "flask",
                "flask.helpers.get_debug_flag",
                "flask.views.MethodView"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'flask'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "gen",
                    "body": "@flask.stream_with_context\ndef gen():\n    yield flask.session['test']",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `gen` method is designed to yield the value stored in the Flask session under the key `'test'`. It is intended for use in streaming responses, allowing the session data to be accessed even when the request context is not directly available.\n\n**How It Works**:\nThe `gen` method is decorated with `@flask.stream_with_context`, which ensures that the request context is preserved while the generator is yielding values. This is crucial for accessing request-bound information, such as session data, during streaming. When called, `gen` will yield the value of `flask.session['test']`, allowing it to be sent as part of a streamed HTTP response. This method is particularly useful in scenarios where data needs to be sent to the client incrementally, such as in long-running processes or large data transfers."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_async_route",
            "module": "test_async",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_async.py",
            "line_number": 82,
            "end_line_number": 87,
            "source_code": "def test_async_route(path, async_app):\n    test_client = async_app.test_client()\n    response = test_client.get(path)\n    assert b\"GET\" in response.get_data()\n    response = test_client.post(path)\n    assert b\"POST\" in response.get_data()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('path', ['/', '/home', '/bp/', '/view', '/methodview'])"
            ],
            "arguments": [
                "path",
                "async_app"
            ],
            "imports": [
                "asyncio",
                "pytest",
                "flask.Blueprint",
                "flask.Flask",
                "flask.request",
                "flask.views.MethodView",
                "flask.views.View"
            ],
            "fixtures": [],
            "assertions": [
                "assert b'GET' in response.get_data()",
                "assert b'POST' in response.get_data()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "test_client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `test_client.get` method is used to simulate a GET request to a specified endpoint in a Flask application. It allows developers to test the behavior of their application routes and verify the responses returned by those routes.\n\n**How It Works**:  \nWhen `test_client.get` is called with a specific URL, it triggers the Flask application to process the request as if it were coming from a real client. The method matches the request to the appropriate route defined in the application (e.g., `@app.route('/get')`). In the provided example, the `get` function retrieves a value from the session (defaulting to 'None' if not set) and returns it. The response can then be inspected for status codes, data, and other attributes, allowing developers to assert expected outcomes in their tests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_async_route",
            "module": "test_async",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_async.py",
            "line_number": 82,
            "end_line_number": 87,
            "source_code": "def test_async_route(path, async_app):\n    test_client = async_app.test_client()\n    response = test_client.get(path)\n    assert b\"GET\" in response.get_data()\n    response = test_client.post(path)\n    assert b\"POST\" in response.get_data()",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('path', ['/', '/home', '/bp/', '/view', '/methodview'])"
            ],
            "arguments": [
                "path",
                "async_app"
            ],
            "imports": [
                "asyncio",
                "pytest",
                "flask.Blueprint",
                "flask.Flask",
                "flask.request",
                "flask.views.MethodView",
                "flask.views.View"
            ],
            "fixtures": [],
            "assertions": [
                "assert b'GET' in response.get_data()",
                "assert b'POST' in response.get_data()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "test_client.post",
                    "body": "def post(self):\n    return 'Create'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `test_client.post` method is used to simulate an HTTP POST request to a specified URL in a Flask application. It is typically employed in testing scenarios to send data to the server and verify the server's response.\n\n**How It Works**:\nWhen `test_client.post` is called, it sends a POST request to the specified endpoint (e.g., `/1/update`) along with any data provided (e.g., `data={\"title\": \"updated\", \"body\": \"\"}`). The method returns a response object that contains the server's response, which can be inspected for status codes, headers, and response data. This allows developers to test the behavior of their application when handling POST requests, ensuring that the application correctly processes the submitted data and returns the expected results."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_async_error_handler",
            "module": "test_async",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_async.py",
            "line_number": 91,
            "end_line_number": 94,
            "source_code": "def test_async_error_handler(path, async_app):\n    test_client = async_app.test_client()\n    response = test_client.get(path)\n    assert response.status_code == 412",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('path', ['/error', '/bp/error'])"
            ],
            "arguments": [
                "path",
                "async_app"
            ],
            "imports": [
                "asyncio",
                "pytest",
                "flask.Blueprint",
                "flask.Flask",
                "flask.request",
                "flask.views.MethodView",
                "flask.views.View"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 412"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "test_client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `test_client.get` method is used to simulate a GET request to a specified endpoint in a Flask application. It allows developers to test the behavior of their application routes and verify the responses returned by those routes.\n\n**How It Works**:  \nWhen `test_client.get` is called with a URL, it sends a GET request to that URL within the context of the Flask application. The method processes the request through the application's routing system, invoking the corresponding view function. In the provided example, the `get` function retrieves a value from the session (defaulting to 'None' if not set) and returns it. The response can then be inspected for status codes, data, and other attributes, enabling developers to assert expected outcomes in their tests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_async_before_after_request",
            "module": "test_async",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_async.py",
            "line_number": 97,
            "end_line_number": 145,
            "source_code": "def test_async_before_after_request():\n    app_before_called = False\n    app_after_called = False\n    bp_before_called = False\n    bp_after_called = False\n\n    app = Flask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        return \"\"\n\n    @app.before_request\n    async def before():\n        nonlocal app_before_called\n        app_before_called = True\n\n    @app.after_request\n    async def after(response):\n        nonlocal app_after_called\n        app_after_called = True\n        return response\n\n    blueprint = Blueprint(\"bp\", __name__)\n\n    @blueprint.route(\"/\")\n    def bp_index():\n        return \"\"\n\n    @blueprint.before_request\n    async def bp_before():\n        nonlocal bp_before_called\n        bp_before_called = True\n\n    @blueprint.after_request\n    async def bp_after(response):\n        nonlocal bp_after_called\n        bp_after_called = True\n        return response\n\n    app.register_blueprint(blueprint, url_prefix=\"/bp\")\n\n    test_client = app.test_client()\n    test_client.get(\"/\")\n    assert app_before_called\n    assert app_after_called\n    test_client.get(\"/bp/\")\n    assert bp_before_called\n    assert bp_after_called",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "pytest",
                "flask.Blueprint",
                "flask.Flask",
                "flask.request",
                "flask.views.MethodView",
                "flask.views.View"
            ],
            "fixtures": [],
            "assertions": [
                "assert app_before_called",
                "assert app_after_called",
                "assert bp_before_called",
                "assert bp_after_called"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "test_client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `test_client.get` method is used to simulate a GET request to a specified endpoint in a Flask application. It allows developers to test the behavior of their application routes and ensure that they return the expected responses.\n\n**How It Works**:  \nWhen `test_client.get` is called with a URL, it sends a GET request to that URL within the context of the Flask application. The method processes the request, invoking the corresponding route handler (in this case, the `get` function defined at the `/get` endpoint). The handler retrieves a value from the session (defaulting to 'None' if not set) and returns it as the response. The test client captures the response, including the status code and any data returned, allowing for assertions to verify the application's behavior during testing."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_async_before_after_request",
            "module": "test_async",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_async.py",
            "line_number": 97,
            "end_line_number": 145,
            "source_code": "def test_async_before_after_request():\n    app_before_called = False\n    app_after_called = False\n    bp_before_called = False\n    bp_after_called = False\n\n    app = Flask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        return \"\"\n\n    @app.before_request\n    async def before():\n        nonlocal app_before_called\n        app_before_called = True\n\n    @app.after_request\n    async def after(response):\n        nonlocal app_after_called\n        app_after_called = True\n        return response\n\n    blueprint = Blueprint(\"bp\", __name__)\n\n    @blueprint.route(\"/\")\n    def bp_index():\n        return \"\"\n\n    @blueprint.before_request\n    async def bp_before():\n        nonlocal bp_before_called\n        bp_before_called = True\n\n    @blueprint.after_request\n    async def bp_after(response):\n        nonlocal bp_after_called\n        bp_after_called = True\n        return response\n\n    app.register_blueprint(blueprint, url_prefix=\"/bp\")\n\n    test_client = app.test_client()\n    test_client.get(\"/\")\n    assert app_before_called\n    assert app_after_called\n    test_client.get(\"/bp/\")\n    assert bp_before_called\n    assert bp_after_called",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "asyncio",
                "pytest",
                "flask.Blueprint",
                "flask.Flask",
                "flask.request",
                "flask.views.MethodView",
                "flask.views.View"
            ],
            "fixtures": [],
            "assertions": [
                "assert app_before_called",
                "assert app_after_called",
                "assert bp_before_called",
                "assert bp_after_called"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "test_client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `test_client.get` method is used to simulate a GET request to a specified endpoint in a Flask application. It allows developers to test the behavior of their application routes and verify the responses returned by those routes.\n\n**How It Works**:  \nWhen `test_client.get` is called with a specific URL, it triggers the Flask application to process the request as if it were coming from a real client. The method matches the request to the appropriate route defined in the application (e.g., `@app.route('/get')`). In the provided example, the `get` function retrieves a value from the session (defaulting to 'None' if not set) and returns it. The response can then be inspected for status codes, data, and other attributes, allowing developers to assert expected outcomes in their tests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_method_route_no_methods",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 65,
            "end_line_number": 67,
            "source_code": "def test_method_route_no_methods(app):\n    with pytest.raises(TypeError):\n        app.get(\"/\", methods=[\"GET\", \"POST\"])",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "app.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `app.get` method is used to define a route in a Flask web application that responds to HTTP GET requests. Specifically, the route `/get` retrieves a value from the session, returning it to the client.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` attempts to retrieve the value associated with the key `'value'` from the session. If the key does not exist, it defaults to returning the string `'None'`. The retrieved value is then returned as the response to the client. This method leverages Flask's session management to store and retrieve user-specific data across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_provide_automatic_options_kwarg",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 92,
            "end_line_number": 126,
            "source_code": "def test_provide_automatic_options_kwarg(app, client):\n    def index():\n        return flask.request.method\n\n    def more():\n        return flask.request.method\n\n    app.add_url_rule(\"/\", view_func=index, provide_automatic_options=False)\n    app.add_url_rule(\n        \"/more\",\n        view_func=more,\n        methods=[\"GET\", \"POST\"],\n        provide_automatic_options=False,\n    )\n    assert client.get(\"/\").data == b\"GET\"\n\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\"]\n\n    rv = client.open(\"/\", method=\"OPTIONS\")\n    assert rv.status_code == 405\n\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"POST\"]\n\n    rv = client.open(\"/more\", method=\"OPTIONS\")\n    assert rv.status_code == 405",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').data == b'GET'",
                "assert rv.status_code == 405",
                "assert sorted(rv.allow) == ['GET', 'HEAD']",
                "assert rv.status_code == 405",
                "assert rv.status_code == 200",
                "assert not rv.data",
                "assert client.post('/more').data == b'POST'",
                "assert client.get('/more').data == b'GET'",
                "assert rv.status_code == 405",
                "assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']",
                "assert rv.status_code == 405"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.post",
                    "body": "def post(self):\n    return 'Create'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is designed to simulate an HTTP POST request to a specified endpoint, allowing developers to send data to the server, typically for creating or updating resources.\n\n**How It Works**:\nWhen invoked, `client.post` sends a request to the server at the specified URL with the provided data. In the context of the code snippets, it is used to test various functionalities such as creating a new post, updating an existing post, and validating input data. The method returns a response indicating the result of the operation, which can be further inspected for status codes or response data. The method is part of a testing framework that helps ensure the application's endpoints behave as expected."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_provide_automatic_options_kwarg",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 92,
            "end_line_number": 126,
            "source_code": "def test_provide_automatic_options_kwarg(app, client):\n    def index():\n        return flask.request.method\n\n    def more():\n        return flask.request.method\n\n    app.add_url_rule(\"/\", view_func=index, provide_automatic_options=False)\n    app.add_url_rule(\n        \"/more\",\n        view_func=more,\n        methods=[\"GET\", \"POST\"],\n        provide_automatic_options=False,\n    )\n    assert client.get(\"/\").data == b\"GET\"\n\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\"]\n\n    rv = client.open(\"/\", method=\"OPTIONS\")\n    assert rv.status_code == 405\n\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"POST\"]\n\n    rv = client.open(\"/more\", method=\"OPTIONS\")\n    assert rv.status_code == 405",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').data == b'GET'",
                "assert rv.status_code == 405",
                "assert sorted(rv.allow) == ['GET', 'HEAD']",
                "assert rv.status_code == 405",
                "assert rv.status_code == 200",
                "assert not rv.data",
                "assert client.post('/more').data == b'POST'",
                "assert client.get('/more').data == b'GET'",
                "assert rv.status_code == 405",
                "assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']",
                "assert rv.status_code == 405"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.head",
                    "body": "def head(self):\n    return flask.Response('', headers={'X-Method': 'HEAD'})",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.head` method is designed to handle HTTP HEAD requests in a Flask application. It returns a response with no body but includes headers, allowing clients to retrieve metadata about a resource without transferring the entire content.\n\n**How It Works**:  \nWhen the `head` method is called, it creates and returns a `flask.Response` object with an empty string as the body and a custom header `X-Method` set to `'HEAD'`. This is useful for clients that want to check the existence or properties of a resource without downloading the full content, as it mimics the behavior of a GET request but omits the response body. The method can be explicitly defined in a view class, allowing for tailored responses to HEAD requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_provide_automatic_options_kwarg",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 92,
            "end_line_number": 126,
            "source_code": "def test_provide_automatic_options_kwarg(app, client):\n    def index():\n        return flask.request.method\n\n    def more():\n        return flask.request.method\n\n    app.add_url_rule(\"/\", view_func=index, provide_automatic_options=False)\n    app.add_url_rule(\n        \"/more\",\n        view_func=more,\n        methods=[\"GET\", \"POST\"],\n        provide_automatic_options=False,\n    )\n    assert client.get(\"/\").data == b\"GET\"\n\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\"]\n\n    rv = client.open(\"/\", method=\"OPTIONS\")\n    assert rv.status_code == 405\n\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"POST\"]\n\n    rv = client.open(\"/more\", method=\"OPTIONS\")\n    assert rv.status_code == 405",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').data == b'GET'",
                "assert rv.status_code == 405",
                "assert sorted(rv.allow) == ['GET', 'HEAD']",
                "assert rv.status_code == 405",
                "assert rv.status_code == 200",
                "assert not rv.data",
                "assert client.post('/more').data == b'POST'",
                "assert client.get('/more').data == b'GET'",
                "assert rv.status_code == 405",
                "assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']",
                "assert rv.status_code == 405"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.delete",
                    "body": "def delete(self):\n    return 'DELETE'",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.delete` method is designed to simulate an HTTP DELETE request in a web application context, typically used to remove a resource identified by a specific URL.\n\n**How It Works**:  \nThe method returns the string `'DELETE'`, indicating the type of HTTP request being simulated. In the context of testing, this method can be used to verify that the application correctly handles DELETE requests, such as removing a post from the database. The relevant test case (`test_delete`) demonstrates this by logging in, sending a DELETE request, and then checking that the post has been removed from the database."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_provide_automatic_options_kwarg",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 92,
            "end_line_number": 126,
            "source_code": "def test_provide_automatic_options_kwarg(app, client):\n    def index():\n        return flask.request.method\n\n    def more():\n        return flask.request.method\n\n    app.add_url_rule(\"/\", view_func=index, provide_automatic_options=False)\n    app.add_url_rule(\n        \"/more\",\n        view_func=more,\n        methods=[\"GET\", \"POST\"],\n        provide_automatic_options=False,\n    )\n    assert client.get(\"/\").data == b\"GET\"\n\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\"]\n\n    rv = client.open(\"/\", method=\"OPTIONS\")\n    assert rv.status_code == 405\n\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"POST\"]\n\n    rv = client.open(\"/more\", method=\"OPTIONS\")\n    assert rv.status_code == 405",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').data == b'GET'",
                "assert rv.status_code == 405",
                "assert sorted(rv.allow) == ['GET', 'HEAD']",
                "assert rv.status_code == 405",
                "assert rv.status_code == 200",
                "assert not rv.data",
                "assert client.post('/more').data == b'POST'",
                "assert client.get('/more').data == b'GET'",
                "assert rv.status_code == 405",
                "assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']",
                "assert rv.status_code == 405"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_provide_automatic_options_kwarg",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 92,
            "end_line_number": 126,
            "source_code": "def test_provide_automatic_options_kwarg(app, client):\n    def index():\n        return flask.request.method\n\n    def more():\n        return flask.request.method\n\n    app.add_url_rule(\"/\", view_func=index, provide_automatic_options=False)\n    app.add_url_rule(\n        \"/more\",\n        view_func=more,\n        methods=[\"GET\", \"POST\"],\n        provide_automatic_options=False,\n    )\n    assert client.get(\"/\").data == b\"GET\"\n\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\"]\n\n    rv = client.open(\"/\", method=\"OPTIONS\")\n    assert rv.status_code == 405\n\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"POST\"]\n\n    rv = client.open(\"/more\", method=\"OPTIONS\")\n    assert rv.status_code == 405",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').data == b'GET'",
                "assert rv.status_code == 405",
                "assert sorted(rv.allow) == ['GET', 'HEAD']",
                "assert rv.status_code == 405",
                "assert rv.status_code == 200",
                "assert not rv.data",
                "assert client.post('/more').data == b'POST'",
                "assert client.get('/more').data == b'GET'",
                "assert rv.status_code == 405",
                "assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']",
                "assert rv.status_code == 405"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.post",
                    "body": "def post(self):\n    return 'Create'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is designed to simulate an HTTP POST request to a specified endpoint, allowing developers to send data to the server, typically for creating or updating resources.\n\n**How It Works**:\nWhen `client.post` is called, it sends a POST request to the specified URL with the provided data. In the context of the provided code snippets, this method is used to test various functionalities such as creating a new post, updating an existing post, and deleting a post. The method returns a response indicating the result of the operation, which can be further validated in tests to ensure the expected behavior of the application. The method body in the example simply returns the string 'Create', but in a real application, it would handle the logic for processing the request and interacting with the database."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_provide_automatic_options_kwarg",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 92,
            "end_line_number": 126,
            "source_code": "def test_provide_automatic_options_kwarg(app, client):\n    def index():\n        return flask.request.method\n\n    def more():\n        return flask.request.method\n\n    app.add_url_rule(\"/\", view_func=index, provide_automatic_options=False)\n    app.add_url_rule(\n        \"/more\",\n        view_func=more,\n        methods=[\"GET\", \"POST\"],\n        provide_automatic_options=False,\n    )\n    assert client.get(\"/\").data == b\"GET\"\n\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\"]\n\n    rv = client.open(\"/\", method=\"OPTIONS\")\n    assert rv.status_code == 405\n\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"POST\"]\n\n    rv = client.open(\"/more\", method=\"OPTIONS\")\n    assert rv.status_code == 405",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').data == b'GET'",
                "assert rv.status_code == 405",
                "assert sorted(rv.allow) == ['GET', 'HEAD']",
                "assert rv.status_code == 405",
                "assert rv.status_code == 200",
                "assert not rv.data",
                "assert client.post('/more').data == b'POST'",
                "assert client.get('/more').data == b'GET'",
                "assert rv.status_code == 405",
                "assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']",
                "assert rv.status_code == 405"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_request_dispatching",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 129,
            "end_line_number": 149,
            "source_code": "def test_request_dispatching(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.request.method\n\n    @app.route(\"/more\", methods=[\"GET\", \"POST\"])\n    def more():\n        return flask.request.method\n\n    assert client.get(\"/\").data == b\"GET\"\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\"]\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').data == b'GET'",
                "assert rv.status_code == 405",
                "assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS']",
                "assert rv.status_code == 200",
                "assert not rv.data",
                "assert client.post('/more').data == b'POST'",
                "assert client.get('/more').data == b'GET'",
                "assert rv.status_code == 405",
                "assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST']"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.post",
                    "body": "def post(self):\n    return 'Create'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is designed to simulate an HTTP POST request to a specified endpoint, allowing developers to test the behavior of their web application when data is submitted.\n\n**How It Works**:\nWhen invoked, `client.post` sends a POST request to the specified URL, optionally including data in the request body. In the provided code snippets, this method is used to update a post's title, validate input during creation, and delete a post. The method returns a response object that can be inspected for status codes and response data, enabling assertions in tests to verify that the application behaves as expected when handling POST requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_request_dispatching",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 129,
            "end_line_number": 149,
            "source_code": "def test_request_dispatching(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.request.method\n\n    @app.route(\"/more\", methods=[\"GET\", \"POST\"])\n    def more():\n        return flask.request.method\n\n    assert client.get(\"/\").data == b\"GET\"\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\"]\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').data == b'GET'",
                "assert rv.status_code == 405",
                "assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS']",
                "assert rv.status_code == 200",
                "assert not rv.data",
                "assert client.post('/more').data == b'POST'",
                "assert client.get('/more').data == b'GET'",
                "assert rv.status_code == 405",
                "assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST']"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.head",
                    "body": "def head(self):\n    return flask.Response('', headers={'X-Method': 'HEAD'})",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.head` method is designed to handle HTTP HEAD requests in a Flask application. It returns a response with no body but includes headers, allowing clients to retrieve metadata about a resource without transferring the entire content.\n\n**How It Works**:  \nWhen the `head` method is called, it creates and returns a `flask.Response` object with an empty string as the body and a custom header `X-Method` set to `'HEAD'`. This is useful for clients that want to check the existence or properties of a resource without downloading the full content, as it mimics the behavior of a GET request but omits the response body. The method can be explicitly defined in a view class, allowing for tailored responses to HEAD requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_request_dispatching",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 129,
            "end_line_number": 149,
            "source_code": "def test_request_dispatching(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.request.method\n\n    @app.route(\"/more\", methods=[\"GET\", \"POST\"])\n    def more():\n        return flask.request.method\n\n    assert client.get(\"/\").data == b\"GET\"\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\"]\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').data == b'GET'",
                "assert rv.status_code == 405",
                "assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS']",
                "assert rv.status_code == 200",
                "assert not rv.data",
                "assert client.post('/more').data == b'POST'",
                "assert client.get('/more').data == b'GET'",
                "assert rv.status_code == 405",
                "assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST']"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.delete",
                    "body": "def delete(self):\n    return 'DELETE'",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.delete` method is designed to simulate an HTTP DELETE request in a web application context, returning a string indicating the type of request made.\n\n**How It Works**:  \nWhen invoked, the `delete` method simply returns the string `'DELETE'`. This indicates that a DELETE operation is being performed, which is typically used to remove a resource from the server. In the context of the provided code snippets, this method would be part of a testing framework where it helps verify the behavior of the application when a DELETE request is made, such as ensuring that a specific resource (like a post) is deleted from the database."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_request_dispatching",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 129,
            "end_line_number": 149,
            "source_code": "def test_request_dispatching(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.request.method\n\n    @app.route(\"/more\", methods=[\"GET\", \"POST\"])\n    def more():\n        return flask.request.method\n\n    assert client.get(\"/\").data == b\"GET\"\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\"]\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').data == b'GET'",
                "assert rv.status_code == 405",
                "assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS']",
                "assert rv.status_code == 200",
                "assert not rv.data",
                "assert client.post('/more').data == b'POST'",
                "assert client.get('/more').data == b'GET'",
                "assert rv.status_code == 405",
                "assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST']"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_request_dispatching",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 129,
            "end_line_number": 149,
            "source_code": "def test_request_dispatching(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.request.method\n\n    @app.route(\"/more\", methods=[\"GET\", \"POST\"])\n    def more():\n        return flask.request.method\n\n    assert client.get(\"/\").data == b\"GET\"\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\"]\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').data == b'GET'",
                "assert rv.status_code == 405",
                "assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS']",
                "assert rv.status_code == 200",
                "assert not rv.data",
                "assert client.post('/more').data == b'POST'",
                "assert client.get('/more').data == b'GET'",
                "assert rv.status_code == 405",
                "assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST']"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.post",
                    "body": "def post(self):\n    return 'Create'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is designed to simulate an HTTP POST request to a specified endpoint, allowing developers to send data to the server, typically for creating or updating resources.\n\n**How It Works**:\nWhen invoked, `client.post` sends a POST request to the specified URL with the provided data. In the context of the provided code snippets, it is used to update a post's title or create a new post. The method returns a response indicating the result of the operation, which can be further validated in tests to ensure the expected behavior, such as checking for successful updates or validation errors. The method is part of a testing framework that allows for easy simulation of client-server interactions."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_request_dispatching",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 129,
            "end_line_number": 149,
            "source_code": "def test_request_dispatching(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.request.method\n\n    @app.route(\"/more\", methods=[\"GET\", \"POST\"])\n    def more():\n        return flask.request.method\n\n    assert client.get(\"/\").data == b\"GET\"\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\"]\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').data == b'GET'",
                "assert rv.status_code == 405",
                "assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS']",
                "assert rv.status_code == 200",
                "assert not rv.data",
                "assert client.post('/more').data == b'POST'",
                "assert client.get('/more').data == b'GET'",
                "assert rv.status_code == 405",
                "assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST']"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_url_mapping",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 157,
            "end_line_number": 190,
            "source_code": "def test_url_mapping(app, client):\n    random_uuid4 = \"7eb41166-9ebf-4d26-b771-ea3f54f8b383\"\n\n    def index():\n        return flask.request.method\n\n    def more():\n        return flask.request.method\n\n    def options():\n        return random_uuid4\n\n    app.add_url_rule(\"/\", \"index\", index)\n    app.add_url_rule(\"/more\", \"more\", more, methods=[\"GET\", \"POST\"])\n\n    # Issue 1288: Test that automatic options are not added\n    #             when non-uppercase 'options' in methods\n    app.add_url_rule(\"/options\", \"options\", options, methods=[\"options\"])\n\n    assert client.get(\"/\").data == b\"GET\"\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\"]\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n    rv = client.open(\"/options\", method=\"OPTIONS\")\n    assert rv.status_code == 200\n    assert random_uuid4 in rv.data.decode(\"utf-8\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').data == b'GET'",
                "assert rv.status_code == 405",
                "assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS']",
                "assert rv.status_code == 200",
                "assert not rv.data",
                "assert client.post('/more').data == b'POST'",
                "assert client.get('/more').data == b'GET'",
                "assert rv.status_code == 405",
                "assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST']",
                "assert rv.status_code == 200",
                "assert random_uuid4 in rv.data.decode('utf-8')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.post",
                    "body": "def post(self):\n    return 'Create'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is designed to simulate an HTTP POST request to a specified endpoint in a web application. It is commonly used in testing scenarios to send data to the server, such as creating or updating resources.\n\n**How It Works**:\nWhen `client.post` is called, it sends a POST request to the specified URL with optional data. In the provided code snippets, this method is used to test various functionalities, such as updating a post or validating input during creation. The method returns a response that can be inspected for status codes, headers, and response data, allowing developers to verify that the server behaves as expected when handling POST requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_url_mapping",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 157,
            "end_line_number": 190,
            "source_code": "def test_url_mapping(app, client):\n    random_uuid4 = \"7eb41166-9ebf-4d26-b771-ea3f54f8b383\"\n\n    def index():\n        return flask.request.method\n\n    def more():\n        return flask.request.method\n\n    def options():\n        return random_uuid4\n\n    app.add_url_rule(\"/\", \"index\", index)\n    app.add_url_rule(\"/more\", \"more\", more, methods=[\"GET\", \"POST\"])\n\n    # Issue 1288: Test that automatic options are not added\n    #             when non-uppercase 'options' in methods\n    app.add_url_rule(\"/options\", \"options\", options, methods=[\"options\"])\n\n    assert client.get(\"/\").data == b\"GET\"\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\"]\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n    rv = client.open(\"/options\", method=\"OPTIONS\")\n    assert rv.status_code == 200\n    assert random_uuid4 in rv.data.decode(\"utf-8\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').data == b'GET'",
                "assert rv.status_code == 405",
                "assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS']",
                "assert rv.status_code == 200",
                "assert not rv.data",
                "assert client.post('/more').data == b'POST'",
                "assert client.get('/more').data == b'GET'",
                "assert rv.status_code == 405",
                "assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST']",
                "assert rv.status_code == 200",
                "assert random_uuid4 in rv.data.decode('utf-8')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.head",
                    "body": "def head(self):\n    return flask.Response('', headers={'X-Method': 'HEAD'})",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.head` method is designed to handle HTTP HEAD requests in a Flask application. It returns a response with no body but includes headers, allowing clients to retrieve metadata about a resource without transferring the entire content.\n\n**How It Works**:  \nWhen the `head` method is called, it creates and returns a `flask.Response` object with an empty string as the body and a custom header `X-Method` set to `'HEAD'`. This is useful for clients that want to check the existence or properties of a resource without downloading the full content, as HEAD requests are typically used for this purpose. The method is part of a class that likely extends Flask's `MethodView`, allowing it to be mapped to a specific route in the application."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_url_mapping",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 157,
            "end_line_number": 190,
            "source_code": "def test_url_mapping(app, client):\n    random_uuid4 = \"7eb41166-9ebf-4d26-b771-ea3f54f8b383\"\n\n    def index():\n        return flask.request.method\n\n    def more():\n        return flask.request.method\n\n    def options():\n        return random_uuid4\n\n    app.add_url_rule(\"/\", \"index\", index)\n    app.add_url_rule(\"/more\", \"more\", more, methods=[\"GET\", \"POST\"])\n\n    # Issue 1288: Test that automatic options are not added\n    #             when non-uppercase 'options' in methods\n    app.add_url_rule(\"/options\", \"options\", options, methods=[\"options\"])\n\n    assert client.get(\"/\").data == b\"GET\"\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\"]\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n    rv = client.open(\"/options\", method=\"OPTIONS\")\n    assert rv.status_code == 200\n    assert random_uuid4 in rv.data.decode(\"utf-8\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').data == b'GET'",
                "assert rv.status_code == 405",
                "assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS']",
                "assert rv.status_code == 200",
                "assert not rv.data",
                "assert client.post('/more').data == b'POST'",
                "assert client.get('/more').data == b'GET'",
                "assert rv.status_code == 405",
                "assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST']",
                "assert rv.status_code == 200",
                "assert random_uuid4 in rv.data.decode('utf-8')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.delete",
                    "body": "def delete(self):\n    return 'DELETE'",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.delete` method is designed to simulate an HTTP DELETE request in a web application context, typically used to remove a resource identified by a specific URL.\n\n**How It Works**:  \nWhen invoked, the method returns the string `'DELETE'`, indicating the type of HTTP request being simulated. This method is part of a testing framework, allowing developers to verify the behavior of their application when a DELETE request is made. In the provided test cases, the DELETE request is used to check if a post can be successfully deleted from the database, ensuring that the application correctly handles resource removal."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_url_mapping",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 157,
            "end_line_number": 190,
            "source_code": "def test_url_mapping(app, client):\n    random_uuid4 = \"7eb41166-9ebf-4d26-b771-ea3f54f8b383\"\n\n    def index():\n        return flask.request.method\n\n    def more():\n        return flask.request.method\n\n    def options():\n        return random_uuid4\n\n    app.add_url_rule(\"/\", \"index\", index)\n    app.add_url_rule(\"/more\", \"more\", more, methods=[\"GET\", \"POST\"])\n\n    # Issue 1288: Test that automatic options are not added\n    #             when non-uppercase 'options' in methods\n    app.add_url_rule(\"/options\", \"options\", options, methods=[\"options\"])\n\n    assert client.get(\"/\").data == b\"GET\"\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\"]\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n    rv = client.open(\"/options\", method=\"OPTIONS\")\n    assert rv.status_code == 200\n    assert random_uuid4 in rv.data.decode(\"utf-8\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').data == b'GET'",
                "assert rv.status_code == 405",
                "assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS']",
                "assert rv.status_code == 200",
                "assert not rv.data",
                "assert client.post('/more').data == b'POST'",
                "assert client.get('/more').data == b'GET'",
                "assert rv.status_code == 405",
                "assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST']",
                "assert rv.status_code == 200",
                "assert random_uuid4 in rv.data.decode('utf-8')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, defaulting to `'None'` if the key `'value'` does not exist.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. It uses `flask.session.get` to access the session data, specifically looking for the key `'value'`. If this key is found, its associated value is returned; if not, the string `'None'` is returned as a fallback. This method is useful for retrieving session-specific data in a web application context."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_url_mapping",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 157,
            "end_line_number": 190,
            "source_code": "def test_url_mapping(app, client):\n    random_uuid4 = \"7eb41166-9ebf-4d26-b771-ea3f54f8b383\"\n\n    def index():\n        return flask.request.method\n\n    def more():\n        return flask.request.method\n\n    def options():\n        return random_uuid4\n\n    app.add_url_rule(\"/\", \"index\", index)\n    app.add_url_rule(\"/more\", \"more\", more, methods=[\"GET\", \"POST\"])\n\n    # Issue 1288: Test that automatic options are not added\n    #             when non-uppercase 'options' in methods\n    app.add_url_rule(\"/options\", \"options\", options, methods=[\"options\"])\n\n    assert client.get(\"/\").data == b\"GET\"\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\"]\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n    rv = client.open(\"/options\", method=\"OPTIONS\")\n    assert rv.status_code == 200\n    assert random_uuid4 in rv.data.decode(\"utf-8\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').data == b'GET'",
                "assert rv.status_code == 405",
                "assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS']",
                "assert rv.status_code == 200",
                "assert not rv.data",
                "assert client.post('/more').data == b'POST'",
                "assert client.get('/more').data == b'GET'",
                "assert rv.status_code == 405",
                "assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST']",
                "assert rv.status_code == 200",
                "assert random_uuid4 in rv.data.decode('utf-8')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.post",
                    "body": "def post(self):\n    return 'Create'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is designed to simulate an HTTP POST request to a specified endpoint, allowing developers to test the behavior of their web application when data is submitted.\n\n**How It Works**:\nWhen invoked, `client.post` sends a POST request to the specified URL, optionally including data in the request body. In the provided code snippets, this method is used to update a post's title, validate input during creation or updating, and delete a post. The method returns a response object that can be inspected for status codes, headers, and response data, enabling assertions in tests to verify that the application behaves as expected."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_url_mapping",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 157,
            "end_line_number": 190,
            "source_code": "def test_url_mapping(app, client):\n    random_uuid4 = \"7eb41166-9ebf-4d26-b771-ea3f54f8b383\"\n\n    def index():\n        return flask.request.method\n\n    def more():\n        return flask.request.method\n\n    def options():\n        return random_uuid4\n\n    app.add_url_rule(\"/\", \"index\", index)\n    app.add_url_rule(\"/more\", \"more\", more, methods=[\"GET\", \"POST\"])\n\n    # Issue 1288: Test that automatic options are not added\n    #             when non-uppercase 'options' in methods\n    app.add_url_rule(\"/options\", \"options\", options, methods=[\"options\"])\n\n    assert client.get(\"/\").data == b\"GET\"\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\"]\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n    rv = client.open(\"/options\", method=\"OPTIONS\")\n    assert rv.status_code == 200\n    assert random_uuid4 in rv.data.decode(\"utf-8\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').data == b'GET'",
                "assert rv.status_code == 405",
                "assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS']",
                "assert rv.status_code == 200",
                "assert not rv.data",
                "assert client.post('/more').data == b'POST'",
                "assert client.get('/more').data == b'GET'",
                "assert rv.status_code == 405",
                "assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST']",
                "assert rv.status_code == 200",
                "assert random_uuid4 in rv.data.decode('utf-8')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it as a response.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` attempts to fetch the value stored in the session under the key `'value'`. If this key does not exist, it defaults to returning the string `'None'`. The retrieved value is then returned as the HTTP response. This method relies on Flask's session management to store and retrieve user-specific data across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_werkzeug_routing",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 193,
            "end_line_number": 211,
            "source_code": "def test_werkzeug_routing(app, client):\n    from werkzeug.routing import Rule\n    from werkzeug.routing import Submount\n\n    app.url_map.add(\n        Submount(\"/foo\", [Rule(\"/bar\", endpoint=\"bar\"), Rule(\"/\", endpoint=\"index\")])\n    )\n\n    def bar():\n        return \"bar\"\n\n    def index():\n        return \"index\"\n\n    app.view_functions[\"bar\"] = bar\n    app.view_functions[\"index\"] = index\n\n    assert client.get(\"/foo/\").data == b\"index\"\n    assert client.get(\"/foo/bar\").data == b\"bar\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/foo/').data == b'index'",
                "assert client.get('/foo/bar').data == b'bar'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "app.url_map.add",
                    "body": "def add(self, app):\n    self.count += 1",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `app.url_map.add` method is designed to register a new URL rule with the application, allowing the application to respond to specific URL patterns with designated view functions. This is essential for routing requests to the appropriate handlers in a web application.\n\n**How It Works**:  \nWhen `add` is called, it increments a counter (`self.count`) to track the number of URL rules added. The method is typically used in conjunction with other methods that define URL rules, such as `add_url_rule`, which constructs the full URL rule and associates it with a view function. The `add_url_rule` method handles the specifics of creating the rule, including applying any prefixes or defaults, and ultimately calls the application's internal method to register the rule in the URL map. This process enables the application to route incoming requests to the correct view based on the defined URL patterns."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_werkzeug_routing",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 193,
            "end_line_number": 211,
            "source_code": "def test_werkzeug_routing(app, client):\n    from werkzeug.routing import Rule\n    from werkzeug.routing import Submount\n\n    app.url_map.add(\n        Submount(\"/foo\", [Rule(\"/bar\", endpoint=\"bar\"), Rule(\"/\", endpoint=\"index\")])\n    )\n\n    def bar():\n        return \"bar\"\n\n    def index():\n        return \"index\"\n\n    app.view_functions[\"bar\"] = bar\n    app.view_functions[\"index\"] = index\n\n    assert client.get(\"/foo/\").data == b\"index\"\n    assert client.get(\"/foo/bar\").data == b\"bar\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/foo/').data == b'index'",
                "assert client.get('/foo/bar').data == b'bar'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. Finally, the retrieved value is returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_werkzeug_routing",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 193,
            "end_line_number": 211,
            "source_code": "def test_werkzeug_routing(app, client):\n    from werkzeug.routing import Rule\n    from werkzeug.routing import Submount\n\n    app.url_map.add(\n        Submount(\"/foo\", [Rule(\"/bar\", endpoint=\"bar\"), Rule(\"/\", endpoint=\"index\")])\n    )\n\n    def bar():\n        return \"bar\"\n\n    def index():\n        return \"index\"\n\n    app.view_functions[\"bar\"] = bar\n    app.view_functions[\"index\"] = index\n\n    assert client.get(\"/foo/\").data == b\"index\"\n    assert client.get(\"/foo/bar\").data == b\"bar\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/foo/').data == b'index'",
                "assert client.get('/foo/bar').data == b'bar'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_endpoint_decorator",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 214,
            "end_line_number": 231,
            "source_code": "def test_endpoint_decorator(app, client):\n    from werkzeug.routing import Rule\n    from werkzeug.routing import Submount\n\n    app.url_map.add(\n        Submount(\"/foo\", [Rule(\"/bar\", endpoint=\"bar\"), Rule(\"/\", endpoint=\"index\")])\n    )\n\n    @app.endpoint(\"bar\")\n    def bar():\n        return \"bar\"\n\n    @app.endpoint(\"index\")\n    def index():\n        return \"index\"\n\n    assert client.get(\"/foo/\").data == b\"index\"\n    assert client.get(\"/foo/bar\").data == b\"bar\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/foo/').data == b'index'",
                "assert client.get('/foo/bar').data == b'bar'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "app.url_map.add",
                    "body": "def add(self, app):\n    self.count += 1",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `app.url_map.add` method is designed to register a new URL rule with the application, effectively mapping a specific URL pattern to a view function. This is essential for defining how incoming requests are routed to the appropriate handler in a web application.\n\n**How It Works**:  \nWhen `add` is called, it increments a counter (`self.count`) to track the number of URL rules added. The method is typically used in conjunction with other methods that define URL rules, such as `add_url_rule`, which constructs the complete URL mapping by combining the provided rule, endpoint, and view function. The method ensures that the application can handle requests to the specified URL by associating it with the corresponding logic defined in the view function."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_endpoint_decorator",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 214,
            "end_line_number": 231,
            "source_code": "def test_endpoint_decorator(app, client):\n    from werkzeug.routing import Rule\n    from werkzeug.routing import Submount\n\n    app.url_map.add(\n        Submount(\"/foo\", [Rule(\"/bar\", endpoint=\"bar\"), Rule(\"/\", endpoint=\"index\")])\n    )\n\n    @app.endpoint(\"bar\")\n    def bar():\n        return \"bar\"\n\n    @app.endpoint(\"index\")\n    def index():\n        return \"index\"\n\n    assert client.get(\"/foo/\").data == b\"index\"\n    assert client.get(\"/foo/bar\").data == b\"bar\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/foo/').data == b'index'",
                "assert client.get('/foo/bar').data == b'bar'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_endpoint_decorator",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 214,
            "end_line_number": 231,
            "source_code": "def test_endpoint_decorator(app, client):\n    from werkzeug.routing import Rule\n    from werkzeug.routing import Submount\n\n    app.url_map.add(\n        Submount(\"/foo\", [Rule(\"/bar\", endpoint=\"bar\"), Rule(\"/\", endpoint=\"index\")])\n    )\n\n    @app.endpoint(\"bar\")\n    def bar():\n        return \"bar\"\n\n    @app.endpoint(\"index\")\n    def index():\n        return \"index\"\n\n    assert client.get(\"/foo/\").data == b\"index\"\n    assert client.get(\"/foo/bar\").data == b\"bar\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/foo/').data == b'index'",
                "assert client.get('/foo/bar').data == b'bar'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, returning it to the client.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. It uses `flask.session.get` to access the session data, specifically looking for a key named `'value'`. If this key does not exist, it defaults to returning the string `'None'`. The retrieved value is then sent back as the response to the client. This method is useful for managing session data in web applications, allowing for state persistence across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 234,
            "end_line_number": 254,
            "source_code": "def test_session(app, client):\n    @app.route(\"/set\", methods=[\"POST\"])\n    def set():\n        assert not flask.session.accessed\n        assert not flask.session.modified\n        flask.session[\"value\"] = flask.request.form[\"value\"]\n        assert flask.session.accessed\n        assert flask.session.modified\n        return \"value set\"\n\n    @app.route(\"/get\")\n    def get():\n        assert not flask.session.accessed\n        assert not flask.session.modified\n        v = flask.session.get(\"value\", \"None\")\n        assert flask.session.accessed\n        assert not flask.session.modified\n        return v\n\n    assert client.post(\"/set\", data={\"value\": \"42\"}).data == b\"value set\"\n    assert client.get(\"/get\").data == b\"42\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.post('/set', data={'value': '42'}).data == b'value set'",
                "assert client.get('/get').data == b'42'",
                "assert not flask.session.accessed",
                "assert not flask.session.modified",
                "assert flask.session.accessed",
                "assert flask.session.modified",
                "assert not flask.session.accessed",
                "assert not flask.session.modified",
                "assert flask.session.accessed",
                "assert not flask.session.modified"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.post",
                    "body": "def post(self):\n    return 'Create'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is designed to simulate an HTTP POST request to a specified endpoint, allowing developers to send data to the server, typically for creating or updating resources.\n\n**How It Works**:\nWhen invoked, `client.post` sends a request to the server at the specified URL with the provided data. In the context of the code snippets, it is used to test various functionalities such as creating a new post, updating an existing post, and deleting a post. The method returns a response indicating the result of the operation, which can be further validated in tests to ensure the expected behavior of the application. The method's implementation in the provided snippet simply returns the string 'Create', but in a real application, it would handle the logic for processing the POST request and returning an appropriate response."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 234,
            "end_line_number": 254,
            "source_code": "def test_session(app, client):\n    @app.route(\"/set\", methods=[\"POST\"])\n    def set():\n        assert not flask.session.accessed\n        assert not flask.session.modified\n        flask.session[\"value\"] = flask.request.form[\"value\"]\n        assert flask.session.accessed\n        assert flask.session.modified\n        return \"value set\"\n\n    @app.route(\"/get\")\n    def get():\n        assert not flask.session.accessed\n        assert not flask.session.modified\n        v = flask.session.get(\"value\", \"None\")\n        assert flask.session.accessed\n        assert not flask.session.modified\n        return v\n\n    assert client.post(\"/set\", data={\"value\": \"42\"}).data == b\"value set\"\n    assert client.get(\"/get\").data == b\"42\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.post('/set', data={'value': '42'}).data == b'value set'",
                "assert client.get('/get').data == b'42'",
                "assert not flask.session.accessed",
                "assert not flask.session.modified",
                "assert flask.session.accessed",
                "assert flask.session.modified",
                "assert not flask.session.accessed",
                "assert not flask.session.modified",
                "assert flask.session.accessed",
                "assert not flask.session.modified"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_path",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 257,
            "end_line_number": 266,
            "source_code": "def test_session_path(app, client):\n    app.config.update(APPLICATION_ROOT=\"/foo\")\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    rv = client.get(\"/\", \"http://example.com:8080/foo\")\n    assert \"path=/foo\" in rv.headers[\"set-cookie\"].lower()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'path=/foo' in rv.headers['set-cookie'].lower()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_using_application_root",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 269,
            "end_line_number": 288,
            "source_code": "def test_session_using_application_root(app, client):\n    class PrefixPathMiddleware:\n        def __init__(self, app, prefix):\n            self.app = app\n            self.prefix = prefix\n\n        def __call__(self, environ, start_response):\n            environ[\"SCRIPT_NAME\"] = self.prefix\n            return self.app(environ, start_response)\n\n    app.wsgi_app = PrefixPathMiddleware(app.wsgi_app, \"/bar\")\n    app.config.update(APPLICATION_ROOT=\"/bar\")\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    rv = client.get(\"/\", \"http://example.com:8080/\")\n    assert \"path=/bar\" in rv.headers[\"set-cookie\"].lower()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'path=/bar' in rv.headers['set-cookie'].lower()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_using_application_root",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 269,
            "end_line_number": 288,
            "source_code": "def test_session_using_application_root(app, client):\n    class PrefixPathMiddleware:\n        def __init__(self, app, prefix):\n            self.app = app\n            self.prefix = prefix\n\n        def __call__(self, environ, start_response):\n            environ[\"SCRIPT_NAME\"] = self.prefix\n            return self.app(environ, start_response)\n\n    app.wsgi_app = PrefixPathMiddleware(app.wsgi_app, \"/bar\")\n    app.config.update(APPLICATION_ROOT=\"/bar\")\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    rv = client.get(\"/\", \"http://example.com:8080/\")\n    assert \"path=/bar\" in rv.headers[\"set-cookie\"].lower()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'path=/bar' in rv.headers['set-cookie'].lower()"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.app",
                    "body": "@pytest.fixture()\ndef app(self, app):\n\n    @app.route('/custom')\n    def do_custom():\n        raise self.Custom()\n\n    @app.route('/error')\n    def do_error():\n        raise KeyError()\n\n    @app.route('/abort')\n    def do_abort():\n        flask.abort(500)\n\n    @app.route('/raise')\n    def do_raise():\n        raise InternalServerError()\n    app.config['PROPAGATE_EXCEPTIONS'] = False\n    return app",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `app` method is a pytest fixture that sets up a Flask application instance with custom error handling routes for testing purposes. It allows for the simulation of various error scenarios to ensure that the application handles exceptions correctly.\n\n**How It Works**:\n1. The method defines several routes (`/custom`, `/error`, `/abort`, and `/raise`) that intentionally raise different exceptions when accessed.\n2. The `app.config['PROPAGATE_EXCEPTIONS']` is set to `False`, which prevents exceptions from being propagated to the default error handlers, allowing custom handlers to take effect.\n3. The method returns the configured Flask application instance, which can then be used in tests to verify that the application responds correctly to the defined error conditions."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_using_session_settings",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 291,
            "end_line_number": 331,
            "source_code": "def test_session_using_session_settings(app, client):\n    app.config.update(\n        SERVER_NAME=\"www.example.com:8080\",\n        APPLICATION_ROOT=\"/test\",\n        SESSION_COOKIE_DOMAIN=\".example.com\",\n        SESSION_COOKIE_HTTPONLY=False,\n        SESSION_COOKIE_SECURE=True,\n        SESSION_COOKIE_PARTITIONED=True,\n        SESSION_COOKIE_SAMESITE=\"Lax\",\n        SESSION_COOKIE_PATH=\"/\",\n    )\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    @app.route(\"/clear\")\n    def clear():\n        flask.session.pop(\"testing\", None)\n        return \"Goodbye World\"\n\n    rv = client.get(\"/\", \"http://www.example.com:8080/test/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    # or condition for Werkzeug < 2.3\n    assert \"domain=example.com\" in cookie or \"domain=.example.com\" in cookie\n    assert \"path=/\" in cookie\n    assert \"secure\" in cookie\n    assert \"httponly\" not in cookie\n    assert \"samesite\" in cookie\n    assert \"partitioned\" in cookie\n\n    rv = client.get(\"/clear\", \"http://www.example.com:8080/test/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"session=;\" in cookie\n    # or condition for Werkzeug < 2.3\n    assert \"domain=example.com\" in cookie or \"domain=.example.com\" in cookie\n    assert \"path=/\" in cookie\n    assert \"secure\" in cookie\n    assert \"samesite\" in cookie\n    assert \"partitioned\" in cookie",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'domain=example.com' in cookie or 'domain=.example.com' in cookie",
                "assert 'path=/' in cookie",
                "assert 'secure' in cookie",
                "assert 'httponly' not in cookie",
                "assert 'samesite' in cookie",
                "assert 'partitioned' in cookie",
                "assert 'session=;' in cookie",
                "assert 'domain=example.com' in cookie or 'domain=.example.com' in cookie",
                "assert 'path=/' in cookie",
                "assert 'secure' in cookie",
                "assert 'samesite' in cookie",
                "assert 'partitioned' in cookie"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_using_session_settings",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 291,
            "end_line_number": 331,
            "source_code": "def test_session_using_session_settings(app, client):\n    app.config.update(\n        SERVER_NAME=\"www.example.com:8080\",\n        APPLICATION_ROOT=\"/test\",\n        SESSION_COOKIE_DOMAIN=\".example.com\",\n        SESSION_COOKIE_HTTPONLY=False,\n        SESSION_COOKIE_SECURE=True,\n        SESSION_COOKIE_PARTITIONED=True,\n        SESSION_COOKIE_SAMESITE=\"Lax\",\n        SESSION_COOKIE_PATH=\"/\",\n    )\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    @app.route(\"/clear\")\n    def clear():\n        flask.session.pop(\"testing\", None)\n        return \"Goodbye World\"\n\n    rv = client.get(\"/\", \"http://www.example.com:8080/test/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    # or condition for Werkzeug < 2.3\n    assert \"domain=example.com\" in cookie or \"domain=.example.com\" in cookie\n    assert \"path=/\" in cookie\n    assert \"secure\" in cookie\n    assert \"httponly\" not in cookie\n    assert \"samesite\" in cookie\n    assert \"partitioned\" in cookie\n\n    rv = client.get(\"/clear\", \"http://www.example.com:8080/test/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"session=;\" in cookie\n    # or condition for Werkzeug < 2.3\n    assert \"domain=example.com\" in cookie or \"domain=.example.com\" in cookie\n    assert \"path=/\" in cookie\n    assert \"secure\" in cookie\n    assert \"samesite\" in cookie\n    assert \"partitioned\" in cookie",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'domain=example.com' in cookie or 'domain=.example.com' in cookie",
                "assert 'path=/' in cookie",
                "assert 'secure' in cookie",
                "assert 'httponly' not in cookie",
                "assert 'samesite' in cookie",
                "assert 'partitioned' in cookie",
                "assert 'session=;' in cookie",
                "assert 'domain=example.com' in cookie or 'domain=.example.com' in cookie",
                "assert 'path=/' in cookie",
                "assert 'secure' in cookie",
                "assert 'samesite' in cookie",
                "assert 'partitioned' in cookie"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. Finally, the retrieved value is returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_using_samesite_attribute",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 334,
            "end_line_number": 358,
            "source_code": "def test_session_using_samesite_attribute(app, client):\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"invalid\")\n\n    with pytest.raises(ValueError):\n        client.get(\"/\")\n\n    app.config.update(SESSION_COOKIE_SAMESITE=None)\n    rv = client.get(\"/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite\" not in cookie\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"Strict\")\n    rv = client.get(\"/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite=strict\" in cookie\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"Lax\")\n    rv = client.get(\"/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite=lax\" in cookie",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'samesite' not in cookie",
                "assert 'samesite=strict' in cookie",
                "assert 'samesite=lax' in cookie"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. Finally, the retrieved value is returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_using_samesite_attribute",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 334,
            "end_line_number": 358,
            "source_code": "def test_session_using_samesite_attribute(app, client):\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"invalid\")\n\n    with pytest.raises(ValueError):\n        client.get(\"/\")\n\n    app.config.update(SESSION_COOKIE_SAMESITE=None)\n    rv = client.get(\"/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite\" not in cookie\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"Strict\")\n    rv = client.get(\"/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite=strict\" in cookie\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"Lax\")\n    rv = client.get(\"/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite=lax\" in cookie",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'samesite' not in cookie",
                "assert 'samesite=strict' in cookie",
                "assert 'samesite=lax' in cookie"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_using_samesite_attribute",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 334,
            "end_line_number": 358,
            "source_code": "def test_session_using_samesite_attribute(app, client):\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"invalid\")\n\n    with pytest.raises(ValueError):\n        client.get(\"/\")\n\n    app.config.update(SESSION_COOKIE_SAMESITE=None)\n    rv = client.get(\"/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite\" not in cookie\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"Strict\")\n    rv = client.get(\"/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite=strict\" in cookie\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"Lax\")\n    rv = client.get(\"/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite=lax\" in cookie",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'samesite' not in cookie",
                "assert 'samesite=strict' in cookie",
                "assert 'samesite=lax' in cookie"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. Finally, the retrieved value is returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_using_samesite_attribute",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 334,
            "end_line_number": 358,
            "source_code": "def test_session_using_samesite_attribute(app, client):\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"invalid\")\n\n    with pytest.raises(ValueError):\n        client.get(\"/\")\n\n    app.config.update(SESSION_COOKIE_SAMESITE=None)\n    rv = client.get(\"/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite\" not in cookie\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"Strict\")\n    rv = client.get(\"/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite=strict\" in cookie\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"Lax\")\n    rv = client.get(\"/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite=lax\" in cookie",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'samesite' not in cookie",
                "assert 'samesite=strict' in cookie",
                "assert 'samesite=lax' in cookie"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_missing_session",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 361,
            "end_line_number": 371,
            "source_code": "def test_missing_session(app):\n    app.secret_key = None\n\n    def expect_exception(f, *args, **kwargs):\n        e = pytest.raises(RuntimeError, f, *args, **kwargs)\n        assert e.value.args and \"session is unavailable\" in e.value.args[0]\n\n    with app.test_request_context():\n        assert flask.session.get(\"missing_key\") is None\n        expect_exception(flask.session.__setitem__, \"foo\", 42)\n        expect_exception(flask.session.pop, \"foo\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert e.value.args and 'session is unavailable' in e.value.args[0]",
                "assert flask.session.get('missing_key') is None"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "expect_exception",
                    "body": "def expect_exception(f, *args, **kwargs):\n    e = pytest.raises(RuntimeError, f, *args, **kwargs)\n    assert e.value.args and 'session is unavailable' in e.value.args[0]",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `expect_exception` method is designed to test that a specific function raises a `RuntimeError` with a message indicating that the session is unavailable. It is typically used in unit tests to ensure that session-related operations fail gracefully when the session is not properly configured.\n\n**How It Works**:\nThe method takes a function `f` along with its positional (`*args`) and keyword arguments (`**kwargs`). It uses `pytest.raises` to assert that calling `f` raises a `RuntimeError`. After the exception is caught, it checks that the exception's message contains the phrase \"session is unavailable\" by examining the `args` attribute of the exception. This ensures that the error handling in the application behaves as expected when session issues occur."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_missing_session",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 361,
            "end_line_number": 371,
            "source_code": "def test_missing_session(app):\n    app.secret_key = None\n\n    def expect_exception(f, *args, **kwargs):\n        e = pytest.raises(RuntimeError, f, *args, **kwargs)\n        assert e.value.args and \"session is unavailable\" in e.value.args[0]\n\n    with app.test_request_context():\n        assert flask.session.get(\"missing_key\") is None\n        expect_exception(flask.session.__setitem__, \"foo\", 42)\n        expect_exception(flask.session.pop, \"foo\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert e.value.args and 'session is unavailable' in e.value.args[0]",
                "assert flask.session.get('missing_key') is None"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "expect_exception",
                    "body": "def expect_exception(f, *args, **kwargs):\n    e = pytest.raises(RuntimeError, f, *args, **kwargs)\n    assert e.value.args and 'session is unavailable' in e.value.args[0]",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `expect_exception` method is designed to test that a specific function raises a `RuntimeError` with a message indicating that the session is unavailable. It is primarily used in unit tests to ensure that the application behaves correctly when session-related errors occur.\n\n**How It Works**:  \nThe method takes a function `f` along with any positional (`*args`) and keyword arguments (`**kwargs`). It uses `pytest.raises` to assert that calling `f` raises a `RuntimeError`. After the exception is caught, it checks that the exception's message contains the phrase \"session is unavailable\". This ensures that the error handling in the application is functioning as expected when session issues arise."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_secret_key_fallbacks",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 374,
            "end_line_number": 392,
            "source_code": "def test_session_secret_key_fallbacks(app, client) -> None:\n    @app.post(\"/\")\n    def set_session() -> str:\n        flask.session[\"a\"] = 1\n        return \"\"\n\n    @app.get(\"/\")\n    def get_session() -> dict[str, t.Any]:\n        return dict(flask.session)\n\n    # Set session with initial secret key\n    client.post()\n    assert client.get().json == {\"a\": 1}\n    # Change secret key, session can't be loaded and appears empty\n    app.secret_key = \"new test key\"\n    assert client.get().json == {}\n    # Add initial secret key as fallback, session can be loaded\n    app.config[\"SECRET_KEY_FALLBACKS\"] = [\"test key\"]\n    assert client.get().json == {\"a\": 1}",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get().json == {'a': 1}",
                "assert client.get().json == {}",
                "assert client.get().json == {'a': 1}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "app.post",
                    "body": "def post(self):\n    return 'Create'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `app.post` method is designed to handle HTTP POST requests in a Flask application. It allows the application to define a route that responds to POST requests, typically used for creating or updating resources.\n\n**How It Works**:\nWhen a POST request is made to a specific route defined in the Flask application, the `post` method is invoked. In the provided example, it simply returns the string 'Create', indicating that a new resource (like a blog post) would be created. In a more complete implementation, this method would typically include logic to process form data, validate input, and interact with a database to create a new entry based on the submitted data. The method can be decorated with Flask's routing decorators to specify the URL path it responds to."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_secret_key_fallbacks",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 374,
            "end_line_number": 392,
            "source_code": "def test_session_secret_key_fallbacks(app, client) -> None:\n    @app.post(\"/\")\n    def set_session() -> str:\n        flask.session[\"a\"] = 1\n        return \"\"\n\n    @app.get(\"/\")\n    def get_session() -> dict[str, t.Any]:\n        return dict(flask.session)\n\n    # Set session with initial secret key\n    client.post()\n    assert client.get().json == {\"a\": 1}\n    # Change secret key, session can't be loaded and appears empty\n    app.secret_key = \"new test key\"\n    assert client.get().json == {}\n    # Add initial secret key as fallback, session can be loaded\n    app.config[\"SECRET_KEY_FALLBACKS\"] = [\"test key\"]\n    assert client.get().json == {\"a\": 1}",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get().json == {'a': 1}",
                "assert client.get().json == {}",
                "assert client.get().json == {'a': 1}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "app.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `app.get` method is used to define a route in a Flask web application that responds to HTTP GET requests. Specifically, the route `/get` retrieves a value from the session, returning it to the client.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` attempts to retrieve the value associated with the key `'value'` from the session. If the key does not exist, it defaults to returning the string `'None'`. The retrieved value is then returned as the response to the client. This method leverages Flask's session management to store and retrieve user-specific data across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_secret_key_fallbacks",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 374,
            "end_line_number": 392,
            "source_code": "def test_session_secret_key_fallbacks(app, client) -> None:\n    @app.post(\"/\")\n    def set_session() -> str:\n        flask.session[\"a\"] = 1\n        return \"\"\n\n    @app.get(\"/\")\n    def get_session() -> dict[str, t.Any]:\n        return dict(flask.session)\n\n    # Set session with initial secret key\n    client.post()\n    assert client.get().json == {\"a\": 1}\n    # Change secret key, session can't be loaded and appears empty\n    app.secret_key = \"new test key\"\n    assert client.get().json == {}\n    # Add initial secret key as fallback, session can be loaded\n    app.config[\"SECRET_KEY_FALLBACKS\"] = [\"test key\"]\n    assert client.get().json == {\"a\": 1}",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get().json == {'a': 1}",
                "assert client.get().json == {}",
                "assert client.get().json == {'a': 1}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.post",
                    "body": "def post(self):\n    return 'Create'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is designed to simulate an HTTP POST request to a specified endpoint, allowing developers to send data to the server, typically for creating or updating resources.\n\n**How It Works**:\nWhen invoked, `client.post` sends a request to the server at the specified URL with the provided data. In the context of the provided code snippets, it is used to test various functionalities such as creating a new post, updating an existing post, and validating input data. The method returns a response indicating the result of the operation, which can be further inspected for status codes or response data. The method is part of a testing framework that helps ensure the application's endpoints behave as expected."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_secret_key_fallbacks",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 374,
            "end_line_number": 392,
            "source_code": "def test_session_secret_key_fallbacks(app, client) -> None:\n    @app.post(\"/\")\n    def set_session() -> str:\n        flask.session[\"a\"] = 1\n        return \"\"\n\n    @app.get(\"/\")\n    def get_session() -> dict[str, t.Any]:\n        return dict(flask.session)\n\n    # Set session with initial secret key\n    client.post()\n    assert client.get().json == {\"a\": 1}\n    # Change secret key, session can't be loaded and appears empty\n    app.secret_key = \"new test key\"\n    assert client.get().json == {}\n    # Add initial secret key as fallback, session can be loaded\n    app.config[\"SECRET_KEY_FALLBACKS\"] = [\"test key\"]\n    assert client.get().json == {\"a\": 1}",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get().json == {'a': 1}",
                "assert client.get().json == {}",
                "assert client.get().json == {'a': 1}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_secret_key_fallbacks",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 374,
            "end_line_number": 392,
            "source_code": "def test_session_secret_key_fallbacks(app, client) -> None:\n    @app.post(\"/\")\n    def set_session() -> str:\n        flask.session[\"a\"] = 1\n        return \"\"\n\n    @app.get(\"/\")\n    def get_session() -> dict[str, t.Any]:\n        return dict(flask.session)\n\n    # Set session with initial secret key\n    client.post()\n    assert client.get().json == {\"a\": 1}\n    # Change secret key, session can't be loaded and appears empty\n    app.secret_key = \"new test key\"\n    assert client.get().json == {}\n    # Add initial secret key as fallback, session can be loaded\n    app.config[\"SECRET_KEY_FALLBACKS\"] = [\"test key\"]\n    assert client.get().json == {\"a\": 1}",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get().json == {'a': 1}",
                "assert client.get().json == {}",
                "assert client.get().json == {'a': 1}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session retrieves the value for the specified key (`'value'`), returning `'None'` if the key is not found. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_secret_key_fallbacks",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 374,
            "end_line_number": 392,
            "source_code": "def test_session_secret_key_fallbacks(app, client) -> None:\n    @app.post(\"/\")\n    def set_session() -> str:\n        flask.session[\"a\"] = 1\n        return \"\"\n\n    @app.get(\"/\")\n    def get_session() -> dict[str, t.Any]:\n        return dict(flask.session)\n\n    # Set session with initial secret key\n    client.post()\n    assert client.get().json == {\"a\": 1}\n    # Change secret key, session can't be loaded and appears empty\n    app.secret_key = \"new test key\"\n    assert client.get().json == {}\n    # Add initial secret key as fallback, session can be loaded\n    app.config[\"SECRET_KEY_FALLBACKS\"] = [\"test key\"]\n    assert client.get().json == {\"a\": 1}",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get().json == {'a': 1}",
                "assert client.get().json == {}",
                "assert client.get().json == {'a': 1}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_expiration",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 395,
            "end_line_number": 424,
            "source_code": "def test_session_expiration(app, client):\n    permanent = True\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"test\"] = 42\n        flask.session.permanent = permanent\n        return \"\"\n\n    @app.route(\"/test\")\n    def test():\n        return str(flask.session.permanent)\n\n    rv = client.get(\"/\")\n    assert \"set-cookie\" in rv.headers\n    match = re.search(r\"(?i)\\bexpires=([^;]+)\", rv.headers[\"set-cookie\"])\n    expires = parse_date(match.group())\n    expected = datetime.now(timezone.utc) + app.permanent_session_lifetime\n    assert expires.year == expected.year\n    assert expires.month == expected.month\n    assert expires.day == expected.day\n\n    rv = client.get(\"/test\")\n    assert rv.data == b\"True\"\n\n    permanent = False\n    rv = client.get(\"/\")\n    assert \"set-cookie\" in rv.headers\n    match = re.search(r\"\\bexpires=([^;]+)\", rv.headers[\"set-cookie\"])\n    assert match is None",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'set-cookie' in rv.headers",
                "assert expires.year == expected.year",
                "assert expires.month == expected.month",
                "assert expires.day == expected.day",
                "assert rv.data == b'True'",
                "assert 'set-cookie' in rv.headers",
                "assert match is None"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_expiration",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 395,
            "end_line_number": 424,
            "source_code": "def test_session_expiration(app, client):\n    permanent = True\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"test\"] = 42\n        flask.session.permanent = permanent\n        return \"\"\n\n    @app.route(\"/test\")\n    def test():\n        return str(flask.session.permanent)\n\n    rv = client.get(\"/\")\n    assert \"set-cookie\" in rv.headers\n    match = re.search(r\"(?i)\\bexpires=([^;]+)\", rv.headers[\"set-cookie\"])\n    expires = parse_date(match.group())\n    expected = datetime.now(timezone.utc) + app.permanent_session_lifetime\n    assert expires.year == expected.year\n    assert expires.month == expected.month\n    assert expires.day == expected.day\n\n    rv = client.get(\"/test\")\n    assert rv.data == b\"True\"\n\n    permanent = False\n    rv = client.get(\"/\")\n    assert \"set-cookie\" in rv.headers\n    match = re.search(r\"\\bexpires=([^;]+)\", rv.headers[\"set-cookie\"])\n    assert match is None",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'set-cookie' in rv.headers",
                "assert expires.year == expected.year",
                "assert expires.month == expected.month",
                "assert expires.day == expected.day",
                "assert rv.data == b'True'",
                "assert 'set-cookie' in rv.headers",
                "assert match is None"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_expiration",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 395,
            "end_line_number": 424,
            "source_code": "def test_session_expiration(app, client):\n    permanent = True\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"test\"] = 42\n        flask.session.permanent = permanent\n        return \"\"\n\n    @app.route(\"/test\")\n    def test():\n        return str(flask.session.permanent)\n\n    rv = client.get(\"/\")\n    assert \"set-cookie\" in rv.headers\n    match = re.search(r\"(?i)\\bexpires=([^;]+)\", rv.headers[\"set-cookie\"])\n    expires = parse_date(match.group())\n    expected = datetime.now(timezone.utc) + app.permanent_session_lifetime\n    assert expires.year == expected.year\n    assert expires.month == expected.month\n    assert expires.day == expected.day\n\n    rv = client.get(\"/test\")\n    assert rv.data == b\"True\"\n\n    permanent = False\n    rv = client.get(\"/\")\n    assert \"set-cookie\" in rv.headers\n    match = re.search(r\"\\bexpires=([^;]+)\", rv.headers[\"set-cookie\"])\n    assert match is None",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'set-cookie' in rv.headers",
                "assert expires.year == expected.year",
                "assert expires.month == expected.month",
                "assert expires.day == expected.day",
                "assert rv.data == b'True'",
                "assert 'set-cookie' in rv.headers",
                "assert match is None"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_stored_last",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 427,
            "end_line_number": 438,
            "source_code": "def test_session_stored_last(app, client):\n    @app.after_request\n    def modify_session(response):\n        flask.session[\"foo\"] = 42\n        return response\n\n    @app.route(\"/\")\n    def dump_session_contents():\n        return repr(flask.session.get(\"foo\"))\n\n    assert client.get(\"/\").data == b\"None\"\n    assert client.get(\"/\").data == b\"42\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').data == b'None'",
                "assert client.get('/').data == b'42'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_stored_last",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 427,
            "end_line_number": 438,
            "source_code": "def test_session_stored_last(app, client):\n    @app.after_request\n    def modify_session(response):\n        flask.session[\"foo\"] = 42\n        return response\n\n    @app.route(\"/\")\n    def dump_session_contents():\n        return repr(flask.session.get(\"foo\"))\n\n    assert client.get(\"/\").data == b\"None\"\n    assert client.get(\"/\").data == b\"42\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').data == b'None'",
                "assert client.get('/').data == b'42'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it as a response.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` attempts to fetch the value stored in the session under the key `'value'`. If this key does not exist, it defaults to returning the string `'None'`. The retrieved value is then returned as the HTTP response. This method relies on Flask's session management to store and retrieve user-specific data across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_special_types",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 441,
            "end_line_number": 469,
            "source_code": "def test_session_special_types(app, client):\n    now = datetime.now(timezone.utc).replace(microsecond=0)\n    the_uuid = uuid.uuid4()\n\n    @app.route(\"/\")\n    def dump_session_contents():\n        flask.session[\"t\"] = (1, 2, 3)\n        flask.session[\"b\"] = b\"\\xff\"\n        flask.session[\"m\"] = Markup(\"<html>\")\n        flask.session[\"u\"] = the_uuid\n        flask.session[\"d\"] = now\n        flask.session[\"t_tag\"] = {\" t\": \"not-a-tuple\"}\n        flask.session[\"di_t_tag\"] = {\" t__\": \"not-a-tuple\"}\n        flask.session[\"di_tag\"] = {\" di\": \"not-a-dict\"}\n        return \"\", 204\n\n    with client:\n        client.get(\"/\")\n        s = flask.session\n        assert s[\"t\"] == (1, 2, 3)\n        assert type(s[\"b\"]) is bytes  # noqa: E721\n        assert s[\"b\"] == b\"\\xff\"\n        assert type(s[\"m\"]) is Markup  # noqa: E721\n        assert s[\"m\"] == Markup(\"<html>\")\n        assert s[\"u\"] == the_uuid\n        assert s[\"d\"] == now\n        assert s[\"t_tag\"] == {\" t\": \"not-a-tuple\"}\n        assert s[\"di_t_tag\"] == {\" t__\": \"not-a-tuple\"}\n        assert s[\"di_tag\"] == {\" di\": \"not-a-dict\"}",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert s['t'] == (1, 2, 3)",
                "assert type(s['b']) is bytes",
                "assert s['b'] == b'\\xff'",
                "assert type(s['m']) is Markup",
                "assert s['m'] == Markup('<html>')",
                "assert s['u'] == the_uuid",
                "assert s['d'] == now",
                "assert s['t_tag'] == {' t': 'not-a-tuple'}",
                "assert s['di_t_tag'] == {' t__': 'not-a-tuple'}",
                "assert s['di_tag'] == {' di': 'not-a-dict'}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_cookie_setting",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 472,
            "end_line_number": 510,
            "source_code": "def test_session_cookie_setting(app):\n    is_permanent = True\n\n    @app.route(\"/bump\")\n    def bump():\n        rv = flask.session[\"foo\"] = flask.session.get(\"foo\", 0) + 1\n        flask.session.permanent = is_permanent\n        return str(rv)\n\n    @app.route(\"/read\")\n    def read():\n        return str(flask.session.get(\"foo\", 0))\n\n    def run_test(expect_header):\n        with app.test_client() as c:\n            assert c.get(\"/bump\").data == b\"1\"\n            assert c.get(\"/bump\").data == b\"2\"\n            assert c.get(\"/bump\").data == b\"3\"\n\n            rv = c.get(\"/read\")\n            set_cookie = rv.headers.get(\"set-cookie\")\n            assert (set_cookie is not None) == expect_header\n            assert rv.data == b\"3\"\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=True)\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert c.get('/bump').data == b'1'",
                "assert c.get('/bump').data == b'2'",
                "assert c.get('/bump').data == b'3'",
                "assert (set_cookie is not None) == expect_header",
                "assert rv.data == b'3'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "run_test",
                    "body": "def run_test(expect_header):\n    with app.test_client() as c:\n        assert c.get('/bump').data == b'1'\n        assert c.get('/bump').data == b'2'\n        assert c.get('/bump').data == b'3'\n        rv = c.get('/read')\n        set_cookie = rv.headers.get('set-cookie')\n        assert (set_cookie is not None) == expect_header\n        assert rv.data == b'3'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_test` method is designed to validate the behavior of session management in a Flask application. It tests the incrementing of a session variable and checks whether a session cookie is set based on the application's configuration.\n\n**How It Works**:\n1. The method uses Flask's test client to simulate requests to the application.\n2. It first sends three GET requests to the `/bump` route, which increments a session variable `foo` and returns its value. The expected responses are asserted to be `b'1'`, `b'2'`, and `b'3'`.\n3. It then sends a GET request to the `/read` route, which returns the current value of the session variable `foo`.\n4. The method checks if the `set-cookie` header is present in the response, asserting that its presence matches the `expect_header` argument.\n5. Finally, it verifies that the response data from the `/read` route is `b'3'`, confirming that the session variable was correctly updated. \n\nThis method is called multiple times with different configurations to test various scenarios of session persistence and cookie behavior."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_cookie_setting",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 472,
            "end_line_number": 510,
            "source_code": "def test_session_cookie_setting(app):\n    is_permanent = True\n\n    @app.route(\"/bump\")\n    def bump():\n        rv = flask.session[\"foo\"] = flask.session.get(\"foo\", 0) + 1\n        flask.session.permanent = is_permanent\n        return str(rv)\n\n    @app.route(\"/read\")\n    def read():\n        return str(flask.session.get(\"foo\", 0))\n\n    def run_test(expect_header):\n        with app.test_client() as c:\n            assert c.get(\"/bump\").data == b\"1\"\n            assert c.get(\"/bump\").data == b\"2\"\n            assert c.get(\"/bump\").data == b\"3\"\n\n            rv = c.get(\"/read\")\n            set_cookie = rv.headers.get(\"set-cookie\")\n            assert (set_cookie is not None) == expect_header\n            assert rv.data == b\"3\"\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=True)\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert c.get('/bump').data == b'1'",
                "assert c.get('/bump').data == b'2'",
                "assert c.get('/bump').data == b'3'",
                "assert (set_cookie is not None) == expect_header",
                "assert rv.data == b'3'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "run_test",
                    "body": "def run_test(expect_header):\n    with app.test_client() as c:\n        assert c.get('/bump').data == b'1'\n        assert c.get('/bump').data == b'2'\n        assert c.get('/bump').data == b'3'\n        rv = c.get('/read')\n        set_cookie = rv.headers.get('set-cookie')\n        assert (set_cookie is not None) == expect_header\n        assert rv.data == b'3'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_test` method is designed to validate the behavior of session management in a Flask application. It specifically tests the incrementing of a session variable and checks whether a session cookie is set based on the application's configuration.\n\n**How It Works**:\n1. The method uses Flask's test client to simulate requests to the application.\n2. It first sends three GET requests to the `/bump` route, which increments a session variable `foo` and returns its value. The expected responses are asserted to be `b'1'`, `b'2'`, and `b'3'`.\n3. It then sends a GET request to the `/read` route, which returns the current value of the session variable `foo`.\n4. The method checks if the `set-cookie` header is present in the response, asserting that its presence matches the `expect_header` argument.\n5. Finally, it asserts that the response data from the `/read` route is `b'3'`, confirming that the session variable was correctly updated. \n\nThis method is called multiple times with different configurations to test various scenarios of session persistence and cookie setting."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_cookie_setting",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 472,
            "end_line_number": 510,
            "source_code": "def test_session_cookie_setting(app):\n    is_permanent = True\n\n    @app.route(\"/bump\")\n    def bump():\n        rv = flask.session[\"foo\"] = flask.session.get(\"foo\", 0) + 1\n        flask.session.permanent = is_permanent\n        return str(rv)\n\n    @app.route(\"/read\")\n    def read():\n        return str(flask.session.get(\"foo\", 0))\n\n    def run_test(expect_header):\n        with app.test_client() as c:\n            assert c.get(\"/bump\").data == b\"1\"\n            assert c.get(\"/bump\").data == b\"2\"\n            assert c.get(\"/bump\").data == b\"3\"\n\n            rv = c.get(\"/read\")\n            set_cookie = rv.headers.get(\"set-cookie\")\n            assert (set_cookie is not None) == expect_header\n            assert rv.data == b\"3\"\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=True)\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert c.get('/bump').data == b'1'",
                "assert c.get('/bump').data == b'2'",
                "assert c.get('/bump').data == b'3'",
                "assert (set_cookie is not None) == expect_header",
                "assert rv.data == b'3'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "run_test",
                    "body": "def run_test(expect_header):\n    with app.test_client() as c:\n        assert c.get('/bump').data == b'1'\n        assert c.get('/bump').data == b'2'\n        assert c.get('/bump').data == b'3'\n        rv = c.get('/read')\n        set_cookie = rv.headers.get('set-cookie')\n        assert (set_cookie is not None) == expect_header\n        assert rv.data == b'3'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_test` method is designed to validate the behavior of session management in a Flask application. It tests the incrementing of a session variable and checks whether a session cookie is set based on the application's configuration.\n\n**How It Works**:\n1. The method uses Flask's test client to simulate requests to the application.\n2. It first sends three GET requests to the `/bump` route, which increments a session variable `foo` and returns its value. The expected responses are asserted to be `b'1'`, `b'2'`, and `b'3'`.\n3. It then sends a GET request to the `/read` route, which returns the current value of the session variable `foo`.\n4. The method checks if the `set-cookie` header is present in the response, asserting that its presence matches the `expect_header` argument.\n5. Finally, it asserts that the response data from the `/read` route is `b'3'`, confirming that the session variable was correctly updated. \n\nThis method is called multiple times with different configurations to test various scenarios of session persistence and cookie behavior."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_cookie_setting",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 472,
            "end_line_number": 510,
            "source_code": "def test_session_cookie_setting(app):\n    is_permanent = True\n\n    @app.route(\"/bump\")\n    def bump():\n        rv = flask.session[\"foo\"] = flask.session.get(\"foo\", 0) + 1\n        flask.session.permanent = is_permanent\n        return str(rv)\n\n    @app.route(\"/read\")\n    def read():\n        return str(flask.session.get(\"foo\", 0))\n\n    def run_test(expect_header):\n        with app.test_client() as c:\n            assert c.get(\"/bump\").data == b\"1\"\n            assert c.get(\"/bump\").data == b\"2\"\n            assert c.get(\"/bump\").data == b\"3\"\n\n            rv = c.get(\"/read\")\n            set_cookie = rv.headers.get(\"set-cookie\")\n            assert (set_cookie is not None) == expect_header\n            assert rv.data == b\"3\"\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=True)\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert c.get('/bump').data == b'1'",
                "assert c.get('/bump').data == b'2'",
                "assert c.get('/bump').data == b'3'",
                "assert (set_cookie is not None) == expect_header",
                "assert rv.data == b'3'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "run_test",
                    "body": "def run_test(expect_header):\n    with app.test_client() as c:\n        assert c.get('/bump').data == b'1'\n        assert c.get('/bump').data == b'2'\n        assert c.get('/bump').data == b'3'\n        rv = c.get('/read')\n        set_cookie = rv.headers.get('set-cookie')\n        assert (set_cookie is not None) == expect_header\n        assert rv.data == b'3'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `run_test` method is designed to validate the behavior of session management in a Flask application. It tests the incrementing of a session variable and checks whether a session cookie is set based on the application's configuration.\n\n**How It Works**:\n1. The method uses Flask's test client to simulate requests to the application.\n2. It first sends three GET requests to the `/bump` route, which increments a session variable `foo` and returns its value. The expected responses are asserted to be `b'1'`, `b'2'`, and `b'3'`.\n3. It then sends a GET request to the `/read` route, which returns the current value of the session variable `foo`.\n4. The method checks if the `set-cookie` header is present in the response, asserting that its presence matches the `expect_header` parameter.\n5. Finally, it asserts that the response data from the `/read` route is `b'3'`, confirming that the session variable was correctly updated. \n\nThis method is called multiple times with different configurations to test various scenarios of session persistence and cookie behavior."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_cookie_setting",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 472,
            "end_line_number": 510,
            "source_code": "def test_session_cookie_setting(app):\n    is_permanent = True\n\n    @app.route(\"/bump\")\n    def bump():\n        rv = flask.session[\"foo\"] = flask.session.get(\"foo\", 0) + 1\n        flask.session.permanent = is_permanent\n        return str(rv)\n\n    @app.route(\"/read\")\n    def read():\n        return str(flask.session.get(\"foo\", 0))\n\n    def run_test(expect_header):\n        with app.test_client() as c:\n            assert c.get(\"/bump\").data == b\"1\"\n            assert c.get(\"/bump\").data == b\"2\"\n            assert c.get(\"/bump\").data == b\"3\"\n\n            rv = c.get(\"/read\")\n            set_cookie = rv.headers.get(\"set-cookie\")\n            assert (set_cookie is not None) == expect_header\n            assert rv.data == b\"3\"\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=True)\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert c.get('/bump').data == b'1'",
                "assert c.get('/bump').data == b'2'",
                "assert c.get('/bump').data == b'3'",
                "assert (set_cookie is not None) == expect_header",
                "assert rv.data == b'3'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "c.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get` method is a Flask route handler that retrieves a value from the session, specifically the value associated with the key `'value'`. If this key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the method uses `flask.session.get()` to access the session data. The `get` method takes two arguments: the key to look for (`'value'`) and a default value (`'None'`) to return if the key is not found. The retrieved value is then returned as the response to the HTTP request. This allows the application to maintain state across requests by storing and retrieving data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_cookie_setting",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 472,
            "end_line_number": 510,
            "source_code": "def test_session_cookie_setting(app):\n    is_permanent = True\n\n    @app.route(\"/bump\")\n    def bump():\n        rv = flask.session[\"foo\"] = flask.session.get(\"foo\", 0) + 1\n        flask.session.permanent = is_permanent\n        return str(rv)\n\n    @app.route(\"/read\")\n    def read():\n        return str(flask.session.get(\"foo\", 0))\n\n    def run_test(expect_header):\n        with app.test_client() as c:\n            assert c.get(\"/bump\").data == b\"1\"\n            assert c.get(\"/bump\").data == b\"2\"\n            assert c.get(\"/bump\").data == b\"3\"\n\n            rv = c.get(\"/read\")\n            set_cookie = rv.headers.get(\"set-cookie\")\n            assert (set_cookie is not None) == expect_header\n            assert rv.data == b\"3\"\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=True)\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert c.get('/bump').data == b'1'",
                "assert c.get('/bump').data == b'2'",
                "assert c.get('/bump').data == b'3'",
                "assert (set_cookie is not None) == expect_header",
                "assert rv.data == b'3'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "rv.headers.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `rv.headers.get` method is used to retrieve a specific header from the response object (`rv`), typically to check for the presence or value of a header, such as \"set-cookie\", after making a request in a Flask application.\n\n**How It Works**:\nIn the provided code snippets, `rv` represents the response object returned by a Flask route. The `headers` attribute of this response object contains all the HTTP headers sent back to the client. The `get` method is called on `rv.headers` to safely access a header by its name (e.g., \"set-cookie\"). If the header exists, its value is returned; if it does not exist, `None` is returned. This is particularly useful for testing scenarios where you need to verify if certain headers are set based on session behavior, as shown in the `test_session_cookie_setting` function."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_cookie_setting",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 472,
            "end_line_number": 510,
            "source_code": "def test_session_cookie_setting(app):\n    is_permanent = True\n\n    @app.route(\"/bump\")\n    def bump():\n        rv = flask.session[\"foo\"] = flask.session.get(\"foo\", 0) + 1\n        flask.session.permanent = is_permanent\n        return str(rv)\n\n    @app.route(\"/read\")\n    def read():\n        return str(flask.session.get(\"foo\", 0))\n\n    def run_test(expect_header):\n        with app.test_client() as c:\n            assert c.get(\"/bump\").data == b\"1\"\n            assert c.get(\"/bump\").data == b\"2\"\n            assert c.get(\"/bump\").data == b\"3\"\n\n            rv = c.get(\"/read\")\n            set_cookie = rv.headers.get(\"set-cookie\")\n            assert (set_cookie is not None) == expect_header\n            assert rv.data == b\"3\"\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=True)\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert c.get('/bump').data == b'1'",
                "assert c.get('/bump').data == b'2'",
                "assert c.get('/bump').data == b'3'",
                "assert (set_cookie is not None) == expect_header",
                "assert rv.data == b'3'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "c.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get` method is a Flask route handler that retrieves a value from the session, specifically the value associated with the key `'value'`. If this key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the method uses `flask.session.get` to access the session data. The `get` method of the session object takes two arguments: the key to look for (`'value'`) and a default value (`'None'`) to return if the key is not found. The retrieved value is then returned as the response to the HTTP request. This allows the application to maintain state across requests by storing and retrieving data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_cookie_setting",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 472,
            "end_line_number": 510,
            "source_code": "def test_session_cookie_setting(app):\n    is_permanent = True\n\n    @app.route(\"/bump\")\n    def bump():\n        rv = flask.session[\"foo\"] = flask.session.get(\"foo\", 0) + 1\n        flask.session.permanent = is_permanent\n        return str(rv)\n\n    @app.route(\"/read\")\n    def read():\n        return str(flask.session.get(\"foo\", 0))\n\n    def run_test(expect_header):\n        with app.test_client() as c:\n            assert c.get(\"/bump\").data == b\"1\"\n            assert c.get(\"/bump\").data == b\"2\"\n            assert c.get(\"/bump\").data == b\"3\"\n\n            rv = c.get(\"/read\")\n            set_cookie = rv.headers.get(\"set-cookie\")\n            assert (set_cookie is not None) == expect_header\n            assert rv.data == b\"3\"\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=True)\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert c.get('/bump').data == b'1'",
                "assert c.get('/bump').data == b'2'",
                "assert c.get('/bump').data == b'3'",
                "assert (set_cookie is not None) == expect_header",
                "assert rv.data == b'3'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "c.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get` method is a Flask route handler that retrieves a value from the session, specifically the value associated with the key `'value'`. If this key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the method uses `flask.session.get()` to access the session data. The `get` method takes two arguments: the key `'value'` and a default value `'None'`. If the key is found, it returns the corresponding value; otherwise, it returns the default value. This allows for safe retrieval of session data without raising an error if the key is missing. The response is then sent back to the client."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_cookie_setting",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 472,
            "end_line_number": 510,
            "source_code": "def test_session_cookie_setting(app):\n    is_permanent = True\n\n    @app.route(\"/bump\")\n    def bump():\n        rv = flask.session[\"foo\"] = flask.session.get(\"foo\", 0) + 1\n        flask.session.permanent = is_permanent\n        return str(rv)\n\n    @app.route(\"/read\")\n    def read():\n        return str(flask.session.get(\"foo\", 0))\n\n    def run_test(expect_header):\n        with app.test_client() as c:\n            assert c.get(\"/bump\").data == b\"1\"\n            assert c.get(\"/bump\").data == b\"2\"\n            assert c.get(\"/bump\").data == b\"3\"\n\n            rv = c.get(\"/read\")\n            set_cookie = rv.headers.get(\"set-cookie\")\n            assert (set_cookie is not None) == expect_header\n            assert rv.data == b\"3\"\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=True)\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert c.get('/bump').data == b'1'",
                "assert c.get('/bump').data == b'2'",
                "assert c.get('/bump').data == b'3'",
                "assert (set_cookie is not None) == expect_header",
                "assert rv.data == b'3'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "c.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get` method is a Flask route handler that retrieves a value from the session, specifically the value associated with the key `'value'`. If this key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the method uses `flask.session.get()` to access the session data. The `get` method takes two arguments: the key to look for (`'value'`) and a default value (`'None'`) to return if the key is not found. The retrieved value is then returned as the response to the HTTP request. This allows the application to maintain state across requests by storing and retrieving data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_vary_cookie",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 513,
            "end_line_number": 571,
            "source_code": "def test_session_vary_cookie(app, client):\n    @app.route(\"/set\")\n    def set_session():\n        flask.session[\"test\"] = \"test\"\n        return \"\"\n\n    @app.route(\"/get\")\n    def get():\n        return flask.session.get(\"test\")\n\n    @app.route(\"/getitem\")\n    def getitem():\n        return flask.session[\"test\"]\n\n    @app.route(\"/setdefault\")\n    def setdefault():\n        return flask.session.setdefault(\"test\", \"default\")\n\n    @app.route(\"/clear\")\n    def clear():\n        flask.session.clear()\n        return \"\"\n\n    @app.route(\"/vary-cookie-header-set\")\n    def vary_cookie_header_set():\n        response = flask.Response()\n        response.vary.add(\"Cookie\")\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/vary-header-set\")\n    def vary_header_set():\n        response = flask.Response()\n        response.vary.update((\"Accept-Encoding\", \"Accept-Language\"))\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/no-vary-header\")\n    def no_vary_header():\n        return \"\"\n\n    def expect(path, header_value=\"Cookie\"):\n        rv = client.get(path)\n\n        if header_value:\n            # The 'Vary' key should exist in the headers only once.\n            assert len(rv.headers.get_all(\"Vary\")) == 1\n            assert rv.headers[\"Vary\"] == header_value\n        else:\n            assert \"Vary\" not in rv.headers\n\n    expect(\"/set\")\n    expect(\"/get\")\n    expect(\"/getitem\")\n    expect(\"/setdefault\")\n    expect(\"/clear\")\n    expect(\"/vary-cookie-header-set\")\n    expect(\"/vary-header-set\", \"Accept-Encoding, Accept-Language, Cookie\")\n    expect(\"/no-vary-header\", None)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert len(rv.headers.get_all('Vary')) == 1",
                "assert rv.headers['Vary'] == header_value",
                "assert 'Vary' not in rv.headers"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "expect",
                    "body": "def expect(path, header_value='Cookie'):\n    rv = client.get(path)\n    if header_value:\n        assert len(rv.headers.get_all('Vary')) == 1\n        assert rv.headers['Vary'] == header_value\n    else:\n        assert 'Vary' not in rv.headers",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `expect` method is designed to verify the presence and correctness of the `Vary` header in the HTTP response returned by a Flask application. It checks whether the response varies based on a specified header value, which is typically used for caching purposes.\n\n**How It Works**:\n1. The method takes two parameters: `path`, which is the URL endpoint to be tested, and `header_value`, which defaults to `'Cookie'`.\n2. It sends a GET request to the specified `path` using a test client.\n3. If `header_value` is provided, it asserts that the `Vary` header is present and matches the expected value. Specifically, it checks that there is exactly one entry in the `Vary` header and that it equals `header_value`.\n4. If `header_value` is not provided (i.e., it is `None` or an empty string), it asserts that the `Vary` header is absent from the response. \n\nThis method is useful in testing scenarios where the behavior of the application may depend on specific headers, ensuring that the application correctly handles caching and content negotiation."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_vary_cookie",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 513,
            "end_line_number": 571,
            "source_code": "def test_session_vary_cookie(app, client):\n    @app.route(\"/set\")\n    def set_session():\n        flask.session[\"test\"] = \"test\"\n        return \"\"\n\n    @app.route(\"/get\")\n    def get():\n        return flask.session.get(\"test\")\n\n    @app.route(\"/getitem\")\n    def getitem():\n        return flask.session[\"test\"]\n\n    @app.route(\"/setdefault\")\n    def setdefault():\n        return flask.session.setdefault(\"test\", \"default\")\n\n    @app.route(\"/clear\")\n    def clear():\n        flask.session.clear()\n        return \"\"\n\n    @app.route(\"/vary-cookie-header-set\")\n    def vary_cookie_header_set():\n        response = flask.Response()\n        response.vary.add(\"Cookie\")\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/vary-header-set\")\n    def vary_header_set():\n        response = flask.Response()\n        response.vary.update((\"Accept-Encoding\", \"Accept-Language\"))\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/no-vary-header\")\n    def no_vary_header():\n        return \"\"\n\n    def expect(path, header_value=\"Cookie\"):\n        rv = client.get(path)\n\n        if header_value:\n            # The 'Vary' key should exist in the headers only once.\n            assert len(rv.headers.get_all(\"Vary\")) == 1\n            assert rv.headers[\"Vary\"] == header_value\n        else:\n            assert \"Vary\" not in rv.headers\n\n    expect(\"/set\")\n    expect(\"/get\")\n    expect(\"/getitem\")\n    expect(\"/setdefault\")\n    expect(\"/clear\")\n    expect(\"/vary-cookie-header-set\")\n    expect(\"/vary-header-set\", \"Accept-Encoding, Accept-Language, Cookie\")\n    expect(\"/no-vary-header\", None)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert len(rv.headers.get_all('Vary')) == 1",
                "assert rv.headers['Vary'] == header_value",
                "assert 'Vary' not in rv.headers"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "expect",
                    "body": "def expect(path, header_value='Cookie'):\n    rv = client.get(path)\n    if header_value:\n        assert len(rv.headers.get_all('Vary')) == 1\n        assert rv.headers['Vary'] == header_value\n    else:\n        assert 'Vary' not in rv.headers",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `expect` method is designed to verify the presence and correctness of the `Vary` HTTP header in the response from a Flask application. It checks whether the header is set to a specified value or not present at all, depending on the input parameters.\n\n**How It Works**:\n1. The method takes two parameters: `path`, which is the URL endpoint to be tested, and `header_value`, which defaults to `'Cookie'`.\n2. It sends a GET request to the specified `path` using a test client.\n3. If `header_value` is provided, it asserts that the `Vary` header exists and matches the expected value. Specifically, it checks that there is exactly one entry in the `Vary` header.\n4. If `header_value` is not provided (i.e., it is `None`), it asserts that the `Vary` header is absent from the response.\nThis method is useful for ensuring that the application correctly handles caching and content negotiation based on the specified headers."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_vary_cookie",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 513,
            "end_line_number": 571,
            "source_code": "def test_session_vary_cookie(app, client):\n    @app.route(\"/set\")\n    def set_session():\n        flask.session[\"test\"] = \"test\"\n        return \"\"\n\n    @app.route(\"/get\")\n    def get():\n        return flask.session.get(\"test\")\n\n    @app.route(\"/getitem\")\n    def getitem():\n        return flask.session[\"test\"]\n\n    @app.route(\"/setdefault\")\n    def setdefault():\n        return flask.session.setdefault(\"test\", \"default\")\n\n    @app.route(\"/clear\")\n    def clear():\n        flask.session.clear()\n        return \"\"\n\n    @app.route(\"/vary-cookie-header-set\")\n    def vary_cookie_header_set():\n        response = flask.Response()\n        response.vary.add(\"Cookie\")\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/vary-header-set\")\n    def vary_header_set():\n        response = flask.Response()\n        response.vary.update((\"Accept-Encoding\", \"Accept-Language\"))\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/no-vary-header\")\n    def no_vary_header():\n        return \"\"\n\n    def expect(path, header_value=\"Cookie\"):\n        rv = client.get(path)\n\n        if header_value:\n            # The 'Vary' key should exist in the headers only once.\n            assert len(rv.headers.get_all(\"Vary\")) == 1\n            assert rv.headers[\"Vary\"] == header_value\n        else:\n            assert \"Vary\" not in rv.headers\n\n    expect(\"/set\")\n    expect(\"/get\")\n    expect(\"/getitem\")\n    expect(\"/setdefault\")\n    expect(\"/clear\")\n    expect(\"/vary-cookie-header-set\")\n    expect(\"/vary-header-set\", \"Accept-Encoding, Accept-Language, Cookie\")\n    expect(\"/no-vary-header\", None)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert len(rv.headers.get_all('Vary')) == 1",
                "assert rv.headers['Vary'] == header_value",
                "assert 'Vary' not in rv.headers"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "expect",
                    "body": "def expect(path, header_value='Cookie'):\n    rv = client.get(path)\n    if header_value:\n        assert len(rv.headers.get_all('Vary')) == 1\n        assert rv.headers['Vary'] == header_value\n    else:\n        assert 'Vary' not in rv.headers",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `expect` method is designed to verify the presence and correctness of the `Vary` header in the HTTP response received from a specified path. It checks whether the response headers vary based on a specified header value, which is typically used for caching mechanisms.\n\n**How It Works**:\n1. The method takes two parameters: `path`, which is the URL endpoint to be tested, and `header_value`, which defaults to `'Cookie'`.\n2. It sends a GET request to the specified `path` using a test client.\n3. If `header_value` is provided, it asserts that the `Vary` header is present and matches the expected value. Specifically, it checks that there is exactly one entry in the `Vary` header.\n4. If `header_value` is not provided (i.e., it is `None`), it asserts that the `Vary` header is absent from the response.\nThis method is useful in testing scenarios where the behavior of responses may change based on certain headers, ensuring that caching and content negotiation work as intended."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_vary_cookie",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 513,
            "end_line_number": 571,
            "source_code": "def test_session_vary_cookie(app, client):\n    @app.route(\"/set\")\n    def set_session():\n        flask.session[\"test\"] = \"test\"\n        return \"\"\n\n    @app.route(\"/get\")\n    def get():\n        return flask.session.get(\"test\")\n\n    @app.route(\"/getitem\")\n    def getitem():\n        return flask.session[\"test\"]\n\n    @app.route(\"/setdefault\")\n    def setdefault():\n        return flask.session.setdefault(\"test\", \"default\")\n\n    @app.route(\"/clear\")\n    def clear():\n        flask.session.clear()\n        return \"\"\n\n    @app.route(\"/vary-cookie-header-set\")\n    def vary_cookie_header_set():\n        response = flask.Response()\n        response.vary.add(\"Cookie\")\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/vary-header-set\")\n    def vary_header_set():\n        response = flask.Response()\n        response.vary.update((\"Accept-Encoding\", \"Accept-Language\"))\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/no-vary-header\")\n    def no_vary_header():\n        return \"\"\n\n    def expect(path, header_value=\"Cookie\"):\n        rv = client.get(path)\n\n        if header_value:\n            # The 'Vary' key should exist in the headers only once.\n            assert len(rv.headers.get_all(\"Vary\")) == 1\n            assert rv.headers[\"Vary\"] == header_value\n        else:\n            assert \"Vary\" not in rv.headers\n\n    expect(\"/set\")\n    expect(\"/get\")\n    expect(\"/getitem\")\n    expect(\"/setdefault\")\n    expect(\"/clear\")\n    expect(\"/vary-cookie-header-set\")\n    expect(\"/vary-header-set\", \"Accept-Encoding, Accept-Language, Cookie\")\n    expect(\"/no-vary-header\", None)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert len(rv.headers.get_all('Vary')) == 1",
                "assert rv.headers['Vary'] == header_value",
                "assert 'Vary' not in rv.headers"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "expect",
                    "body": "def expect(path, header_value='Cookie'):\n    rv = client.get(path)\n    if header_value:\n        assert len(rv.headers.get_all('Vary')) == 1\n        assert rv.headers['Vary'] == header_value\n    else:\n        assert 'Vary' not in rv.headers",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `expect` method is designed to verify the presence and correctness of the `Vary` header in the HTTP response received from a specified path. It checks whether the response varies based on a specified header value, which is typically used in caching mechanisms.\n\n**How It Works**:\n1. The method takes two parameters: `path`, which is the URL endpoint to be tested, and `header_value`, which defaults to `'Cookie'`.\n2. It sends a GET request to the specified `path` using a test client.\n3. If `header_value` is provided, it asserts that the `Vary` header is present and matches the expected value. Specifically, it checks that there is exactly one entry in the `Vary` header and that it equals `header_value`.\n4. If `header_value` is not provided (i.e., it is `None` or an empty string), it asserts that the `Vary` header is absent from the response. \n\nThis method is useful for ensuring that responses are correctly configured for caching based on specific request headers."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_vary_cookie",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 513,
            "end_line_number": 571,
            "source_code": "def test_session_vary_cookie(app, client):\n    @app.route(\"/set\")\n    def set_session():\n        flask.session[\"test\"] = \"test\"\n        return \"\"\n\n    @app.route(\"/get\")\n    def get():\n        return flask.session.get(\"test\")\n\n    @app.route(\"/getitem\")\n    def getitem():\n        return flask.session[\"test\"]\n\n    @app.route(\"/setdefault\")\n    def setdefault():\n        return flask.session.setdefault(\"test\", \"default\")\n\n    @app.route(\"/clear\")\n    def clear():\n        flask.session.clear()\n        return \"\"\n\n    @app.route(\"/vary-cookie-header-set\")\n    def vary_cookie_header_set():\n        response = flask.Response()\n        response.vary.add(\"Cookie\")\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/vary-header-set\")\n    def vary_header_set():\n        response = flask.Response()\n        response.vary.update((\"Accept-Encoding\", \"Accept-Language\"))\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/no-vary-header\")\n    def no_vary_header():\n        return \"\"\n\n    def expect(path, header_value=\"Cookie\"):\n        rv = client.get(path)\n\n        if header_value:\n            # The 'Vary' key should exist in the headers only once.\n            assert len(rv.headers.get_all(\"Vary\")) == 1\n            assert rv.headers[\"Vary\"] == header_value\n        else:\n            assert \"Vary\" not in rv.headers\n\n    expect(\"/set\")\n    expect(\"/get\")\n    expect(\"/getitem\")\n    expect(\"/setdefault\")\n    expect(\"/clear\")\n    expect(\"/vary-cookie-header-set\")\n    expect(\"/vary-header-set\", \"Accept-Encoding, Accept-Language, Cookie\")\n    expect(\"/no-vary-header\", None)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert len(rv.headers.get_all('Vary')) == 1",
                "assert rv.headers['Vary'] == header_value",
                "assert 'Vary' not in rv.headers"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "expect",
                    "body": "def expect(path, header_value='Cookie'):\n    rv = client.get(path)\n    if header_value:\n        assert len(rv.headers.get_all('Vary')) == 1\n        assert rv.headers['Vary'] == header_value\n    else:\n        assert 'Vary' not in rv.headers",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `expect` method is designed to verify the presence and correctness of the `Vary` header in the HTTP response received from a specified path. It checks whether the response headers vary based on a specified header value, which is typically used in caching mechanisms.\n\n**How It Works**:\n1. The method takes two parameters: `path`, which is the URL endpoint to be tested, and `header_value`, which defaults to `'Cookie'`.\n2. It sends a GET request to the specified `path` using a test client.\n3. If `header_value` is provided, it asserts that the `Vary` header is present and matches the expected value. Specifically, it checks that there is exactly one entry in the `Vary` header.\n4. If `header_value` is not provided, it asserts that the `Vary` header is absent from the response.\nThis method is useful for ensuring that responses are correctly configured for caching based on specific request headers."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_vary_cookie",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 513,
            "end_line_number": 571,
            "source_code": "def test_session_vary_cookie(app, client):\n    @app.route(\"/set\")\n    def set_session():\n        flask.session[\"test\"] = \"test\"\n        return \"\"\n\n    @app.route(\"/get\")\n    def get():\n        return flask.session.get(\"test\")\n\n    @app.route(\"/getitem\")\n    def getitem():\n        return flask.session[\"test\"]\n\n    @app.route(\"/setdefault\")\n    def setdefault():\n        return flask.session.setdefault(\"test\", \"default\")\n\n    @app.route(\"/clear\")\n    def clear():\n        flask.session.clear()\n        return \"\"\n\n    @app.route(\"/vary-cookie-header-set\")\n    def vary_cookie_header_set():\n        response = flask.Response()\n        response.vary.add(\"Cookie\")\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/vary-header-set\")\n    def vary_header_set():\n        response = flask.Response()\n        response.vary.update((\"Accept-Encoding\", \"Accept-Language\"))\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/no-vary-header\")\n    def no_vary_header():\n        return \"\"\n\n    def expect(path, header_value=\"Cookie\"):\n        rv = client.get(path)\n\n        if header_value:\n            # The 'Vary' key should exist in the headers only once.\n            assert len(rv.headers.get_all(\"Vary\")) == 1\n            assert rv.headers[\"Vary\"] == header_value\n        else:\n            assert \"Vary\" not in rv.headers\n\n    expect(\"/set\")\n    expect(\"/get\")\n    expect(\"/getitem\")\n    expect(\"/setdefault\")\n    expect(\"/clear\")\n    expect(\"/vary-cookie-header-set\")\n    expect(\"/vary-header-set\", \"Accept-Encoding, Accept-Language, Cookie\")\n    expect(\"/no-vary-header\", None)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert len(rv.headers.get_all('Vary')) == 1",
                "assert rv.headers['Vary'] == header_value",
                "assert 'Vary' not in rv.headers"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "expect",
                    "body": "def expect(path, header_value='Cookie'):\n    rv = client.get(path)\n    if header_value:\n        assert len(rv.headers.get_all('Vary')) == 1\n        assert rv.headers['Vary'] == header_value\n    else:\n        assert 'Vary' not in rv.headers",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `expect` method is designed to verify the presence and correctness of the `Vary` header in the HTTP response returned by a Flask application. It checks whether the response varies based on a specified header value, which is typically used for caching purposes.\n\n**How It Works**:\n1. The method takes two parameters: `path`, which is the URL endpoint to be tested, and `header_value`, which defaults to `'Cookie'`.\n2. It sends a GET request to the specified `path` using a test client.\n3. If `header_value` is provided, it asserts that the `Vary` header is present and matches the expected value. Specifically, it checks that there is exactly one entry in the `Vary` header and that it equals `header_value`.\n4. If `header_value` is not provided (i.e., it is `None`), it asserts that the `Vary` header is absent from the response.\nThis method is useful for ensuring that the application correctly handles caching based on specific request headers."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_vary_cookie",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 513,
            "end_line_number": 571,
            "source_code": "def test_session_vary_cookie(app, client):\n    @app.route(\"/set\")\n    def set_session():\n        flask.session[\"test\"] = \"test\"\n        return \"\"\n\n    @app.route(\"/get\")\n    def get():\n        return flask.session.get(\"test\")\n\n    @app.route(\"/getitem\")\n    def getitem():\n        return flask.session[\"test\"]\n\n    @app.route(\"/setdefault\")\n    def setdefault():\n        return flask.session.setdefault(\"test\", \"default\")\n\n    @app.route(\"/clear\")\n    def clear():\n        flask.session.clear()\n        return \"\"\n\n    @app.route(\"/vary-cookie-header-set\")\n    def vary_cookie_header_set():\n        response = flask.Response()\n        response.vary.add(\"Cookie\")\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/vary-header-set\")\n    def vary_header_set():\n        response = flask.Response()\n        response.vary.update((\"Accept-Encoding\", \"Accept-Language\"))\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/no-vary-header\")\n    def no_vary_header():\n        return \"\"\n\n    def expect(path, header_value=\"Cookie\"):\n        rv = client.get(path)\n\n        if header_value:\n            # The 'Vary' key should exist in the headers only once.\n            assert len(rv.headers.get_all(\"Vary\")) == 1\n            assert rv.headers[\"Vary\"] == header_value\n        else:\n            assert \"Vary\" not in rv.headers\n\n    expect(\"/set\")\n    expect(\"/get\")\n    expect(\"/getitem\")\n    expect(\"/setdefault\")\n    expect(\"/clear\")\n    expect(\"/vary-cookie-header-set\")\n    expect(\"/vary-header-set\", \"Accept-Encoding, Accept-Language, Cookie\")\n    expect(\"/no-vary-header\", None)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert len(rv.headers.get_all('Vary')) == 1",
                "assert rv.headers['Vary'] == header_value",
                "assert 'Vary' not in rv.headers"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "expect",
                    "body": "def expect(path, header_value='Cookie'):\n    rv = client.get(path)\n    if header_value:\n        assert len(rv.headers.get_all('Vary')) == 1\n        assert rv.headers['Vary'] == header_value\n    else:\n        assert 'Vary' not in rv.headers",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `expect` method is designed to verify the presence and correctness of the `Vary` HTTP header in the response from a Flask application. It checks whether the header is set to a specified value or not present at all, depending on the input parameters.\n\n**How It Works**:\n1. The method takes two parameters: `path`, which is the URL endpoint to be tested, and `header_value`, which defaults to `'Cookie'`.\n2. It sends a GET request to the specified `path` using a test client.\n3. If `header_value` is provided, it asserts that the `Vary` header exists and matches the expected value. Specifically, it checks that there is exactly one entry in the `Vary` header.\n4. If `header_value` is not provided (i.e., it is `None`), it asserts that the `Vary` header is absent from the response.\nThis method is useful for ensuring that the application correctly handles caching and content negotiation based on the specified headers."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_vary_cookie",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 513,
            "end_line_number": 571,
            "source_code": "def test_session_vary_cookie(app, client):\n    @app.route(\"/set\")\n    def set_session():\n        flask.session[\"test\"] = \"test\"\n        return \"\"\n\n    @app.route(\"/get\")\n    def get():\n        return flask.session.get(\"test\")\n\n    @app.route(\"/getitem\")\n    def getitem():\n        return flask.session[\"test\"]\n\n    @app.route(\"/setdefault\")\n    def setdefault():\n        return flask.session.setdefault(\"test\", \"default\")\n\n    @app.route(\"/clear\")\n    def clear():\n        flask.session.clear()\n        return \"\"\n\n    @app.route(\"/vary-cookie-header-set\")\n    def vary_cookie_header_set():\n        response = flask.Response()\n        response.vary.add(\"Cookie\")\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/vary-header-set\")\n    def vary_header_set():\n        response = flask.Response()\n        response.vary.update((\"Accept-Encoding\", \"Accept-Language\"))\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/no-vary-header\")\n    def no_vary_header():\n        return \"\"\n\n    def expect(path, header_value=\"Cookie\"):\n        rv = client.get(path)\n\n        if header_value:\n            # The 'Vary' key should exist in the headers only once.\n            assert len(rv.headers.get_all(\"Vary\")) == 1\n            assert rv.headers[\"Vary\"] == header_value\n        else:\n            assert \"Vary\" not in rv.headers\n\n    expect(\"/set\")\n    expect(\"/get\")\n    expect(\"/getitem\")\n    expect(\"/setdefault\")\n    expect(\"/clear\")\n    expect(\"/vary-cookie-header-set\")\n    expect(\"/vary-header-set\", \"Accept-Encoding, Accept-Language, Cookie\")\n    expect(\"/no-vary-header\", None)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert len(rv.headers.get_all('Vary')) == 1",
                "assert rv.headers['Vary'] == header_value",
                "assert 'Vary' not in rv.headers"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "expect",
                    "body": "def expect(path, header_value='Cookie'):\n    rv = client.get(path)\n    if header_value:\n        assert len(rv.headers.get_all('Vary')) == 1\n        assert rv.headers['Vary'] == header_value\n    else:\n        assert 'Vary' not in rv.headers",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `expect` method is designed to verify the presence and correctness of the `Vary` header in the HTTP response returned by a Flask application. It checks whether the response varies based on a specified header value, which is typically used for caching purposes.\n\n**How It Works**:\n1. The method takes two parameters: `path`, which is the URL endpoint to be tested, and `header_value`, which defaults to `'Cookie'`.\n2. It sends a GET request to the specified `path` using a test client.\n3. If `header_value` is provided, it asserts that the `Vary` header is present and contains exactly one value that matches `header_value`.\n4. If `header_value` is not provided, it asserts that the `Vary` header is absent from the response.\nThis method is useful for ensuring that the application correctly handles caching based on specific request headers."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_vary_cookie",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 513,
            "end_line_number": 571,
            "source_code": "def test_session_vary_cookie(app, client):\n    @app.route(\"/set\")\n    def set_session():\n        flask.session[\"test\"] = \"test\"\n        return \"\"\n\n    @app.route(\"/get\")\n    def get():\n        return flask.session.get(\"test\")\n\n    @app.route(\"/getitem\")\n    def getitem():\n        return flask.session[\"test\"]\n\n    @app.route(\"/setdefault\")\n    def setdefault():\n        return flask.session.setdefault(\"test\", \"default\")\n\n    @app.route(\"/clear\")\n    def clear():\n        flask.session.clear()\n        return \"\"\n\n    @app.route(\"/vary-cookie-header-set\")\n    def vary_cookie_header_set():\n        response = flask.Response()\n        response.vary.add(\"Cookie\")\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/vary-header-set\")\n    def vary_header_set():\n        response = flask.Response()\n        response.vary.update((\"Accept-Encoding\", \"Accept-Language\"))\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/no-vary-header\")\n    def no_vary_header():\n        return \"\"\n\n    def expect(path, header_value=\"Cookie\"):\n        rv = client.get(path)\n\n        if header_value:\n            # The 'Vary' key should exist in the headers only once.\n            assert len(rv.headers.get_all(\"Vary\")) == 1\n            assert rv.headers[\"Vary\"] == header_value\n        else:\n            assert \"Vary\" not in rv.headers\n\n    expect(\"/set\")\n    expect(\"/get\")\n    expect(\"/getitem\")\n    expect(\"/setdefault\")\n    expect(\"/clear\")\n    expect(\"/vary-cookie-header-set\")\n    expect(\"/vary-header-set\", \"Accept-Encoding, Accept-Language, Cookie\")\n    expect(\"/no-vary-header\", None)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert len(rv.headers.get_all('Vary')) == 1",
                "assert rv.headers['Vary'] == header_value",
                "assert 'Vary' not in rv.headers"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "response.vary.add",
                    "body": "def add(self, app):\n    self.count += 1",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `response.vary.add` method is designed to increment a counter that tracks the number of times a specific application (or variation) has been added to the response's Vary header. This is useful for managing caching behavior based on different request variations.\n\n**How It Works**:  \nWhen the `add` method is called with an application (or variation) as an argument, it increases the `count` attribute by 1. This count can be used to determine how many variations have been added, which can influence how responses are cached and served based on different request headers. The method is likely part of a larger mechanism that manages response headers to ensure proper caching and content negotiation."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_vary_cookie",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 513,
            "end_line_number": 571,
            "source_code": "def test_session_vary_cookie(app, client):\n    @app.route(\"/set\")\n    def set_session():\n        flask.session[\"test\"] = \"test\"\n        return \"\"\n\n    @app.route(\"/get\")\n    def get():\n        return flask.session.get(\"test\")\n\n    @app.route(\"/getitem\")\n    def getitem():\n        return flask.session[\"test\"]\n\n    @app.route(\"/setdefault\")\n    def setdefault():\n        return flask.session.setdefault(\"test\", \"default\")\n\n    @app.route(\"/clear\")\n    def clear():\n        flask.session.clear()\n        return \"\"\n\n    @app.route(\"/vary-cookie-header-set\")\n    def vary_cookie_header_set():\n        response = flask.Response()\n        response.vary.add(\"Cookie\")\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/vary-header-set\")\n    def vary_header_set():\n        response = flask.Response()\n        response.vary.update((\"Accept-Encoding\", \"Accept-Language\"))\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/no-vary-header\")\n    def no_vary_header():\n        return \"\"\n\n    def expect(path, header_value=\"Cookie\"):\n        rv = client.get(path)\n\n        if header_value:\n            # The 'Vary' key should exist in the headers only once.\n            assert len(rv.headers.get_all(\"Vary\")) == 1\n            assert rv.headers[\"Vary\"] == header_value\n        else:\n            assert \"Vary\" not in rv.headers\n\n    expect(\"/set\")\n    expect(\"/get\")\n    expect(\"/getitem\")\n    expect(\"/setdefault\")\n    expect(\"/clear\")\n    expect(\"/vary-cookie-header-set\")\n    expect(\"/vary-header-set\", \"Accept-Encoding, Accept-Language, Cookie\")\n    expect(\"/no-vary-header\", None)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert len(rv.headers.get_all('Vary')) == 1",
                "assert rv.headers['Vary'] == header_value",
                "assert 'Vary' not in rv.headers"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_refresh_vary",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 574,
            "end_line_number": 588,
            "source_code": "def test_session_refresh_vary(app, client):\n    @app.get(\"/login\")\n    def login():\n        flask.session[\"user_id\"] = 1\n        flask.session.permanent = True\n        return \"\"\n\n    @app.get(\"/ignored\")\n    def ignored():\n        return \"\"\n\n    rv = client.get(\"/login\")\n    assert rv.headers[\"Vary\"] == \"Cookie\"\n    rv = client.get(\"/ignored\")\n    assert rv.headers[\"Vary\"] == \"Cookie\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.headers['Vary'] == 'Cookie'",
                "assert rv.headers['Vary'] == 'Cookie'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "app.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `app.get` method is used to define a route in a Flask web application that responds to HTTP GET requests. Specifically, the route `/get` retrieves a value from the session, returning it to the client.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` attempts to retrieve the value associated with the key `'value'` from the session. If the key does not exist, it defaults to returning the string `'None'`. The retrieved value is then returned as the response to the client. This method leverages Flask's session management to store and retrieve user-specific data across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_refresh_vary",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 574,
            "end_line_number": 588,
            "source_code": "def test_session_refresh_vary(app, client):\n    @app.get(\"/login\")\n    def login():\n        flask.session[\"user_id\"] = 1\n        flask.session.permanent = True\n        return \"\"\n\n    @app.get(\"/ignored\")\n    def ignored():\n        return \"\"\n\n    rv = client.get(\"/login\")\n    assert rv.headers[\"Vary\"] == \"Cookie\"\n    rv = client.get(\"/ignored\")\n    assert rv.headers[\"Vary\"] == \"Cookie\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.headers['Vary'] == 'Cookie'",
                "assert rv.headers['Vary'] == 'Cookie'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "app.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `app.get` method is used to define a route in a Flask web application that responds to HTTP GET requests. Specifically, it maps the URL path `/get` to the `get` function, which retrieves a value from the session.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, it attempts to retrieve the value associated with the key `'value'` from the Flask session. If the key does not exist, it defaults to returning the string `'None'`. The retrieved value is then returned as the response to the client. This method leverages Flask's session management to store and retrieve user-specific data across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_refresh_vary",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 574,
            "end_line_number": 588,
            "source_code": "def test_session_refresh_vary(app, client):\n    @app.get(\"/login\")\n    def login():\n        flask.session[\"user_id\"] = 1\n        flask.session.permanent = True\n        return \"\"\n\n    @app.get(\"/ignored\")\n    def ignored():\n        return \"\"\n\n    rv = client.get(\"/login\")\n    assert rv.headers[\"Vary\"] == \"Cookie\"\n    rv = client.get(\"/ignored\")\n    assert rv.headers[\"Vary\"] == \"Cookie\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.headers['Vary'] == 'Cookie'",
                "assert rv.headers['Vary'] == 'Cookie'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it as a response.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` attempts to fetch the value stored in the session under the key `'value'`. If this key does not exist, it defaults to returning the string `'None'`. The retrieved value is then returned as the HTTP response. This method relies on Flask's session management to store and retrieve user-specific data across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_session_refresh_vary",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 574,
            "end_line_number": 588,
            "source_code": "def test_session_refresh_vary(app, client):\n    @app.get(\"/login\")\n    def login():\n        flask.session[\"user_id\"] = 1\n        flask.session.permanent = True\n        return \"\"\n\n    @app.get(\"/ignored\")\n    def ignored():\n        return \"\"\n\n    rv = client.get(\"/login\")\n    assert rv.headers[\"Vary\"] == \"Cookie\"\n    rv = client.get(\"/ignored\")\n    assert rv.headers[\"Vary\"] == \"Cookie\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.headers['Vary'] == 'Cookie'",
                "assert rv.headers['Vary'] == 'Cookie'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. Finally, the retrieved value is returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_extended_flashing",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 600,
            "end_line_number": 678,
            "source_code": "def test_extended_flashing(app):\n    # Be sure app.testing=True below, else tests can fail silently.\n    #\n    # Specifically, if app.testing is not set to True, the AssertionErrors\n    # in the view functions will cause a 500 response to the test client\n    # instead of propagating exceptions.\n\n    @app.route(\"/\")\n    def index():\n        flask.flash(\"Hello World\")\n        flask.flash(\"Hello World\", \"error\")\n        flask.flash(Markup(\"<em>Testing</em>\"), \"warning\")\n        return \"\"\n\n    @app.route(\"/test/\")\n    def test():\n        messages = flask.get_flashed_messages()\n        assert list(messages) == [\n            \"Hello World\",\n            \"Hello World\",\n            Markup(\"<em>Testing</em>\"),\n        ]\n        return \"\"\n\n    @app.route(\"/test_with_categories/\")\n    def test_with_categories():\n        messages = flask.get_flashed_messages(with_categories=True)\n        assert len(messages) == 3\n        assert list(messages) == [\n            (\"message\", \"Hello World\"),\n            (\"error\", \"Hello World\"),\n            (\"warning\", Markup(\"<em>Testing</em>\")),\n        ]\n        return \"\"\n\n    @app.route(\"/test_filter/\")\n    def test_filter():\n        messages = flask.get_flashed_messages(\n            category_filter=[\"message\"], with_categories=True\n        )\n        assert list(messages) == [(\"message\", \"Hello World\")]\n        return \"\"\n\n    @app.route(\"/test_filters/\")\n    def test_filters():\n        messages = flask.get_flashed_messages(\n            category_filter=[\"message\", \"warning\"], with_categories=True\n        )\n        assert list(messages) == [\n            (\"message\", \"Hello World\"),\n            (\"warning\", Markup(\"<em>Testing</em>\")),\n        ]\n        return \"\"\n\n    @app.route(\"/test_filters_without_returning_categories/\")\n    def test_filters2():\n        messages = flask.get_flashed_messages(category_filter=[\"message\", \"warning\"])\n        assert len(messages) == 2\n        assert messages[0] == \"Hello World\"\n        assert messages[1] == Markup(\"<em>Testing</em>\")\n        return \"\"\n\n    # Create new test client on each test to clean flashed messages.\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_with_categories/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filter/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filters/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filters_without_returning_categories/\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert list(messages) == ['Hello World', 'Hello World', Markup('<em>Testing</em>')]",
                "assert len(messages) == 3",
                "assert list(messages) == [('message', 'Hello World'), ('error', 'Hello World'), ('warning', Markup('<em>Testing</em>'))]",
                "assert list(messages) == [('message', 'Hello World')]",
                "assert list(messages) == [('message', 'Hello World'), ('warning', Markup('<em>Testing</em>'))]",
                "assert len(messages) == 2",
                "assert messages[0] == 'Hello World'",
                "assert messages[1] == Markup('<em>Testing</em>')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it as a response.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` attempts to fetch the value stored in the session under the key `'value'`. If this key does not exist, it defaults to returning the string `'None'`. The retrieved value is then returned as the HTTP response. This method is useful for accessing session data in a web application context."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_extended_flashing",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 600,
            "end_line_number": 678,
            "source_code": "def test_extended_flashing(app):\n    # Be sure app.testing=True below, else tests can fail silently.\n    #\n    # Specifically, if app.testing is not set to True, the AssertionErrors\n    # in the view functions will cause a 500 response to the test client\n    # instead of propagating exceptions.\n\n    @app.route(\"/\")\n    def index():\n        flask.flash(\"Hello World\")\n        flask.flash(\"Hello World\", \"error\")\n        flask.flash(Markup(\"<em>Testing</em>\"), \"warning\")\n        return \"\"\n\n    @app.route(\"/test/\")\n    def test():\n        messages = flask.get_flashed_messages()\n        assert list(messages) == [\n            \"Hello World\",\n            \"Hello World\",\n            Markup(\"<em>Testing</em>\"),\n        ]\n        return \"\"\n\n    @app.route(\"/test_with_categories/\")\n    def test_with_categories():\n        messages = flask.get_flashed_messages(with_categories=True)\n        assert len(messages) == 3\n        assert list(messages) == [\n            (\"message\", \"Hello World\"),\n            (\"error\", \"Hello World\"),\n            (\"warning\", Markup(\"<em>Testing</em>\")),\n        ]\n        return \"\"\n\n    @app.route(\"/test_filter/\")\n    def test_filter():\n        messages = flask.get_flashed_messages(\n            category_filter=[\"message\"], with_categories=True\n        )\n        assert list(messages) == [(\"message\", \"Hello World\")]\n        return \"\"\n\n    @app.route(\"/test_filters/\")\n    def test_filters():\n        messages = flask.get_flashed_messages(\n            category_filter=[\"message\", \"warning\"], with_categories=True\n        )\n        assert list(messages) == [\n            (\"message\", \"Hello World\"),\n            (\"warning\", Markup(\"<em>Testing</em>\")),\n        ]\n        return \"\"\n\n    @app.route(\"/test_filters_without_returning_categories/\")\n    def test_filters2():\n        messages = flask.get_flashed_messages(category_filter=[\"message\", \"warning\"])\n        assert len(messages) == 2\n        assert messages[0] == \"Hello World\"\n        assert messages[1] == Markup(\"<em>Testing</em>\")\n        return \"\"\n\n    # Create new test client on each test to clean flashed messages.\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_with_categories/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filter/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filters/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filters_without_returning_categories/\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert list(messages) == ['Hello World', 'Hello World', Markup('<em>Testing</em>')]",
                "assert len(messages) == 3",
                "assert list(messages) == [('message', 'Hello World'), ('error', 'Hello World'), ('warning', Markup('<em>Testing</em>'))]",
                "assert list(messages) == [('message', 'Hello World')]",
                "assert list(messages) == [('message', 'Hello World'), ('warning', Markup('<em>Testing</em>'))]",
                "assert len(messages) == 2",
                "assert messages[0] == 'Hello World'",
                "assert messages[1] == Markup('<em>Testing</em>')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. Finally, the retrieved value is returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_extended_flashing",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 600,
            "end_line_number": 678,
            "source_code": "def test_extended_flashing(app):\n    # Be sure app.testing=True below, else tests can fail silently.\n    #\n    # Specifically, if app.testing is not set to True, the AssertionErrors\n    # in the view functions will cause a 500 response to the test client\n    # instead of propagating exceptions.\n\n    @app.route(\"/\")\n    def index():\n        flask.flash(\"Hello World\")\n        flask.flash(\"Hello World\", \"error\")\n        flask.flash(Markup(\"<em>Testing</em>\"), \"warning\")\n        return \"\"\n\n    @app.route(\"/test/\")\n    def test():\n        messages = flask.get_flashed_messages()\n        assert list(messages) == [\n            \"Hello World\",\n            \"Hello World\",\n            Markup(\"<em>Testing</em>\"),\n        ]\n        return \"\"\n\n    @app.route(\"/test_with_categories/\")\n    def test_with_categories():\n        messages = flask.get_flashed_messages(with_categories=True)\n        assert len(messages) == 3\n        assert list(messages) == [\n            (\"message\", \"Hello World\"),\n            (\"error\", \"Hello World\"),\n            (\"warning\", Markup(\"<em>Testing</em>\")),\n        ]\n        return \"\"\n\n    @app.route(\"/test_filter/\")\n    def test_filter():\n        messages = flask.get_flashed_messages(\n            category_filter=[\"message\"], with_categories=True\n        )\n        assert list(messages) == [(\"message\", \"Hello World\")]\n        return \"\"\n\n    @app.route(\"/test_filters/\")\n    def test_filters():\n        messages = flask.get_flashed_messages(\n            category_filter=[\"message\", \"warning\"], with_categories=True\n        )\n        assert list(messages) == [\n            (\"message\", \"Hello World\"),\n            (\"warning\", Markup(\"<em>Testing</em>\")),\n        ]\n        return \"\"\n\n    @app.route(\"/test_filters_without_returning_categories/\")\n    def test_filters2():\n        messages = flask.get_flashed_messages(category_filter=[\"message\", \"warning\"])\n        assert len(messages) == 2\n        assert messages[0] == \"Hello World\"\n        assert messages[1] == Markup(\"<em>Testing</em>\")\n        return \"\"\n\n    # Create new test client on each test to clean flashed messages.\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_with_categories/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filter/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filters/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filters_without_returning_categories/\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert list(messages) == ['Hello World', 'Hello World', Markup('<em>Testing</em>')]",
                "assert len(messages) == 3",
                "assert list(messages) == [('message', 'Hello World'), ('error', 'Hello World'), ('warning', Markup('<em>Testing</em>'))]",
                "assert list(messages) == [('message', 'Hello World')]",
                "assert list(messages) == [('message', 'Hello World'), ('warning', Markup('<em>Testing</em>'))]",
                "assert len(messages) == 2",
                "assert messages[0] == 'Hello World'",
                "assert messages[1] == Markup('<em>Testing</em>')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_extended_flashing",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 600,
            "end_line_number": 678,
            "source_code": "def test_extended_flashing(app):\n    # Be sure app.testing=True below, else tests can fail silently.\n    #\n    # Specifically, if app.testing is not set to True, the AssertionErrors\n    # in the view functions will cause a 500 response to the test client\n    # instead of propagating exceptions.\n\n    @app.route(\"/\")\n    def index():\n        flask.flash(\"Hello World\")\n        flask.flash(\"Hello World\", \"error\")\n        flask.flash(Markup(\"<em>Testing</em>\"), \"warning\")\n        return \"\"\n\n    @app.route(\"/test/\")\n    def test():\n        messages = flask.get_flashed_messages()\n        assert list(messages) == [\n            \"Hello World\",\n            \"Hello World\",\n            Markup(\"<em>Testing</em>\"),\n        ]\n        return \"\"\n\n    @app.route(\"/test_with_categories/\")\n    def test_with_categories():\n        messages = flask.get_flashed_messages(with_categories=True)\n        assert len(messages) == 3\n        assert list(messages) == [\n            (\"message\", \"Hello World\"),\n            (\"error\", \"Hello World\"),\n            (\"warning\", Markup(\"<em>Testing</em>\")),\n        ]\n        return \"\"\n\n    @app.route(\"/test_filter/\")\n    def test_filter():\n        messages = flask.get_flashed_messages(\n            category_filter=[\"message\"], with_categories=True\n        )\n        assert list(messages) == [(\"message\", \"Hello World\")]\n        return \"\"\n\n    @app.route(\"/test_filters/\")\n    def test_filters():\n        messages = flask.get_flashed_messages(\n            category_filter=[\"message\", \"warning\"], with_categories=True\n        )\n        assert list(messages) == [\n            (\"message\", \"Hello World\"),\n            (\"warning\", Markup(\"<em>Testing</em>\")),\n        ]\n        return \"\"\n\n    @app.route(\"/test_filters_without_returning_categories/\")\n    def test_filters2():\n        messages = flask.get_flashed_messages(category_filter=[\"message\", \"warning\"])\n        assert len(messages) == 2\n        assert messages[0] == \"Hello World\"\n        assert messages[1] == Markup(\"<em>Testing</em>\")\n        return \"\"\n\n    # Create new test client on each test to clean flashed messages.\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_with_categories/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filter/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filters/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filters_without_returning_categories/\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert list(messages) == ['Hello World', 'Hello World', Markup('<em>Testing</em>')]",
                "assert len(messages) == 3",
                "assert list(messages) == [('message', 'Hello World'), ('error', 'Hello World'), ('warning', Markup('<em>Testing</em>'))]",
                "assert list(messages) == [('message', 'Hello World')]",
                "assert list(messages) == [('message', 'Hello World'), ('warning', Markup('<em>Testing</em>'))]",
                "assert len(messages) == 2",
                "assert messages[0] == 'Hello World'",
                "assert messages[1] == Markup('<em>Testing</em>')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_extended_flashing",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 600,
            "end_line_number": 678,
            "source_code": "def test_extended_flashing(app):\n    # Be sure app.testing=True below, else tests can fail silently.\n    #\n    # Specifically, if app.testing is not set to True, the AssertionErrors\n    # in the view functions will cause a 500 response to the test client\n    # instead of propagating exceptions.\n\n    @app.route(\"/\")\n    def index():\n        flask.flash(\"Hello World\")\n        flask.flash(\"Hello World\", \"error\")\n        flask.flash(Markup(\"<em>Testing</em>\"), \"warning\")\n        return \"\"\n\n    @app.route(\"/test/\")\n    def test():\n        messages = flask.get_flashed_messages()\n        assert list(messages) == [\n            \"Hello World\",\n            \"Hello World\",\n            Markup(\"<em>Testing</em>\"),\n        ]\n        return \"\"\n\n    @app.route(\"/test_with_categories/\")\n    def test_with_categories():\n        messages = flask.get_flashed_messages(with_categories=True)\n        assert len(messages) == 3\n        assert list(messages) == [\n            (\"message\", \"Hello World\"),\n            (\"error\", \"Hello World\"),\n            (\"warning\", Markup(\"<em>Testing</em>\")),\n        ]\n        return \"\"\n\n    @app.route(\"/test_filter/\")\n    def test_filter():\n        messages = flask.get_flashed_messages(\n            category_filter=[\"message\"], with_categories=True\n        )\n        assert list(messages) == [(\"message\", \"Hello World\")]\n        return \"\"\n\n    @app.route(\"/test_filters/\")\n    def test_filters():\n        messages = flask.get_flashed_messages(\n            category_filter=[\"message\", \"warning\"], with_categories=True\n        )\n        assert list(messages) == [\n            (\"message\", \"Hello World\"),\n            (\"warning\", Markup(\"<em>Testing</em>\")),\n        ]\n        return \"\"\n\n    @app.route(\"/test_filters_without_returning_categories/\")\n    def test_filters2():\n        messages = flask.get_flashed_messages(category_filter=[\"message\", \"warning\"])\n        assert len(messages) == 2\n        assert messages[0] == \"Hello World\"\n        assert messages[1] == Markup(\"<em>Testing</em>\")\n        return \"\"\n\n    # Create new test client on each test to clean flashed messages.\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_with_categories/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filter/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filters/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filters_without_returning_categories/\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert list(messages) == ['Hello World', 'Hello World', Markup('<em>Testing</em>')]",
                "assert len(messages) == 3",
                "assert list(messages) == [('message', 'Hello World'), ('error', 'Hello World'), ('warning', Markup('<em>Testing</em>'))]",
                "assert list(messages) == [('message', 'Hello World')]",
                "assert list(messages) == [('message', 'Hello World'), ('warning', Markup('<em>Testing</em>'))]",
                "assert len(messages) == 2",
                "assert messages[0] == 'Hello World'",
                "assert messages[1] == Markup('<em>Testing</em>')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called, which attempts to fetch the value stored in the session under the key `'value'`. If this key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve user-specific data across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_extended_flashing",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 600,
            "end_line_number": 678,
            "source_code": "def test_extended_flashing(app):\n    # Be sure app.testing=True below, else tests can fail silently.\n    #\n    # Specifically, if app.testing is not set to True, the AssertionErrors\n    # in the view functions will cause a 500 response to the test client\n    # instead of propagating exceptions.\n\n    @app.route(\"/\")\n    def index():\n        flask.flash(\"Hello World\")\n        flask.flash(\"Hello World\", \"error\")\n        flask.flash(Markup(\"<em>Testing</em>\"), \"warning\")\n        return \"\"\n\n    @app.route(\"/test/\")\n    def test():\n        messages = flask.get_flashed_messages()\n        assert list(messages) == [\n            \"Hello World\",\n            \"Hello World\",\n            Markup(\"<em>Testing</em>\"),\n        ]\n        return \"\"\n\n    @app.route(\"/test_with_categories/\")\n    def test_with_categories():\n        messages = flask.get_flashed_messages(with_categories=True)\n        assert len(messages) == 3\n        assert list(messages) == [\n            (\"message\", \"Hello World\"),\n            (\"error\", \"Hello World\"),\n            (\"warning\", Markup(\"<em>Testing</em>\")),\n        ]\n        return \"\"\n\n    @app.route(\"/test_filter/\")\n    def test_filter():\n        messages = flask.get_flashed_messages(\n            category_filter=[\"message\"], with_categories=True\n        )\n        assert list(messages) == [(\"message\", \"Hello World\")]\n        return \"\"\n\n    @app.route(\"/test_filters/\")\n    def test_filters():\n        messages = flask.get_flashed_messages(\n            category_filter=[\"message\", \"warning\"], with_categories=True\n        )\n        assert list(messages) == [\n            (\"message\", \"Hello World\"),\n            (\"warning\", Markup(\"<em>Testing</em>\")),\n        ]\n        return \"\"\n\n    @app.route(\"/test_filters_without_returning_categories/\")\n    def test_filters2():\n        messages = flask.get_flashed_messages(category_filter=[\"message\", \"warning\"])\n        assert len(messages) == 2\n        assert messages[0] == \"Hello World\"\n        assert messages[1] == Markup(\"<em>Testing</em>\")\n        return \"\"\n\n    # Create new test client on each test to clean flashed messages.\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_with_categories/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filter/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filters/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filters_without_returning_categories/\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert list(messages) == ['Hello World', 'Hello World', Markup('<em>Testing</em>')]",
                "assert len(messages) == 3",
                "assert list(messages) == [('message', 'Hello World'), ('error', 'Hello World'), ('warning', Markup('<em>Testing</em>'))]",
                "assert list(messages) == [('message', 'Hello World')]",
                "assert list(messages) == [('message', 'Hello World'), ('warning', Markup('<em>Testing</em>'))]",
                "assert len(messages) == 2",
                "assert messages[0] == 'Hello World'",
                "assert messages[1] == Markup('<em>Testing</em>')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, returning it to the client.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. It uses `flask.session.get` to attempt to retrieve the value associated with the key `'value'` from the session. If the key does not exist, it defaults to returning the string `'None'`. The retrieved value is then sent back as the response to the client. This method is useful for accessing session data in a web application context."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_extended_flashing",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 600,
            "end_line_number": 678,
            "source_code": "def test_extended_flashing(app):\n    # Be sure app.testing=True below, else tests can fail silently.\n    #\n    # Specifically, if app.testing is not set to True, the AssertionErrors\n    # in the view functions will cause a 500 response to the test client\n    # instead of propagating exceptions.\n\n    @app.route(\"/\")\n    def index():\n        flask.flash(\"Hello World\")\n        flask.flash(\"Hello World\", \"error\")\n        flask.flash(Markup(\"<em>Testing</em>\"), \"warning\")\n        return \"\"\n\n    @app.route(\"/test/\")\n    def test():\n        messages = flask.get_flashed_messages()\n        assert list(messages) == [\n            \"Hello World\",\n            \"Hello World\",\n            Markup(\"<em>Testing</em>\"),\n        ]\n        return \"\"\n\n    @app.route(\"/test_with_categories/\")\n    def test_with_categories():\n        messages = flask.get_flashed_messages(with_categories=True)\n        assert len(messages) == 3\n        assert list(messages) == [\n            (\"message\", \"Hello World\"),\n            (\"error\", \"Hello World\"),\n            (\"warning\", Markup(\"<em>Testing</em>\")),\n        ]\n        return \"\"\n\n    @app.route(\"/test_filter/\")\n    def test_filter():\n        messages = flask.get_flashed_messages(\n            category_filter=[\"message\"], with_categories=True\n        )\n        assert list(messages) == [(\"message\", \"Hello World\")]\n        return \"\"\n\n    @app.route(\"/test_filters/\")\n    def test_filters():\n        messages = flask.get_flashed_messages(\n            category_filter=[\"message\", \"warning\"], with_categories=True\n        )\n        assert list(messages) == [\n            (\"message\", \"Hello World\"),\n            (\"warning\", Markup(\"<em>Testing</em>\")),\n        ]\n        return \"\"\n\n    @app.route(\"/test_filters_without_returning_categories/\")\n    def test_filters2():\n        messages = flask.get_flashed_messages(category_filter=[\"message\", \"warning\"])\n        assert len(messages) == 2\n        assert messages[0] == \"Hello World\"\n        assert messages[1] == Markup(\"<em>Testing</em>\")\n        return \"\"\n\n    # Create new test client on each test to clean flashed messages.\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_with_categories/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filter/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filters/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filters_without_returning_categories/\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert list(messages) == ['Hello World', 'Hello World', Markup('<em>Testing</em>')]",
                "assert len(messages) == 3",
                "assert list(messages) == [('message', 'Hello World'), ('error', 'Hello World'), ('warning', Markup('<em>Testing</em>'))]",
                "assert list(messages) == [('message', 'Hello World')]",
                "assert list(messages) == [('message', 'Hello World'), ('warning', Markup('<em>Testing</em>'))]",
                "assert len(messages) == 2",
                "assert messages[0] == 'Hello World'",
                "assert messages[1] == Markup('<em>Testing</em>')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_extended_flashing",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 600,
            "end_line_number": 678,
            "source_code": "def test_extended_flashing(app):\n    # Be sure app.testing=True below, else tests can fail silently.\n    #\n    # Specifically, if app.testing is not set to True, the AssertionErrors\n    # in the view functions will cause a 500 response to the test client\n    # instead of propagating exceptions.\n\n    @app.route(\"/\")\n    def index():\n        flask.flash(\"Hello World\")\n        flask.flash(\"Hello World\", \"error\")\n        flask.flash(Markup(\"<em>Testing</em>\"), \"warning\")\n        return \"\"\n\n    @app.route(\"/test/\")\n    def test():\n        messages = flask.get_flashed_messages()\n        assert list(messages) == [\n            \"Hello World\",\n            \"Hello World\",\n            Markup(\"<em>Testing</em>\"),\n        ]\n        return \"\"\n\n    @app.route(\"/test_with_categories/\")\n    def test_with_categories():\n        messages = flask.get_flashed_messages(with_categories=True)\n        assert len(messages) == 3\n        assert list(messages) == [\n            (\"message\", \"Hello World\"),\n            (\"error\", \"Hello World\"),\n            (\"warning\", Markup(\"<em>Testing</em>\")),\n        ]\n        return \"\"\n\n    @app.route(\"/test_filter/\")\n    def test_filter():\n        messages = flask.get_flashed_messages(\n            category_filter=[\"message\"], with_categories=True\n        )\n        assert list(messages) == [(\"message\", \"Hello World\")]\n        return \"\"\n\n    @app.route(\"/test_filters/\")\n    def test_filters():\n        messages = flask.get_flashed_messages(\n            category_filter=[\"message\", \"warning\"], with_categories=True\n        )\n        assert list(messages) == [\n            (\"message\", \"Hello World\"),\n            (\"warning\", Markup(\"<em>Testing</em>\")),\n        ]\n        return \"\"\n\n    @app.route(\"/test_filters_without_returning_categories/\")\n    def test_filters2():\n        messages = flask.get_flashed_messages(category_filter=[\"message\", \"warning\"])\n        assert len(messages) == 2\n        assert messages[0] == \"Hello World\"\n        assert messages[1] == Markup(\"<em>Testing</em>\")\n        return \"\"\n\n    # Create new test client on each test to clean flashed messages.\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_with_categories/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filter/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filters/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filters_without_returning_categories/\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert list(messages) == ['Hello World', 'Hello World', Markup('<em>Testing</em>')]",
                "assert len(messages) == 3",
                "assert list(messages) == [('message', 'Hello World'), ('error', 'Hello World'), ('warning', Markup('<em>Testing</em>'))]",
                "assert list(messages) == [('message', 'Hello World')]",
                "assert list(messages) == [('message', 'Hello World'), ('warning', Markup('<em>Testing</em>'))]",
                "assert len(messages) == 2",
                "assert messages[0] == 'Hello World'",
                "assert messages[1] == Markup('<em>Testing</em>')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it as a response.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` attempts to fetch the value stored in the session under the key `'value'`. If this key does not exist, it defaults to returning the string `'None'`. The retrieved value is then returned as the HTTP response. This method relies on Flask's session management to store and retrieve user-specific data across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_request_processing",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 681,
            "end_line_number": 703,
            "source_code": "def test_request_processing(app, client):\n    evts = []\n\n    @app.before_request\n    def before_request():\n        evts.append(\"before\")\n\n    @app.after_request\n    def after_request(response):\n        response.data += b\"|after\"\n        evts.append(\"after\")\n        return response\n\n    @app.route(\"/\")\n    def index():\n        assert \"before\" in evts\n        assert \"after\" not in evts\n        return \"request\"\n\n    assert \"after\" not in evts\n    rv = client.get(\"/\").data\n    assert \"after\" in evts\n    assert rv == b\"request|after\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'after' not in evts",
                "assert 'after' in evts",
                "assert rv == b'request|after'",
                "assert 'before' in evts",
                "assert 'after' not in evts"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, defaulting to `'None'` if the key `'value'` does not exist.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. It uses `flask.session.get` to access the session data, specifically looking for the key `'value'`. If this key is found, its associated value is returned; if not, the string `'None'` is returned. This method is useful for retrieving session-specific data in a web application context."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_request_preprocessing_early_return",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 706,
            "end_line_number": 730,
            "source_code": "def test_request_preprocessing_early_return(app, client):\n    evts = []\n\n    @app.before_request\n    def before_request1():\n        evts.append(1)\n\n    @app.before_request\n    def before_request2():\n        evts.append(2)\n        return \"hello\"\n\n    @app.before_request\n    def before_request3():\n        evts.append(3)\n        return \"bye\"\n\n    @app.route(\"/\")\n    def index():\n        evts.append(\"index\")\n        return \"damnit\"\n\n    rv = client.get(\"/\").data.strip()\n    assert rv == b\"hello\"\n    assert evts == [1, 2]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv == b'hello'",
                "assert evts == [1, 2]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it as a response.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` attempts to fetch the value stored in the session under the key `'value'`. If this key does not exist, it defaults to returning the string `'None'`. The retrieved value is then returned as the HTTP response. This method relies on Flask's session management to store and retrieve user-specific data across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_after_request_processing",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 733,
            "end_line_number": 745,
            "source_code": "def test_after_request_processing(app, client):\n    @app.route(\"/\")\n    def index():\n        @flask.after_this_request\n        def foo(response):\n            response.headers[\"X-Foo\"] = \"a header\"\n            return response\n\n        return \"Test\"\n\n    resp = client.get(\"/\")\n    assert resp.status_code == 200\n    assert resp.headers[\"X-Foo\"] == \"a header\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert resp.status_code == 200",
                "assert resp.headers['X-Foo'] == 'a header'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_teardown_request_handler",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 748,
            "end_line_number": 763,
            "source_code": "def test_teardown_request_handler(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_request(exc):\n        called.append(True)\n        return \"Ignored\"\n\n    @app.route(\"/\")\n    def root():\n        return \"Response\"\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 200\n    assert b\"Response\" in rv.data\n    assert len(called) == 1",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.status_code == 200",
                "assert b'Response' in rv.data",
                "assert len(called) == 1"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_teardown_request_handler_debug_mode",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 766,
            "end_line_number": 781,
            "source_code": "def test_teardown_request_handler_debug_mode(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_request(exc):\n        called.append(True)\n        return \"Ignored\"\n\n    @app.route(\"/\")\n    def root():\n        return \"Response\"\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 200\n    assert b\"Response\" in rv.data\n    assert len(called) == 1",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.status_code == 200",
                "assert b'Response' in rv.data",
                "assert len(called) == 1"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_teardown_request_handler_error",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 784,
            "end_line_number": 819,
            "source_code": "def test_teardown_request_handler_error(app, client):\n    called = []\n    app.testing = False\n\n    @app.teardown_request\n    def teardown_request1(exc):\n        assert type(exc) is ZeroDivisionError\n        called.append(True)\n        # This raises a new error and blows away sys.exc_info(), so we can\n        # test that all teardown_requests get passed the same original\n        # exception.\n        try:\n            raise TypeError()\n        except Exception:\n            pass\n\n    @app.teardown_request\n    def teardown_request2(exc):\n        assert type(exc) is ZeroDivisionError\n        called.append(True)\n        # This raises a new error and blows away sys.exc_info(), so we can\n        # test that all teardown_requests get passed the same original\n        # exception.\n        try:\n            raise TypeError()\n        except Exception:\n            pass\n\n    @app.route(\"/\")\n    def fails():\n        raise ZeroDivisionError\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 500\n    assert b\"Internal Server Error\" in rv.data\n    assert len(called) == 2",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.status_code == 500",
                "assert b'Internal Server Error' in rv.data",
                "assert len(called) == 2",
                "assert type(exc) is ZeroDivisionError",
                "assert type(exc) is ZeroDivisionError"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_before_after_request_order",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 822,
            "end_line_number": 857,
            "source_code": "def test_before_after_request_order(app, client):\n    called = []\n\n    @app.before_request\n    def before1():\n        called.append(1)\n\n    @app.before_request\n    def before2():\n        called.append(2)\n\n    @app.after_request\n    def after1(response):\n        called.append(4)\n        return response\n\n    @app.after_request\n    def after2(response):\n        called.append(3)\n        return response\n\n    @app.teardown_request\n    def finish1(exc):\n        called.append(6)\n\n    @app.teardown_request\n    def finish2(exc):\n        called.append(5)\n\n    @app.route(\"/\")\n    def index():\n        return \"42\"\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"42\"\n    assert called == [1, 2, 3, 4, 5, 6]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'42'",
                "assert called == [1, 2, 3, 4, 5, 6]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_error_handling",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 860,
            "end_line_number": 895,
            "source_code": "def test_error_handling(app, client):\n    app.testing = False\n\n    @app.errorhandler(404)\n    def not_found(e):\n        return \"not found\", 404\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"internal server error\", 500\n\n    @app.errorhandler(Forbidden)\n    def forbidden(e):\n        return \"forbidden\", 403\n\n    @app.route(\"/\")\n    def index():\n        flask.abort(404)\n\n    @app.route(\"/error\")\n    def error():\n        raise ZeroDivisionError\n\n    @app.route(\"/forbidden\")\n    def error2():\n        flask.abort(403)\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 404\n    assert rv.data == b\"not found\"\n    rv = client.get(\"/error\")\n    assert rv.status_code == 500\n    assert b\"internal server error\" == rv.data\n    rv = client.get(\"/forbidden\")\n    assert rv.status_code == 403\n    assert b\"forbidden\" == rv.data",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.status_code == 404",
                "assert rv.data == b'not found'",
                "assert rv.status_code == 500",
                "assert b'internal server error' == rv.data",
                "assert rv.status_code == 403",
                "assert b'forbidden' == rv.data"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_error_handling",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 860,
            "end_line_number": 895,
            "source_code": "def test_error_handling(app, client):\n    app.testing = False\n\n    @app.errorhandler(404)\n    def not_found(e):\n        return \"not found\", 404\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"internal server error\", 500\n\n    @app.errorhandler(Forbidden)\n    def forbidden(e):\n        return \"forbidden\", 403\n\n    @app.route(\"/\")\n    def index():\n        flask.abort(404)\n\n    @app.route(\"/error\")\n    def error():\n        raise ZeroDivisionError\n\n    @app.route(\"/forbidden\")\n    def error2():\n        flask.abort(403)\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 404\n    assert rv.data == b\"not found\"\n    rv = client.get(\"/error\")\n    assert rv.status_code == 500\n    assert b\"internal server error\" == rv.data\n    rv = client.get(\"/forbidden\")\n    assert rv.status_code == 403\n    assert b\"forbidden\" == rv.data",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.status_code == 404",
                "assert rv.data == b'not found'",
                "assert rv.status_code == 500",
                "assert b'internal server error' == rv.data",
                "assert rv.status_code == 403",
                "assert b'forbidden' == rv.data"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_error_handling",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 860,
            "end_line_number": 895,
            "source_code": "def test_error_handling(app, client):\n    app.testing = False\n\n    @app.errorhandler(404)\n    def not_found(e):\n        return \"not found\", 404\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"internal server error\", 500\n\n    @app.errorhandler(Forbidden)\n    def forbidden(e):\n        return \"forbidden\", 403\n\n    @app.route(\"/\")\n    def index():\n        flask.abort(404)\n\n    @app.route(\"/error\")\n    def error():\n        raise ZeroDivisionError\n\n    @app.route(\"/forbidden\")\n    def error2():\n        flask.abort(403)\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 404\n    assert rv.data == b\"not found\"\n    rv = client.get(\"/error\")\n    assert rv.status_code == 500\n    assert b\"internal server error\" == rv.data\n    rv = client.get(\"/forbidden\")\n    assert rv.status_code == 403\n    assert b\"forbidden\" == rv.data",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.status_code == 404",
                "assert rv.data == b'not found'",
                "assert rv.status_code == 500",
                "assert b'internal server error' == rv.data",
                "assert rv.status_code == 403",
                "assert b'forbidden' == rv.data"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_error_handling_processing",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 898,
            "end_line_number": 916,
            "source_code": "def test_error_handling_processing(app, client):\n    app.testing = False\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"internal server error\", 500\n\n    @app.route(\"/\")\n    def broken_func():\n        raise ZeroDivisionError\n\n    @app.after_request\n    def after_request(resp):\n        resp.mimetype = \"text/x-special\"\n        return resp\n\n    resp = client.get(\"/\")\n    assert resp.mimetype == \"text/x-special\"\n    assert resp.data == b\"internal server error\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert resp.mimetype == 'text/x-special'",
                "assert resp.data == b'internal server error'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_baseexception_error_handling",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 919,
            "end_line_number": 927,
            "source_code": "def test_baseexception_error_handling(app, client):\n    app.testing = False\n\n    @app.route(\"/\")\n    def broken_func():\n        raise KeyboardInterrupt()\n\n    with pytest.raises(KeyboardInterrupt):\n        client.get(\"/\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it as a response.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` attempts to fetch the value stored in the session under the key `'value'`. If this key does not exist, it defaults to returning the string `'None'`. The retrieved value is then returned as the HTTP response. This method relies on Flask's session management to store and retrieve user-specific data across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_before_request_and_routing_errors",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 930,
            "end_line_number": 941,
            "source_code": "def test_before_request_and_routing_errors(app, client):\n    @app.before_request\n    def attach_something():\n        flask.g.something = \"value\"\n\n    @app.errorhandler(404)\n    def return_something(error):\n        return flask.g.something, 404\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 404\n    assert rv.data == b\"value\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.status_code == 404",
                "assert rv.data == b'value'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, defaulting to `'None'` if the key `'value'` does not exist.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. It uses `flask.session.get` to access the session data, specifically looking for the key `'value'`. If this key is found, its associated value is returned; if not, the string `'None'` is returned. This method is useful for retrieving session-specific data in a web application context."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_user_error_handling",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 944,
            "end_line_number": 957,
            "source_code": "def test_user_error_handling(app, client):\n    class MyException(Exception):\n        pass\n\n    @app.errorhandler(MyException)\n    def handle_my_exception(e):\n        assert isinstance(e, MyException)\n        return \"42\"\n\n    @app.route(\"/\")\n    def index():\n        raise MyException()\n\n    assert client.get(\"/\").data == b\"42\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').data == b'42'",
                "assert isinstance(e, MyException)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. Finally, the retrieved value is returned as the response to the HTTP request. This method is useful for accessing session data in a web application context."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_http_error_subclass_handling",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 960,
            "end_line_number": 989,
            "source_code": "def test_http_error_subclass_handling(app, client):\n    class ForbiddenSubclass(Forbidden):\n        pass\n\n    @app.errorhandler(ForbiddenSubclass)\n    def handle_forbidden_subclass(e):\n        assert isinstance(e, ForbiddenSubclass)\n        return \"banana\"\n\n    @app.errorhandler(403)\n    def handle_403(e):\n        assert not isinstance(e, ForbiddenSubclass)\n        assert isinstance(e, Forbidden)\n        return \"apple\"\n\n    @app.route(\"/1\")\n    def index1():\n        raise ForbiddenSubclass()\n\n    @app.route(\"/2\")\n    def index2():\n        flask.abort(403)\n\n    @app.route(\"/3\")\n    def index3():\n        raise Forbidden()\n\n    assert client.get(\"/1\").data == b\"banana\"\n    assert client.get(\"/2\").data == b\"apple\"\n    assert client.get(\"/3\").data == b\"apple\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/1').data == b'banana'",
                "assert client.get('/2').data == b'apple'",
                "assert client.get('/3').data == b'apple'",
                "assert isinstance(e, ForbiddenSubclass)",
                "assert not isinstance(e, ForbiddenSubclass)",
                "assert isinstance(e, Forbidden)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_http_error_subclass_handling",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 960,
            "end_line_number": 989,
            "source_code": "def test_http_error_subclass_handling(app, client):\n    class ForbiddenSubclass(Forbidden):\n        pass\n\n    @app.errorhandler(ForbiddenSubclass)\n    def handle_forbidden_subclass(e):\n        assert isinstance(e, ForbiddenSubclass)\n        return \"banana\"\n\n    @app.errorhandler(403)\n    def handle_403(e):\n        assert not isinstance(e, ForbiddenSubclass)\n        assert isinstance(e, Forbidden)\n        return \"apple\"\n\n    @app.route(\"/1\")\n    def index1():\n        raise ForbiddenSubclass()\n\n    @app.route(\"/2\")\n    def index2():\n        flask.abort(403)\n\n    @app.route(\"/3\")\n    def index3():\n        raise Forbidden()\n\n    assert client.get(\"/1\").data == b\"banana\"\n    assert client.get(\"/2\").data == b\"apple\"\n    assert client.get(\"/3\").data == b\"apple\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/1').data == b'banana'",
                "assert client.get('/2').data == b'apple'",
                "assert client.get('/3').data == b'apple'",
                "assert isinstance(e, ForbiddenSubclass)",
                "assert not isinstance(e, ForbiddenSubclass)",
                "assert isinstance(e, Forbidden)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. Finally, the retrieved value is returned as the response to the HTTP request. This method is useful for accessing session data in a web application context."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_http_error_subclass_handling",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 960,
            "end_line_number": 989,
            "source_code": "def test_http_error_subclass_handling(app, client):\n    class ForbiddenSubclass(Forbidden):\n        pass\n\n    @app.errorhandler(ForbiddenSubclass)\n    def handle_forbidden_subclass(e):\n        assert isinstance(e, ForbiddenSubclass)\n        return \"banana\"\n\n    @app.errorhandler(403)\n    def handle_403(e):\n        assert not isinstance(e, ForbiddenSubclass)\n        assert isinstance(e, Forbidden)\n        return \"apple\"\n\n    @app.route(\"/1\")\n    def index1():\n        raise ForbiddenSubclass()\n\n    @app.route(\"/2\")\n    def index2():\n        flask.abort(403)\n\n    @app.route(\"/3\")\n    def index3():\n        raise Forbidden()\n\n    assert client.get(\"/1\").data == b\"banana\"\n    assert client.get(\"/2\").data == b\"apple\"\n    assert client.get(\"/3\").data == b\"apple\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/1').data == b'banana'",
                "assert client.get('/2').data == b'apple'",
                "assert client.get('/3').data == b'apple'",
                "assert isinstance(e, ForbiddenSubclass)",
                "assert not isinstance(e, ForbiddenSubclass)",
                "assert isinstance(e, Forbidden)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to define a route in a Flask web application that retrieves a value stored in the session. If the session does not contain the specified value, it returns a default value of 'None'.\n\n**How It Works**:\nThe method is decorated with `@app.route('/get')`, which maps the URL path `/get` to the `get` function. Inside the function, `flask.session.get('value', 'None')` attempts to retrieve the value associated with the key `'value'` from the session. If the key does not exist, it returns the string `'None'`. The retrieved value is then returned as the response to the HTTP request made to the `/get` endpoint. This allows clients to access session data easily through a simple GET request."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_errorhandler_precedence",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 992,
            "end_line_number": 1022,
            "source_code": "def test_errorhandler_precedence(app, client):\n    class E1(Exception):\n        pass\n\n    class E2(Exception):\n        pass\n\n    class E3(E1, E2):\n        pass\n\n    @app.errorhandler(E2)\n    def handle_e2(e):\n        return \"E2\"\n\n    @app.errorhandler(Exception)\n    def handle_exception(e):\n        return \"Exception\"\n\n    @app.route(\"/E1\")\n    def raise_e1():\n        raise E1\n\n    @app.route(\"/E3\")\n    def raise_e3():\n        raise E3\n\n    rv = client.get(\"/E1\")\n    assert rv.data == b\"Exception\"\n\n    rv = client.get(\"/E3\")\n    assert rv.data == b\"E2\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'Exception'",
                "assert rv.data == b'E2'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_errorhandler_precedence",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 992,
            "end_line_number": 1022,
            "source_code": "def test_errorhandler_precedence(app, client):\n    class E1(Exception):\n        pass\n\n    class E2(Exception):\n        pass\n\n    class E3(E1, E2):\n        pass\n\n    @app.errorhandler(E2)\n    def handle_e2(e):\n        return \"E2\"\n\n    @app.errorhandler(Exception)\n    def handle_exception(e):\n        return \"Exception\"\n\n    @app.route(\"/E1\")\n    def raise_e1():\n        raise E1\n\n    @app.route(\"/E3\")\n    def raise_e3():\n        raise E3\n\n    rv = client.get(\"/E1\")\n    assert rv.data == b\"Exception\"\n\n    rv = client.get(\"/E3\")\n    assert rv.data == b\"E2\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'Exception'",
                "assert rv.data == b'E2'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, defaulting to `'None'` if the key `'value'` does not exist.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. It uses `flask.session.get` to access the session data, specifically looking for the key `'value'`. If this key is found, its associated value is returned; otherwise, the string `'None'` is returned. This method is useful for retrieving session-specific data in a web application context."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_trap_bad_request_key_error",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1029,
            "end_line_number": 1057,
            "source_code": "def test_trap_bad_request_key_error(app, client, debug, trap, expect_key, expect_abort):\n    app.config[\"DEBUG\"] = debug\n    app.config[\"TRAP_BAD_REQUEST_ERRORS\"] = trap\n\n    @app.route(\"/key\")\n    def fail():\n        flask.request.form[\"missing_key\"]\n\n    @app.route(\"/abort\")\n    def allow_abort():\n        flask.abort(400)\n\n    if expect_key:\n        rv = client.get(\"/key\")\n        assert rv.status_code == 400\n        assert b\"missing_key\" not in rv.data\n    else:\n        with pytest.raises(KeyError) as exc_info:\n            client.get(\"/key\")\n\n        assert exc_info.errisinstance(BadRequest)\n        assert \"missing_key\" in exc_info.value.get_description()\n\n    if expect_abort:\n        rv = client.get(\"/abort\")\n        assert rv.status_code == 400\n    else:\n        with pytest.raises(BadRequest):\n            client.get(\"/abort\")",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize(('debug', 'trap', 'expect_key', 'expect_abort'), [(False, None, True, True), (True, None, False, True), (False, True, False, False)])"
            ],
            "arguments": [
                "app",
                "client",
                "debug",
                "trap",
                "expect_key",
                "expect_abort"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.status_code == 400",
                "assert b'missing_key' not in rv.data",
                "assert exc_info.errisinstance(BadRequest)",
                "assert 'missing_key' in exc_info.value.get_description()",
                "assert rv.status_code == 400"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_trap_bad_request_key_error",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1029,
            "end_line_number": 1057,
            "source_code": "def test_trap_bad_request_key_error(app, client, debug, trap, expect_key, expect_abort):\n    app.config[\"DEBUG\"] = debug\n    app.config[\"TRAP_BAD_REQUEST_ERRORS\"] = trap\n\n    @app.route(\"/key\")\n    def fail():\n        flask.request.form[\"missing_key\"]\n\n    @app.route(\"/abort\")\n    def allow_abort():\n        flask.abort(400)\n\n    if expect_key:\n        rv = client.get(\"/key\")\n        assert rv.status_code == 400\n        assert b\"missing_key\" not in rv.data\n    else:\n        with pytest.raises(KeyError) as exc_info:\n            client.get(\"/key\")\n\n        assert exc_info.errisinstance(BadRequest)\n        assert \"missing_key\" in exc_info.value.get_description()\n\n    if expect_abort:\n        rv = client.get(\"/abort\")\n        assert rv.status_code == 400\n    else:\n        with pytest.raises(BadRequest):\n            client.get(\"/abort\")",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize(('debug', 'trap', 'expect_key', 'expect_abort'), [(False, None, True, True), (True, None, False, True), (False, True, False, False)])"
            ],
            "arguments": [
                "app",
                "client",
                "debug",
                "trap",
                "expect_key",
                "expect_abort"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.status_code == 400",
                "assert b'missing_key' not in rv.data",
                "assert exc_info.errisinstance(BadRequest)",
                "assert 'missing_key' in exc_info.value.get_description()",
                "assert rv.status_code == 400"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, defaulting to `'None'` if the key `'value'` does not exist.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` route, the `get` function is invoked. It uses `flask.session.get` to access the session data, specifically looking for the key `'value'`. If this key is found, its associated value is returned; if not, the string `'None'` is returned. This method is useful for retrieving session-specific data in a web application context."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_trap_bad_request_key_error",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1029,
            "end_line_number": 1057,
            "source_code": "def test_trap_bad_request_key_error(app, client, debug, trap, expect_key, expect_abort):\n    app.config[\"DEBUG\"] = debug\n    app.config[\"TRAP_BAD_REQUEST_ERRORS\"] = trap\n\n    @app.route(\"/key\")\n    def fail():\n        flask.request.form[\"missing_key\"]\n\n    @app.route(\"/abort\")\n    def allow_abort():\n        flask.abort(400)\n\n    if expect_key:\n        rv = client.get(\"/key\")\n        assert rv.status_code == 400\n        assert b\"missing_key\" not in rv.data\n    else:\n        with pytest.raises(KeyError) as exc_info:\n            client.get(\"/key\")\n\n        assert exc_info.errisinstance(BadRequest)\n        assert \"missing_key\" in exc_info.value.get_description()\n\n    if expect_abort:\n        rv = client.get(\"/abort\")\n        assert rv.status_code == 400\n    else:\n        with pytest.raises(BadRequest):\n            client.get(\"/abort\")",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize(('debug', 'trap', 'expect_key', 'expect_abort'), [(False, None, True, True), (True, None, False, True), (False, True, False, False)])"
            ],
            "arguments": [
                "app",
                "client",
                "debug",
                "trap",
                "expect_key",
                "expect_abort"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.status_code == 400",
                "assert b'missing_key' not in rv.data",
                "assert exc_info.errisinstance(BadRequest)",
                "assert 'missing_key' in exc_info.value.get_description()",
                "assert rv.status_code == 400"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it as a response.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. It uses `flask.session.get` to attempt to retrieve the value stored under the key `'value'`. If this key does not exist in the session, it defaults to returning the string `'None'`. The retrieved value is then returned as the HTTP response. This method is useful for accessing session data in a web application context."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_trap_bad_request_key_error",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1029,
            "end_line_number": 1057,
            "source_code": "def test_trap_bad_request_key_error(app, client, debug, trap, expect_key, expect_abort):\n    app.config[\"DEBUG\"] = debug\n    app.config[\"TRAP_BAD_REQUEST_ERRORS\"] = trap\n\n    @app.route(\"/key\")\n    def fail():\n        flask.request.form[\"missing_key\"]\n\n    @app.route(\"/abort\")\n    def allow_abort():\n        flask.abort(400)\n\n    if expect_key:\n        rv = client.get(\"/key\")\n        assert rv.status_code == 400\n        assert b\"missing_key\" not in rv.data\n    else:\n        with pytest.raises(KeyError) as exc_info:\n            client.get(\"/key\")\n\n        assert exc_info.errisinstance(BadRequest)\n        assert \"missing_key\" in exc_info.value.get_description()\n\n    if expect_abort:\n        rv = client.get(\"/abort\")\n        assert rv.status_code == 400\n    else:\n        with pytest.raises(BadRequest):\n            client.get(\"/abort\")",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize(('debug', 'trap', 'expect_key', 'expect_abort'), [(False, None, True, True), (True, None, False, True), (False, True, False, False)])"
            ],
            "arguments": [
                "app",
                "client",
                "debug",
                "trap",
                "expect_key",
                "expect_abort"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.status_code == 400",
                "assert b'missing_key' not in rv.data",
                "assert exc_info.errisinstance(BadRequest)",
                "assert 'missing_key' in exc_info.value.get_description()",
                "assert rv.status_code == 400"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. Finally, the retrieved value is returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_trapping_of_all_http_exceptions",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1060,
            "end_line_number": 1068,
            "source_code": "def test_trapping_of_all_http_exceptions(app, client):\n    app.config[\"TRAP_HTTP_EXCEPTIONS\"] = True\n\n    @app.route(\"/fail\")\n    def fail():\n        flask.abort(404)\n\n    with pytest.raises(NotFound):\n        client.get(\"/fail\")",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_error_handler_after_processor_error",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1071,
            "end_line_number": 1097,
            "source_code": "def test_error_handler_after_processor_error(app, client):\n    app.testing = False\n\n    @app.before_request\n    def before_request():\n        if _trigger == \"before\":\n            raise ZeroDivisionError\n\n    @app.after_request\n    def after_request(response):\n        if _trigger == \"after\":\n            raise ZeroDivisionError\n\n        return response\n\n    @app.route(\"/\")\n    def index():\n        return \"Foo\"\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"Hello Server Error\", 500\n\n    for _trigger in \"before\", \"after\":\n        rv = client.get(\"/\")\n        assert rv.status_code == 500\n        assert rv.data == b\"Hello Server Error\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.status_code == 500",
                "assert rv.data == b'Hello Server Error'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_enctype_debug_helper",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1100,
            "end_line_number": 1112,
            "source_code": "def test_enctype_debug_helper(app, client):\n    from flask.debughelpers import DebugFilesKeyError\n\n    app.debug = True\n\n    @app.route(\"/fail\", methods=[\"POST\"])\n    def index():\n        return flask.request.files[\"foo\"].filename\n\n    with pytest.raises(DebugFilesKeyError) as e:\n        client.post(\"/fail\", data={\"foo\": \"index.txt\"})\n    assert \"no file contents were transmitted\" in str(e.value)\n    assert \"This was submitted: 'index.txt'\" in str(e.value)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'no file contents were transmitted' in str(e.value)",
                "assert \"This was submitted: 'index.txt'\" in str(e.value)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.post",
                    "body": "def post(self):\n    return 'Create'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is designed to simulate an HTTP POST request to a specified endpoint, allowing developers to send data to the server, typically for creating or updating resources.\n\n**How It Works**:\nWhen invoked, `client.post` sends a request to the server at the specified URL with the provided data. In the context of the code snippets, it is used to test various functionalities such as creating a new post, updating an existing post, and validating input data. The method returns a response indicating the result of the operation, which can be further inspected for status codes or response data. The method is part of a testing framework that helps ensure the application's endpoints behave as expected."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_response_types",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1115,
            "end_line_number": 1206,
            "source_code": "def test_response_types(app, client):\n    @app.route(\"/text\")\n    def from_text():\n        return \"H\u00e4llo W\u00f6rld\"\n\n    @app.route(\"/bytes\")\n    def from_bytes():\n        return \"H\u00e4llo W\u00f6rld\".encode()\n\n    @app.route(\"/full_tuple\")\n    def from_full_tuple():\n        return (\n            \"Meh\",\n            400,\n            {\"X-Foo\": \"Testing\", \"Content-Type\": \"text/plain; charset=utf-8\"},\n        )\n\n    @app.route(\"/text_headers\")\n    def from_text_headers():\n        return \"Hello\", {\"X-Foo\": \"Test\", \"Content-Type\": \"text/plain; charset=utf-8\"}\n\n    @app.route(\"/text_status\")\n    def from_text_status():\n        return \"Hi, status!\", 400\n\n    @app.route(\"/response_headers\")\n    def from_response_headers():\n        return (\n            flask.Response(\n                \"Hello world\", 404, {\"Content-Type\": \"text/html\", \"X-Foo\": \"Baz\"}\n            ),\n            {\"Content-Type\": \"text/plain\", \"X-Foo\": \"Bar\", \"X-Bar\": \"Foo\"},\n        )\n\n    @app.route(\"/response_status\")\n    def from_response_status():\n        return app.response_class(\"Hello world\", 400), 500\n\n    @app.route(\"/wsgi\")\n    def from_wsgi():\n        return NotFound()\n\n    @app.route(\"/dict\")\n    def from_dict():\n        return {\"foo\": \"bar\"}, 201\n\n    @app.route(\"/list\")\n    def from_list():\n        return [\"foo\", \"bar\"], 201\n\n    assert client.get(\"/text\").data == \"H\u00e4llo W\u00f6rld\".encode()\n    assert client.get(\"/bytes\").data == \"H\u00e4llo W\u00f6rld\".encode()\n\n    rv = client.get(\"/full_tuple\")\n    assert rv.data == b\"Meh\"\n    assert rv.headers[\"X-Foo\"] == \"Testing\"\n    assert rv.status_code == 400\n    assert rv.mimetype == \"text/plain\"\n\n    rv = client.get(\"/text_headers\")\n    assert rv.data == b\"Hello\"\n    assert rv.headers[\"X-Foo\"] == \"Test\"\n    assert rv.status_code == 200\n    assert rv.mimetype == \"text/plain\"\n\n    rv = client.get(\"/text_status\")\n    assert rv.data == b\"Hi, status!\"\n    assert rv.status_code == 400\n    assert rv.mimetype == \"text/html\"\n\n    rv = client.get(\"/response_headers\")\n    assert rv.data == b\"Hello world\"\n    assert rv.content_type == \"text/plain\"\n    assert rv.headers.getlist(\"X-Foo\") == [\"Bar\"]\n    assert rv.headers[\"X-Bar\"] == \"Foo\"\n    assert rv.status_code == 404\n\n    rv = client.get(\"/response_status\")\n    assert rv.data == b\"Hello world\"\n    assert rv.status_code == 500\n\n    rv = client.get(\"/wsgi\")\n    assert b\"Not Found\" in rv.data\n    assert rv.status_code == 404\n\n    rv = client.get(\"/dict\")\n    assert rv.json == {\"foo\": \"bar\"}\n    assert rv.status_code == 201\n\n    rv = client.get(\"/list\")\n    assert rv.json == [\"foo\", \"bar\"]\n    assert rv.status_code == 201",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/text').data == 'H\u00e4llo W\u00f6rld'.encode()",
                "assert client.get('/bytes').data == 'H\u00e4llo W\u00f6rld'.encode()",
                "assert rv.data == b'Meh'",
                "assert rv.headers['X-Foo'] == 'Testing'",
                "assert rv.status_code == 400",
                "assert rv.mimetype == 'text/plain'",
                "assert rv.data == b'Hello'",
                "assert rv.headers['X-Foo'] == 'Test'",
                "assert rv.status_code == 200",
                "assert rv.mimetype == 'text/plain'",
                "assert rv.data == b'Hi, status!'",
                "assert rv.status_code == 400",
                "assert rv.mimetype == 'text/html'",
                "assert rv.data == b'Hello world'",
                "assert rv.content_type == 'text/plain'",
                "assert rv.headers.getlist('X-Foo') == ['Bar']",
                "assert rv.headers['X-Bar'] == 'Foo'",
                "assert rv.status_code == 404",
                "assert rv.data == b'Hello world'",
                "assert rv.status_code == 500",
                "assert b'Not Found' in rv.data",
                "assert rv.status_code == 404",
                "assert rv.json == {'foo': 'bar'}",
                "assert rv.status_code == 201",
                "assert rv.json == ['foo', 'bar']",
                "assert rv.status_code == 201"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. Finally, the retrieved value is returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_response_types",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1115,
            "end_line_number": 1206,
            "source_code": "def test_response_types(app, client):\n    @app.route(\"/text\")\n    def from_text():\n        return \"H\u00e4llo W\u00f6rld\"\n\n    @app.route(\"/bytes\")\n    def from_bytes():\n        return \"H\u00e4llo W\u00f6rld\".encode()\n\n    @app.route(\"/full_tuple\")\n    def from_full_tuple():\n        return (\n            \"Meh\",\n            400,\n            {\"X-Foo\": \"Testing\", \"Content-Type\": \"text/plain; charset=utf-8\"},\n        )\n\n    @app.route(\"/text_headers\")\n    def from_text_headers():\n        return \"Hello\", {\"X-Foo\": \"Test\", \"Content-Type\": \"text/plain; charset=utf-8\"}\n\n    @app.route(\"/text_status\")\n    def from_text_status():\n        return \"Hi, status!\", 400\n\n    @app.route(\"/response_headers\")\n    def from_response_headers():\n        return (\n            flask.Response(\n                \"Hello world\", 404, {\"Content-Type\": \"text/html\", \"X-Foo\": \"Baz\"}\n            ),\n            {\"Content-Type\": \"text/plain\", \"X-Foo\": \"Bar\", \"X-Bar\": \"Foo\"},\n        )\n\n    @app.route(\"/response_status\")\n    def from_response_status():\n        return app.response_class(\"Hello world\", 400), 500\n\n    @app.route(\"/wsgi\")\n    def from_wsgi():\n        return NotFound()\n\n    @app.route(\"/dict\")\n    def from_dict():\n        return {\"foo\": \"bar\"}, 201\n\n    @app.route(\"/list\")\n    def from_list():\n        return [\"foo\", \"bar\"], 201\n\n    assert client.get(\"/text\").data == \"H\u00e4llo W\u00f6rld\".encode()\n    assert client.get(\"/bytes\").data == \"H\u00e4llo W\u00f6rld\".encode()\n\n    rv = client.get(\"/full_tuple\")\n    assert rv.data == b\"Meh\"\n    assert rv.headers[\"X-Foo\"] == \"Testing\"\n    assert rv.status_code == 400\n    assert rv.mimetype == \"text/plain\"\n\n    rv = client.get(\"/text_headers\")\n    assert rv.data == b\"Hello\"\n    assert rv.headers[\"X-Foo\"] == \"Test\"\n    assert rv.status_code == 200\n    assert rv.mimetype == \"text/plain\"\n\n    rv = client.get(\"/text_status\")\n    assert rv.data == b\"Hi, status!\"\n    assert rv.status_code == 400\n    assert rv.mimetype == \"text/html\"\n\n    rv = client.get(\"/response_headers\")\n    assert rv.data == b\"Hello world\"\n    assert rv.content_type == \"text/plain\"\n    assert rv.headers.getlist(\"X-Foo\") == [\"Bar\"]\n    assert rv.headers[\"X-Bar\"] == \"Foo\"\n    assert rv.status_code == 404\n\n    rv = client.get(\"/response_status\")\n    assert rv.data == b\"Hello world\"\n    assert rv.status_code == 500\n\n    rv = client.get(\"/wsgi\")\n    assert b\"Not Found\" in rv.data\n    assert rv.status_code == 404\n\n    rv = client.get(\"/dict\")\n    assert rv.json == {\"foo\": \"bar\"}\n    assert rv.status_code == 201\n\n    rv = client.get(\"/list\")\n    assert rv.json == [\"foo\", \"bar\"]\n    assert rv.status_code == 201",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/text').data == 'H\u00e4llo W\u00f6rld'.encode()",
                "assert client.get('/bytes').data == 'H\u00e4llo W\u00f6rld'.encode()",
                "assert rv.data == b'Meh'",
                "assert rv.headers['X-Foo'] == 'Testing'",
                "assert rv.status_code == 400",
                "assert rv.mimetype == 'text/plain'",
                "assert rv.data == b'Hello'",
                "assert rv.headers['X-Foo'] == 'Test'",
                "assert rv.status_code == 200",
                "assert rv.mimetype == 'text/plain'",
                "assert rv.data == b'Hi, status!'",
                "assert rv.status_code == 400",
                "assert rv.mimetype == 'text/html'",
                "assert rv.data == b'Hello world'",
                "assert rv.content_type == 'text/plain'",
                "assert rv.headers.getlist('X-Foo') == ['Bar']",
                "assert rv.headers['X-Bar'] == 'Foo'",
                "assert rv.status_code == 404",
                "assert rv.data == b'Hello world'",
                "assert rv.status_code == 500",
                "assert b'Not Found' in rv.data",
                "assert rv.status_code == 404",
                "assert rv.json == {'foo': 'bar'}",
                "assert rv.status_code == 201",
                "assert rv.json == ['foo', 'bar']",
                "assert rv.status_code == 201"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. Finally, the retrieved value is returned as the response to the HTTP request. This method is useful for accessing session data in a web application context, allowing for stateful interactions with users."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_response_types",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1115,
            "end_line_number": 1206,
            "source_code": "def test_response_types(app, client):\n    @app.route(\"/text\")\n    def from_text():\n        return \"H\u00e4llo W\u00f6rld\"\n\n    @app.route(\"/bytes\")\n    def from_bytes():\n        return \"H\u00e4llo W\u00f6rld\".encode()\n\n    @app.route(\"/full_tuple\")\n    def from_full_tuple():\n        return (\n            \"Meh\",\n            400,\n            {\"X-Foo\": \"Testing\", \"Content-Type\": \"text/plain; charset=utf-8\"},\n        )\n\n    @app.route(\"/text_headers\")\n    def from_text_headers():\n        return \"Hello\", {\"X-Foo\": \"Test\", \"Content-Type\": \"text/plain; charset=utf-8\"}\n\n    @app.route(\"/text_status\")\n    def from_text_status():\n        return \"Hi, status!\", 400\n\n    @app.route(\"/response_headers\")\n    def from_response_headers():\n        return (\n            flask.Response(\n                \"Hello world\", 404, {\"Content-Type\": \"text/html\", \"X-Foo\": \"Baz\"}\n            ),\n            {\"Content-Type\": \"text/plain\", \"X-Foo\": \"Bar\", \"X-Bar\": \"Foo\"},\n        )\n\n    @app.route(\"/response_status\")\n    def from_response_status():\n        return app.response_class(\"Hello world\", 400), 500\n\n    @app.route(\"/wsgi\")\n    def from_wsgi():\n        return NotFound()\n\n    @app.route(\"/dict\")\n    def from_dict():\n        return {\"foo\": \"bar\"}, 201\n\n    @app.route(\"/list\")\n    def from_list():\n        return [\"foo\", \"bar\"], 201\n\n    assert client.get(\"/text\").data == \"H\u00e4llo W\u00f6rld\".encode()\n    assert client.get(\"/bytes\").data == \"H\u00e4llo W\u00f6rld\".encode()\n\n    rv = client.get(\"/full_tuple\")\n    assert rv.data == b\"Meh\"\n    assert rv.headers[\"X-Foo\"] == \"Testing\"\n    assert rv.status_code == 400\n    assert rv.mimetype == \"text/plain\"\n\n    rv = client.get(\"/text_headers\")\n    assert rv.data == b\"Hello\"\n    assert rv.headers[\"X-Foo\"] == \"Test\"\n    assert rv.status_code == 200\n    assert rv.mimetype == \"text/plain\"\n\n    rv = client.get(\"/text_status\")\n    assert rv.data == b\"Hi, status!\"\n    assert rv.status_code == 400\n    assert rv.mimetype == \"text/html\"\n\n    rv = client.get(\"/response_headers\")\n    assert rv.data == b\"Hello world\"\n    assert rv.content_type == \"text/plain\"\n    assert rv.headers.getlist(\"X-Foo\") == [\"Bar\"]\n    assert rv.headers[\"X-Bar\"] == \"Foo\"\n    assert rv.status_code == 404\n\n    rv = client.get(\"/response_status\")\n    assert rv.data == b\"Hello world\"\n    assert rv.status_code == 500\n\n    rv = client.get(\"/wsgi\")\n    assert b\"Not Found\" in rv.data\n    assert rv.status_code == 404\n\n    rv = client.get(\"/dict\")\n    assert rv.json == {\"foo\": \"bar\"}\n    assert rv.status_code == 201\n\n    rv = client.get(\"/list\")\n    assert rv.json == [\"foo\", \"bar\"]\n    assert rv.status_code == 201",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/text').data == 'H\u00e4llo W\u00f6rld'.encode()",
                "assert client.get('/bytes').data == 'H\u00e4llo W\u00f6rld'.encode()",
                "assert rv.data == b'Meh'",
                "assert rv.headers['X-Foo'] == 'Testing'",
                "assert rv.status_code == 400",
                "assert rv.mimetype == 'text/plain'",
                "assert rv.data == b'Hello'",
                "assert rv.headers['X-Foo'] == 'Test'",
                "assert rv.status_code == 200",
                "assert rv.mimetype == 'text/plain'",
                "assert rv.data == b'Hi, status!'",
                "assert rv.status_code == 400",
                "assert rv.mimetype == 'text/html'",
                "assert rv.data == b'Hello world'",
                "assert rv.content_type == 'text/plain'",
                "assert rv.headers.getlist('X-Foo') == ['Bar']",
                "assert rv.headers['X-Bar'] == 'Foo'",
                "assert rv.status_code == 404",
                "assert rv.data == b'Hello world'",
                "assert rv.status_code == 500",
                "assert b'Not Found' in rv.data",
                "assert rv.status_code == 404",
                "assert rv.json == {'foo': 'bar'}",
                "assert rv.status_code == 201",
                "assert rv.json == ['foo', 'bar']",
                "assert rv.status_code == 201"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, returning it to the client.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. It uses `flask.session.get` to attempt to retrieve the value associated with the key `'value'` from the session. If the key does not exist, it defaults to returning the string `'None'`. The retrieved value is then returned as the response to the client. This method is useful for accessing session data in a web application context."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_response_types",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1115,
            "end_line_number": 1206,
            "source_code": "def test_response_types(app, client):\n    @app.route(\"/text\")\n    def from_text():\n        return \"H\u00e4llo W\u00f6rld\"\n\n    @app.route(\"/bytes\")\n    def from_bytes():\n        return \"H\u00e4llo W\u00f6rld\".encode()\n\n    @app.route(\"/full_tuple\")\n    def from_full_tuple():\n        return (\n            \"Meh\",\n            400,\n            {\"X-Foo\": \"Testing\", \"Content-Type\": \"text/plain; charset=utf-8\"},\n        )\n\n    @app.route(\"/text_headers\")\n    def from_text_headers():\n        return \"Hello\", {\"X-Foo\": \"Test\", \"Content-Type\": \"text/plain; charset=utf-8\"}\n\n    @app.route(\"/text_status\")\n    def from_text_status():\n        return \"Hi, status!\", 400\n\n    @app.route(\"/response_headers\")\n    def from_response_headers():\n        return (\n            flask.Response(\n                \"Hello world\", 404, {\"Content-Type\": \"text/html\", \"X-Foo\": \"Baz\"}\n            ),\n            {\"Content-Type\": \"text/plain\", \"X-Foo\": \"Bar\", \"X-Bar\": \"Foo\"},\n        )\n\n    @app.route(\"/response_status\")\n    def from_response_status():\n        return app.response_class(\"Hello world\", 400), 500\n\n    @app.route(\"/wsgi\")\n    def from_wsgi():\n        return NotFound()\n\n    @app.route(\"/dict\")\n    def from_dict():\n        return {\"foo\": \"bar\"}, 201\n\n    @app.route(\"/list\")\n    def from_list():\n        return [\"foo\", \"bar\"], 201\n\n    assert client.get(\"/text\").data == \"H\u00e4llo W\u00f6rld\".encode()\n    assert client.get(\"/bytes\").data == \"H\u00e4llo W\u00f6rld\".encode()\n\n    rv = client.get(\"/full_tuple\")\n    assert rv.data == b\"Meh\"\n    assert rv.headers[\"X-Foo\"] == \"Testing\"\n    assert rv.status_code == 400\n    assert rv.mimetype == \"text/plain\"\n\n    rv = client.get(\"/text_headers\")\n    assert rv.data == b\"Hello\"\n    assert rv.headers[\"X-Foo\"] == \"Test\"\n    assert rv.status_code == 200\n    assert rv.mimetype == \"text/plain\"\n\n    rv = client.get(\"/text_status\")\n    assert rv.data == b\"Hi, status!\"\n    assert rv.status_code == 400\n    assert rv.mimetype == \"text/html\"\n\n    rv = client.get(\"/response_headers\")\n    assert rv.data == b\"Hello world\"\n    assert rv.content_type == \"text/plain\"\n    assert rv.headers.getlist(\"X-Foo\") == [\"Bar\"]\n    assert rv.headers[\"X-Bar\"] == \"Foo\"\n    assert rv.status_code == 404\n\n    rv = client.get(\"/response_status\")\n    assert rv.data == b\"Hello world\"\n    assert rv.status_code == 500\n\n    rv = client.get(\"/wsgi\")\n    assert b\"Not Found\" in rv.data\n    assert rv.status_code == 404\n\n    rv = client.get(\"/dict\")\n    assert rv.json == {\"foo\": \"bar\"}\n    assert rv.status_code == 201\n\n    rv = client.get(\"/list\")\n    assert rv.json == [\"foo\", \"bar\"]\n    assert rv.status_code == 201",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/text').data == 'H\u00e4llo W\u00f6rld'.encode()",
                "assert client.get('/bytes').data == 'H\u00e4llo W\u00f6rld'.encode()",
                "assert rv.data == b'Meh'",
                "assert rv.headers['X-Foo'] == 'Testing'",
                "assert rv.status_code == 400",
                "assert rv.mimetype == 'text/plain'",
                "assert rv.data == b'Hello'",
                "assert rv.headers['X-Foo'] == 'Test'",
                "assert rv.status_code == 200",
                "assert rv.mimetype == 'text/plain'",
                "assert rv.data == b'Hi, status!'",
                "assert rv.status_code == 400",
                "assert rv.mimetype == 'text/html'",
                "assert rv.data == b'Hello world'",
                "assert rv.content_type == 'text/plain'",
                "assert rv.headers.getlist('X-Foo') == ['Bar']",
                "assert rv.headers['X-Bar'] == 'Foo'",
                "assert rv.status_code == 404",
                "assert rv.data == b'Hello world'",
                "assert rv.status_code == 500",
                "assert b'Not Found' in rv.data",
                "assert rv.status_code == 404",
                "assert rv.json == {'foo': 'bar'}",
                "assert rv.status_code == 201",
                "assert rv.json == ['foo', 'bar']",
                "assert rv.status_code == 201"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_response_types",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1115,
            "end_line_number": 1206,
            "source_code": "def test_response_types(app, client):\n    @app.route(\"/text\")\n    def from_text():\n        return \"H\u00e4llo W\u00f6rld\"\n\n    @app.route(\"/bytes\")\n    def from_bytes():\n        return \"H\u00e4llo W\u00f6rld\".encode()\n\n    @app.route(\"/full_tuple\")\n    def from_full_tuple():\n        return (\n            \"Meh\",\n            400,\n            {\"X-Foo\": \"Testing\", \"Content-Type\": \"text/plain; charset=utf-8\"},\n        )\n\n    @app.route(\"/text_headers\")\n    def from_text_headers():\n        return \"Hello\", {\"X-Foo\": \"Test\", \"Content-Type\": \"text/plain; charset=utf-8\"}\n\n    @app.route(\"/text_status\")\n    def from_text_status():\n        return \"Hi, status!\", 400\n\n    @app.route(\"/response_headers\")\n    def from_response_headers():\n        return (\n            flask.Response(\n                \"Hello world\", 404, {\"Content-Type\": \"text/html\", \"X-Foo\": \"Baz\"}\n            ),\n            {\"Content-Type\": \"text/plain\", \"X-Foo\": \"Bar\", \"X-Bar\": \"Foo\"},\n        )\n\n    @app.route(\"/response_status\")\n    def from_response_status():\n        return app.response_class(\"Hello world\", 400), 500\n\n    @app.route(\"/wsgi\")\n    def from_wsgi():\n        return NotFound()\n\n    @app.route(\"/dict\")\n    def from_dict():\n        return {\"foo\": \"bar\"}, 201\n\n    @app.route(\"/list\")\n    def from_list():\n        return [\"foo\", \"bar\"], 201\n\n    assert client.get(\"/text\").data == \"H\u00e4llo W\u00f6rld\".encode()\n    assert client.get(\"/bytes\").data == \"H\u00e4llo W\u00f6rld\".encode()\n\n    rv = client.get(\"/full_tuple\")\n    assert rv.data == b\"Meh\"\n    assert rv.headers[\"X-Foo\"] == \"Testing\"\n    assert rv.status_code == 400\n    assert rv.mimetype == \"text/plain\"\n\n    rv = client.get(\"/text_headers\")\n    assert rv.data == b\"Hello\"\n    assert rv.headers[\"X-Foo\"] == \"Test\"\n    assert rv.status_code == 200\n    assert rv.mimetype == \"text/plain\"\n\n    rv = client.get(\"/text_status\")\n    assert rv.data == b\"Hi, status!\"\n    assert rv.status_code == 400\n    assert rv.mimetype == \"text/html\"\n\n    rv = client.get(\"/response_headers\")\n    assert rv.data == b\"Hello world\"\n    assert rv.content_type == \"text/plain\"\n    assert rv.headers.getlist(\"X-Foo\") == [\"Bar\"]\n    assert rv.headers[\"X-Bar\"] == \"Foo\"\n    assert rv.status_code == 404\n\n    rv = client.get(\"/response_status\")\n    assert rv.data == b\"Hello world\"\n    assert rv.status_code == 500\n\n    rv = client.get(\"/wsgi\")\n    assert b\"Not Found\" in rv.data\n    assert rv.status_code == 404\n\n    rv = client.get(\"/dict\")\n    assert rv.json == {\"foo\": \"bar\"}\n    assert rv.status_code == 201\n\n    rv = client.get(\"/list\")\n    assert rv.json == [\"foo\", \"bar\"]\n    assert rv.status_code == 201",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/text').data == 'H\u00e4llo W\u00f6rld'.encode()",
                "assert client.get('/bytes').data == 'H\u00e4llo W\u00f6rld'.encode()",
                "assert rv.data == b'Meh'",
                "assert rv.headers['X-Foo'] == 'Testing'",
                "assert rv.status_code == 400",
                "assert rv.mimetype == 'text/plain'",
                "assert rv.data == b'Hello'",
                "assert rv.headers['X-Foo'] == 'Test'",
                "assert rv.status_code == 200",
                "assert rv.mimetype == 'text/plain'",
                "assert rv.data == b'Hi, status!'",
                "assert rv.status_code == 400",
                "assert rv.mimetype == 'text/html'",
                "assert rv.data == b'Hello world'",
                "assert rv.content_type == 'text/plain'",
                "assert rv.headers.getlist('X-Foo') == ['Bar']",
                "assert rv.headers['X-Bar'] == 'Foo'",
                "assert rv.status_code == 404",
                "assert rv.data == b'Hello world'",
                "assert rv.status_code == 500",
                "assert b'Not Found' in rv.data",
                "assert rv.status_code == 404",
                "assert rv.json == {'foo': 'bar'}",
                "assert rv.status_code == 201",
                "assert rv.json == ['foo', 'bar']",
                "assert rv.status_code == 201"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, returning it to the client.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. It uses `flask.session.get` to access the session data, specifically looking for a key named `'value'`. If this key does not exist, it defaults to returning the string `'None'`. The retrieved value is then sent back as the response to the client. This method is useful for managing session data in web applications, allowing for state persistence across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_response_types",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1115,
            "end_line_number": 1206,
            "source_code": "def test_response_types(app, client):\n    @app.route(\"/text\")\n    def from_text():\n        return \"H\u00e4llo W\u00f6rld\"\n\n    @app.route(\"/bytes\")\n    def from_bytes():\n        return \"H\u00e4llo W\u00f6rld\".encode()\n\n    @app.route(\"/full_tuple\")\n    def from_full_tuple():\n        return (\n            \"Meh\",\n            400,\n            {\"X-Foo\": \"Testing\", \"Content-Type\": \"text/plain; charset=utf-8\"},\n        )\n\n    @app.route(\"/text_headers\")\n    def from_text_headers():\n        return \"Hello\", {\"X-Foo\": \"Test\", \"Content-Type\": \"text/plain; charset=utf-8\"}\n\n    @app.route(\"/text_status\")\n    def from_text_status():\n        return \"Hi, status!\", 400\n\n    @app.route(\"/response_headers\")\n    def from_response_headers():\n        return (\n            flask.Response(\n                \"Hello world\", 404, {\"Content-Type\": \"text/html\", \"X-Foo\": \"Baz\"}\n            ),\n            {\"Content-Type\": \"text/plain\", \"X-Foo\": \"Bar\", \"X-Bar\": \"Foo\"},\n        )\n\n    @app.route(\"/response_status\")\n    def from_response_status():\n        return app.response_class(\"Hello world\", 400), 500\n\n    @app.route(\"/wsgi\")\n    def from_wsgi():\n        return NotFound()\n\n    @app.route(\"/dict\")\n    def from_dict():\n        return {\"foo\": \"bar\"}, 201\n\n    @app.route(\"/list\")\n    def from_list():\n        return [\"foo\", \"bar\"], 201\n\n    assert client.get(\"/text\").data == \"H\u00e4llo W\u00f6rld\".encode()\n    assert client.get(\"/bytes\").data == \"H\u00e4llo W\u00f6rld\".encode()\n\n    rv = client.get(\"/full_tuple\")\n    assert rv.data == b\"Meh\"\n    assert rv.headers[\"X-Foo\"] == \"Testing\"\n    assert rv.status_code == 400\n    assert rv.mimetype == \"text/plain\"\n\n    rv = client.get(\"/text_headers\")\n    assert rv.data == b\"Hello\"\n    assert rv.headers[\"X-Foo\"] == \"Test\"\n    assert rv.status_code == 200\n    assert rv.mimetype == \"text/plain\"\n\n    rv = client.get(\"/text_status\")\n    assert rv.data == b\"Hi, status!\"\n    assert rv.status_code == 400\n    assert rv.mimetype == \"text/html\"\n\n    rv = client.get(\"/response_headers\")\n    assert rv.data == b\"Hello world\"\n    assert rv.content_type == \"text/plain\"\n    assert rv.headers.getlist(\"X-Foo\") == [\"Bar\"]\n    assert rv.headers[\"X-Bar\"] == \"Foo\"\n    assert rv.status_code == 404\n\n    rv = client.get(\"/response_status\")\n    assert rv.data == b\"Hello world\"\n    assert rv.status_code == 500\n\n    rv = client.get(\"/wsgi\")\n    assert b\"Not Found\" in rv.data\n    assert rv.status_code == 404\n\n    rv = client.get(\"/dict\")\n    assert rv.json == {\"foo\": \"bar\"}\n    assert rv.status_code == 201\n\n    rv = client.get(\"/list\")\n    assert rv.json == [\"foo\", \"bar\"]\n    assert rv.status_code == 201",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/text').data == 'H\u00e4llo W\u00f6rld'.encode()",
                "assert client.get('/bytes').data == 'H\u00e4llo W\u00f6rld'.encode()",
                "assert rv.data == b'Meh'",
                "assert rv.headers['X-Foo'] == 'Testing'",
                "assert rv.status_code == 400",
                "assert rv.mimetype == 'text/plain'",
                "assert rv.data == b'Hello'",
                "assert rv.headers['X-Foo'] == 'Test'",
                "assert rv.status_code == 200",
                "assert rv.mimetype == 'text/plain'",
                "assert rv.data == b'Hi, status!'",
                "assert rv.status_code == 400",
                "assert rv.mimetype == 'text/html'",
                "assert rv.data == b'Hello world'",
                "assert rv.content_type == 'text/plain'",
                "assert rv.headers.getlist('X-Foo') == ['Bar']",
                "assert rv.headers['X-Bar'] == 'Foo'",
                "assert rv.status_code == 404",
                "assert rv.data == b'Hello world'",
                "assert rv.status_code == 500",
                "assert b'Not Found' in rv.data",
                "assert rv.status_code == 404",
                "assert rv.json == {'foo': 'bar'}",
                "assert rv.status_code == 201",
                "assert rv.json == ['foo', 'bar']",
                "assert rv.status_code == 201"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is used to define a route in a Flask web application that retrieves a value stored in the session. If the session does not contain the specified value, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nThe method is decorated with `@app.route('/get')`, which maps the URL path `/get` to the `get` function. When a GET request is made to this endpoint, the function attempts to access the session variable `'value'` using `flask.session.get('value', 'None')`. If `'value'` exists in the session, its value is returned; otherwise, the string `'None'` is returned. This allows for easy retrieval of session data in a web application context."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_response_types",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1115,
            "end_line_number": 1206,
            "source_code": "def test_response_types(app, client):\n    @app.route(\"/text\")\n    def from_text():\n        return \"H\u00e4llo W\u00f6rld\"\n\n    @app.route(\"/bytes\")\n    def from_bytes():\n        return \"H\u00e4llo W\u00f6rld\".encode()\n\n    @app.route(\"/full_tuple\")\n    def from_full_tuple():\n        return (\n            \"Meh\",\n            400,\n            {\"X-Foo\": \"Testing\", \"Content-Type\": \"text/plain; charset=utf-8\"},\n        )\n\n    @app.route(\"/text_headers\")\n    def from_text_headers():\n        return \"Hello\", {\"X-Foo\": \"Test\", \"Content-Type\": \"text/plain; charset=utf-8\"}\n\n    @app.route(\"/text_status\")\n    def from_text_status():\n        return \"Hi, status!\", 400\n\n    @app.route(\"/response_headers\")\n    def from_response_headers():\n        return (\n            flask.Response(\n                \"Hello world\", 404, {\"Content-Type\": \"text/html\", \"X-Foo\": \"Baz\"}\n            ),\n            {\"Content-Type\": \"text/plain\", \"X-Foo\": \"Bar\", \"X-Bar\": \"Foo\"},\n        )\n\n    @app.route(\"/response_status\")\n    def from_response_status():\n        return app.response_class(\"Hello world\", 400), 500\n\n    @app.route(\"/wsgi\")\n    def from_wsgi():\n        return NotFound()\n\n    @app.route(\"/dict\")\n    def from_dict():\n        return {\"foo\": \"bar\"}, 201\n\n    @app.route(\"/list\")\n    def from_list():\n        return [\"foo\", \"bar\"], 201\n\n    assert client.get(\"/text\").data == \"H\u00e4llo W\u00f6rld\".encode()\n    assert client.get(\"/bytes\").data == \"H\u00e4llo W\u00f6rld\".encode()\n\n    rv = client.get(\"/full_tuple\")\n    assert rv.data == b\"Meh\"\n    assert rv.headers[\"X-Foo\"] == \"Testing\"\n    assert rv.status_code == 400\n    assert rv.mimetype == \"text/plain\"\n\n    rv = client.get(\"/text_headers\")\n    assert rv.data == b\"Hello\"\n    assert rv.headers[\"X-Foo\"] == \"Test\"\n    assert rv.status_code == 200\n    assert rv.mimetype == \"text/plain\"\n\n    rv = client.get(\"/text_status\")\n    assert rv.data == b\"Hi, status!\"\n    assert rv.status_code == 400\n    assert rv.mimetype == \"text/html\"\n\n    rv = client.get(\"/response_headers\")\n    assert rv.data == b\"Hello world\"\n    assert rv.content_type == \"text/plain\"\n    assert rv.headers.getlist(\"X-Foo\") == [\"Bar\"]\n    assert rv.headers[\"X-Bar\"] == \"Foo\"\n    assert rv.status_code == 404\n\n    rv = client.get(\"/response_status\")\n    assert rv.data == b\"Hello world\"\n    assert rv.status_code == 500\n\n    rv = client.get(\"/wsgi\")\n    assert b\"Not Found\" in rv.data\n    assert rv.status_code == 404\n\n    rv = client.get(\"/dict\")\n    assert rv.json == {\"foo\": \"bar\"}\n    assert rv.status_code == 201\n\n    rv = client.get(\"/list\")\n    assert rv.json == [\"foo\", \"bar\"]\n    assert rv.status_code == 201",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/text').data == 'H\u00e4llo W\u00f6rld'.encode()",
                "assert client.get('/bytes').data == 'H\u00e4llo W\u00f6rld'.encode()",
                "assert rv.data == b'Meh'",
                "assert rv.headers['X-Foo'] == 'Testing'",
                "assert rv.status_code == 400",
                "assert rv.mimetype == 'text/plain'",
                "assert rv.data == b'Hello'",
                "assert rv.headers['X-Foo'] == 'Test'",
                "assert rv.status_code == 200",
                "assert rv.mimetype == 'text/plain'",
                "assert rv.data == b'Hi, status!'",
                "assert rv.status_code == 400",
                "assert rv.mimetype == 'text/html'",
                "assert rv.data == b'Hello world'",
                "assert rv.content_type == 'text/plain'",
                "assert rv.headers.getlist('X-Foo') == ['Bar']",
                "assert rv.headers['X-Bar'] == 'Foo'",
                "assert rv.status_code == 404",
                "assert rv.data == b'Hello world'",
                "assert rv.status_code == 500",
                "assert b'Not Found' in rv.data",
                "assert rv.status_code == 404",
                "assert rv.json == {'foo': 'bar'}",
                "assert rv.status_code == 201",
                "assert rv.json == ['foo', 'bar']",
                "assert rv.status_code == 201"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it returns the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session retrieves the value for the specified key (`'value'`), returning `'None'` if the key is not found. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_response_types",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1115,
            "end_line_number": 1206,
            "source_code": "def test_response_types(app, client):\n    @app.route(\"/text\")\n    def from_text():\n        return \"H\u00e4llo W\u00f6rld\"\n\n    @app.route(\"/bytes\")\n    def from_bytes():\n        return \"H\u00e4llo W\u00f6rld\".encode()\n\n    @app.route(\"/full_tuple\")\n    def from_full_tuple():\n        return (\n            \"Meh\",\n            400,\n            {\"X-Foo\": \"Testing\", \"Content-Type\": \"text/plain; charset=utf-8\"},\n        )\n\n    @app.route(\"/text_headers\")\n    def from_text_headers():\n        return \"Hello\", {\"X-Foo\": \"Test\", \"Content-Type\": \"text/plain; charset=utf-8\"}\n\n    @app.route(\"/text_status\")\n    def from_text_status():\n        return \"Hi, status!\", 400\n\n    @app.route(\"/response_headers\")\n    def from_response_headers():\n        return (\n            flask.Response(\n                \"Hello world\", 404, {\"Content-Type\": \"text/html\", \"X-Foo\": \"Baz\"}\n            ),\n            {\"Content-Type\": \"text/plain\", \"X-Foo\": \"Bar\", \"X-Bar\": \"Foo\"},\n        )\n\n    @app.route(\"/response_status\")\n    def from_response_status():\n        return app.response_class(\"Hello world\", 400), 500\n\n    @app.route(\"/wsgi\")\n    def from_wsgi():\n        return NotFound()\n\n    @app.route(\"/dict\")\n    def from_dict():\n        return {\"foo\": \"bar\"}, 201\n\n    @app.route(\"/list\")\n    def from_list():\n        return [\"foo\", \"bar\"], 201\n\n    assert client.get(\"/text\").data == \"H\u00e4llo W\u00f6rld\".encode()\n    assert client.get(\"/bytes\").data == \"H\u00e4llo W\u00f6rld\".encode()\n\n    rv = client.get(\"/full_tuple\")\n    assert rv.data == b\"Meh\"\n    assert rv.headers[\"X-Foo\"] == \"Testing\"\n    assert rv.status_code == 400\n    assert rv.mimetype == \"text/plain\"\n\n    rv = client.get(\"/text_headers\")\n    assert rv.data == b\"Hello\"\n    assert rv.headers[\"X-Foo\"] == \"Test\"\n    assert rv.status_code == 200\n    assert rv.mimetype == \"text/plain\"\n\n    rv = client.get(\"/text_status\")\n    assert rv.data == b\"Hi, status!\"\n    assert rv.status_code == 400\n    assert rv.mimetype == \"text/html\"\n\n    rv = client.get(\"/response_headers\")\n    assert rv.data == b\"Hello world\"\n    assert rv.content_type == \"text/plain\"\n    assert rv.headers.getlist(\"X-Foo\") == [\"Bar\"]\n    assert rv.headers[\"X-Bar\"] == \"Foo\"\n    assert rv.status_code == 404\n\n    rv = client.get(\"/response_status\")\n    assert rv.data == b\"Hello world\"\n    assert rv.status_code == 500\n\n    rv = client.get(\"/wsgi\")\n    assert b\"Not Found\" in rv.data\n    assert rv.status_code == 404\n\n    rv = client.get(\"/dict\")\n    assert rv.json == {\"foo\": \"bar\"}\n    assert rv.status_code == 201\n\n    rv = client.get(\"/list\")\n    assert rv.json == [\"foo\", \"bar\"]\n    assert rv.status_code == 201",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/text').data == 'H\u00e4llo W\u00f6rld'.encode()",
                "assert client.get('/bytes').data == 'H\u00e4llo W\u00f6rld'.encode()",
                "assert rv.data == b'Meh'",
                "assert rv.headers['X-Foo'] == 'Testing'",
                "assert rv.status_code == 400",
                "assert rv.mimetype == 'text/plain'",
                "assert rv.data == b'Hello'",
                "assert rv.headers['X-Foo'] == 'Test'",
                "assert rv.status_code == 200",
                "assert rv.mimetype == 'text/plain'",
                "assert rv.data == b'Hi, status!'",
                "assert rv.status_code == 400",
                "assert rv.mimetype == 'text/html'",
                "assert rv.data == b'Hello world'",
                "assert rv.content_type == 'text/plain'",
                "assert rv.headers.getlist('X-Foo') == ['Bar']",
                "assert rv.headers['X-Bar'] == 'Foo'",
                "assert rv.status_code == 404",
                "assert rv.data == b'Hello world'",
                "assert rv.status_code == 500",
                "assert b'Not Found' in rv.data",
                "assert rv.status_code == 404",
                "assert rv.json == {'foo': 'bar'}",
                "assert rv.status_code == 201",
                "assert rv.json == ['foo', 'bar']",
                "assert rv.status_code == 201"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_response_types",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1115,
            "end_line_number": 1206,
            "source_code": "def test_response_types(app, client):\n    @app.route(\"/text\")\n    def from_text():\n        return \"H\u00e4llo W\u00f6rld\"\n\n    @app.route(\"/bytes\")\n    def from_bytes():\n        return \"H\u00e4llo W\u00f6rld\".encode()\n\n    @app.route(\"/full_tuple\")\n    def from_full_tuple():\n        return (\n            \"Meh\",\n            400,\n            {\"X-Foo\": \"Testing\", \"Content-Type\": \"text/plain; charset=utf-8\"},\n        )\n\n    @app.route(\"/text_headers\")\n    def from_text_headers():\n        return \"Hello\", {\"X-Foo\": \"Test\", \"Content-Type\": \"text/plain; charset=utf-8\"}\n\n    @app.route(\"/text_status\")\n    def from_text_status():\n        return \"Hi, status!\", 400\n\n    @app.route(\"/response_headers\")\n    def from_response_headers():\n        return (\n            flask.Response(\n                \"Hello world\", 404, {\"Content-Type\": \"text/html\", \"X-Foo\": \"Baz\"}\n            ),\n            {\"Content-Type\": \"text/plain\", \"X-Foo\": \"Bar\", \"X-Bar\": \"Foo\"},\n        )\n\n    @app.route(\"/response_status\")\n    def from_response_status():\n        return app.response_class(\"Hello world\", 400), 500\n\n    @app.route(\"/wsgi\")\n    def from_wsgi():\n        return NotFound()\n\n    @app.route(\"/dict\")\n    def from_dict():\n        return {\"foo\": \"bar\"}, 201\n\n    @app.route(\"/list\")\n    def from_list():\n        return [\"foo\", \"bar\"], 201\n\n    assert client.get(\"/text\").data == \"H\u00e4llo W\u00f6rld\".encode()\n    assert client.get(\"/bytes\").data == \"H\u00e4llo W\u00f6rld\".encode()\n\n    rv = client.get(\"/full_tuple\")\n    assert rv.data == b\"Meh\"\n    assert rv.headers[\"X-Foo\"] == \"Testing\"\n    assert rv.status_code == 400\n    assert rv.mimetype == \"text/plain\"\n\n    rv = client.get(\"/text_headers\")\n    assert rv.data == b\"Hello\"\n    assert rv.headers[\"X-Foo\"] == \"Test\"\n    assert rv.status_code == 200\n    assert rv.mimetype == \"text/plain\"\n\n    rv = client.get(\"/text_status\")\n    assert rv.data == b\"Hi, status!\"\n    assert rv.status_code == 400\n    assert rv.mimetype == \"text/html\"\n\n    rv = client.get(\"/response_headers\")\n    assert rv.data == b\"Hello world\"\n    assert rv.content_type == \"text/plain\"\n    assert rv.headers.getlist(\"X-Foo\") == [\"Bar\"]\n    assert rv.headers[\"X-Bar\"] == \"Foo\"\n    assert rv.status_code == 404\n\n    rv = client.get(\"/response_status\")\n    assert rv.data == b\"Hello world\"\n    assert rv.status_code == 500\n\n    rv = client.get(\"/wsgi\")\n    assert b\"Not Found\" in rv.data\n    assert rv.status_code == 404\n\n    rv = client.get(\"/dict\")\n    assert rv.json == {\"foo\": \"bar\"}\n    assert rv.status_code == 201\n\n    rv = client.get(\"/list\")\n    assert rv.json == [\"foo\", \"bar\"]\n    assert rv.status_code == 201",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/text').data == 'H\u00e4llo W\u00f6rld'.encode()",
                "assert client.get('/bytes').data == 'H\u00e4llo W\u00f6rld'.encode()",
                "assert rv.data == b'Meh'",
                "assert rv.headers['X-Foo'] == 'Testing'",
                "assert rv.status_code == 400",
                "assert rv.mimetype == 'text/plain'",
                "assert rv.data == b'Hello'",
                "assert rv.headers['X-Foo'] == 'Test'",
                "assert rv.status_code == 200",
                "assert rv.mimetype == 'text/plain'",
                "assert rv.data == b'Hi, status!'",
                "assert rv.status_code == 400",
                "assert rv.mimetype == 'text/html'",
                "assert rv.data == b'Hello world'",
                "assert rv.content_type == 'text/plain'",
                "assert rv.headers.getlist('X-Foo') == ['Bar']",
                "assert rv.headers['X-Bar'] == 'Foo'",
                "assert rv.status_code == 404",
                "assert rv.data == b'Hello world'",
                "assert rv.status_code == 500",
                "assert b'Not Found' in rv.data",
                "assert rv.status_code == 404",
                "assert rv.json == {'foo': 'bar'}",
                "assert rv.status_code == 201",
                "assert rv.json == ['foo', 'bar']",
                "assert rv.status_code == 201"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_response_types",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1115,
            "end_line_number": 1206,
            "source_code": "def test_response_types(app, client):\n    @app.route(\"/text\")\n    def from_text():\n        return \"H\u00e4llo W\u00f6rld\"\n\n    @app.route(\"/bytes\")\n    def from_bytes():\n        return \"H\u00e4llo W\u00f6rld\".encode()\n\n    @app.route(\"/full_tuple\")\n    def from_full_tuple():\n        return (\n            \"Meh\",\n            400,\n            {\"X-Foo\": \"Testing\", \"Content-Type\": \"text/plain; charset=utf-8\"},\n        )\n\n    @app.route(\"/text_headers\")\n    def from_text_headers():\n        return \"Hello\", {\"X-Foo\": \"Test\", \"Content-Type\": \"text/plain; charset=utf-8\"}\n\n    @app.route(\"/text_status\")\n    def from_text_status():\n        return \"Hi, status!\", 400\n\n    @app.route(\"/response_headers\")\n    def from_response_headers():\n        return (\n            flask.Response(\n                \"Hello world\", 404, {\"Content-Type\": \"text/html\", \"X-Foo\": \"Baz\"}\n            ),\n            {\"Content-Type\": \"text/plain\", \"X-Foo\": \"Bar\", \"X-Bar\": \"Foo\"},\n        )\n\n    @app.route(\"/response_status\")\n    def from_response_status():\n        return app.response_class(\"Hello world\", 400), 500\n\n    @app.route(\"/wsgi\")\n    def from_wsgi():\n        return NotFound()\n\n    @app.route(\"/dict\")\n    def from_dict():\n        return {\"foo\": \"bar\"}, 201\n\n    @app.route(\"/list\")\n    def from_list():\n        return [\"foo\", \"bar\"], 201\n\n    assert client.get(\"/text\").data == \"H\u00e4llo W\u00f6rld\".encode()\n    assert client.get(\"/bytes\").data == \"H\u00e4llo W\u00f6rld\".encode()\n\n    rv = client.get(\"/full_tuple\")\n    assert rv.data == b\"Meh\"\n    assert rv.headers[\"X-Foo\"] == \"Testing\"\n    assert rv.status_code == 400\n    assert rv.mimetype == \"text/plain\"\n\n    rv = client.get(\"/text_headers\")\n    assert rv.data == b\"Hello\"\n    assert rv.headers[\"X-Foo\"] == \"Test\"\n    assert rv.status_code == 200\n    assert rv.mimetype == \"text/plain\"\n\n    rv = client.get(\"/text_status\")\n    assert rv.data == b\"Hi, status!\"\n    assert rv.status_code == 400\n    assert rv.mimetype == \"text/html\"\n\n    rv = client.get(\"/response_headers\")\n    assert rv.data == b\"Hello world\"\n    assert rv.content_type == \"text/plain\"\n    assert rv.headers.getlist(\"X-Foo\") == [\"Bar\"]\n    assert rv.headers[\"X-Bar\"] == \"Foo\"\n    assert rv.status_code == 404\n\n    rv = client.get(\"/response_status\")\n    assert rv.data == b\"Hello world\"\n    assert rv.status_code == 500\n\n    rv = client.get(\"/wsgi\")\n    assert b\"Not Found\" in rv.data\n    assert rv.status_code == 404\n\n    rv = client.get(\"/dict\")\n    assert rv.json == {\"foo\": \"bar\"}\n    assert rv.status_code == 201\n\n    rv = client.get(\"/list\")\n    assert rv.json == [\"foo\", \"bar\"]\n    assert rv.status_code == 201",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/text').data == 'H\u00e4llo W\u00f6rld'.encode()",
                "assert client.get('/bytes').data == 'H\u00e4llo W\u00f6rld'.encode()",
                "assert rv.data == b'Meh'",
                "assert rv.headers['X-Foo'] == 'Testing'",
                "assert rv.status_code == 400",
                "assert rv.mimetype == 'text/plain'",
                "assert rv.data == b'Hello'",
                "assert rv.headers['X-Foo'] == 'Test'",
                "assert rv.status_code == 200",
                "assert rv.mimetype == 'text/plain'",
                "assert rv.data == b'Hi, status!'",
                "assert rv.status_code == 400",
                "assert rv.mimetype == 'text/html'",
                "assert rv.data == b'Hello world'",
                "assert rv.content_type == 'text/plain'",
                "assert rv.headers.getlist('X-Foo') == ['Bar']",
                "assert rv.headers['X-Bar'] == 'Foo'",
                "assert rv.status_code == 404",
                "assert rv.data == b'Hello world'",
                "assert rv.status_code == 500",
                "assert b'Not Found' in rv.data",
                "assert rv.status_code == 404",
                "assert rv.json == {'foo': 'bar'}",
                "assert rv.status_code == 201",
                "assert rv.json == ['foo', 'bar']",
                "assert rv.status_code == 201"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, defaulting to `'None'` if the key `'value'` does not exist.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` route, the `get` function is invoked. It uses `flask.session.get` to access the session data associated with the key `'value'`. If this key is not found, it returns the string `'None'`. The session management is facilitated by Flask's session interface, which allows for storing and retrieving user-specific data across requests. This method is useful for maintaining state in web applications, such as user preferences or authentication status."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_response_type_errors",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1209,
            "end_line_number": 1255,
            "source_code": "def test_response_type_errors():\n    app = flask.Flask(__name__)\n    app.testing = True\n\n    @app.route(\"/none\")\n    def from_none():\n        pass\n\n    @app.route(\"/small_tuple\")\n    def from_small_tuple():\n        return (\"Hello\",)\n\n    @app.route(\"/large_tuple\")\n    def from_large_tuple():\n        return \"Hello\", 234, {\"X-Foo\": \"Bar\"}, \"???\"\n\n    @app.route(\"/bad_type\")\n    def from_bad_type():\n        return True\n\n    @app.route(\"/bad_wsgi\")\n    def from_bad_wsgi():\n        return lambda: None\n\n    c = app.test_client()\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"/none\")\n\n    assert \"returned None\" in str(e.value)\n    assert \"from_none\" in str(e.value)\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"/small_tuple\")\n\n    assert \"tuple must have the form\" in str(e.value)\n\n    with pytest.raises(TypeError):\n        c.get(\"/large_tuple\")\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"/bad_type\")\n\n    assert \"it was a bool\" in str(e.value)\n\n    with pytest.raises(TypeError):\n        c.get(\"/bad_wsgi\")",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'returned None' in str(e.value)",
                "assert 'from_none' in str(e.value)",
                "assert 'tuple must have the form' in str(e.value)",
                "assert 'it was a bool' in str(e.value)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "c.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get` method is a Flask route handler that retrieves a value from the session, specifically the value associated with the key `'value'`. If this key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the method uses `flask.session.get` to access the session data. The `get` method of the session object takes two arguments: the key to look for (`'value'`) and a default value (`'None'`) to return if the key is not found. The retrieved value is then returned as the response to the HTTP request. This allows the application to maintain state across requests by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_response_type_errors",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1209,
            "end_line_number": 1255,
            "source_code": "def test_response_type_errors():\n    app = flask.Flask(__name__)\n    app.testing = True\n\n    @app.route(\"/none\")\n    def from_none():\n        pass\n\n    @app.route(\"/small_tuple\")\n    def from_small_tuple():\n        return (\"Hello\",)\n\n    @app.route(\"/large_tuple\")\n    def from_large_tuple():\n        return \"Hello\", 234, {\"X-Foo\": \"Bar\"}, \"???\"\n\n    @app.route(\"/bad_type\")\n    def from_bad_type():\n        return True\n\n    @app.route(\"/bad_wsgi\")\n    def from_bad_wsgi():\n        return lambda: None\n\n    c = app.test_client()\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"/none\")\n\n    assert \"returned None\" in str(e.value)\n    assert \"from_none\" in str(e.value)\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"/small_tuple\")\n\n    assert \"tuple must have the form\" in str(e.value)\n\n    with pytest.raises(TypeError):\n        c.get(\"/large_tuple\")\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"/bad_type\")\n\n    assert \"it was a bool\" in str(e.value)\n\n    with pytest.raises(TypeError):\n        c.get(\"/bad_wsgi\")",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'returned None' in str(e.value)",
                "assert 'from_none' in str(e.value)",
                "assert 'tuple must have the form' in str(e.value)",
                "assert 'it was a bool' in str(e.value)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "c.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get` method is a Flask route handler that retrieves a value from the session, specifically the value associated with the key `'value'`. If this key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the method uses `flask.session.get` to access the session data. The `get` method takes two arguments: the key to look for (`'value'`) and a default value (`'None'`) to return if the key is not found. The retrieved value is then returned as the response to the HTTP request. This allows the application to maintain state across requests by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_response_type_errors",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1209,
            "end_line_number": 1255,
            "source_code": "def test_response_type_errors():\n    app = flask.Flask(__name__)\n    app.testing = True\n\n    @app.route(\"/none\")\n    def from_none():\n        pass\n\n    @app.route(\"/small_tuple\")\n    def from_small_tuple():\n        return (\"Hello\",)\n\n    @app.route(\"/large_tuple\")\n    def from_large_tuple():\n        return \"Hello\", 234, {\"X-Foo\": \"Bar\"}, \"???\"\n\n    @app.route(\"/bad_type\")\n    def from_bad_type():\n        return True\n\n    @app.route(\"/bad_wsgi\")\n    def from_bad_wsgi():\n        return lambda: None\n\n    c = app.test_client()\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"/none\")\n\n    assert \"returned None\" in str(e.value)\n    assert \"from_none\" in str(e.value)\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"/small_tuple\")\n\n    assert \"tuple must have the form\" in str(e.value)\n\n    with pytest.raises(TypeError):\n        c.get(\"/large_tuple\")\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"/bad_type\")\n\n    assert \"it was a bool\" in str(e.value)\n\n    with pytest.raises(TypeError):\n        c.get(\"/bad_wsgi\")",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'returned None' in str(e.value)",
                "assert 'from_none' in str(e.value)",
                "assert 'tuple must have the form' in str(e.value)",
                "assert 'it was a bool' in str(e.value)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "c.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get` method is a Flask route handler that retrieves a value from the session, specifically the value associated with the key `'value'`. If this key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the method uses `flask.session.get()` to access the session data. The `get` method takes two arguments: the key `'value'` and a default value `'None'`. If the key is found, it returns the corresponding value; otherwise, it returns the default value. This allows for safe retrieval of session data without raising an error if the key is missing. The response is then sent back to the client."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_response_type_errors",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1209,
            "end_line_number": 1255,
            "source_code": "def test_response_type_errors():\n    app = flask.Flask(__name__)\n    app.testing = True\n\n    @app.route(\"/none\")\n    def from_none():\n        pass\n\n    @app.route(\"/small_tuple\")\n    def from_small_tuple():\n        return (\"Hello\",)\n\n    @app.route(\"/large_tuple\")\n    def from_large_tuple():\n        return \"Hello\", 234, {\"X-Foo\": \"Bar\"}, \"???\"\n\n    @app.route(\"/bad_type\")\n    def from_bad_type():\n        return True\n\n    @app.route(\"/bad_wsgi\")\n    def from_bad_wsgi():\n        return lambda: None\n\n    c = app.test_client()\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"/none\")\n\n    assert \"returned None\" in str(e.value)\n    assert \"from_none\" in str(e.value)\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"/small_tuple\")\n\n    assert \"tuple must have the form\" in str(e.value)\n\n    with pytest.raises(TypeError):\n        c.get(\"/large_tuple\")\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"/bad_type\")\n\n    assert \"it was a bool\" in str(e.value)\n\n    with pytest.raises(TypeError):\n        c.get(\"/bad_wsgi\")",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'returned None' in str(e.value)",
                "assert 'from_none' in str(e.value)",
                "assert 'tuple must have the form' in str(e.value)",
                "assert 'it was a bool' in str(e.value)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "c.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get` method is a Flask route handler that retrieves a value from the session, specifically the value associated with the key `'value'`. If this key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the method uses `flask.session.get()` to access the session data. The `get` method takes two arguments: the key to look for (`'value'`) and a default value (`'None'`) to return if the key is not found. The retrieved value is then returned as the response to the HTTP request. This allows for session-based data retrieval in a web application context."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_response_type_errors",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1209,
            "end_line_number": 1255,
            "source_code": "def test_response_type_errors():\n    app = flask.Flask(__name__)\n    app.testing = True\n\n    @app.route(\"/none\")\n    def from_none():\n        pass\n\n    @app.route(\"/small_tuple\")\n    def from_small_tuple():\n        return (\"Hello\",)\n\n    @app.route(\"/large_tuple\")\n    def from_large_tuple():\n        return \"Hello\", 234, {\"X-Foo\": \"Bar\"}, \"???\"\n\n    @app.route(\"/bad_type\")\n    def from_bad_type():\n        return True\n\n    @app.route(\"/bad_wsgi\")\n    def from_bad_wsgi():\n        return lambda: None\n\n    c = app.test_client()\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"/none\")\n\n    assert \"returned None\" in str(e.value)\n    assert \"from_none\" in str(e.value)\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"/small_tuple\")\n\n    assert \"tuple must have the form\" in str(e.value)\n\n    with pytest.raises(TypeError):\n        c.get(\"/large_tuple\")\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"/bad_type\")\n\n    assert \"it was a bool\" in str(e.value)\n\n    with pytest.raises(TypeError):\n        c.get(\"/bad_wsgi\")",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'returned None' in str(e.value)",
                "assert 'from_none' in str(e.value)",
                "assert 'tuple must have the form' in str(e.value)",
                "assert 'it was a bool' in str(e.value)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "c.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get` method is a Flask route handler that retrieves a value from the session, specifically the value associated with the key `'value'`. If this key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the method uses `flask.session.get()` to access the session data. The `get` method takes two arguments: the key `'value'` and a default value `'None'`. If the key is found, it returns the corresponding value; otherwise, it returns the default value. This allows for safe retrieval of session data without raising an error if the key is missing. The response is then sent back to the client."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_json_dump_dataclass",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1317,
            "end_line_number": 1323,
            "source_code": "def test_json_dump_dataclass(app, req_ctx):\n    from dataclasses import make_dataclass\n\n    Data = make_dataclass(\"Data\", [(\"name\", str)])\n    value = app.json.dumps(Data(\"Flask\"))\n    value = app.json.loads(value)\n    assert value == {\"name\": \"Flask\"}",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "req_ctx"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert value == {'name': 'Flask'}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "app.json.loads",
                    "body": "def loads(self, s, **kwargs):\n    kwargs.setdefault('object_hook', self.object_hook)\n    return super().loads(s, **kwargs)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `loads` method is designed to deserialize a JSON-formatted string into a Python object. It allows for customization of the deserialization process through the use of an `object_hook`, which can transform parsed JSON objects into custom Python objects.\n\n**How It Works**:  \nThe method takes a JSON string `s` and optional keyword arguments `**kwargs`. It sets a default `object_hook` to the instance's `object_hook` method if one is not provided in `kwargs`. It then calls the parent class's `loads` method, passing the JSON string and the updated keyword arguments. This allows for the flexibility of using custom deserialization logic while leveraging the underlying JSON library's functionality."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_static_files",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1396,
            "end_line_number": 1402,
            "source_code": "def test_static_files(app, client):\n    rv = client.get(\"/static/index.html\")\n    assert rv.status_code == 200\n    assert rv.data.strip() == b\"<h1>Hello World!</h1>\"\n    with app.test_request_context():\n        assert flask.url_for(\"static\", filename=\"index.html\") == \"/static/index.html\"\n    rv.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.status_code == 200",
                "assert rv.data.strip() == b'<h1>Hello World!</h1>'",
                "assert flask.url_for('static', filename='index.html') == '/static/index.html'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_static_files",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1396,
            "end_line_number": 1402,
            "source_code": "def test_static_files(app, client):\n    rv = client.get(\"/static/index.html\")\n    assert rv.status_code == 200\n    assert rv.data.strip() == b\"<h1>Hello World!</h1>\"\n    with app.test_request_context():\n        assert flask.url_for(\"static\", filename=\"index.html\") == \"/static/index.html\"\n    rv.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.status_code == 200",
                "assert rv.data.strip() == b'<h1>Hello World!</h1>'",
                "assert flask.url_for('static', filename='index.html') == '/static/index.html'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "rv.close",
                    "body": "def close(self):\n    called.append(42)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically related to resource management, by appending a specific value (42) to a list named `called`. This indicates that the method has been invoked, which can be useful for tracking or debugging purposes.\n\n**How It Works**:  \nWhen the `close` method is called, it executes a single line of code that appends the integer 42 to the `called` list. This action serves as a simple signal that the method has been executed, allowing developers to verify that the cleanup process has occurred. The method does not return any value or perform additional operations beyond this append action."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_static_url_path",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1405,
            "end_line_number": 1413,
            "source_code": "def test_static_url_path():\n    app = flask.Flask(__name__, static_url_path=\"/foo\")\n    app.testing = True\n    rv = app.test_client().get(\"/foo/index.html\")\n    assert rv.status_code == 200\n    rv.close()\n\n    with app.test_request_context():\n        assert flask.url_for(\"static\", filename=\"index.html\") == \"/foo/index.html\"",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.status_code == 200",
                "assert flask.url_for('static', filename='index.html') == '/foo/index.html'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "rv.close",
                    "body": "def close(self):\n    called.append(42)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically related to resource management, by appending a value (42) to a list named `called`. This suggests that the method is likely part of a resource management system where tracking the closure of resources is important.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes a single line of code that appends the integer 42 to the `called` list. This action serves as a simple indicator that the method has been called, which can be useful for debugging or tracking the state of resource management within the application. The method does not return any value or perform any additional operations beyond this append action."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_static_url_path_with_ending_slash",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1416,
            "end_line_number": 1424,
            "source_code": "def test_static_url_path_with_ending_slash():\n    app = flask.Flask(__name__, static_url_path=\"/foo/\")\n    app.testing = True\n    rv = app.test_client().get(\"/foo/index.html\")\n    assert rv.status_code == 200\n    rv.close()\n\n    with app.test_request_context():\n        assert flask.url_for(\"static\", filename=\"index.html\") == \"/foo/index.html\"",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.status_code == 200",
                "assert flask.url_for('static', filename='index.html') == '/foo/index.html'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "rv.close",
                    "body": "def close(self):\n    called.append(42)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify its execution in tests or other parts of the code. The method does not return any value or perform any additional actions, focusing solely on this tracking functionality."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_static_url_empty_path",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1427,
            "end_line_number": 1431,
            "source_code": "def test_static_url_empty_path(app):\n    app = flask.Flask(__name__, static_folder=\"\", static_url_path=\"\")\n    rv = app.test_client().open(\"/static/index.html\", method=\"GET\")\n    assert rv.status_code == 200\n    rv.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.status_code == 200"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "rv.close",
                    "body": "def close(self):\n    called.append(42)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically related to resource management, by appending a value (42) to a list named `called`. This suggests that the method is part of a larger context where tracking the invocation of cleanup actions is necessary.\n\n**How It Works**:  \nWhen the `close` method is called, it executes a single line of code that appends the integer 42 to the `called` list. This indicates that the method has been invoked, which can be useful for testing or debugging purposes to confirm that the cleanup process is executed as expected. The method does not return any value or perform additional operations beyond this logging action."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_static_url_empty_path_default",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1434,
            "end_line_number": 1438,
            "source_code": "def test_static_url_empty_path_default(app):\n    app = flask.Flask(__name__, static_folder=\"\")\n    rv = app.test_client().open(\"/static/index.html\", method=\"GET\")\n    assert rv.status_code == 200\n    rv.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.status_code == 200"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "rv.close",
                    "body": "def close(self):\n    called.append(42)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically related to resource management, by appending a value (42) to a list named `called`. This suggests that it is part of a mechanism to track when the method is invoked, possibly for debugging or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is called, it executes a single line of code that appends the integer 42 to the `called` list. This indicates that the method has been executed, allowing developers to verify its invocation during tests or runtime. The method does not return any value or perform additional operations, focusing solely on recording its call."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_static_folder_with_pathlib_path",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1441,
            "end_line_number": 1447,
            "source_code": "def test_static_folder_with_pathlib_path(app):\n    from pathlib import Path\n\n    app = flask.Flask(__name__, static_folder=Path(\"static\"))\n    rv = app.test_client().open(\"/static/index.html\", method=\"GET\")\n    assert rv.status_code == 200\n    rv.close()",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.status_code == 200"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "rv.close",
                    "body": "def close(self):\n    called.append(42)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically related to resource management, by appending a specific value (42) to a list named `called`. This indicates that the method has been invoked, which can be useful for tracking or debugging purposes.\n\n**How It Works**:  \nWhen the `close` method is called, it executes a single line of code that appends the integer 42 to the `called` list. This action serves as a simple notification mechanism to signal that the `close` method has been executed. The method does not return any value or perform any additional operations, making it a straightforward implementation primarily for tracking method calls."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_static_route_with_host_matching",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1461,
            "end_line_number": 1479,
            "source_code": "def test_static_route_with_host_matching():\n    app = flask.Flask(__name__, host_matching=True, static_host=\"example.com\")\n    c = app.test_client()\n    rv = c.get(\"http://example.com/static/index.html\")\n    assert rv.status_code == 200\n    rv.close()\n    with app.test_request_context():\n        rv = flask.url_for(\"static\", filename=\"index.html\", _external=True)\n        assert rv == \"http://example.com/static/index.html\"\n    # Providing static_host without host_matching=True should error.\n    with pytest.raises(AssertionError):\n        flask.Flask(__name__, static_host=\"example.com\")\n    # Providing host_matching=True with static_folder\n    # but without static_host should error.\n    with pytest.raises(AssertionError):\n        flask.Flask(__name__, host_matching=True)\n    # Providing host_matching=True without static_host\n    # but with static_folder=None should not error.\n    flask.Flask(__name__, host_matching=True, static_folder=None)",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.status_code == 200",
                "assert rv == 'http://example.com/static/index.html'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "c.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get` method is a Flask route handler that retrieves a value from the session, specifically the value associated with the key `'value'`. If this key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the method uses `flask.session.get` to access the session data. The `get` method of the session object allows for a default value to be specified, which in this case is `'None'`. The retrieved value (or the default if not found) is then returned as the response to the client. This method is useful for checking session data and providing a fallback when the expected data is not present."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_static_route_with_host_matching",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1461,
            "end_line_number": 1479,
            "source_code": "def test_static_route_with_host_matching():\n    app = flask.Flask(__name__, host_matching=True, static_host=\"example.com\")\n    c = app.test_client()\n    rv = c.get(\"http://example.com/static/index.html\")\n    assert rv.status_code == 200\n    rv.close()\n    with app.test_request_context():\n        rv = flask.url_for(\"static\", filename=\"index.html\", _external=True)\n        assert rv == \"http://example.com/static/index.html\"\n    # Providing static_host without host_matching=True should error.\n    with pytest.raises(AssertionError):\n        flask.Flask(__name__, static_host=\"example.com\")\n    # Providing host_matching=True with static_folder\n    # but without static_host should error.\n    with pytest.raises(AssertionError):\n        flask.Flask(__name__, host_matching=True)\n    # Providing host_matching=True without static_host\n    # but with static_folder=None should not error.\n    flask.Flask(__name__, host_matching=True, static_folder=None)",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.status_code == 200",
                "assert rv == 'http://example.com/static/index.html'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "rv.close",
                    "body": "def close(self):\n    called.append(42)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify that the cleanup process was triggered. The method does not return any value or perform any additional actions beyond this simple operation."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_server_name_matching",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1495,
            "end_line_number": 1526,
            "source_code": "def test_server_name_matching(\n    subdomain_matching: bool,\n    host_matching: bool,\n    expect_base: str,\n    expect_abc: str,\n    expect_xyz: str,\n) -> None:\n    app = flask.Flask(\n        __name__,\n        subdomain_matching=subdomain_matching,\n        host_matching=host_matching,\n        static_host=\"example.test\" if host_matching else None,\n    )\n    app.config[\"SERVER_NAME\"] = \"example.test\"\n\n    @app.route(\"/\", defaults={\"name\": \"default\"}, host=\"<name>\")\n    @app.route(\"/\", subdomain=\"<name>\", host=\"<name>.example.test\")\n    def index(name: str) -> str:\n        return name\n\n    client = app.test_client()\n\n    r = client.get(base_url=\"http://example.test\")\n    assert r.text == expect_base\n\n    r = client.get(base_url=\"http://abc.example.test\")\n    assert r.text == expect_abc\n\n    with pytest.warns() if subdomain_matching else nullcontext():\n        r = client.get(base_url=\"http://xyz.other.test\")\n\n    assert r.text == expect_xyz",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize(('subdomain_matching', 'host_matching', 'expect_base', 'expect_abc', 'expect_xyz'), [(False, False, 'default', 'default', 'default'), (True, False, 'default', 'abc', '<invalid>'), (False, True, 'default', 'abc', 'default')])"
            ],
            "arguments": [
                "subdomain_matching",
                "host_matching",
                "expect_base",
                "expect_abc",
                "expect_xyz"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert r.text == expect_base",
                "assert r.text == expect_abc",
                "assert r.text == expect_xyz"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, returning it to the client.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. It uses `flask.session.get` to access the session data, specifically looking for a key named `'value'`. If this key does not exist, it defaults to returning the string `'None'`. The retrieved value is then sent back as the response to the client. This method is useful for accessing session data in a web application context."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_server_name_matching",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1495,
            "end_line_number": 1526,
            "source_code": "def test_server_name_matching(\n    subdomain_matching: bool,\n    host_matching: bool,\n    expect_base: str,\n    expect_abc: str,\n    expect_xyz: str,\n) -> None:\n    app = flask.Flask(\n        __name__,\n        subdomain_matching=subdomain_matching,\n        host_matching=host_matching,\n        static_host=\"example.test\" if host_matching else None,\n    )\n    app.config[\"SERVER_NAME\"] = \"example.test\"\n\n    @app.route(\"/\", defaults={\"name\": \"default\"}, host=\"<name>\")\n    @app.route(\"/\", subdomain=\"<name>\", host=\"<name>.example.test\")\n    def index(name: str) -> str:\n        return name\n\n    client = app.test_client()\n\n    r = client.get(base_url=\"http://example.test\")\n    assert r.text == expect_base\n\n    r = client.get(base_url=\"http://abc.example.test\")\n    assert r.text == expect_abc\n\n    with pytest.warns() if subdomain_matching else nullcontext():\n        r = client.get(base_url=\"http://xyz.other.test\")\n\n    assert r.text == expect_xyz",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize(('subdomain_matching', 'host_matching', 'expect_base', 'expect_abc', 'expect_xyz'), [(False, False, 'default', 'default', 'default'), (True, False, 'default', 'abc', '<invalid>'), (False, True, 'default', 'abc', 'default')])"
            ],
            "arguments": [
                "subdomain_matching",
                "host_matching",
                "expect_base",
                "expect_abc",
                "expect_xyz"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert r.text == expect_base",
                "assert r.text == expect_abc",
                "assert r.text == expect_xyz"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_server_name_matching",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1495,
            "end_line_number": 1526,
            "source_code": "def test_server_name_matching(\n    subdomain_matching: bool,\n    host_matching: bool,\n    expect_base: str,\n    expect_abc: str,\n    expect_xyz: str,\n) -> None:\n    app = flask.Flask(\n        __name__,\n        subdomain_matching=subdomain_matching,\n        host_matching=host_matching,\n        static_host=\"example.test\" if host_matching else None,\n    )\n    app.config[\"SERVER_NAME\"] = \"example.test\"\n\n    @app.route(\"/\", defaults={\"name\": \"default\"}, host=\"<name>\")\n    @app.route(\"/\", subdomain=\"<name>\", host=\"<name>.example.test\")\n    def index(name: str) -> str:\n        return name\n\n    client = app.test_client()\n\n    r = client.get(base_url=\"http://example.test\")\n    assert r.text == expect_base\n\n    r = client.get(base_url=\"http://abc.example.test\")\n    assert r.text == expect_abc\n\n    with pytest.warns() if subdomain_matching else nullcontext():\n        r = client.get(base_url=\"http://xyz.other.test\")\n\n    assert r.text == expect_xyz",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize(('subdomain_matching', 'host_matching', 'expect_base', 'expect_abc', 'expect_xyz'), [(False, False, 'default', 'default', 'default'), (True, False, 'default', 'abc', '<invalid>'), (False, True, 'default', 'abc', 'default')])"
            ],
            "arguments": [
                "subdomain_matching",
                "host_matching",
                "expect_base",
                "expect_abc",
                "expect_xyz"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert r.text == expect_base",
                "assert r.text == expect_abc",
                "assert r.text == expect_xyz"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_server_name_subdomain",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1529,
            "end_line_number": 1571,
            "source_code": "def test_server_name_subdomain():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    client = app.test_client()\n\n    @app.route(\"/\")\n    def index():\n        return \"default\"\n\n    @app.route(\"/\", subdomain=\"foo\")\n    def subdomain():\n        return \"subdomain\"\n\n    app.config[\"SERVER_NAME\"] = \"dev.local:5000\"\n    rv = client.get(\"/\")\n    assert rv.data == b\"default\"\n\n    rv = client.get(\"/\", \"http://dev.local:5000\")\n    assert rv.data == b\"default\"\n\n    rv = client.get(\"/\", \"https://dev.local:5000\")\n    assert rv.data == b\"default\"\n\n    app.config[\"SERVER_NAME\"] = \"dev.local:443\"\n    rv = client.get(\"/\", \"https://dev.local\")\n\n    # Werkzeug 1.0 fixes matching https scheme with 443 port\n    if rv.status_code != 404:\n        assert rv.data == b\"default\"\n\n    app.config[\"SERVER_NAME\"] = \"dev.local\"\n    rv = client.get(\"/\", \"https://dev.local\")\n    assert rv.data == b\"default\"\n\n    # suppress Werkzeug 0.15 warning about name mismatch\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\n            \"ignore\", \"Current server name\", UserWarning, \"flask.app\"\n        )\n        rv = client.get(\"/\", \"http://foo.localhost\")\n        assert rv.status_code == 404\n\n    rv = client.get(\"/\", \"http://foo.dev.local\")\n    assert rv.data == b\"subdomain\"",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'default'",
                "assert rv.data == b'default'",
                "assert rv.data == b'default'",
                "assert rv.data == b'default'",
                "assert rv.data == b'subdomain'",
                "assert rv.data == b'default'",
                "assert rv.status_code == 404"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called, which attempts to fetch the value stored in the session under the key `'value'`. If this key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve user-specific data across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_server_name_subdomain",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1529,
            "end_line_number": 1571,
            "source_code": "def test_server_name_subdomain():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    client = app.test_client()\n\n    @app.route(\"/\")\n    def index():\n        return \"default\"\n\n    @app.route(\"/\", subdomain=\"foo\")\n    def subdomain():\n        return \"subdomain\"\n\n    app.config[\"SERVER_NAME\"] = \"dev.local:5000\"\n    rv = client.get(\"/\")\n    assert rv.data == b\"default\"\n\n    rv = client.get(\"/\", \"http://dev.local:5000\")\n    assert rv.data == b\"default\"\n\n    rv = client.get(\"/\", \"https://dev.local:5000\")\n    assert rv.data == b\"default\"\n\n    app.config[\"SERVER_NAME\"] = \"dev.local:443\"\n    rv = client.get(\"/\", \"https://dev.local\")\n\n    # Werkzeug 1.0 fixes matching https scheme with 443 port\n    if rv.status_code != 404:\n        assert rv.data == b\"default\"\n\n    app.config[\"SERVER_NAME\"] = \"dev.local\"\n    rv = client.get(\"/\", \"https://dev.local\")\n    assert rv.data == b\"default\"\n\n    # suppress Werkzeug 0.15 warning about name mismatch\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\n            \"ignore\", \"Current server name\", UserWarning, \"flask.app\"\n        )\n        rv = client.get(\"/\", \"http://foo.localhost\")\n        assert rv.status_code == 404\n\n    rv = client.get(\"/\", \"http://foo.dev.local\")\n    assert rv.data == b\"subdomain\"",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'default'",
                "assert rv.data == b'default'",
                "assert rv.data == b'default'",
                "assert rv.data == b'default'",
                "assert rv.data == b'subdomain'",
                "assert rv.data == b'default'",
                "assert rv.status_code == 404"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_server_name_subdomain",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1529,
            "end_line_number": 1571,
            "source_code": "def test_server_name_subdomain():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    client = app.test_client()\n\n    @app.route(\"/\")\n    def index():\n        return \"default\"\n\n    @app.route(\"/\", subdomain=\"foo\")\n    def subdomain():\n        return \"subdomain\"\n\n    app.config[\"SERVER_NAME\"] = \"dev.local:5000\"\n    rv = client.get(\"/\")\n    assert rv.data == b\"default\"\n\n    rv = client.get(\"/\", \"http://dev.local:5000\")\n    assert rv.data == b\"default\"\n\n    rv = client.get(\"/\", \"https://dev.local:5000\")\n    assert rv.data == b\"default\"\n\n    app.config[\"SERVER_NAME\"] = \"dev.local:443\"\n    rv = client.get(\"/\", \"https://dev.local\")\n\n    # Werkzeug 1.0 fixes matching https scheme with 443 port\n    if rv.status_code != 404:\n        assert rv.data == b\"default\"\n\n    app.config[\"SERVER_NAME\"] = \"dev.local\"\n    rv = client.get(\"/\", \"https://dev.local\")\n    assert rv.data == b\"default\"\n\n    # suppress Werkzeug 0.15 warning about name mismatch\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\n            \"ignore\", \"Current server name\", UserWarning, \"flask.app\"\n        )\n        rv = client.get(\"/\", \"http://foo.localhost\")\n        assert rv.status_code == 404\n\n    rv = client.get(\"/\", \"http://foo.dev.local\")\n    assert rv.data == b\"subdomain\"",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'default'",
                "assert rv.data == b'default'",
                "assert rv.data == b'default'",
                "assert rv.data == b'default'",
                "assert rv.data == b'subdomain'",
                "assert rv.data == b'default'",
                "assert rv.status_code == 404"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_server_name_subdomain",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1529,
            "end_line_number": 1571,
            "source_code": "def test_server_name_subdomain():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    client = app.test_client()\n\n    @app.route(\"/\")\n    def index():\n        return \"default\"\n\n    @app.route(\"/\", subdomain=\"foo\")\n    def subdomain():\n        return \"subdomain\"\n\n    app.config[\"SERVER_NAME\"] = \"dev.local:5000\"\n    rv = client.get(\"/\")\n    assert rv.data == b\"default\"\n\n    rv = client.get(\"/\", \"http://dev.local:5000\")\n    assert rv.data == b\"default\"\n\n    rv = client.get(\"/\", \"https://dev.local:5000\")\n    assert rv.data == b\"default\"\n\n    app.config[\"SERVER_NAME\"] = \"dev.local:443\"\n    rv = client.get(\"/\", \"https://dev.local\")\n\n    # Werkzeug 1.0 fixes matching https scheme with 443 port\n    if rv.status_code != 404:\n        assert rv.data == b\"default\"\n\n    app.config[\"SERVER_NAME\"] = \"dev.local\"\n    rv = client.get(\"/\", \"https://dev.local\")\n    assert rv.data == b\"default\"\n\n    # suppress Werkzeug 0.15 warning about name mismatch\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\n            \"ignore\", \"Current server name\", UserWarning, \"flask.app\"\n        )\n        rv = client.get(\"/\", \"http://foo.localhost\")\n        assert rv.status_code == 404\n\n    rv = client.get(\"/\", \"http://foo.dev.local\")\n    assert rv.data == b\"subdomain\"",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'default'",
                "assert rv.data == b'default'",
                "assert rv.data == b'default'",
                "assert rv.data == b'default'",
                "assert rv.data == b'subdomain'",
                "assert rv.data == b'default'",
                "assert rv.status_code == 404"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_server_name_subdomain",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1529,
            "end_line_number": 1571,
            "source_code": "def test_server_name_subdomain():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    client = app.test_client()\n\n    @app.route(\"/\")\n    def index():\n        return \"default\"\n\n    @app.route(\"/\", subdomain=\"foo\")\n    def subdomain():\n        return \"subdomain\"\n\n    app.config[\"SERVER_NAME\"] = \"dev.local:5000\"\n    rv = client.get(\"/\")\n    assert rv.data == b\"default\"\n\n    rv = client.get(\"/\", \"http://dev.local:5000\")\n    assert rv.data == b\"default\"\n\n    rv = client.get(\"/\", \"https://dev.local:5000\")\n    assert rv.data == b\"default\"\n\n    app.config[\"SERVER_NAME\"] = \"dev.local:443\"\n    rv = client.get(\"/\", \"https://dev.local\")\n\n    # Werkzeug 1.0 fixes matching https scheme with 443 port\n    if rv.status_code != 404:\n        assert rv.data == b\"default\"\n\n    app.config[\"SERVER_NAME\"] = \"dev.local\"\n    rv = client.get(\"/\", \"https://dev.local\")\n    assert rv.data == b\"default\"\n\n    # suppress Werkzeug 0.15 warning about name mismatch\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\n            \"ignore\", \"Current server name\", UserWarning, \"flask.app\"\n        )\n        rv = client.get(\"/\", \"http://foo.localhost\")\n        assert rv.status_code == 404\n\n    rv = client.get(\"/\", \"http://foo.dev.local\")\n    assert rv.data == b\"subdomain\"",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'default'",
                "assert rv.data == b'default'",
                "assert rv.data == b'default'",
                "assert rv.data == b'default'",
                "assert rv.data == b'subdomain'",
                "assert rv.data == b'default'",
                "assert rv.status_code == 404"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_server_name_subdomain",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1529,
            "end_line_number": 1571,
            "source_code": "def test_server_name_subdomain():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    client = app.test_client()\n\n    @app.route(\"/\")\n    def index():\n        return \"default\"\n\n    @app.route(\"/\", subdomain=\"foo\")\n    def subdomain():\n        return \"subdomain\"\n\n    app.config[\"SERVER_NAME\"] = \"dev.local:5000\"\n    rv = client.get(\"/\")\n    assert rv.data == b\"default\"\n\n    rv = client.get(\"/\", \"http://dev.local:5000\")\n    assert rv.data == b\"default\"\n\n    rv = client.get(\"/\", \"https://dev.local:5000\")\n    assert rv.data == b\"default\"\n\n    app.config[\"SERVER_NAME\"] = \"dev.local:443\"\n    rv = client.get(\"/\", \"https://dev.local\")\n\n    # Werkzeug 1.0 fixes matching https scheme with 443 port\n    if rv.status_code != 404:\n        assert rv.data == b\"default\"\n\n    app.config[\"SERVER_NAME\"] = \"dev.local\"\n    rv = client.get(\"/\", \"https://dev.local\")\n    assert rv.data == b\"default\"\n\n    # suppress Werkzeug 0.15 warning about name mismatch\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\n            \"ignore\", \"Current server name\", UserWarning, \"flask.app\"\n        )\n        rv = client.get(\"/\", \"http://foo.localhost\")\n        assert rv.status_code == 404\n\n    rv = client.get(\"/\", \"http://foo.dev.local\")\n    assert rv.data == b\"subdomain\"",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'default'",
                "assert rv.data == b'default'",
                "assert rv.data == b'default'",
                "assert rv.data == b'default'",
                "assert rv.data == b'subdomain'",
                "assert rv.data == b'default'",
                "assert rv.status_code == 404"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, defaulting to `'None'` if the key `'value'` does not exist.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. It uses `flask.session.get` to access the session data, specifically looking for the key `'value'`. If this key is found, its associated value is returned; if not, the string `'None'` is returned. This method is useful for retrieving session-specific data in a web application context."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_server_name_subdomain",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1529,
            "end_line_number": 1571,
            "source_code": "def test_server_name_subdomain():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    client = app.test_client()\n\n    @app.route(\"/\")\n    def index():\n        return \"default\"\n\n    @app.route(\"/\", subdomain=\"foo\")\n    def subdomain():\n        return \"subdomain\"\n\n    app.config[\"SERVER_NAME\"] = \"dev.local:5000\"\n    rv = client.get(\"/\")\n    assert rv.data == b\"default\"\n\n    rv = client.get(\"/\", \"http://dev.local:5000\")\n    assert rv.data == b\"default\"\n\n    rv = client.get(\"/\", \"https://dev.local:5000\")\n    assert rv.data == b\"default\"\n\n    app.config[\"SERVER_NAME\"] = \"dev.local:443\"\n    rv = client.get(\"/\", \"https://dev.local\")\n\n    # Werkzeug 1.0 fixes matching https scheme with 443 port\n    if rv.status_code != 404:\n        assert rv.data == b\"default\"\n\n    app.config[\"SERVER_NAME\"] = \"dev.local\"\n    rv = client.get(\"/\", \"https://dev.local\")\n    assert rv.data == b\"default\"\n\n    # suppress Werkzeug 0.15 warning about name mismatch\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\n            \"ignore\", \"Current server name\", UserWarning, \"flask.app\"\n        )\n        rv = client.get(\"/\", \"http://foo.localhost\")\n        assert rv.status_code == 404\n\n    rv = client.get(\"/\", \"http://foo.dev.local\")\n    assert rv.data == b\"subdomain\"",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'default'",
                "assert rv.data == b'default'",
                "assert rv.data == b'default'",
                "assert rv.data == b'default'",
                "assert rv.data == b'subdomain'",
                "assert rv.data == b'default'",
                "assert rv.status_code == 404"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_exception_propagation",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1575,
            "end_line_number": 1588,
            "source_code": "def test_exception_propagation(app, client, key):\n    app.testing = False\n\n    @app.route(\"/\")\n    def index():\n        raise ZeroDivisionError\n\n    if key is not None:\n        app.config[key] = True\n\n        with pytest.raises(ZeroDivisionError):\n            client.get(\"/\")\n    else:\n        assert client.get(\"/\").status_code == 500",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('key', ['TESTING', 'PROPAGATE_EXCEPTIONS', 'DEBUG', None])"
            ],
            "arguments": [
                "app",
                "client",
                "key"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').status_code == 500"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, defaulting to `'None'` if the key `'value'` does not exist.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. It uses `flask.session.get` to access the session data, specifically looking for the key `'value'`. If this key is found, its associated value is returned; if not, the string `'None'` is returned. This method is useful for retrieving session-specific data in a web application context."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_exception_propagation",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1575,
            "end_line_number": 1588,
            "source_code": "def test_exception_propagation(app, client, key):\n    app.testing = False\n\n    @app.route(\"/\")\n    def index():\n        raise ZeroDivisionError\n\n    if key is not None:\n        app.config[key] = True\n\n        with pytest.raises(ZeroDivisionError):\n            client.get(\"/\")\n    else:\n        assert client.get(\"/\").status_code == 500",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('key', ['TESTING', 'PROPAGATE_EXCEPTIONS', 'DEBUG', None])"
            ],
            "arguments": [
                "app",
                "client",
                "key"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').status_code == 500"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_werkzeug_passthrough_errors",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1595,
            "end_line_number": 1606,
            "source_code": "def test_werkzeug_passthrough_errors(\n    monkeypatch, debug, use_debugger, use_reloader, propagate_exceptions, app\n):\n    rv = {}\n\n    # Mocks werkzeug.serving.run_simple method\n    def run_simple_mock(*args, **kwargs):\n        rv[\"passthrough_errors\"] = kwargs.get(\"passthrough_errors\")\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n    app.config[\"PROPAGATE_EXCEPTIONS\"] = propagate_exceptions\n    app.run(debug=debug, use_debugger=use_debugger, use_reloader=use_reloader)",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('debug', [True, False])",
                "pytest.mark.parametrize('use_debugger', [True, False])",
                "pytest.mark.parametrize('use_reloader', [True, False])",
                "pytest.mark.parametrize('propagate_exceptions', [None, True, False])"
            ],
            "arguments": [
                "monkeypatch",
                "debug",
                "use_debugger",
                "use_reloader",
                "propagate_exceptions",
                "app"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "kwargs.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `kwargs.get` method is used to retrieve a value from a dictionary (in this case, keyword arguments) safely, providing a default value if the specified key does not exist. This is particularly useful for handling optional parameters in functions or methods.\n\n**How It Works**:\nIn the context of the provided code snippets, `flask.session.get('value', 'None')` utilizes the `get` method to attempt to retrieve the value associated with the key `'value'` from the session. If the key is not found, it returns the string `'None'` as a fallback. This prevents potential `KeyError` exceptions that would occur if you tried to access a non-existent key directly. The method signature is `dict.get(key, default=None)`, where `key` is the item you want to retrieve, and `default` is the value returned if the key is not found."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_url_processors",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1609,
            "end_line_number": 1635,
            "source_code": "def test_url_processors(app, client):\n    @app.url_defaults\n    def add_language_code(endpoint, values):\n        if flask.g.lang_code is not None and app.url_map.is_endpoint_expecting(\n            endpoint, \"lang_code\"\n        ):\n            values.setdefault(\"lang_code\", flask.g.lang_code)\n\n    @app.url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop(\"lang_code\", None)\n\n    @app.route(\"/<lang_code>/\")\n    def index():\n        return flask.url_for(\"about\")\n\n    @app.route(\"/<lang_code>/about\")\n    def about():\n        return flask.url_for(\"something_else\")\n\n    @app.route(\"/foo\")\n    def something_else():\n        return flask.url_for(\"about\", lang_code=\"en\")\n\n    assert client.get(\"/de/\").data == b\"/de/about\"\n    assert client.get(\"/de/about\").data == b\"/foo\"\n    assert client.get(\"/foo\").data == b\"/en/about\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/de/').data == b'/de/about'",
                "assert client.get('/de/about').data == b'/foo'",
                "assert client.get('/foo').data == b'/en/about'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "values.setdefault",
                    "body": "@app.route('/setdefault')\ndef setdefault():\n    return flask.session.setdefault('test', 'default')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `setdefault` method is used to retrieve a value from the session, and if the key does not exist, it sets the key to a specified default value. In this case, it ensures that the session variable `'test'` has a default value of `'default'` if it hasn't been set previously.\n\n**How It Works**:  \nWhen the `/setdefault` route is accessed, the `setdefault` method is called. It attempts to get the value associated with the key `'test'` from the Flask session. If `'test'` is not already in the session, it assigns it the value `'default'`. This is useful for initializing session variables without overwriting existing values, ensuring that the session maintains its state across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_url_processors",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1609,
            "end_line_number": 1635,
            "source_code": "def test_url_processors(app, client):\n    @app.url_defaults\n    def add_language_code(endpoint, values):\n        if flask.g.lang_code is not None and app.url_map.is_endpoint_expecting(\n            endpoint, \"lang_code\"\n        ):\n            values.setdefault(\"lang_code\", flask.g.lang_code)\n\n    @app.url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop(\"lang_code\", None)\n\n    @app.route(\"/<lang_code>/\")\n    def index():\n        return flask.url_for(\"about\")\n\n    @app.route(\"/<lang_code>/about\")\n    def about():\n        return flask.url_for(\"something_else\")\n\n    @app.route(\"/foo\")\n    def something_else():\n        return flask.url_for(\"about\", lang_code=\"en\")\n\n    assert client.get(\"/de/\").data == b\"/de/about\"\n    assert client.get(\"/de/about\").data == b\"/foo\"\n    assert client.get(\"/foo\").data == b\"/en/about\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/de/').data == b'/de/about'",
                "assert client.get('/de/about').data == b'/foo'",
                "assert client.get('/foo').data == b'/en/about'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_url_processors",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1609,
            "end_line_number": 1635,
            "source_code": "def test_url_processors(app, client):\n    @app.url_defaults\n    def add_language_code(endpoint, values):\n        if flask.g.lang_code is not None and app.url_map.is_endpoint_expecting(\n            endpoint, \"lang_code\"\n        ):\n            values.setdefault(\"lang_code\", flask.g.lang_code)\n\n    @app.url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop(\"lang_code\", None)\n\n    @app.route(\"/<lang_code>/\")\n    def index():\n        return flask.url_for(\"about\")\n\n    @app.route(\"/<lang_code>/about\")\n    def about():\n        return flask.url_for(\"something_else\")\n\n    @app.route(\"/foo\")\n    def something_else():\n        return flask.url_for(\"about\", lang_code=\"en\")\n\n    assert client.get(\"/de/\").data == b\"/de/about\"\n    assert client.get(\"/de/about\").data == b\"/foo\"\n    assert client.get(\"/foo\").data == b\"/en/about\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/de/').data == b'/de/about'",
                "assert client.get('/de/about').data == b'/foo'",
                "assert client.get('/foo').data == b'/en/about'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it as a response.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` attempts to fetch the value stored in the session under the key `'value'`. If this key does not exist, it defaults to returning the string `'None'`. The retrieved value is then returned as the HTTP response. This method relies on Flask's session management to store and retrieve user-specific data across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_url_processors",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1609,
            "end_line_number": 1635,
            "source_code": "def test_url_processors(app, client):\n    @app.url_defaults\n    def add_language_code(endpoint, values):\n        if flask.g.lang_code is not None and app.url_map.is_endpoint_expecting(\n            endpoint, \"lang_code\"\n        ):\n            values.setdefault(\"lang_code\", flask.g.lang_code)\n\n    @app.url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop(\"lang_code\", None)\n\n    @app.route(\"/<lang_code>/\")\n    def index():\n        return flask.url_for(\"about\")\n\n    @app.route(\"/<lang_code>/about\")\n    def about():\n        return flask.url_for(\"something_else\")\n\n    @app.route(\"/foo\")\n    def something_else():\n        return flask.url_for(\"about\", lang_code=\"en\")\n\n    assert client.get(\"/de/\").data == b\"/de/about\"\n    assert client.get(\"/de/about\").data == b\"/foo\"\n    assert client.get(\"/foo\").data == b\"/en/about\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/de/').data == b'/de/about'",
                "assert client.get('/de/about').data == b'/foo'",
                "assert client.get('/foo').data == b'/en/about'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, returning it to the client.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. It uses `flask.session.get` to access the session data, specifically looking for a key named `'value'`. If this key does not exist, it defaults to returning the string `'None'`. The retrieved value is then sent back as the response to the client. This method is useful for managing session data in web applications, allowing for state persistence across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_nonascii_pathinfo",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1662,
            "end_line_number": 1668,
            "source_code": "def test_nonascii_pathinfo(app, client):\n    @app.route(\"/\u043a\u0438\u0440\u0442\u0435\u0441\u0442\")\n    def index():\n        return \"Hello World!\"\n\n    rv = client.get(\"/\u043a\u0438\u0440\u0442\u0435\u0441\u0442\")\n    assert rv.data == b\"Hello World!\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'Hello World!'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it as a response.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` attempts to fetch the value stored in the session under the key `'value'`. If this key does not exist, it defaults to returning the string `'None'`. The retrieved value is then returned as the HTTP response. This method relies on Flask's session management to store and retrieve user-specific data across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_no_setup_after_first_request",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1671,
            "end_line_number": 1683,
            "source_code": "def test_no_setup_after_first_request(app, client):\n    app.debug = True\n\n    @app.route(\"/\")\n    def index():\n        return \"Awesome\"\n\n    assert client.get(\"/\").data == b\"Awesome\"\n\n    with pytest.raises(AssertionError) as exc_info:\n        app.add_url_rule(\"/foo\", endpoint=\"late\")\n\n    assert \"setup method 'add_url_rule'\" in str(exc_info.value)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').data == b'Awesome'",
                "assert \"setup method 'add_url_rule'\" in str(exc_info.value)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_routing_redirect_debugging",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1686,
            "end_line_number": 1703,
            "source_code": "def test_routing_redirect_debugging(monkeypatch, app, client):\n    app.config[\"DEBUG\"] = True\n\n    @app.route(\"/user/\", methods=[\"GET\", \"POST\"])\n    def user():\n        return flask.request.form[\"status\"]\n\n    # default redirect code preserves form data\n    rv = client.post(\"/user\", data={\"status\": \"success\"}, follow_redirects=True)\n    assert rv.data == b\"success\"\n\n    # 301 and 302 raise error\n    monkeypatch.setattr(RequestRedirect, \"code\", 301)\n\n    with client, pytest.raises(AssertionError) as exc_info:\n        client.post(\"/user\", data={\"status\": \"error\"}, follow_redirects=True)\n\n    assert \"canonical URL 'http://localhost/user/'\" in str(exc_info.value)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "monkeypatch",
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'success'",
                "assert \"canonical URL 'http://localhost/user/'\" in str(exc_info.value)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.post",
                    "body": "def post(self):\n    return 'Create'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is designed to simulate an HTTP POST request to a specified endpoint, allowing developers to send data to the server, typically for creating or updating resources.\n\n**How It Works**:\nWhen invoked, `client.post` sends a request to the server at the specified URL with the provided data. In the context of the provided code snippets, it is used to test various functionalities such as creating a new post, updating an existing post, and validating input data. The method returns a response indicating the result of the operation, which can be further inspected for status codes or response data. The method is part of a testing framework that helps ensure the application's endpoints behave as expected."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_routing_redirect_debugging",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1686,
            "end_line_number": 1703,
            "source_code": "def test_routing_redirect_debugging(monkeypatch, app, client):\n    app.config[\"DEBUG\"] = True\n\n    @app.route(\"/user/\", methods=[\"GET\", \"POST\"])\n    def user():\n        return flask.request.form[\"status\"]\n\n    # default redirect code preserves form data\n    rv = client.post(\"/user\", data={\"status\": \"success\"}, follow_redirects=True)\n    assert rv.data == b\"success\"\n\n    # 301 and 302 raise error\n    monkeypatch.setattr(RequestRedirect, \"code\", 301)\n\n    with client, pytest.raises(AssertionError) as exc_info:\n        client.post(\"/user\", data={\"status\": \"error\"}, follow_redirects=True)\n\n    assert \"canonical URL 'http://localhost/user/'\" in str(exc_info.value)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "monkeypatch",
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'success'",
                "assert \"canonical URL 'http://localhost/user/'\" in str(exc_info.value)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.post",
                    "body": "def post(self):\n    return 'Create'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is designed to simulate an HTTP POST request to a specified endpoint, allowing developers to send data to the server, typically for creating or updating resources.\n\n**How It Works**:\nWhen invoked, `client.post` sends a request to the server at the specified URL with the provided data. In the context of the provided code snippets, it is used to test various functionalities such as creating a new post, updating an existing post, and validating input data. The method returns a response indicating the result of the operation, which can be further inspected for status codes or response data. The method is part of a testing framework that helps ensure the application's endpoints behave as expected."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_route_decorator_custom_endpoint",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1706,
            "end_line_number": 1728,
            "source_code": "def test_route_decorator_custom_endpoint(app, client):\n    app.debug = True\n\n    @app.route(\"/foo/\")\n    def foo():\n        return flask.request.endpoint\n\n    @app.route(\"/bar/\", endpoint=\"bar\")\n    def for_bar():\n        return flask.request.endpoint\n\n    @app.route(\"/bar/123\", endpoint=\"123\")\n    def for_bar_foo():\n        return flask.request.endpoint\n\n    with app.test_request_context():\n        assert flask.url_for(\"foo\") == \"/foo/\"\n        assert flask.url_for(\"bar\") == \"/bar/\"\n        assert flask.url_for(\"123\") == \"/bar/123\"\n\n    assert client.get(\"/foo/\").data == b\"foo\"\n    assert client.get(\"/bar/\").data == b\"bar\"\n    assert client.get(\"/bar/123\").data == b\"123\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/foo/').data == b'foo'",
                "assert client.get('/bar/').data == b'bar'",
                "assert client.get('/bar/123').data == b'123'",
                "assert flask.url_for('foo') == '/foo/'",
                "assert flask.url_for('bar') == '/bar/'",
                "assert flask.url_for('123') == '/bar/123'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_route_decorator_custom_endpoint",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1706,
            "end_line_number": 1728,
            "source_code": "def test_route_decorator_custom_endpoint(app, client):\n    app.debug = True\n\n    @app.route(\"/foo/\")\n    def foo():\n        return flask.request.endpoint\n\n    @app.route(\"/bar/\", endpoint=\"bar\")\n    def for_bar():\n        return flask.request.endpoint\n\n    @app.route(\"/bar/123\", endpoint=\"123\")\n    def for_bar_foo():\n        return flask.request.endpoint\n\n    with app.test_request_context():\n        assert flask.url_for(\"foo\") == \"/foo/\"\n        assert flask.url_for(\"bar\") == \"/bar/\"\n        assert flask.url_for(\"123\") == \"/bar/123\"\n\n    assert client.get(\"/foo/\").data == b\"foo\"\n    assert client.get(\"/bar/\").data == b\"bar\"\n    assert client.get(\"/bar/123\").data == b\"123\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/foo/').data == b'foo'",
                "assert client.get('/bar/').data == b'bar'",
                "assert client.get('/bar/123').data == b'123'",
                "assert flask.url_for('foo') == '/foo/'",
                "assert flask.url_for('bar') == '/bar/'",
                "assert flask.url_for('123') == '/bar/123'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it as a response.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` attempts to fetch the value stored in the session under the key `'value'`. If this key does not exist, it defaults to returning the string `'None'`. The retrieved value is then returned as the HTTP response. This method relies on Flask's session management to store and retrieve user-specific data across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_route_decorator_custom_endpoint",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1706,
            "end_line_number": 1728,
            "source_code": "def test_route_decorator_custom_endpoint(app, client):\n    app.debug = True\n\n    @app.route(\"/foo/\")\n    def foo():\n        return flask.request.endpoint\n\n    @app.route(\"/bar/\", endpoint=\"bar\")\n    def for_bar():\n        return flask.request.endpoint\n\n    @app.route(\"/bar/123\", endpoint=\"123\")\n    def for_bar_foo():\n        return flask.request.endpoint\n\n    with app.test_request_context():\n        assert flask.url_for(\"foo\") == \"/foo/\"\n        assert flask.url_for(\"bar\") == \"/bar/\"\n        assert flask.url_for(\"123\") == \"/bar/123\"\n\n    assert client.get(\"/foo/\").data == b\"foo\"\n    assert client.get(\"/bar/\").data == b\"bar\"\n    assert client.get(\"/bar/123\").data == b\"123\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/foo/').data == b'foo'",
                "assert client.get('/bar/').data == b'bar'",
                "assert client.get('/bar/123').data == b'123'",
                "assert flask.url_for('foo') == '/foo/'",
                "assert flask.url_for('bar') == '/bar/'",
                "assert flask.url_for('123') == '/bar/123'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_subdomain_basic_support",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1747,
            "end_line_number": 1764,
            "source_code": "def test_subdomain_basic_support():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain\"\n    client = app.test_client()\n\n    @app.route(\"/\")\n    def normal_index():\n        return \"normal index\"\n\n    @app.route(\"/\", subdomain=\"test\")\n    def test_index():\n        return \"test index\"\n\n    rv = client.get(\"/\", \"http://localhost.localdomain/\")\n    assert rv.data == b\"normal index\"\n\n    rv = client.get(\"/\", \"http://test.localhost.localdomain/\")\n    assert rv.data == b\"test index\"",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'normal index'",
                "assert rv.data == b'test index'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_subdomain_basic_support",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1747,
            "end_line_number": 1764,
            "source_code": "def test_subdomain_basic_support():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain\"\n    client = app.test_client()\n\n    @app.route(\"/\")\n    def normal_index():\n        return \"normal index\"\n\n    @app.route(\"/\", subdomain=\"test\")\n    def test_index():\n        return \"test index\"\n\n    rv = client.get(\"/\", \"http://localhost.localdomain/\")\n    assert rv.data == b\"normal index\"\n\n    rv = client.get(\"/\", \"http://test.localhost.localdomain/\")\n    assert rv.data == b\"test index\"",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'normal index'",
                "assert rv.data == b'test index'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_subdomain_matching",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1767,
            "end_line_number": 1777,
            "source_code": "def test_subdomain_matching():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    client = app.test_client()\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain\"\n\n    @app.route(\"/\", subdomain=\"<user>\")\n    def index(user):\n        return f\"index for {user}\"\n\n    rv = client.get(\"/\", \"http://mitsuhiko.localhost.localdomain/\")\n    assert rv.data == b\"index for mitsuhiko\"",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'index for mitsuhiko'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_subdomain_matching_with_ports",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1780,
            "end_line_number": 1790,
            "source_code": "def test_subdomain_matching_with_ports():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain:3000\"\n    client = app.test_client()\n\n    @app.route(\"/\", subdomain=\"<user>\")\n    def index(user):\n        return f\"index for {user}\"\n\n    rv = client.get(\"/\", \"http://mitsuhiko.localhost.localdomain:3000/\")\n    assert rv.data == b\"index for mitsuhiko\"",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'index for mitsuhiko'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_subdomain_matching_other_name",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1794,
            "end_line_number": 1814,
            "source_code": "def test_subdomain_matching_other_name(matching):\n    app = flask.Flask(__name__, subdomain_matching=matching)\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain:3000\"\n    client = app.test_client()\n\n    @app.route(\"/\")\n    def index():\n        return \"\", 204\n\n    # suppress Werkzeug 0.15 warning about name mismatch\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\n            \"ignore\", \"Current server name\", UserWarning, \"flask.app\"\n        )\n        # ip address can't match name\n        rv = client.get(\"/\", \"http://127.0.0.1:3000/\")\n        assert rv.status_code == 404 if matching else 204\n\n    # allow all subdomains if matching is disabled\n    rv = client.get(\"/\", \"http://www.localhost.localdomain:3000/\")\n    assert rv.status_code == 404 if matching else 204",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('matching', (False, True))"
            ],
            "arguments": [
                "matching"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.status_code == 404 if matching else 204",
                "assert rv.status_code == 404 if matching else 204"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, returning it to the client.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. It uses `flask.session.get` to access the session data, specifically looking for a key named `'value'`. If this key does not exist, it defaults to returning the string `'None'`. The retrieved value is then sent back as the response to the client. This method is useful for accessing session data in a web application context."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_subdomain_matching_other_name",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1794,
            "end_line_number": 1814,
            "source_code": "def test_subdomain_matching_other_name(matching):\n    app = flask.Flask(__name__, subdomain_matching=matching)\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain:3000\"\n    client = app.test_client()\n\n    @app.route(\"/\")\n    def index():\n        return \"\", 204\n\n    # suppress Werkzeug 0.15 warning about name mismatch\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\n            \"ignore\", \"Current server name\", UserWarning, \"flask.app\"\n        )\n        # ip address can't match name\n        rv = client.get(\"/\", \"http://127.0.0.1:3000/\")\n        assert rv.status_code == 404 if matching else 204\n\n    # allow all subdomains if matching is disabled\n    rv = client.get(\"/\", \"http://www.localhost.localdomain:3000/\")\n    assert rv.status_code == 404 if matching else 204",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('matching', (False, True))"
            ],
            "arguments": [
                "matching"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.status_code == 404 if matching else 204",
                "assert rv.status_code == 404 if matching else 204"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_max_cookie_size",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1894,
            "end_line_number": 1921,
            "source_code": "def test_max_cookie_size(app, client, recwarn):\n    app.config[\"MAX_COOKIE_SIZE\"] = 100\n\n    # outside app context, default to Werkzeug static value,\n    # which is also the default config\n    response = flask.Response()\n    default = flask.Flask.default_config[\"MAX_COOKIE_SIZE\"]\n    assert response.max_cookie_size == default\n\n    # inside app context, use app config\n    with app.app_context():\n        assert flask.Response().max_cookie_size == 100\n\n    @app.route(\"/\")\n    def index():\n        r = flask.Response(\"\", status=204)\n        r.set_cookie(\"foo\", \"bar\" * 100)\n        return r\n\n    client.get(\"/\")\n    assert len(recwarn) == 1\n    w = recwarn.pop()\n    assert \"cookie is too large\" in str(w.message)\n\n    app.config[\"MAX_COOKIE_SIZE\"] = 0\n\n    client.get(\"/\")\n    assert len(recwarn) == 0",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client",
                "recwarn"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.max_cookie_size == default",
                "assert len(recwarn) == 1",
                "assert 'cookie is too large' in str(w.message)",
                "assert len(recwarn) == 0",
                "assert flask.Response().max_cookie_size == 100"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, returning it to the client.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. It uses `flask.session.get` to access the session data, specifically looking for a key named `'value'`. If this key does not exist, it defaults to returning the string `'None'`. The retrieved value is then sent back as the response to the client. This method is useful for managing session data in web applications, allowing for state persistence across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_max_cookie_size",
            "module": "test_basic",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_basic.py",
            "line_number": 1894,
            "end_line_number": 1921,
            "source_code": "def test_max_cookie_size(app, client, recwarn):\n    app.config[\"MAX_COOKIE_SIZE\"] = 100\n\n    # outside app context, default to Werkzeug static value,\n    # which is also the default config\n    response = flask.Response()\n    default = flask.Flask.default_config[\"MAX_COOKIE_SIZE\"]\n    assert response.max_cookie_size == default\n\n    # inside app context, use app config\n    with app.app_context():\n        assert flask.Response().max_cookie_size == 100\n\n    @app.route(\"/\")\n    def index():\n        r = flask.Response(\"\", status=204)\n        r.set_cookie(\"foo\", \"bar\" * 100)\n        return r\n\n    client.get(\"/\")\n    assert len(recwarn) == 1\n    w = recwarn.pop()\n    assert \"cookie is too large\" in str(w.message)\n\n    app.config[\"MAX_COOKIE_SIZE\"] = 0\n\n    client.get(\"/\")\n    assert len(recwarn) == 0",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client",
                "recwarn"
            ],
            "imports": [
                "gc",
                "re",
                "typing",
                "uuid",
                "warnings",
                "weakref",
                "contextlib.nullcontext",
                "datetime.datetime",
                "datetime.timezone",
                "platform.python_implementation",
                "pytest",
                "werkzeug.serving",
                "markupsafe.Markup",
                "werkzeug.exceptions.BadRequest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.NotFound",
                "werkzeug.http.parse_date",
                "werkzeug.routing.BuildError",
                "werkzeug.routing.RequestRedirect",
                "flask",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "werkzeug.routing.Rule",
                "werkzeug.routing.Submount",
                "flask.debughelpers.DebugFilesKeyError",
                "dataclasses.make_dataclass",
                "pathlib.Path"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.max_cookie_size == default",
                "assert len(recwarn) == 1",
                "assert 'cookie is too large' in str(w.message)",
                "assert len(recwarn) == 0",
                "assert flask.Response().max_cookie_size == 100"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_blueprint_specific_error_handling",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 8,
            "end_line_number": 43,
            "source_code": "def test_blueprint_specific_error_handling(app, client):\n    frontend = flask.Blueprint(\"frontend\", __name__)\n    backend = flask.Blueprint(\"backend\", __name__)\n    sideend = flask.Blueprint(\"sideend\", __name__)\n\n    @frontend.errorhandler(403)\n    def frontend_forbidden(e):\n        return \"frontend says no\", 403\n\n    @frontend.route(\"/frontend-no\")\n    def frontend_no():\n        flask.abort(403)\n\n    @backend.errorhandler(403)\n    def backend_forbidden(e):\n        return \"backend says no\", 403\n\n    @backend.route(\"/backend-no\")\n    def backend_no():\n        flask.abort(403)\n\n    @sideend.route(\"/what-is-a-sideend\")\n    def sideend_no():\n        flask.abort(403)\n\n    app.register_blueprint(frontend)\n    app.register_blueprint(backend)\n    app.register_blueprint(sideend)\n\n    @app.errorhandler(403)\n    def app_forbidden(e):\n        return \"application itself says no\", 403\n\n    assert client.get(\"/frontend-no\").data == b\"frontend says no\"\n    assert client.get(\"/backend-no\").data == b\"backend says no\"\n    assert client.get(\"/what-is-a-sideend\").data == b\"application itself says no\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/frontend-no').data == b'frontend says no'",
                "assert client.get('/backend-no').data == b'backend says no'",
                "assert client.get('/what-is-a-sideend').data == b'application itself says no'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_blueprint_specific_error_handling",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 8,
            "end_line_number": 43,
            "source_code": "def test_blueprint_specific_error_handling(app, client):\n    frontend = flask.Blueprint(\"frontend\", __name__)\n    backend = flask.Blueprint(\"backend\", __name__)\n    sideend = flask.Blueprint(\"sideend\", __name__)\n\n    @frontend.errorhandler(403)\n    def frontend_forbidden(e):\n        return \"frontend says no\", 403\n\n    @frontend.route(\"/frontend-no\")\n    def frontend_no():\n        flask.abort(403)\n\n    @backend.errorhandler(403)\n    def backend_forbidden(e):\n        return \"backend says no\", 403\n\n    @backend.route(\"/backend-no\")\n    def backend_no():\n        flask.abort(403)\n\n    @sideend.route(\"/what-is-a-sideend\")\n    def sideend_no():\n        flask.abort(403)\n\n    app.register_blueprint(frontend)\n    app.register_blueprint(backend)\n    app.register_blueprint(sideend)\n\n    @app.errorhandler(403)\n    def app_forbidden(e):\n        return \"application itself says no\", 403\n\n    assert client.get(\"/frontend-no\").data == b\"frontend says no\"\n    assert client.get(\"/backend-no\").data == b\"backend says no\"\n    assert client.get(\"/what-is-a-sideend\").data == b\"application itself says no\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/frontend-no').data == b'frontend says no'",
                "assert client.get('/backend-no').data == b'backend says no'",
                "assert client.get('/what-is-a-sideend').data == b'application itself says no'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_blueprint_specific_error_handling",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 8,
            "end_line_number": 43,
            "source_code": "def test_blueprint_specific_error_handling(app, client):\n    frontend = flask.Blueprint(\"frontend\", __name__)\n    backend = flask.Blueprint(\"backend\", __name__)\n    sideend = flask.Blueprint(\"sideend\", __name__)\n\n    @frontend.errorhandler(403)\n    def frontend_forbidden(e):\n        return \"frontend says no\", 403\n\n    @frontend.route(\"/frontend-no\")\n    def frontend_no():\n        flask.abort(403)\n\n    @backend.errorhandler(403)\n    def backend_forbidden(e):\n        return \"backend says no\", 403\n\n    @backend.route(\"/backend-no\")\n    def backend_no():\n        flask.abort(403)\n\n    @sideend.route(\"/what-is-a-sideend\")\n    def sideend_no():\n        flask.abort(403)\n\n    app.register_blueprint(frontend)\n    app.register_blueprint(backend)\n    app.register_blueprint(sideend)\n\n    @app.errorhandler(403)\n    def app_forbidden(e):\n        return \"application itself says no\", 403\n\n    assert client.get(\"/frontend-no\").data == b\"frontend says no\"\n    assert client.get(\"/backend-no\").data == b\"backend says no\"\n    assert client.get(\"/what-is-a-sideend\").data == b\"application itself says no\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/frontend-no').data == b'frontend says no'",
                "assert client.get('/backend-no').data == b'backend says no'",
                "assert client.get('/what-is-a-sideend').data == b'application itself says no'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_blueprint_specific_user_error_handling",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 46,
            "end_line_number": 77,
            "source_code": "def test_blueprint_specific_user_error_handling(app, client):\n    class MyDecoratorException(Exception):\n        pass\n\n    class MyFunctionException(Exception):\n        pass\n\n    blue = flask.Blueprint(\"blue\", __name__)\n\n    @blue.errorhandler(MyDecoratorException)\n    def my_decorator_exception_handler(e):\n        assert isinstance(e, MyDecoratorException)\n        return \"boom\"\n\n    def my_function_exception_handler(e):\n        assert isinstance(e, MyFunctionException)\n        return \"bam\"\n\n    blue.register_error_handler(MyFunctionException, my_function_exception_handler)\n\n    @blue.route(\"/decorator\")\n    def blue_deco_test():\n        raise MyDecoratorException()\n\n    @blue.route(\"/function\")\n    def blue_func_test():\n        raise MyFunctionException()\n\n    app.register_blueprint(blue)\n\n    assert client.get(\"/decorator\").data == b\"boom\"\n    assert client.get(\"/function\").data == b\"bam\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/decorator').data == b'boom'",
                "assert client.get('/function').data == b'bam'",
                "assert isinstance(e, MyDecoratorException)",
                "assert isinstance(e, MyFunctionException)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, defaulting to `'None'` if the key `'value'` does not exist.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. It uses `flask.session.get` to access the session data, specifically looking for the key `'value'`. If this key is found, its associated value is returned; otherwise, the string `'None'` is returned. This method is useful for retrieving session-specific data in a web application context."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_blueprint_specific_user_error_handling",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 46,
            "end_line_number": 77,
            "source_code": "def test_blueprint_specific_user_error_handling(app, client):\n    class MyDecoratorException(Exception):\n        pass\n\n    class MyFunctionException(Exception):\n        pass\n\n    blue = flask.Blueprint(\"blue\", __name__)\n\n    @blue.errorhandler(MyDecoratorException)\n    def my_decorator_exception_handler(e):\n        assert isinstance(e, MyDecoratorException)\n        return \"boom\"\n\n    def my_function_exception_handler(e):\n        assert isinstance(e, MyFunctionException)\n        return \"bam\"\n\n    blue.register_error_handler(MyFunctionException, my_function_exception_handler)\n\n    @blue.route(\"/decorator\")\n    def blue_deco_test():\n        raise MyDecoratorException()\n\n    @blue.route(\"/function\")\n    def blue_func_test():\n        raise MyFunctionException()\n\n    app.register_blueprint(blue)\n\n    assert client.get(\"/decorator\").data == b\"boom\"\n    assert client.get(\"/function\").data == b\"bam\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/decorator').data == b'boom'",
                "assert client.get('/function').data == b'bam'",
                "assert isinstance(e, MyDecoratorException)",
                "assert isinstance(e, MyFunctionException)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. Finally, the retrieved value is returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_blueprint_app_error_handling",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 80,
            "end_line_number": 101,
            "source_code": "def test_blueprint_app_error_handling(app, client):\n    errors = flask.Blueprint(\"errors\", __name__)\n\n    @errors.app_errorhandler(403)\n    def forbidden_handler(e):\n        return \"you shall not pass\", 403\n\n    @app.route(\"/forbidden\")\n    def app_forbidden():\n        flask.abort(403)\n\n    forbidden_bp = flask.Blueprint(\"forbidden_bp\", __name__)\n\n    @forbidden_bp.route(\"/nope\")\n    def bp_forbidden():\n        flask.abort(403)\n\n    app.register_blueprint(errors)\n    app.register_blueprint(forbidden_bp)\n\n    assert client.get(\"/forbidden\").data == b\"you shall not pass\"\n    assert client.get(\"/nope\").data == b\"you shall not pass\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/forbidden').data == b'you shall not pass'",
                "assert client.get('/nope').data == b'you shall not pass'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, returning it to the client.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. It uses `flask.session.get` to access the session data, specifically looking for a key named `'value'`. If this key does not exist, it defaults to returning the string `'None'`. The retrieved value is then sent back as the response to the client. This method is useful for accessing session data in a web application context."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_blueprint_app_error_handling",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 80,
            "end_line_number": 101,
            "source_code": "def test_blueprint_app_error_handling(app, client):\n    errors = flask.Blueprint(\"errors\", __name__)\n\n    @errors.app_errorhandler(403)\n    def forbidden_handler(e):\n        return \"you shall not pass\", 403\n\n    @app.route(\"/forbidden\")\n    def app_forbidden():\n        flask.abort(403)\n\n    forbidden_bp = flask.Blueprint(\"forbidden_bp\", __name__)\n\n    @forbidden_bp.route(\"/nope\")\n    def bp_forbidden():\n        flask.abort(403)\n\n    app.register_blueprint(errors)\n    app.register_blueprint(forbidden_bp)\n\n    assert client.get(\"/forbidden\").data == b\"you shall not pass\"\n    assert client.get(\"/nope\").data == b\"you shall not pass\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/forbidden').data == b'you shall not pass'",
                "assert client.get('/nope').data == b'you shall not pass'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_blueprint_prefix_slash",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 120,
            "end_line_number": 128,
            "source_code": "def test_blueprint_prefix_slash(app, client, prefix, rule, url):\n    bp = flask.Blueprint(\"test\", __name__, url_prefix=prefix)\n\n    @bp.route(rule)\n    def index():\n        return \"\", 204\n\n    app.register_blueprint(bp)\n    assert client.get(url).status_code == 204",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize(('prefix', 'rule', 'url'), (('', '/', '/'), ('/', '', '/'), ('/', '/', '/'), ('/foo', '', '/foo'), ('/foo/', '', '/foo/'), ('', '/bar', '/bar'), ('/foo/', '/bar', '/foo/bar'), ('/foo/', 'bar', '/foo/bar'), ('/foo', '/bar', '/foo/bar'), ('/foo/', '//bar', '/foo/bar'), ('/foo//', '/bar', '/foo/bar')))"
            ],
            "arguments": [
                "app",
                "client",
                "prefix",
                "rule",
                "url"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get(url).status_code == 204"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is used to define a route in a Flask web application that retrieves a value stored in the session. If the session does not contain the specified value, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nThe method is decorated with `@app.route('/get')`, which maps the URL path `/get` to the `get` function. When a GET request is made to this endpoint, the function accesses the session using `flask.session.get('value', 'None')`. This retrieves the value associated with the key `'value'` from the session; if it does not exist, it returns `'None'`. The retrieved value is then returned as the response to the client. This allows for session data to be accessed and utilized in web applications, facilitating state management across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_blueprint_url_defaults",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 131,
            "end_line_number": 148,
            "source_code": "def test_blueprint_url_defaults(app, client):\n    bp = flask.Blueprint(\"test\", __name__)\n\n    @bp.route(\"/foo\", defaults={\"baz\": 42})\n    def foo(bar, baz):\n        return f\"{bar}/{baz:d}\"\n\n    @bp.route(\"/bar\")\n    def bar(bar):\n        return str(bar)\n\n    app.register_blueprint(bp, url_prefix=\"/1\", url_defaults={\"bar\": 23})\n    app.register_blueprint(bp, name=\"test2\", url_prefix=\"/2\", url_defaults={\"bar\": 19})\n\n    assert client.get(\"/1/foo\").data == b\"23/42\"\n    assert client.get(\"/2/foo\").data == b\"19/42\"\n    assert client.get(\"/1/bar\").data == b\"23\"\n    assert client.get(\"/2/bar\").data == b\"19\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/1/foo').data == b'23/42'",
                "assert client.get('/2/foo').data == b'19/42'",
                "assert client.get('/1/bar').data == b'23'",
                "assert client.get('/2/bar').data == b'19'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_blueprint_url_defaults",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 131,
            "end_line_number": 148,
            "source_code": "def test_blueprint_url_defaults(app, client):\n    bp = flask.Blueprint(\"test\", __name__)\n\n    @bp.route(\"/foo\", defaults={\"baz\": 42})\n    def foo(bar, baz):\n        return f\"{bar}/{baz:d}\"\n\n    @bp.route(\"/bar\")\n    def bar(bar):\n        return str(bar)\n\n    app.register_blueprint(bp, url_prefix=\"/1\", url_defaults={\"bar\": 23})\n    app.register_blueprint(bp, name=\"test2\", url_prefix=\"/2\", url_defaults={\"bar\": 19})\n\n    assert client.get(\"/1/foo\").data == b\"23/42\"\n    assert client.get(\"/2/foo\").data == b\"19/42\"\n    assert client.get(\"/1/bar\").data == b\"23\"\n    assert client.get(\"/2/bar\").data == b\"19\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/1/foo').data == b'23/42'",
                "assert client.get('/2/foo').data == b'19/42'",
                "assert client.get('/1/bar').data == b'23'",
                "assert client.get('/2/bar').data == b'19'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_blueprint_url_defaults",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 131,
            "end_line_number": 148,
            "source_code": "def test_blueprint_url_defaults(app, client):\n    bp = flask.Blueprint(\"test\", __name__)\n\n    @bp.route(\"/foo\", defaults={\"baz\": 42})\n    def foo(bar, baz):\n        return f\"{bar}/{baz:d}\"\n\n    @bp.route(\"/bar\")\n    def bar(bar):\n        return str(bar)\n\n    app.register_blueprint(bp, url_prefix=\"/1\", url_defaults={\"bar\": 23})\n    app.register_blueprint(bp, name=\"test2\", url_prefix=\"/2\", url_defaults={\"bar\": 19})\n\n    assert client.get(\"/1/foo\").data == b\"23/42\"\n    assert client.get(\"/2/foo\").data == b\"19/42\"\n    assert client.get(\"/1/bar\").data == b\"23\"\n    assert client.get(\"/2/bar\").data == b\"19\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/1/foo').data == b'23/42'",
                "assert client.get('/2/foo').data == b'19/42'",
                "assert client.get('/1/bar').data == b'23'",
                "assert client.get('/2/bar').data == b'19'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_blueprint_url_defaults",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 131,
            "end_line_number": 148,
            "source_code": "def test_blueprint_url_defaults(app, client):\n    bp = flask.Blueprint(\"test\", __name__)\n\n    @bp.route(\"/foo\", defaults={\"baz\": 42})\n    def foo(bar, baz):\n        return f\"{bar}/{baz:d}\"\n\n    @bp.route(\"/bar\")\n    def bar(bar):\n        return str(bar)\n\n    app.register_blueprint(bp, url_prefix=\"/1\", url_defaults={\"bar\": 23})\n    app.register_blueprint(bp, name=\"test2\", url_prefix=\"/2\", url_defaults={\"bar\": 19})\n\n    assert client.get(\"/1/foo\").data == b\"23/42\"\n    assert client.get(\"/2/foo\").data == b\"19/42\"\n    assert client.get(\"/1/bar\").data == b\"23\"\n    assert client.get(\"/2/bar\").data == b\"19\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/1/foo').data == b'23/42'",
                "assert client.get('/2/foo').data == b'19/42'",
                "assert client.get('/1/bar').data == b'23'",
                "assert client.get('/2/bar').data == b'19'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_blueprint_url_processors",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 151,
            "end_line_number": 173,
            "source_code": "def test_blueprint_url_processors(app, client):\n    bp = flask.Blueprint(\"frontend\", __name__, url_prefix=\"/<lang_code>\")\n\n    @bp.url_defaults\n    def add_language_code(endpoint, values):\n        values.setdefault(\"lang_code\", flask.g.lang_code)\n\n    @bp.url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop(\"lang_code\")\n\n    @bp.route(\"/\")\n    def index():\n        return flask.url_for(\".about\")\n\n    @bp.route(\"/about\")\n    def about():\n        return flask.url_for(\".index\")\n\n    app.register_blueprint(bp)\n\n    assert client.get(\"/de/\").data == b\"/de/about\"\n    assert client.get(\"/de/about\").data == b\"/de/\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/de/').data == b'/de/about'",
                "assert client.get('/de/about').data == b'/de/'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "values.setdefault",
                    "body": "@app.route('/setdefault')\ndef setdefault():\n    return flask.session.setdefault('test', 'default')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `setdefault` method is used to retrieve a value from the session, and if the specified key does not exist, it sets the key to a default value. In this case, it ensures that the session variable `'test'` has a value, defaulting to `'default'` if it is not already set.\n\n**How It Works**:  \nWhen the `/setdefault` route is accessed, the `setdefault` method is called. It attempts to get the value associated with the key `'test'` from the Flask session. If `'test'` is not present in the session, it assigns it the value `'default'`. This is useful for initializing session variables without overwriting existing values, ensuring that the session maintains its state across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_blueprint_url_processors",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 151,
            "end_line_number": 173,
            "source_code": "def test_blueprint_url_processors(app, client):\n    bp = flask.Blueprint(\"frontend\", __name__, url_prefix=\"/<lang_code>\")\n\n    @bp.url_defaults\n    def add_language_code(endpoint, values):\n        values.setdefault(\"lang_code\", flask.g.lang_code)\n\n    @bp.url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop(\"lang_code\")\n\n    @bp.route(\"/\")\n    def index():\n        return flask.url_for(\".about\")\n\n    @bp.route(\"/about\")\n    def about():\n        return flask.url_for(\".index\")\n\n    app.register_blueprint(bp)\n\n    assert client.get(\"/de/\").data == b\"/de/about\"\n    assert client.get(\"/de/about\").data == b\"/de/\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/de/').data == b'/de/about'",
                "assert client.get('/de/about').data == b'/de/'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_blueprint_url_processors",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 151,
            "end_line_number": 173,
            "source_code": "def test_blueprint_url_processors(app, client):\n    bp = flask.Blueprint(\"frontend\", __name__, url_prefix=\"/<lang_code>\")\n\n    @bp.url_defaults\n    def add_language_code(endpoint, values):\n        values.setdefault(\"lang_code\", flask.g.lang_code)\n\n    @bp.url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop(\"lang_code\")\n\n    @bp.route(\"/\")\n    def index():\n        return flask.url_for(\".about\")\n\n    @bp.route(\"/about\")\n    def about():\n        return flask.url_for(\".index\")\n\n    app.register_blueprint(bp)\n\n    assert client.get(\"/de/\").data == b\"/de/about\"\n    assert client.get(\"/de/about\").data == b\"/de/\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/de/').data == b'/de/about'",
                "assert client.get('/de/about').data == b'/de/'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it as a response.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` attempts to fetch the value stored in the session under the key `'value'`. If this key does not exist, it defaults to returning the string `'None'`. The retrieved value is then returned as the HTTP response. This method relies on Flask's session management to store and retrieve user-specific data across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_templates_and_static",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 176,
            "end_line_number": 220,
            "source_code": "def test_templates_and_static(test_apps):\n    from blueprintapp import app\n\n    client = app.test_client()\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"Hello from the Frontend\"\n    rv = client.get(\"/admin/\")\n    assert rv.data == b\"Hello from the Admin\"\n    rv = client.get(\"/admin/index2\")\n    assert rv.data == b\"Hello from the Admin\"\n    rv = client.get(\"/admin/static/test.txt\")\n    assert rv.data.strip() == b\"Admin File\"\n    rv.close()\n    rv = client.get(\"/admin/static/css/test.css\")\n    assert rv.data.strip() == b\"/* nested file */\"\n    rv.close()\n\n    # try/finally, in case other tests use this app for Blueprint tests.\n    max_age_default = app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n    try:\n        expected_max_age = 3600\n        if app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] == expected_max_age:\n            expected_max_age = 7200\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = expected_max_age\n        rv = client.get(\"/admin/static/css/test.css\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == expected_max_age\n        rv.close()\n    finally:\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = max_age_default\n\n    with app.test_request_context():\n        assert (\n            flask.url_for(\"admin.static\", filename=\"test.txt\")\n            == \"/admin/static/test.txt\"\n        )\n\n    with app.test_request_context():\n        with pytest.raises(TemplateNotFound) as e:\n            flask.render_template(\"missing.html\")\n        assert e.value.name == \"missing.html\"\n\n    with flask.Flask(__name__).test_request_context():\n        assert flask.render_template(\"nested/nested.txt\") == \"I'm nested\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "test_apps"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'Hello from the Frontend'",
                "assert rv.data == b'Hello from the Admin'",
                "assert rv.data == b'Hello from the Admin'",
                "assert rv.data.strip() == b'Admin File'",
                "assert rv.data.strip() == b'/* nested file */'",
                "assert cc.max_age == expected_max_age",
                "assert flask.url_for('admin.static', filename='test.txt') == '/admin/static/test.txt'",
                "assert e.value.name == 'missing.html'",
                "assert flask.render_template('nested/nested.txt') == \"I'm nested\""
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. Finally, the retrieved value is returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_templates_and_static",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 176,
            "end_line_number": 220,
            "source_code": "def test_templates_and_static(test_apps):\n    from blueprintapp import app\n\n    client = app.test_client()\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"Hello from the Frontend\"\n    rv = client.get(\"/admin/\")\n    assert rv.data == b\"Hello from the Admin\"\n    rv = client.get(\"/admin/index2\")\n    assert rv.data == b\"Hello from the Admin\"\n    rv = client.get(\"/admin/static/test.txt\")\n    assert rv.data.strip() == b\"Admin File\"\n    rv.close()\n    rv = client.get(\"/admin/static/css/test.css\")\n    assert rv.data.strip() == b\"/* nested file */\"\n    rv.close()\n\n    # try/finally, in case other tests use this app for Blueprint tests.\n    max_age_default = app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n    try:\n        expected_max_age = 3600\n        if app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] == expected_max_age:\n            expected_max_age = 7200\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = expected_max_age\n        rv = client.get(\"/admin/static/css/test.css\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == expected_max_age\n        rv.close()\n    finally:\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = max_age_default\n\n    with app.test_request_context():\n        assert (\n            flask.url_for(\"admin.static\", filename=\"test.txt\")\n            == \"/admin/static/test.txt\"\n        )\n\n    with app.test_request_context():\n        with pytest.raises(TemplateNotFound) as e:\n            flask.render_template(\"missing.html\")\n        assert e.value.name == \"missing.html\"\n\n    with flask.Flask(__name__).test_request_context():\n        assert flask.render_template(\"nested/nested.txt\") == \"I'm nested\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "test_apps"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'Hello from the Frontend'",
                "assert rv.data == b'Hello from the Admin'",
                "assert rv.data == b'Hello from the Admin'",
                "assert rv.data.strip() == b'Admin File'",
                "assert rv.data.strip() == b'/* nested file */'",
                "assert cc.max_age == expected_max_age",
                "assert flask.url_for('admin.static', filename='test.txt') == '/admin/static/test.txt'",
                "assert e.value.name == 'missing.html'",
                "assert flask.render_template('nested/nested.txt') == \"I'm nested\""
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_templates_and_static",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 176,
            "end_line_number": 220,
            "source_code": "def test_templates_and_static(test_apps):\n    from blueprintapp import app\n\n    client = app.test_client()\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"Hello from the Frontend\"\n    rv = client.get(\"/admin/\")\n    assert rv.data == b\"Hello from the Admin\"\n    rv = client.get(\"/admin/index2\")\n    assert rv.data == b\"Hello from the Admin\"\n    rv = client.get(\"/admin/static/test.txt\")\n    assert rv.data.strip() == b\"Admin File\"\n    rv.close()\n    rv = client.get(\"/admin/static/css/test.css\")\n    assert rv.data.strip() == b\"/* nested file */\"\n    rv.close()\n\n    # try/finally, in case other tests use this app for Blueprint tests.\n    max_age_default = app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n    try:\n        expected_max_age = 3600\n        if app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] == expected_max_age:\n            expected_max_age = 7200\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = expected_max_age\n        rv = client.get(\"/admin/static/css/test.css\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == expected_max_age\n        rv.close()\n    finally:\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = max_age_default\n\n    with app.test_request_context():\n        assert (\n            flask.url_for(\"admin.static\", filename=\"test.txt\")\n            == \"/admin/static/test.txt\"\n        )\n\n    with app.test_request_context():\n        with pytest.raises(TemplateNotFound) as e:\n            flask.render_template(\"missing.html\")\n        assert e.value.name == \"missing.html\"\n\n    with flask.Flask(__name__).test_request_context():\n        assert flask.render_template(\"nested/nested.txt\") == \"I'm nested\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "test_apps"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'Hello from the Frontend'",
                "assert rv.data == b'Hello from the Admin'",
                "assert rv.data == b'Hello from the Admin'",
                "assert rv.data.strip() == b'Admin File'",
                "assert rv.data.strip() == b'/* nested file */'",
                "assert cc.max_age == expected_max_age",
                "assert flask.url_for('admin.static', filename='test.txt') == '/admin/static/test.txt'",
                "assert e.value.name == 'missing.html'",
                "assert flask.render_template('nested/nested.txt') == \"I'm nested\""
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_templates_and_static",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 176,
            "end_line_number": 220,
            "source_code": "def test_templates_and_static(test_apps):\n    from blueprintapp import app\n\n    client = app.test_client()\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"Hello from the Frontend\"\n    rv = client.get(\"/admin/\")\n    assert rv.data == b\"Hello from the Admin\"\n    rv = client.get(\"/admin/index2\")\n    assert rv.data == b\"Hello from the Admin\"\n    rv = client.get(\"/admin/static/test.txt\")\n    assert rv.data.strip() == b\"Admin File\"\n    rv.close()\n    rv = client.get(\"/admin/static/css/test.css\")\n    assert rv.data.strip() == b\"/* nested file */\"\n    rv.close()\n\n    # try/finally, in case other tests use this app for Blueprint tests.\n    max_age_default = app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n    try:\n        expected_max_age = 3600\n        if app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] == expected_max_age:\n            expected_max_age = 7200\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = expected_max_age\n        rv = client.get(\"/admin/static/css/test.css\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == expected_max_age\n        rv.close()\n    finally:\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = max_age_default\n\n    with app.test_request_context():\n        assert (\n            flask.url_for(\"admin.static\", filename=\"test.txt\")\n            == \"/admin/static/test.txt\"\n        )\n\n    with app.test_request_context():\n        with pytest.raises(TemplateNotFound) as e:\n            flask.render_template(\"missing.html\")\n        assert e.value.name == \"missing.html\"\n\n    with flask.Flask(__name__).test_request_context():\n        assert flask.render_template(\"nested/nested.txt\") == \"I'm nested\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "test_apps"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'Hello from the Frontend'",
                "assert rv.data == b'Hello from the Admin'",
                "assert rv.data == b'Hello from the Admin'",
                "assert rv.data.strip() == b'Admin File'",
                "assert rv.data.strip() == b'/* nested file */'",
                "assert cc.max_age == expected_max_age",
                "assert flask.url_for('admin.static', filename='test.txt') == '/admin/static/test.txt'",
                "assert e.value.name == 'missing.html'",
                "assert flask.render_template('nested/nested.txt') == \"I'm nested\""
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_templates_and_static",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 176,
            "end_line_number": 220,
            "source_code": "def test_templates_and_static(test_apps):\n    from blueprintapp import app\n\n    client = app.test_client()\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"Hello from the Frontend\"\n    rv = client.get(\"/admin/\")\n    assert rv.data == b\"Hello from the Admin\"\n    rv = client.get(\"/admin/index2\")\n    assert rv.data == b\"Hello from the Admin\"\n    rv = client.get(\"/admin/static/test.txt\")\n    assert rv.data.strip() == b\"Admin File\"\n    rv.close()\n    rv = client.get(\"/admin/static/css/test.css\")\n    assert rv.data.strip() == b\"/* nested file */\"\n    rv.close()\n\n    # try/finally, in case other tests use this app for Blueprint tests.\n    max_age_default = app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n    try:\n        expected_max_age = 3600\n        if app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] == expected_max_age:\n            expected_max_age = 7200\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = expected_max_age\n        rv = client.get(\"/admin/static/css/test.css\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == expected_max_age\n        rv.close()\n    finally:\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = max_age_default\n\n    with app.test_request_context():\n        assert (\n            flask.url_for(\"admin.static\", filename=\"test.txt\")\n            == \"/admin/static/test.txt\"\n        )\n\n    with app.test_request_context():\n        with pytest.raises(TemplateNotFound) as e:\n            flask.render_template(\"missing.html\")\n        assert e.value.name == \"missing.html\"\n\n    with flask.Flask(__name__).test_request_context():\n        assert flask.render_template(\"nested/nested.txt\") == \"I'm nested\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "test_apps"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'Hello from the Frontend'",
                "assert rv.data == b'Hello from the Admin'",
                "assert rv.data == b'Hello from the Admin'",
                "assert rv.data.strip() == b'Admin File'",
                "assert rv.data.strip() == b'/* nested file */'",
                "assert cc.max_age == expected_max_age",
                "assert flask.url_for('admin.static', filename='test.txt') == '/admin/static/test.txt'",
                "assert e.value.name == 'missing.html'",
                "assert flask.render_template('nested/nested.txt') == \"I'm nested\""
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "rv.close",
                    "body": "def close(self):\n    called.append(42)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically related to resource management, by appending a specific value (42) to a list named `called`. This indicates that the method has been invoked, which can be useful for tracking or debugging purposes.\n\n**How It Works**:  \nWhen the `close` method is called, it executes a single line of code that appends the integer 42 to the `called` list. This action serves as a simple signal that the method has been executed, allowing developers to verify that the cleanup process has occurred. The method does not return any value or perform any additional operations beyond this append action."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_templates_and_static",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 176,
            "end_line_number": 220,
            "source_code": "def test_templates_and_static(test_apps):\n    from blueprintapp import app\n\n    client = app.test_client()\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"Hello from the Frontend\"\n    rv = client.get(\"/admin/\")\n    assert rv.data == b\"Hello from the Admin\"\n    rv = client.get(\"/admin/index2\")\n    assert rv.data == b\"Hello from the Admin\"\n    rv = client.get(\"/admin/static/test.txt\")\n    assert rv.data.strip() == b\"Admin File\"\n    rv.close()\n    rv = client.get(\"/admin/static/css/test.css\")\n    assert rv.data.strip() == b\"/* nested file */\"\n    rv.close()\n\n    # try/finally, in case other tests use this app for Blueprint tests.\n    max_age_default = app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n    try:\n        expected_max_age = 3600\n        if app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] == expected_max_age:\n            expected_max_age = 7200\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = expected_max_age\n        rv = client.get(\"/admin/static/css/test.css\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == expected_max_age\n        rv.close()\n    finally:\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = max_age_default\n\n    with app.test_request_context():\n        assert (\n            flask.url_for(\"admin.static\", filename=\"test.txt\")\n            == \"/admin/static/test.txt\"\n        )\n\n    with app.test_request_context():\n        with pytest.raises(TemplateNotFound) as e:\n            flask.render_template(\"missing.html\")\n        assert e.value.name == \"missing.html\"\n\n    with flask.Flask(__name__).test_request_context():\n        assert flask.render_template(\"nested/nested.txt\") == \"I'm nested\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "test_apps"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'Hello from the Frontend'",
                "assert rv.data == b'Hello from the Admin'",
                "assert rv.data == b'Hello from the Admin'",
                "assert rv.data.strip() == b'Admin File'",
                "assert rv.data.strip() == b'/* nested file */'",
                "assert cc.max_age == expected_max_age",
                "assert flask.url_for('admin.static', filename='test.txt') == '/admin/static/test.txt'",
                "assert e.value.name == 'missing.html'",
                "assert flask.render_template('nested/nested.txt') == \"I'm nested\""
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it as a response.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` attempts to fetch the value stored in the session under the key `'value'`. If this key does not exist, it defaults to returning the string `'None'`. The retrieved value is then returned as the HTTP response. This method relies on Flask's session management to store and retrieve user-specific data across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_templates_and_static",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 176,
            "end_line_number": 220,
            "source_code": "def test_templates_and_static(test_apps):\n    from blueprintapp import app\n\n    client = app.test_client()\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"Hello from the Frontend\"\n    rv = client.get(\"/admin/\")\n    assert rv.data == b\"Hello from the Admin\"\n    rv = client.get(\"/admin/index2\")\n    assert rv.data == b\"Hello from the Admin\"\n    rv = client.get(\"/admin/static/test.txt\")\n    assert rv.data.strip() == b\"Admin File\"\n    rv.close()\n    rv = client.get(\"/admin/static/css/test.css\")\n    assert rv.data.strip() == b\"/* nested file */\"\n    rv.close()\n\n    # try/finally, in case other tests use this app for Blueprint tests.\n    max_age_default = app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n    try:\n        expected_max_age = 3600\n        if app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] == expected_max_age:\n            expected_max_age = 7200\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = expected_max_age\n        rv = client.get(\"/admin/static/css/test.css\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == expected_max_age\n        rv.close()\n    finally:\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = max_age_default\n\n    with app.test_request_context():\n        assert (\n            flask.url_for(\"admin.static\", filename=\"test.txt\")\n            == \"/admin/static/test.txt\"\n        )\n\n    with app.test_request_context():\n        with pytest.raises(TemplateNotFound) as e:\n            flask.render_template(\"missing.html\")\n        assert e.value.name == \"missing.html\"\n\n    with flask.Flask(__name__).test_request_context():\n        assert flask.render_template(\"nested/nested.txt\") == \"I'm nested\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "test_apps"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'Hello from the Frontend'",
                "assert rv.data == b'Hello from the Admin'",
                "assert rv.data == b'Hello from the Admin'",
                "assert rv.data.strip() == b'Admin File'",
                "assert rv.data.strip() == b'/* nested file */'",
                "assert cc.max_age == expected_max_age",
                "assert flask.url_for('admin.static', filename='test.txt') == '/admin/static/test.txt'",
                "assert e.value.name == 'missing.html'",
                "assert flask.render_template('nested/nested.txt') == \"I'm nested\""
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "rv.close",
                    "body": "def close(self):\n    called.append(42)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically related to resource management, by appending a specific value (42) to a list named `called`. This indicates that the method has been invoked, which can be useful for tracking or debugging purposes.\n\n**How It Works**:  \nWhen the `close` method is called, it executes a single line of code that appends the integer 42 to the `called` list. This action serves as a simple signal that the method has been executed, allowing developers to verify that the cleanup process has occurred. The method does not return any value or perform any additional operations beyond this append action."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_templates_and_static",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 176,
            "end_line_number": 220,
            "source_code": "def test_templates_and_static(test_apps):\n    from blueprintapp import app\n\n    client = app.test_client()\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"Hello from the Frontend\"\n    rv = client.get(\"/admin/\")\n    assert rv.data == b\"Hello from the Admin\"\n    rv = client.get(\"/admin/index2\")\n    assert rv.data == b\"Hello from the Admin\"\n    rv = client.get(\"/admin/static/test.txt\")\n    assert rv.data.strip() == b\"Admin File\"\n    rv.close()\n    rv = client.get(\"/admin/static/css/test.css\")\n    assert rv.data.strip() == b\"/* nested file */\"\n    rv.close()\n\n    # try/finally, in case other tests use this app for Blueprint tests.\n    max_age_default = app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n    try:\n        expected_max_age = 3600\n        if app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] == expected_max_age:\n            expected_max_age = 7200\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = expected_max_age\n        rv = client.get(\"/admin/static/css/test.css\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == expected_max_age\n        rv.close()\n    finally:\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = max_age_default\n\n    with app.test_request_context():\n        assert (\n            flask.url_for(\"admin.static\", filename=\"test.txt\")\n            == \"/admin/static/test.txt\"\n        )\n\n    with app.test_request_context():\n        with pytest.raises(TemplateNotFound) as e:\n            flask.render_template(\"missing.html\")\n        assert e.value.name == \"missing.html\"\n\n    with flask.Flask(__name__).test_request_context():\n        assert flask.render_template(\"nested/nested.txt\") == \"I'm nested\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "test_apps"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'Hello from the Frontend'",
                "assert rv.data == b'Hello from the Admin'",
                "assert rv.data == b'Hello from the Admin'",
                "assert rv.data.strip() == b'Admin File'",
                "assert rv.data.strip() == b'/* nested file */'",
                "assert cc.max_age == expected_max_age",
                "assert flask.url_for('admin.static', filename='test.txt') == '/admin/static/test.txt'",
                "assert e.value.name == 'missing.html'",
                "assert flask.render_template('nested/nested.txt') == \"I'm nested\""
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_templates_and_static",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 176,
            "end_line_number": 220,
            "source_code": "def test_templates_and_static(test_apps):\n    from blueprintapp import app\n\n    client = app.test_client()\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"Hello from the Frontend\"\n    rv = client.get(\"/admin/\")\n    assert rv.data == b\"Hello from the Admin\"\n    rv = client.get(\"/admin/index2\")\n    assert rv.data == b\"Hello from the Admin\"\n    rv = client.get(\"/admin/static/test.txt\")\n    assert rv.data.strip() == b\"Admin File\"\n    rv.close()\n    rv = client.get(\"/admin/static/css/test.css\")\n    assert rv.data.strip() == b\"/* nested file */\"\n    rv.close()\n\n    # try/finally, in case other tests use this app for Blueprint tests.\n    max_age_default = app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n    try:\n        expected_max_age = 3600\n        if app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] == expected_max_age:\n            expected_max_age = 7200\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = expected_max_age\n        rv = client.get(\"/admin/static/css/test.css\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == expected_max_age\n        rv.close()\n    finally:\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = max_age_default\n\n    with app.test_request_context():\n        assert (\n            flask.url_for(\"admin.static\", filename=\"test.txt\")\n            == \"/admin/static/test.txt\"\n        )\n\n    with app.test_request_context():\n        with pytest.raises(TemplateNotFound) as e:\n            flask.render_template(\"missing.html\")\n        assert e.value.name == \"missing.html\"\n\n    with flask.Flask(__name__).test_request_context():\n        assert flask.render_template(\"nested/nested.txt\") == \"I'm nested\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "test_apps"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'Hello from the Frontend'",
                "assert rv.data == b'Hello from the Admin'",
                "assert rv.data == b'Hello from the Admin'",
                "assert rv.data.strip() == b'Admin File'",
                "assert rv.data.strip() == b'/* nested file */'",
                "assert cc.max_age == expected_max_age",
                "assert flask.url_for('admin.static', filename='test.txt') == '/admin/static/test.txt'",
                "assert e.value.name == 'missing.html'",
                "assert flask.render_template('nested/nested.txt') == \"I'm nested\""
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "rv.close",
                    "body": "def close(self):\n    called.append(42)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically related to resource management, by appending a value (42) to a list named `called`. This suggests that it is part of a mechanism to track when the method is invoked, possibly indicating that a resource (like a database connection or file) has been closed.\n\n**How It Works**:  \nWhen the `close` method is called, it executes a single line of code that appends the integer 42 to the `called` list. This action serves as a simple logging or tracking mechanism to confirm that the `close` method has been executed. The method does not return any value or perform any additional operations, making it a straightforward implementation focused solely on recording its invocation."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_default_static_max_age",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 223,
            "end_line_number": 244,
            "source_code": "def test_default_static_max_age(app):\n    class MyBlueprint(flask.Blueprint):\n        def get_send_file_max_age(self, filename):\n            return 100\n\n    blueprint = MyBlueprint(\"blueprint\", __name__, static_folder=\"static\")\n    app.register_blueprint(blueprint)\n\n    # try/finally, in case other tests use this app for Blueprint tests.\n    max_age_default = app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n    try:\n        with app.test_request_context():\n            unexpected_max_age = 3600\n            if app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] == unexpected_max_age:\n                unexpected_max_age = 7200\n            app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = unexpected_max_age\n            rv = blueprint.send_static_file(\"index.html\")\n            cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n            assert cc.max_age == 100\n            rv.close()\n    finally:\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = max_age_default",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert cc.max_age == 100"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "rv.close",
                    "body": "def close(self):\n    called.append(42)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically related to resource management, by appending a specific value (42) to a list named `called`. This indicates that the method has been invoked, which can be useful for tracking or debugging purposes.\n\n**How It Works**:  \nWhen the `close` method is called, it executes a single line of code that appends the integer 42 to the `called` list. This action serves as a simple signal that the method has been executed, allowing developers to verify that the cleanup process has occurred. The method does not return any value or perform any additional operations beyond this append action."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_dotted_names_from_app",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 264,
            "end_line_number": 278,
            "source_code": "def test_dotted_names_from_app(app, client):\n    test = flask.Blueprint(\"test\", __name__)\n\n    @app.route(\"/\")\n    def app_index():\n        return flask.url_for(\"test.index\")\n\n    @test.route(\"/test/\")\n    def index():\n        return flask.url_for(\"app_index\")\n\n    app.register_blueprint(test)\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"/test/\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'/test/'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it as a response.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` attempts to fetch the session variable `'value'`. If this variable does not exist, it defaults to returning the string `'None'`. The retrieved value is then returned as the HTTP response. This method relies on Flask's session management to store and retrieve user-specific data across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_empty_url_defaults",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 281,
            "end_line_number": 292,
            "source_code": "def test_empty_url_defaults(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.route(\"/\", defaults={\"page\": 1})\n    @bp.route(\"/page/<int:page>\")\n    def something(page):\n        return str(page)\n\n    app.register_blueprint(bp)\n\n    assert client.get(\"/\").data == b\"1\"\n    assert client.get(\"/page/2\").data == b\"2\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').data == b'1'",
                "assert client.get('/page/2').data == b'2'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. Finally, the retrieved value is returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_empty_url_defaults",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 281,
            "end_line_number": 292,
            "source_code": "def test_empty_url_defaults(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.route(\"/\", defaults={\"page\": 1})\n    @bp.route(\"/page/<int:page>\")\n    def something(page):\n        return str(page)\n\n    app.register_blueprint(bp)\n\n    assert client.get(\"/\").data == b\"1\"\n    assert client.get(\"/page/2\").data == b\"2\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').data == b'1'",
                "assert client.get('/page/2').data == b'2'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_route_decorator_custom_endpoint",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 295,
            "end_line_number": 324,
            "source_code": "def test_route_decorator_custom_endpoint(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.route(\"/foo\")\n    def foo():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar\", endpoint=\"bar\")\n    def foo_bar():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar/123\", endpoint=\"123\")\n    def foo_bar_foo():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar/foo\")\n    def bar_foo():\n        return flask.request.endpoint\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.request.endpoint\n\n    assert client.get(\"/\").data == b\"index\"\n    assert client.get(\"/py/foo\").data == b\"bp.foo\"\n    assert client.get(\"/py/bar\").data == b\"bp.bar\"\n    assert client.get(\"/py/bar/123\").data == b\"bp.123\"\n    assert client.get(\"/py/bar/foo\").data == b\"bp.bar_foo\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').data == b'index'",
                "assert client.get('/py/foo').data == b'bp.foo'",
                "assert client.get('/py/bar').data == b'bp.bar'",
                "assert client.get('/py/bar/123').data == b'bp.123'",
                "assert client.get('/py/bar/foo').data == b'bp.bar_foo'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_route_decorator_custom_endpoint",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 295,
            "end_line_number": 324,
            "source_code": "def test_route_decorator_custom_endpoint(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.route(\"/foo\")\n    def foo():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar\", endpoint=\"bar\")\n    def foo_bar():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar/123\", endpoint=\"123\")\n    def foo_bar_foo():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar/foo\")\n    def bar_foo():\n        return flask.request.endpoint\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.request.endpoint\n\n    assert client.get(\"/\").data == b\"index\"\n    assert client.get(\"/py/foo\").data == b\"bp.foo\"\n    assert client.get(\"/py/bar\").data == b\"bp.bar\"\n    assert client.get(\"/py/bar/123\").data == b\"bp.123\"\n    assert client.get(\"/py/bar/foo\").data == b\"bp.bar_foo\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').data == b'index'",
                "assert client.get('/py/foo').data == b'bp.foo'",
                "assert client.get('/py/bar').data == b'bp.bar'",
                "assert client.get('/py/bar/123').data == b'bp.123'",
                "assert client.get('/py/bar/foo').data == b'bp.bar_foo'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it as a response.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` attempts to fetch the value stored in the session under the key `'value'`. If this key does not exist, it defaults to returning the string `'None'`. The retrieved value is then returned as the HTTP response. This method relies on Flask's session management to store and retrieve user-specific data across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_route_decorator_custom_endpoint",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 295,
            "end_line_number": 324,
            "source_code": "def test_route_decorator_custom_endpoint(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.route(\"/foo\")\n    def foo():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar\", endpoint=\"bar\")\n    def foo_bar():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar/123\", endpoint=\"123\")\n    def foo_bar_foo():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar/foo\")\n    def bar_foo():\n        return flask.request.endpoint\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.request.endpoint\n\n    assert client.get(\"/\").data == b\"index\"\n    assert client.get(\"/py/foo\").data == b\"bp.foo\"\n    assert client.get(\"/py/bar\").data == b\"bp.bar\"\n    assert client.get(\"/py/bar/123\").data == b\"bp.123\"\n    assert client.get(\"/py/bar/foo\").data == b\"bp.bar_foo\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').data == b'index'",
                "assert client.get('/py/foo').data == b'bp.foo'",
                "assert client.get('/py/bar').data == b'bp.bar'",
                "assert client.get('/py/bar/123').data == b'bp.123'",
                "assert client.get('/py/bar/foo').data == b'bp.bar_foo'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it as a response.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` attempts to fetch the value stored in the session under the key `'value'`. If this key does not exist, it defaults to returning the string `'None'`. The retrieved value is then returned as the HTTP response. This method relies on Flask's session management to store and retrieve user-specific data across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_route_decorator_custom_endpoint",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 295,
            "end_line_number": 324,
            "source_code": "def test_route_decorator_custom_endpoint(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.route(\"/foo\")\n    def foo():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar\", endpoint=\"bar\")\n    def foo_bar():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar/123\", endpoint=\"123\")\n    def foo_bar_foo():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar/foo\")\n    def bar_foo():\n        return flask.request.endpoint\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.request.endpoint\n\n    assert client.get(\"/\").data == b\"index\"\n    assert client.get(\"/py/foo\").data == b\"bp.foo\"\n    assert client.get(\"/py/bar\").data == b\"bp.bar\"\n    assert client.get(\"/py/bar/123\").data == b\"bp.123\"\n    assert client.get(\"/py/bar/foo\").data == b\"bp.bar_foo\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').data == b'index'",
                "assert client.get('/py/foo').data == b'bp.foo'",
                "assert client.get('/py/bar').data == b'bp.bar'",
                "assert client.get('/py/bar/123').data == b'bp.123'",
                "assert client.get('/py/bar/foo').data == b'bp.bar_foo'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_route_decorator_custom_endpoint",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 295,
            "end_line_number": 324,
            "source_code": "def test_route_decorator_custom_endpoint(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.route(\"/foo\")\n    def foo():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar\", endpoint=\"bar\")\n    def foo_bar():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar/123\", endpoint=\"123\")\n    def foo_bar_foo():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar/foo\")\n    def bar_foo():\n        return flask.request.endpoint\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.request.endpoint\n\n    assert client.get(\"/\").data == b\"index\"\n    assert client.get(\"/py/foo\").data == b\"bp.foo\"\n    assert client.get(\"/py/bar\").data == b\"bp.bar\"\n    assert client.get(\"/py/bar/123\").data == b\"bp.123\"\n    assert client.get(\"/py/bar/foo\").data == b\"bp.bar_foo\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').data == b'index'",
                "assert client.get('/py/foo').data == b'bp.foo'",
                "assert client.get('/py/bar').data == b'bp.bar'",
                "assert client.get('/py/bar/123').data == b'bp.123'",
                "assert client.get('/py/bar/foo').data == b'bp.bar_foo'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_endpoint_decorator",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 345,
            "end_line_number": 359,
            "source_code": "def test_endpoint_decorator(app, client):\n    from werkzeug.routing import Rule\n\n    app.url_map.add(Rule(\"/foo\", endpoint=\"bar\"))\n\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.endpoint(\"bar\")\n    def foobar():\n        return flask.request.endpoint\n\n    app.register_blueprint(bp, url_prefix=\"/bp_prefix\")\n\n    assert client.get(\"/foo\").data == b\"bar\"\n    assert client.get(\"/bp_prefix/bar\").status_code == 404",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/foo').data == b'bar'",
                "assert client.get('/bp_prefix/bar').status_code == 404"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "app.url_map.add",
                    "body": "def add(self, app):\n    self.count += 1",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `app.url_map.add` method is designed to register a new URL rule with the application, effectively mapping a specific URL pattern to a view function. This is essential for defining how incoming requests are routed to the appropriate handler in a web application.\n\n**How It Works**:  \nWhen `add` is called, it increments a counter (`self.count`) to track the number of URL rules added. The method is typically used in conjunction with other methods that define URL rules, such as `add_url_rule`, which constructs the complete URL mapping by combining the provided rule, endpoint, and view function. The method ensures that the application can handle requests to the specified URL by associating it with the corresponding logic defined in the view function."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_endpoint_decorator",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 345,
            "end_line_number": 359,
            "source_code": "def test_endpoint_decorator(app, client):\n    from werkzeug.routing import Rule\n\n    app.url_map.add(Rule(\"/foo\", endpoint=\"bar\"))\n\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.endpoint(\"bar\")\n    def foobar():\n        return flask.request.endpoint\n\n    app.register_blueprint(bp, url_prefix=\"/bp_prefix\")\n\n    assert client.get(\"/foo\").data == b\"bar\"\n    assert client.get(\"/bp_prefix/bar\").status_code == 404",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/foo').data == b'bar'",
                "assert client.get('/bp_prefix/bar').status_code == 404"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. Finally, the retrieved value is returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_endpoint_decorator",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 345,
            "end_line_number": 359,
            "source_code": "def test_endpoint_decorator(app, client):\n    from werkzeug.routing import Rule\n\n    app.url_map.add(Rule(\"/foo\", endpoint=\"bar\"))\n\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.endpoint(\"bar\")\n    def foobar():\n        return flask.request.endpoint\n\n    app.register_blueprint(bp, url_prefix=\"/bp_prefix\")\n\n    assert client.get(\"/foo\").data == b\"bar\"\n    assert client.get(\"/bp_prefix/bar\").status_code == 404",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/foo').data == b'bar'",
                "assert client.get('/bp_prefix/bar').status_code == 404"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_template_filter_with_template",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 414,
            "end_line_number": 428,
            "source_code": "def test_template_filter_with_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'dcba'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, defaulting to `'None'` if the key `'value'` does not exist.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. It uses `flask.session.get` to access the session data, specifically looking for the key `'value'`. If this key is found, its associated value is returned; otherwise, the string `'None'` is returned. This method is useful for retrieving session-specific data in a web application context."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_template_filter_after_route_with_template",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 431,
            "end_line_number": 444,
            "source_code": "def test_template_filter_after_route_with_template(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'dcba'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_add_template_filter_with_template",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 447,
            "end_line_number": 461,
            "source_code": "def test_add_template_filter_with_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def super_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(super_reverse)\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'dcba'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_template_filter_with_name_and_template",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 464,
            "end_line_number": 478,
            "source_code": "def test_template_filter_with_name_and_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter(\"super_reverse\")\n    def my_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'dcba'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_add_template_filter_with_name_and_template",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 481,
            "end_line_number": 495,
            "source_code": "def test_add_template_filter_with_name_and_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def my_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(my_reverse, \"super_reverse\")\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'dcba'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_template_test_with_template",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 550,
            "end_line_number": 564,
            "source_code": "def test_template_test_with_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert b'Success!' in rv.data"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_template_test_after_route_with_template",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 567,
            "end_line_number": 580,
            "source_code": "def test_template_test_after_route_with_template(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert b'Success!' in rv.data"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_add_template_test_with_template",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 583,
            "end_line_number": 597,
            "source_code": "def test_add_template_test_with_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def boolean(value):\n        return isinstance(value, bool)\n\n    bp.add_app_template_test(boolean)\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert b'Success!' in rv.data"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_template_test_with_name_and_template",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 600,
            "end_line_number": 614,
            "source_code": "def test_template_test_with_name_and_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert b'Success!' in rv.data"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_add_template_test_with_name_and_template",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 617,
            "end_line_number": 631,
            "source_code": "def test_add_template_test_with_name_and_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    bp.add_app_template_test(is_boolean, \"boolean\")\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert b'Success!' in rv.data"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called, which attempts to fetch the value stored in the session under the key `'value'`. If this key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve user-specific data across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_context_processing",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 634,
            "end_line_number": 672,
            "source_code": "def test_context_processing(app, client):\n    answer_bp = flask.Blueprint(\"answer_bp\", __name__)\n\n    def template_string():\n        return flask.render_template_string(\n            \"{% if notanswer %}{{ notanswer }} is not the answer. {% endif %}\"\n            \"{% if answer %}{{ answer }} is the answer.{% endif %}\"\n        )\n\n    # App global context processor\n    @answer_bp.app_context_processor\n    def not_answer_context_processor():\n        return {\"notanswer\": 43}\n\n    # Blueprint local context processor\n    @answer_bp.context_processor\n    def answer_context_processor():\n        return {\"answer\": 42}\n\n    # Setup endpoints for testing\n    @answer_bp.route(\"/bp\")\n    def bp_page():\n        return template_string()\n\n    @app.route(\"/\")\n    def app_page():\n        return template_string()\n\n    # Register the blueprint\n    app.register_blueprint(answer_bp)\n\n    app_page_bytes = client.get(\"/\").data\n    answer_page_bytes = client.get(\"/bp\").data\n\n    assert b\"43\" in app_page_bytes\n    assert b\"42\" not in app_page_bytes\n\n    assert b\"42\" in answer_page_bytes\n    assert b\"43\" in answer_page_bytes",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert b'43' in app_page_bytes",
                "assert b'42' not in app_page_bytes",
                "assert b'42' in answer_page_bytes",
                "assert b'43' in answer_page_bytes"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "template_string",
                    "body": "def template_string():\n    return flask.render_template_string('{% if notanswer %}{{ notanswer }} is not the answer. {% endif %}{% if answer %}{{ answer }} is the answer.{% endif %}')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `template_string` method is designed to render a dynamic HTML template using Flask's `render_template_string` function. It allows for conditional rendering based on the presence of variables `notanswer` and `answer`.\n\n**How It Works**:  \nThe method returns a string that contains Jinja2 template syntax. It checks if the variable `notanswer` is defined; if so, it outputs that value followed by \"is not the answer.\" Similarly, if the variable `answer` is defined, it outputs that value followed by \"is the answer.\" This method is typically used in Flask routes to generate HTML responses that can adapt based on the context provided by the application."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_context_processing",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 634,
            "end_line_number": 672,
            "source_code": "def test_context_processing(app, client):\n    answer_bp = flask.Blueprint(\"answer_bp\", __name__)\n\n    def template_string():\n        return flask.render_template_string(\n            \"{% if notanswer %}{{ notanswer }} is not the answer. {% endif %}\"\n            \"{% if answer %}{{ answer }} is the answer.{% endif %}\"\n        )\n\n    # App global context processor\n    @answer_bp.app_context_processor\n    def not_answer_context_processor():\n        return {\"notanswer\": 43}\n\n    # Blueprint local context processor\n    @answer_bp.context_processor\n    def answer_context_processor():\n        return {\"answer\": 42}\n\n    # Setup endpoints for testing\n    @answer_bp.route(\"/bp\")\n    def bp_page():\n        return template_string()\n\n    @app.route(\"/\")\n    def app_page():\n        return template_string()\n\n    # Register the blueprint\n    app.register_blueprint(answer_bp)\n\n    app_page_bytes = client.get(\"/\").data\n    answer_page_bytes = client.get(\"/bp\").data\n\n    assert b\"43\" in app_page_bytes\n    assert b\"42\" not in app_page_bytes\n\n    assert b\"42\" in answer_page_bytes\n    assert b\"43\" in answer_page_bytes",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert b'43' in app_page_bytes",
                "assert b'42' not in app_page_bytes",
                "assert b'42' in answer_page_bytes",
                "assert b'43' in answer_page_bytes"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "template_string",
                    "body": "def template_string():\n    return flask.render_template_string('{% if notanswer %}{{ notanswer }} is not the answer. {% endif %}{% if answer %}{{ answer }} is the answer.{% endif %}')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `template_string` method is designed to render a dynamic HTML template using Flask's `render_template_string` function. It allows for conditional rendering based on the presence of variables `notanswer` and `answer`.\n\n**How It Works**:  \nThe method returns a string that contains Jinja2 template syntax. It checks if the variable `notanswer` is defined; if so, it outputs that value followed by \"is not the answer.\" Similarly, if the variable `answer` is defined, it outputs that value followed by \"is the answer.\" This method is typically used in Flask routes to generate HTML responses that can adapt based on the context provided by the application or blueprint."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_context_processing",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 634,
            "end_line_number": 672,
            "source_code": "def test_context_processing(app, client):\n    answer_bp = flask.Blueprint(\"answer_bp\", __name__)\n\n    def template_string():\n        return flask.render_template_string(\n            \"{% if notanswer %}{{ notanswer }} is not the answer. {% endif %}\"\n            \"{% if answer %}{{ answer }} is the answer.{% endif %}\"\n        )\n\n    # App global context processor\n    @answer_bp.app_context_processor\n    def not_answer_context_processor():\n        return {\"notanswer\": 43}\n\n    # Blueprint local context processor\n    @answer_bp.context_processor\n    def answer_context_processor():\n        return {\"answer\": 42}\n\n    # Setup endpoints for testing\n    @answer_bp.route(\"/bp\")\n    def bp_page():\n        return template_string()\n\n    @app.route(\"/\")\n    def app_page():\n        return template_string()\n\n    # Register the blueprint\n    app.register_blueprint(answer_bp)\n\n    app_page_bytes = client.get(\"/\").data\n    answer_page_bytes = client.get(\"/bp\").data\n\n    assert b\"43\" in app_page_bytes\n    assert b\"42\" not in app_page_bytes\n\n    assert b\"42\" in answer_page_bytes\n    assert b\"43\" in answer_page_bytes",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert b'43' in app_page_bytes",
                "assert b'42' not in app_page_bytes",
                "assert b'42' in answer_page_bytes",
                "assert b'43' in answer_page_bytes"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_context_processing",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 634,
            "end_line_number": 672,
            "source_code": "def test_context_processing(app, client):\n    answer_bp = flask.Blueprint(\"answer_bp\", __name__)\n\n    def template_string():\n        return flask.render_template_string(\n            \"{% if notanswer %}{{ notanswer }} is not the answer. {% endif %}\"\n            \"{% if answer %}{{ answer }} is the answer.{% endif %}\"\n        )\n\n    # App global context processor\n    @answer_bp.app_context_processor\n    def not_answer_context_processor():\n        return {\"notanswer\": 43}\n\n    # Blueprint local context processor\n    @answer_bp.context_processor\n    def answer_context_processor():\n        return {\"answer\": 42}\n\n    # Setup endpoints for testing\n    @answer_bp.route(\"/bp\")\n    def bp_page():\n        return template_string()\n\n    @app.route(\"/\")\n    def app_page():\n        return template_string()\n\n    # Register the blueprint\n    app.register_blueprint(answer_bp)\n\n    app_page_bytes = client.get(\"/\").data\n    answer_page_bytes = client.get(\"/bp\").data\n\n    assert b\"43\" in app_page_bytes\n    assert b\"42\" not in app_page_bytes\n\n    assert b\"42\" in answer_page_bytes\n    assert b\"43\" in answer_page_bytes",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert b'43' in app_page_bytes",
                "assert b'42' not in app_page_bytes",
                "assert b'42' in answer_page_bytes",
                "assert b'43' in answer_page_bytes"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_request_processing",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 696,
            "end_line_number": 724,
            "source_code": "def test_request_processing(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n    evts = []\n\n    @bp.before_request\n    def before_bp():\n        evts.append(\"before\")\n\n    @bp.after_request\n    def after_bp(response):\n        response.data += b\"|after\"\n        evts.append(\"after\")\n        return response\n\n    @bp.teardown_request\n    def teardown_bp(exc):\n        evts.append(\"teardown\")\n\n    # Setup routes for testing\n    @bp.route(\"/bp\")\n    def bp_endpoint():\n        return \"request\"\n\n    app.register_blueprint(bp)\n\n    assert evts == []\n    rv = client.get(\"/bp\")\n    assert rv.data == b\"request|after\"\n    assert evts == [\"before\", \"after\", \"teardown\"]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert evts == []",
                "assert rv.data == b'request|after'",
                "assert evts == ['before', 'after', 'teardown']"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_app_request_processing",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 727,
            "end_line_number": 763,
            "source_code": "def test_app_request_processing(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n    evts = []\n\n    @bp.before_app_request\n    def before_app():\n        evts.append(\"before\")\n\n    @bp.after_app_request\n    def after_app(response):\n        response.data += b\"|after\"\n        evts.append(\"after\")\n        return response\n\n    @bp.teardown_app_request\n    def teardown_app(exc):\n        evts.append(\"teardown\")\n\n    app.register_blueprint(bp)\n\n    # Setup routes for testing\n    @app.route(\"/\")\n    def bp_endpoint():\n        return \"request\"\n\n    # before first request\n    assert evts == []\n\n    # first request\n    resp = client.get(\"/\").data\n    assert resp == b\"request|after\"\n    assert evts == [\"before\", \"after\", \"teardown\"]\n\n    # second request\n    resp = client.get(\"/\").data\n    assert resp == b\"request|after\"\n    assert evts == [\"before\", \"after\", \"teardown\"] * 2",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert evts == []",
                "assert resp == b'request|after'",
                "assert evts == ['before', 'after', 'teardown']",
                "assert resp == b'request|after'",
                "assert evts == ['before', 'after', 'teardown'] * 2"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. Finally, the retrieved value is returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_app_request_processing",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 727,
            "end_line_number": 763,
            "source_code": "def test_app_request_processing(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n    evts = []\n\n    @bp.before_app_request\n    def before_app():\n        evts.append(\"before\")\n\n    @bp.after_app_request\n    def after_app(response):\n        response.data += b\"|after\"\n        evts.append(\"after\")\n        return response\n\n    @bp.teardown_app_request\n    def teardown_app(exc):\n        evts.append(\"teardown\")\n\n    app.register_blueprint(bp)\n\n    # Setup routes for testing\n    @app.route(\"/\")\n    def bp_endpoint():\n        return \"request\"\n\n    # before first request\n    assert evts == []\n\n    # first request\n    resp = client.get(\"/\").data\n    assert resp == b\"request|after\"\n    assert evts == [\"before\", \"after\", \"teardown\"]\n\n    # second request\n    resp = client.get(\"/\").data\n    assert resp == b\"request|after\"\n    assert evts == [\"before\", \"after\", \"teardown\"] * 2",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert evts == []",
                "assert resp == b'request|after'",
                "assert evts == ['before', 'after', 'teardown']",
                "assert resp == b'request|after'",
                "assert evts == ['before', 'after', 'teardown'] * 2"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, defaulting to `'None'` if the key `'value'` does not exist.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. It uses `flask.session.get` to access the session data, specifically looking for the key `'value'`. If this key is found, its associated value is returned; otherwise, the string `'None'` is returned. This method is useful for retrieving session-specific data in a web application context."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_app_url_processors",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 766,
            "end_line_number": 790,
            "source_code": "def test_app_url_processors(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    # Register app-wide url defaults and preprocessor on blueprint\n    @bp.app_url_defaults\n    def add_language_code(endpoint, values):\n        values.setdefault(\"lang_code\", flask.g.lang_code)\n\n    @bp.app_url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop(\"lang_code\")\n\n    # Register route rules at the app level\n    @app.route(\"/<lang_code>/\")\n    def index():\n        return flask.url_for(\"about\")\n\n    @app.route(\"/<lang_code>/about\")\n    def about():\n        return flask.url_for(\"index\")\n\n    app.register_blueprint(bp)\n\n    assert client.get(\"/de/\").data == b\"/de/about\"\n    assert client.get(\"/de/about\").data == b\"/de/\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/de/').data == b'/de/about'",
                "assert client.get('/de/about').data == b'/de/'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "values.setdefault",
                    "body": "@app.route('/setdefault')\ndef setdefault():\n    return flask.session.setdefault('test', 'default')",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `setdefault` method is used to retrieve a value from the session, and if the key does not exist, it sets the key to a specified default value. In this case, it ensures that the session variable `'test'` has a default value of `'default'` if it hasn't been set previously.\n\n**How It Works**:  \nWhen the `/setdefault` route is accessed, the `setdefault` function is called. It uses `flask.session.setdefault('test', 'default')`, which checks if the key `'test'` exists in the session. If it does, it returns the current value; if not, it sets `'test'` to `'default'` and then returns this value. This method is useful for initializing session variables without overwriting existing values."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_app_url_processors",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 766,
            "end_line_number": 790,
            "source_code": "def test_app_url_processors(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    # Register app-wide url defaults and preprocessor on blueprint\n    @bp.app_url_defaults\n    def add_language_code(endpoint, values):\n        values.setdefault(\"lang_code\", flask.g.lang_code)\n\n    @bp.app_url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop(\"lang_code\")\n\n    # Register route rules at the app level\n    @app.route(\"/<lang_code>/\")\n    def index():\n        return flask.url_for(\"about\")\n\n    @app.route(\"/<lang_code>/about\")\n    def about():\n        return flask.url_for(\"index\")\n\n    app.register_blueprint(bp)\n\n    assert client.get(\"/de/\").data == b\"/de/about\"\n    assert client.get(\"/de/about\").data == b\"/de/\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/de/').data == b'/de/about'",
                "assert client.get('/de/about').data == b'/de/'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. Finally, the retrieved value is returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_app_url_processors",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 766,
            "end_line_number": 790,
            "source_code": "def test_app_url_processors(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    # Register app-wide url defaults and preprocessor on blueprint\n    @bp.app_url_defaults\n    def add_language_code(endpoint, values):\n        values.setdefault(\"lang_code\", flask.g.lang_code)\n\n    @bp.app_url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop(\"lang_code\")\n\n    # Register route rules at the app level\n    @app.route(\"/<lang_code>/\")\n    def index():\n        return flask.url_for(\"about\")\n\n    @app.route(\"/<lang_code>/about\")\n    def about():\n        return flask.url_for(\"index\")\n\n    app.register_blueprint(bp)\n\n    assert client.get(\"/de/\").data == b\"/de/about\"\n    assert client.get(\"/de/about\").data == b\"/de/\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/de/').data == b'/de/about'",
                "assert client.get('/de/about').data == b'/de/'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_nested_blueprint",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 793,
            "end_line_number": 839,
            "source_code": "def test_nested_blueprint(app, client):\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__)\n    grandchild = flask.Blueprint(\"grandchild\", __name__)\n\n    @parent.errorhandler(403)\n    def forbidden(e):\n        return \"Parent no\", 403\n\n    @parent.route(\"/\")\n    def parent_index():\n        return \"Parent yes\"\n\n    @parent.route(\"/no\")\n    def parent_no():\n        flask.abort(403)\n\n    @child.route(\"/\")\n    def child_index():\n        return \"Child yes\"\n\n    @child.route(\"/no\")\n    def child_no():\n        flask.abort(403)\n\n    @grandchild.errorhandler(403)\n    def grandchild_forbidden(e):\n        return \"Grandchild no\", 403\n\n    @grandchild.route(\"/\")\n    def grandchild_index():\n        return \"Grandchild yes\"\n\n    @grandchild.route(\"/no\")\n    def grandchild_no():\n        flask.abort(403)\n\n    child.register_blueprint(grandchild, url_prefix=\"/grandchild\")\n    parent.register_blueprint(child, url_prefix=\"/child\")\n    app.register_blueprint(parent, url_prefix=\"/parent\")\n\n    assert client.get(\"/parent/\").data == b\"Parent yes\"\n    assert client.get(\"/parent/child/\").data == b\"Child yes\"\n    assert client.get(\"/parent/child/grandchild/\").data == b\"Grandchild yes\"\n    assert client.get(\"/parent/no\").data == b\"Parent no\"\n    assert client.get(\"/parent/child/no\").data == b\"Parent no\"\n    assert client.get(\"/parent/child/grandchild/no\").data == b\"Grandchild no\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/parent/').data == b'Parent yes'",
                "assert client.get('/parent/child/').data == b'Child yes'",
                "assert client.get('/parent/child/grandchild/').data == b'Grandchild yes'",
                "assert client.get('/parent/no').data == b'Parent no'",
                "assert client.get('/parent/child/no').data == b'Parent no'",
                "assert client.get('/parent/child/grandchild/no').data == b'Grandchild no'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is used to define a route in a Flask web application that retrieves a value stored in the session. If the session does not contain the specified value, it returns a default value of 'None'.\n\n**How It Works**:  \nThe method is decorated with `@app.route('/get')`, which maps the URL path `/get` to the `get` function. When a GET request is made to this endpoint, the function accesses the session using `flask.session.get('value', 'None')`. This retrieves the value associated with the key `'value'` from the session; if it does not exist, it returns the string `'None'`. The retrieved value is then returned as the response to the client. This allows for session data to be accessed and utilized in web applications, facilitating state management across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_nested_blueprint",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 793,
            "end_line_number": 839,
            "source_code": "def test_nested_blueprint(app, client):\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__)\n    grandchild = flask.Blueprint(\"grandchild\", __name__)\n\n    @parent.errorhandler(403)\n    def forbidden(e):\n        return \"Parent no\", 403\n\n    @parent.route(\"/\")\n    def parent_index():\n        return \"Parent yes\"\n\n    @parent.route(\"/no\")\n    def parent_no():\n        flask.abort(403)\n\n    @child.route(\"/\")\n    def child_index():\n        return \"Child yes\"\n\n    @child.route(\"/no\")\n    def child_no():\n        flask.abort(403)\n\n    @grandchild.errorhandler(403)\n    def grandchild_forbidden(e):\n        return \"Grandchild no\", 403\n\n    @grandchild.route(\"/\")\n    def grandchild_index():\n        return \"Grandchild yes\"\n\n    @grandchild.route(\"/no\")\n    def grandchild_no():\n        flask.abort(403)\n\n    child.register_blueprint(grandchild, url_prefix=\"/grandchild\")\n    parent.register_blueprint(child, url_prefix=\"/child\")\n    app.register_blueprint(parent, url_prefix=\"/parent\")\n\n    assert client.get(\"/parent/\").data == b\"Parent yes\"\n    assert client.get(\"/parent/child/\").data == b\"Child yes\"\n    assert client.get(\"/parent/child/grandchild/\").data == b\"Grandchild yes\"\n    assert client.get(\"/parent/no\").data == b\"Parent no\"\n    assert client.get(\"/parent/child/no\").data == b\"Parent no\"\n    assert client.get(\"/parent/child/grandchild/no\").data == b\"Grandchild no\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/parent/').data == b'Parent yes'",
                "assert client.get('/parent/child/').data == b'Child yes'",
                "assert client.get('/parent/child/grandchild/').data == b'Grandchild yes'",
                "assert client.get('/parent/no').data == b'Parent no'",
                "assert client.get('/parent/child/no').data == b'Parent no'",
                "assert client.get('/parent/child/grandchild/no').data == b'Grandchild no'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_nested_blueprint",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 793,
            "end_line_number": 839,
            "source_code": "def test_nested_blueprint(app, client):\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__)\n    grandchild = flask.Blueprint(\"grandchild\", __name__)\n\n    @parent.errorhandler(403)\n    def forbidden(e):\n        return \"Parent no\", 403\n\n    @parent.route(\"/\")\n    def parent_index():\n        return \"Parent yes\"\n\n    @parent.route(\"/no\")\n    def parent_no():\n        flask.abort(403)\n\n    @child.route(\"/\")\n    def child_index():\n        return \"Child yes\"\n\n    @child.route(\"/no\")\n    def child_no():\n        flask.abort(403)\n\n    @grandchild.errorhandler(403)\n    def grandchild_forbidden(e):\n        return \"Grandchild no\", 403\n\n    @grandchild.route(\"/\")\n    def grandchild_index():\n        return \"Grandchild yes\"\n\n    @grandchild.route(\"/no\")\n    def grandchild_no():\n        flask.abort(403)\n\n    child.register_blueprint(grandchild, url_prefix=\"/grandchild\")\n    parent.register_blueprint(child, url_prefix=\"/child\")\n    app.register_blueprint(parent, url_prefix=\"/parent\")\n\n    assert client.get(\"/parent/\").data == b\"Parent yes\"\n    assert client.get(\"/parent/child/\").data == b\"Child yes\"\n    assert client.get(\"/parent/child/grandchild/\").data == b\"Grandchild yes\"\n    assert client.get(\"/parent/no\").data == b\"Parent no\"\n    assert client.get(\"/parent/child/no\").data == b\"Parent no\"\n    assert client.get(\"/parent/child/grandchild/no\").data == b\"Grandchild no\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/parent/').data == b'Parent yes'",
                "assert client.get('/parent/child/').data == b'Child yes'",
                "assert client.get('/parent/child/grandchild/').data == b'Grandchild yes'",
                "assert client.get('/parent/no').data == b'Parent no'",
                "assert client.get('/parent/child/no').data == b'Parent no'",
                "assert client.get('/parent/child/grandchild/no').data == b'Grandchild no'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, returning it to the client.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. It uses `flask.session.get` to access the session data, specifically looking for a key named `'value'`. If this key does not exist, it defaults to returning the string `'None'`. The retrieved value is then sent back as the response to the client. This method is useful for managing session data in web applications, allowing for state persistence across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_nested_blueprint",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 793,
            "end_line_number": 839,
            "source_code": "def test_nested_blueprint(app, client):\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__)\n    grandchild = flask.Blueprint(\"grandchild\", __name__)\n\n    @parent.errorhandler(403)\n    def forbidden(e):\n        return \"Parent no\", 403\n\n    @parent.route(\"/\")\n    def parent_index():\n        return \"Parent yes\"\n\n    @parent.route(\"/no\")\n    def parent_no():\n        flask.abort(403)\n\n    @child.route(\"/\")\n    def child_index():\n        return \"Child yes\"\n\n    @child.route(\"/no\")\n    def child_no():\n        flask.abort(403)\n\n    @grandchild.errorhandler(403)\n    def grandchild_forbidden(e):\n        return \"Grandchild no\", 403\n\n    @grandchild.route(\"/\")\n    def grandchild_index():\n        return \"Grandchild yes\"\n\n    @grandchild.route(\"/no\")\n    def grandchild_no():\n        flask.abort(403)\n\n    child.register_blueprint(grandchild, url_prefix=\"/grandchild\")\n    parent.register_blueprint(child, url_prefix=\"/child\")\n    app.register_blueprint(parent, url_prefix=\"/parent\")\n\n    assert client.get(\"/parent/\").data == b\"Parent yes\"\n    assert client.get(\"/parent/child/\").data == b\"Child yes\"\n    assert client.get(\"/parent/child/grandchild/\").data == b\"Grandchild yes\"\n    assert client.get(\"/parent/no\").data == b\"Parent no\"\n    assert client.get(\"/parent/child/no\").data == b\"Parent no\"\n    assert client.get(\"/parent/child/grandchild/no\").data == b\"Grandchild no\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/parent/').data == b'Parent yes'",
                "assert client.get('/parent/child/').data == b'Child yes'",
                "assert client.get('/parent/child/grandchild/').data == b'Grandchild yes'",
                "assert client.get('/parent/no').data == b'Parent no'",
                "assert client.get('/parent/child/no').data == b'Parent no'",
                "assert client.get('/parent/child/grandchild/no').data == b'Grandchild no'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_nested_blueprint",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 793,
            "end_line_number": 839,
            "source_code": "def test_nested_blueprint(app, client):\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__)\n    grandchild = flask.Blueprint(\"grandchild\", __name__)\n\n    @parent.errorhandler(403)\n    def forbidden(e):\n        return \"Parent no\", 403\n\n    @parent.route(\"/\")\n    def parent_index():\n        return \"Parent yes\"\n\n    @parent.route(\"/no\")\n    def parent_no():\n        flask.abort(403)\n\n    @child.route(\"/\")\n    def child_index():\n        return \"Child yes\"\n\n    @child.route(\"/no\")\n    def child_no():\n        flask.abort(403)\n\n    @grandchild.errorhandler(403)\n    def grandchild_forbidden(e):\n        return \"Grandchild no\", 403\n\n    @grandchild.route(\"/\")\n    def grandchild_index():\n        return \"Grandchild yes\"\n\n    @grandchild.route(\"/no\")\n    def grandchild_no():\n        flask.abort(403)\n\n    child.register_blueprint(grandchild, url_prefix=\"/grandchild\")\n    parent.register_blueprint(child, url_prefix=\"/child\")\n    app.register_blueprint(parent, url_prefix=\"/parent\")\n\n    assert client.get(\"/parent/\").data == b\"Parent yes\"\n    assert client.get(\"/parent/child/\").data == b\"Child yes\"\n    assert client.get(\"/parent/child/grandchild/\").data == b\"Grandchild yes\"\n    assert client.get(\"/parent/no\").data == b\"Parent no\"\n    assert client.get(\"/parent/child/no\").data == b\"Parent no\"\n    assert client.get(\"/parent/child/grandchild/no\").data == b\"Grandchild no\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/parent/').data == b'Parent yes'",
                "assert client.get('/parent/child/').data == b'Child yes'",
                "assert client.get('/parent/child/grandchild/').data == b'Grandchild yes'",
                "assert client.get('/parent/no').data == b'Parent no'",
                "assert client.get('/parent/child/no').data == b'Parent no'",
                "assert client.get('/parent/child/grandchild/no').data == b'Grandchild no'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_nested_blueprint",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 793,
            "end_line_number": 839,
            "source_code": "def test_nested_blueprint(app, client):\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__)\n    grandchild = flask.Blueprint(\"grandchild\", __name__)\n\n    @parent.errorhandler(403)\n    def forbidden(e):\n        return \"Parent no\", 403\n\n    @parent.route(\"/\")\n    def parent_index():\n        return \"Parent yes\"\n\n    @parent.route(\"/no\")\n    def parent_no():\n        flask.abort(403)\n\n    @child.route(\"/\")\n    def child_index():\n        return \"Child yes\"\n\n    @child.route(\"/no\")\n    def child_no():\n        flask.abort(403)\n\n    @grandchild.errorhandler(403)\n    def grandchild_forbidden(e):\n        return \"Grandchild no\", 403\n\n    @grandchild.route(\"/\")\n    def grandchild_index():\n        return \"Grandchild yes\"\n\n    @grandchild.route(\"/no\")\n    def grandchild_no():\n        flask.abort(403)\n\n    child.register_blueprint(grandchild, url_prefix=\"/grandchild\")\n    parent.register_blueprint(child, url_prefix=\"/child\")\n    app.register_blueprint(parent, url_prefix=\"/parent\")\n\n    assert client.get(\"/parent/\").data == b\"Parent yes\"\n    assert client.get(\"/parent/child/\").data == b\"Child yes\"\n    assert client.get(\"/parent/child/grandchild/\").data == b\"Grandchild yes\"\n    assert client.get(\"/parent/no\").data == b\"Parent no\"\n    assert client.get(\"/parent/child/no\").data == b\"Parent no\"\n    assert client.get(\"/parent/child/grandchild/no\").data == b\"Grandchild no\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/parent/').data == b'Parent yes'",
                "assert client.get('/parent/child/').data == b'Child yes'",
                "assert client.get('/parent/child/grandchild/').data == b'Grandchild yes'",
                "assert client.get('/parent/no').data == b'Parent no'",
                "assert client.get('/parent/child/no').data == b'Parent no'",
                "assert client.get('/parent/child/grandchild/no').data == b'Grandchild no'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_nested_callback_order",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 842,
            "end_line_number": 919,
            "source_code": "def test_nested_callback_order(app, client):\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__)\n\n    @app.before_request\n    def app_before1():\n        flask.g.setdefault(\"seen\", []).append(\"app_1\")\n\n    @app.teardown_request\n    def app_teardown1(e=None):\n        assert flask.g.seen.pop() == \"app_1\"\n\n    @app.before_request\n    def app_before2():\n        flask.g.setdefault(\"seen\", []).append(\"app_2\")\n\n    @app.teardown_request\n    def app_teardown2(e=None):\n        assert flask.g.seen.pop() == \"app_2\"\n\n    @app.context_processor\n    def app_ctx():\n        return dict(key=\"app\")\n\n    @parent.before_request\n    def parent_before1():\n        flask.g.setdefault(\"seen\", []).append(\"parent_1\")\n\n    @parent.teardown_request\n    def parent_teardown1(e=None):\n        assert flask.g.seen.pop() == \"parent_1\"\n\n    @parent.before_request\n    def parent_before2():\n        flask.g.setdefault(\"seen\", []).append(\"parent_2\")\n\n    @parent.teardown_request\n    def parent_teardown2(e=None):\n        assert flask.g.seen.pop() == \"parent_2\"\n\n    @parent.context_processor\n    def parent_ctx():\n        return dict(key=\"parent\")\n\n    @child.before_request\n    def child_before1():\n        flask.g.setdefault(\"seen\", []).append(\"child_1\")\n\n    @child.teardown_request\n    def child_teardown1(e=None):\n        assert flask.g.seen.pop() == \"child_1\"\n\n    @child.before_request\n    def child_before2():\n        flask.g.setdefault(\"seen\", []).append(\"child_2\")\n\n    @child.teardown_request\n    def child_teardown2(e=None):\n        assert flask.g.seen.pop() == \"child_2\"\n\n    @child.context_processor\n    def child_ctx():\n        return dict(key=\"child\")\n\n    @child.route(\"/a\")\n    def a():\n        return \", \".join(flask.g.seen)\n\n    @child.route(\"/b\")\n    def b():\n        return flask.render_template_string(\"{{ key }}\")\n\n    parent.register_blueprint(child)\n    app.register_blueprint(parent)\n    assert (\n        client.get(\"/a\").data == b\"app_1, app_2, parent_1, parent_2, child_1, child_2\"\n    )\n    assert client.get(\"/b\").data == b\"child\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/a').data == b'app_1, app_2, parent_1, parent_2, child_1, child_2'",
                "assert client.get('/b').data == b'child'",
                "assert flask.g.seen.pop() == 'app_1'",
                "assert flask.g.seen.pop() == 'app_2'",
                "assert flask.g.seen.pop() == 'parent_1'",
                "assert flask.g.seen.pop() == 'parent_2'",
                "assert flask.g.seen.pop() == 'child_1'",
                "assert flask.g.seen.pop() == 'child_2'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_nested_callback_order",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 842,
            "end_line_number": 919,
            "source_code": "def test_nested_callback_order(app, client):\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__)\n\n    @app.before_request\n    def app_before1():\n        flask.g.setdefault(\"seen\", []).append(\"app_1\")\n\n    @app.teardown_request\n    def app_teardown1(e=None):\n        assert flask.g.seen.pop() == \"app_1\"\n\n    @app.before_request\n    def app_before2():\n        flask.g.setdefault(\"seen\", []).append(\"app_2\")\n\n    @app.teardown_request\n    def app_teardown2(e=None):\n        assert flask.g.seen.pop() == \"app_2\"\n\n    @app.context_processor\n    def app_ctx():\n        return dict(key=\"app\")\n\n    @parent.before_request\n    def parent_before1():\n        flask.g.setdefault(\"seen\", []).append(\"parent_1\")\n\n    @parent.teardown_request\n    def parent_teardown1(e=None):\n        assert flask.g.seen.pop() == \"parent_1\"\n\n    @parent.before_request\n    def parent_before2():\n        flask.g.setdefault(\"seen\", []).append(\"parent_2\")\n\n    @parent.teardown_request\n    def parent_teardown2(e=None):\n        assert flask.g.seen.pop() == \"parent_2\"\n\n    @parent.context_processor\n    def parent_ctx():\n        return dict(key=\"parent\")\n\n    @child.before_request\n    def child_before1():\n        flask.g.setdefault(\"seen\", []).append(\"child_1\")\n\n    @child.teardown_request\n    def child_teardown1(e=None):\n        assert flask.g.seen.pop() == \"child_1\"\n\n    @child.before_request\n    def child_before2():\n        flask.g.setdefault(\"seen\", []).append(\"child_2\")\n\n    @child.teardown_request\n    def child_teardown2(e=None):\n        assert flask.g.seen.pop() == \"child_2\"\n\n    @child.context_processor\n    def child_ctx():\n        return dict(key=\"child\")\n\n    @child.route(\"/a\")\n    def a():\n        return \", \".join(flask.g.seen)\n\n    @child.route(\"/b\")\n    def b():\n        return flask.render_template_string(\"{{ key }}\")\n\n    parent.register_blueprint(child)\n    app.register_blueprint(parent)\n    assert (\n        client.get(\"/a\").data == b\"app_1, app_2, parent_1, parent_2, child_1, child_2\"\n    )\n    assert client.get(\"/b\").data == b\"child\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/a').data == b'app_1, app_2, parent_1, parent_2, child_1, child_2'",
                "assert client.get('/b').data == b'child'",
                "assert flask.g.seen.pop() == 'app_1'",
                "assert flask.g.seen.pop() == 'app_2'",
                "assert flask.g.seen.pop() == 'parent_1'",
                "assert flask.g.seen.pop() == 'parent_2'",
                "assert flask.g.seen.pop() == 'child_1'",
                "assert flask.g.seen.pop() == 'child_2'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_nesting_url_prefixes",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 931,
            "end_line_number": 950,
            "source_code": "def test_nesting_url_prefixes(\n    parent_init,\n    child_init,\n    parent_registration,\n    child_registration,\n    app,\n    client,\n) -> None:\n    parent = flask.Blueprint(\"parent\", __name__, url_prefix=parent_init)\n    child = flask.Blueprint(\"child\", __name__, url_prefix=child_init)\n\n    @child.route(\"/\")\n    def index():\n        return \"index\"\n\n    parent.register_blueprint(child, url_prefix=child_registration)\n    app.register_blueprint(parent, url_prefix=parent_registration)\n\n    response = client.get(\"/parent/child/\")\n    assert response.status_code == 200",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('parent_init, child_init, parent_registration, child_registration', [('/parent', '/child', None, None), ('/parent', None, None, '/child'), (None, None, '/parent', '/child'), ('/other', '/something', '/parent', '/child')])"
            ],
            "arguments": [
                "parent_init",
                "child_init",
                "parent_registration",
                "child_registration",
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 200"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_nesting_subdomains",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 953,
            "end_line_number": 969,
            "source_code": "def test_nesting_subdomains(app, client) -> None:\n    app.subdomain_matching = True\n    app.config[\"SERVER_NAME\"] = \"example.test\"\n    client.allow_subdomain_redirects = True\n\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__)\n\n    @child.route(\"/child/\")\n    def index():\n        return \"child\"\n\n    parent.register_blueprint(child)\n    app.register_blueprint(parent, subdomain=\"api\")\n\n    response = client.get(\"/child/\", base_url=\"http://api.example.test\")\n    assert response.status_code == 200",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 200"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_child_and_parent_subdomain",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 972,
            "end_line_number": 991,
            "source_code": "def test_child_and_parent_subdomain(app, client) -> None:\n    app.subdomain_matching = True\n    app.config[\"SERVER_NAME\"] = \"example.test\"\n    client.allow_subdomain_redirects = True\n\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__, subdomain=\"api\")\n\n    @child.route(\"/\")\n    def index():\n        return \"child\"\n\n    parent.register_blueprint(child)\n    app.register_blueprint(parent, subdomain=\"parent\")\n\n    response = client.get(\"/\", base_url=\"http://api.parent.example.test\")\n    assert response.status_code == 200\n\n    response = client.get(\"/\", base_url=\"http://parent.example.test\")\n    assert response.status_code == 404",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 200",
                "assert response.status_code == 404"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it as a response.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` attempts to fetch the value stored in the session under the key `'value'`. If this key does not exist, it defaults to returning the string `'None'`. The retrieved value is then returned as the HTTP response. This method relies on Flask's session management to store and retrieve user-specific data across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_child_and_parent_subdomain",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 972,
            "end_line_number": 991,
            "source_code": "def test_child_and_parent_subdomain(app, client) -> None:\n    app.subdomain_matching = True\n    app.config[\"SERVER_NAME\"] = \"example.test\"\n    client.allow_subdomain_redirects = True\n\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__, subdomain=\"api\")\n\n    @child.route(\"/\")\n    def index():\n        return \"child\"\n\n    parent.register_blueprint(child)\n    app.register_blueprint(parent, subdomain=\"parent\")\n\n    response = client.get(\"/\", base_url=\"http://api.parent.example.test\")\n    assert response.status_code == 200\n\n    response = client.get(\"/\", base_url=\"http://parent.example.test\")\n    assert response.status_code == 404",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 200",
                "assert response.status_code == 404"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_blueprint_renaming",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 1017,
            "end_line_number": 1046,
            "source_code": "def test_blueprint_renaming(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    bp2 = flask.Blueprint(\"bp2\", __name__)\n\n    @bp.get(\"/\")\n    def index():\n        return flask.request.endpoint\n\n    @bp.get(\"/error\")\n    def error():\n        flask.abort(403)\n\n    @bp.errorhandler(403)\n    def forbidden(_: Exception):\n        return \"Error\", 403\n\n    @bp2.get(\"/\")\n    def index2():\n        return flask.request.endpoint\n\n    bp.register_blueprint(bp2, url_prefix=\"/a\", name=\"sub\")\n    app.register_blueprint(bp, url_prefix=\"/a\")\n    app.register_blueprint(bp, url_prefix=\"/b\", name=\"alt\")\n\n    assert client.get(\"/a/\").data == b\"bp.index\"\n    assert client.get(\"/b/\").data == b\"alt.index\"\n    assert client.get(\"/a/a/\").data == b\"bp.sub.index2\"\n    assert client.get(\"/b/a/\").data == b\"alt.sub.index2\"\n    assert client.get(\"/a/error\").data == b\"Error\"\n    assert client.get(\"/b/error\").data == b\"Error\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/a/').data == b'bp.index'",
                "assert client.get('/b/').data == b'alt.index'",
                "assert client.get('/a/a/').data == b'bp.sub.index2'",
                "assert client.get('/b/a/').data == b'alt.sub.index2'",
                "assert client.get('/a/error').data == b'Error'",
                "assert client.get('/b/error').data == b'Error'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "bp.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `bp.get` method defines a Flask route that retrieves a value from the session, specifically the value associated with the key `'value'`. If this key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the method uses `flask.session.get()` to attempt to fetch the value stored under the key `'value'`. The second argument, `'None'`, serves as a default return value if the key is not found. The method then returns this value, which can be used in the response to the client. This functionality is useful for managing user-specific data across requests in a web application."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_blueprint_renaming",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 1017,
            "end_line_number": 1046,
            "source_code": "def test_blueprint_renaming(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    bp2 = flask.Blueprint(\"bp2\", __name__)\n\n    @bp.get(\"/\")\n    def index():\n        return flask.request.endpoint\n\n    @bp.get(\"/error\")\n    def error():\n        flask.abort(403)\n\n    @bp.errorhandler(403)\n    def forbidden(_: Exception):\n        return \"Error\", 403\n\n    @bp2.get(\"/\")\n    def index2():\n        return flask.request.endpoint\n\n    bp.register_blueprint(bp2, url_prefix=\"/a\", name=\"sub\")\n    app.register_blueprint(bp, url_prefix=\"/a\")\n    app.register_blueprint(bp, url_prefix=\"/b\", name=\"alt\")\n\n    assert client.get(\"/a/\").data == b\"bp.index\"\n    assert client.get(\"/b/\").data == b\"alt.index\"\n    assert client.get(\"/a/a/\").data == b\"bp.sub.index2\"\n    assert client.get(\"/b/a/\").data == b\"alt.sub.index2\"\n    assert client.get(\"/a/error\").data == b\"Error\"\n    assert client.get(\"/b/error\").data == b\"Error\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/a/').data == b'bp.index'",
                "assert client.get('/b/').data == b'alt.index'",
                "assert client.get('/a/a/').data == b'bp.sub.index2'",
                "assert client.get('/b/a/').data == b'alt.sub.index2'",
                "assert client.get('/a/error').data == b'Error'",
                "assert client.get('/b/error').data == b'Error'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "bp.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `bp.get` method defines a Flask route that retrieves a value from the session, specifically looking for a key named `'value'`. If this key does not exist, it returns the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the method uses `flask.session.get()` to access the session data. The `get()` method checks for the presence of the key `'value'` and returns its associated value if found; otherwise, it defaults to returning the string `'None'`. This allows the application to maintain state across requests by storing user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_blueprint_renaming",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 1017,
            "end_line_number": 1046,
            "source_code": "def test_blueprint_renaming(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    bp2 = flask.Blueprint(\"bp2\", __name__)\n\n    @bp.get(\"/\")\n    def index():\n        return flask.request.endpoint\n\n    @bp.get(\"/error\")\n    def error():\n        flask.abort(403)\n\n    @bp.errorhandler(403)\n    def forbidden(_: Exception):\n        return \"Error\", 403\n\n    @bp2.get(\"/\")\n    def index2():\n        return flask.request.endpoint\n\n    bp.register_blueprint(bp2, url_prefix=\"/a\", name=\"sub\")\n    app.register_blueprint(bp, url_prefix=\"/a\")\n    app.register_blueprint(bp, url_prefix=\"/b\", name=\"alt\")\n\n    assert client.get(\"/a/\").data == b\"bp.index\"\n    assert client.get(\"/b/\").data == b\"alt.index\"\n    assert client.get(\"/a/a/\").data == b\"bp.sub.index2\"\n    assert client.get(\"/b/a/\").data == b\"alt.sub.index2\"\n    assert client.get(\"/a/error\").data == b\"Error\"\n    assert client.get(\"/b/error\").data == b\"Error\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/a/').data == b'bp.index'",
                "assert client.get('/b/').data == b'alt.index'",
                "assert client.get('/a/a/').data == b'bp.sub.index2'",
                "assert client.get('/b/a/').data == b'alt.sub.index2'",
                "assert client.get('/a/error').data == b'Error'",
                "assert client.get('/b/error').data == b'Error'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "bp2.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `bp2.get` method defines a Flask route that retrieves a value from the session, specifically looking for a key named `'value'`. If this key does not exist, it returns the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the method uses `flask.session.get()` to access the session data. The `get()` method attempts to retrieve the value associated with the key `'value'`, and if it is not found, it defaults to returning the string `'None'`. This allows for a simple way to check session data and provides a fallback value if the key is absent. The session management is handled by Flask's built-in session handling capabilities, which store data across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_blueprint_renaming",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 1017,
            "end_line_number": 1046,
            "source_code": "def test_blueprint_renaming(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    bp2 = flask.Blueprint(\"bp2\", __name__)\n\n    @bp.get(\"/\")\n    def index():\n        return flask.request.endpoint\n\n    @bp.get(\"/error\")\n    def error():\n        flask.abort(403)\n\n    @bp.errorhandler(403)\n    def forbidden(_: Exception):\n        return \"Error\", 403\n\n    @bp2.get(\"/\")\n    def index2():\n        return flask.request.endpoint\n\n    bp.register_blueprint(bp2, url_prefix=\"/a\", name=\"sub\")\n    app.register_blueprint(bp, url_prefix=\"/a\")\n    app.register_blueprint(bp, url_prefix=\"/b\", name=\"alt\")\n\n    assert client.get(\"/a/\").data == b\"bp.index\"\n    assert client.get(\"/b/\").data == b\"alt.index\"\n    assert client.get(\"/a/a/\").data == b\"bp.sub.index2\"\n    assert client.get(\"/b/a/\").data == b\"alt.sub.index2\"\n    assert client.get(\"/a/error\").data == b\"Error\"\n    assert client.get(\"/b/error\").data == b\"Error\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/a/').data == b'bp.index'",
                "assert client.get('/b/').data == b'alt.index'",
                "assert client.get('/a/a/').data == b'bp.sub.index2'",
                "assert client.get('/b/a/').data == b'alt.sub.index2'",
                "assert client.get('/a/error').data == b'Error'",
                "assert client.get('/b/error').data == b'Error'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_blueprint_renaming",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 1017,
            "end_line_number": 1046,
            "source_code": "def test_blueprint_renaming(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    bp2 = flask.Blueprint(\"bp2\", __name__)\n\n    @bp.get(\"/\")\n    def index():\n        return flask.request.endpoint\n\n    @bp.get(\"/error\")\n    def error():\n        flask.abort(403)\n\n    @bp.errorhandler(403)\n    def forbidden(_: Exception):\n        return \"Error\", 403\n\n    @bp2.get(\"/\")\n    def index2():\n        return flask.request.endpoint\n\n    bp.register_blueprint(bp2, url_prefix=\"/a\", name=\"sub\")\n    app.register_blueprint(bp, url_prefix=\"/a\")\n    app.register_blueprint(bp, url_prefix=\"/b\", name=\"alt\")\n\n    assert client.get(\"/a/\").data == b\"bp.index\"\n    assert client.get(\"/b/\").data == b\"alt.index\"\n    assert client.get(\"/a/a/\").data == b\"bp.sub.index2\"\n    assert client.get(\"/b/a/\").data == b\"alt.sub.index2\"\n    assert client.get(\"/a/error\").data == b\"Error\"\n    assert client.get(\"/b/error\").data == b\"Error\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/a/').data == b'bp.index'",
                "assert client.get('/b/').data == b'alt.index'",
                "assert client.get('/a/a/').data == b'bp.sub.index2'",
                "assert client.get('/b/a/').data == b'alt.sub.index2'",
                "assert client.get('/a/error').data == b'Error'",
                "assert client.get('/b/error').data == b'Error'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, returning it to the client.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` route, the `get` function is invoked. It uses `flask.session.get` to access the session data, specifically looking for a key named `'value'`. If this key does not exist, it defaults to returning the string `'None'`. The retrieved value is then sent back as the response to the client. This method is useful for maintaining state across requests by storing and retrieving session data."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_blueprint_renaming",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 1017,
            "end_line_number": 1046,
            "source_code": "def test_blueprint_renaming(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    bp2 = flask.Blueprint(\"bp2\", __name__)\n\n    @bp.get(\"/\")\n    def index():\n        return flask.request.endpoint\n\n    @bp.get(\"/error\")\n    def error():\n        flask.abort(403)\n\n    @bp.errorhandler(403)\n    def forbidden(_: Exception):\n        return \"Error\", 403\n\n    @bp2.get(\"/\")\n    def index2():\n        return flask.request.endpoint\n\n    bp.register_blueprint(bp2, url_prefix=\"/a\", name=\"sub\")\n    app.register_blueprint(bp, url_prefix=\"/a\")\n    app.register_blueprint(bp, url_prefix=\"/b\", name=\"alt\")\n\n    assert client.get(\"/a/\").data == b\"bp.index\"\n    assert client.get(\"/b/\").data == b\"alt.index\"\n    assert client.get(\"/a/a/\").data == b\"bp.sub.index2\"\n    assert client.get(\"/b/a/\").data == b\"alt.sub.index2\"\n    assert client.get(\"/a/error\").data == b\"Error\"\n    assert client.get(\"/b/error\").data == b\"Error\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/a/').data == b'bp.index'",
                "assert client.get('/b/').data == b'alt.index'",
                "assert client.get('/a/a/').data == b'bp.sub.index2'",
                "assert client.get('/b/a/').data == b'alt.sub.index2'",
                "assert client.get('/a/error').data == b'Error'",
                "assert client.get('/b/error').data == b'Error'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_blueprint_renaming",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 1017,
            "end_line_number": 1046,
            "source_code": "def test_blueprint_renaming(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    bp2 = flask.Blueprint(\"bp2\", __name__)\n\n    @bp.get(\"/\")\n    def index():\n        return flask.request.endpoint\n\n    @bp.get(\"/error\")\n    def error():\n        flask.abort(403)\n\n    @bp.errorhandler(403)\n    def forbidden(_: Exception):\n        return \"Error\", 403\n\n    @bp2.get(\"/\")\n    def index2():\n        return flask.request.endpoint\n\n    bp.register_blueprint(bp2, url_prefix=\"/a\", name=\"sub\")\n    app.register_blueprint(bp, url_prefix=\"/a\")\n    app.register_blueprint(bp, url_prefix=\"/b\", name=\"alt\")\n\n    assert client.get(\"/a/\").data == b\"bp.index\"\n    assert client.get(\"/b/\").data == b\"alt.index\"\n    assert client.get(\"/a/a/\").data == b\"bp.sub.index2\"\n    assert client.get(\"/b/a/\").data == b\"alt.sub.index2\"\n    assert client.get(\"/a/error\").data == b\"Error\"\n    assert client.get(\"/b/error\").data == b\"Error\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/a/').data == b'bp.index'",
                "assert client.get('/b/').data == b'alt.index'",
                "assert client.get('/a/a/').data == b'bp.sub.index2'",
                "assert client.get('/b/a/').data == b'alt.sub.index2'",
                "assert client.get('/a/error').data == b'Error'",
                "assert client.get('/b/error').data == b'Error'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_blueprint_renaming",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 1017,
            "end_line_number": 1046,
            "source_code": "def test_blueprint_renaming(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    bp2 = flask.Blueprint(\"bp2\", __name__)\n\n    @bp.get(\"/\")\n    def index():\n        return flask.request.endpoint\n\n    @bp.get(\"/error\")\n    def error():\n        flask.abort(403)\n\n    @bp.errorhandler(403)\n    def forbidden(_: Exception):\n        return \"Error\", 403\n\n    @bp2.get(\"/\")\n    def index2():\n        return flask.request.endpoint\n\n    bp.register_blueprint(bp2, url_prefix=\"/a\", name=\"sub\")\n    app.register_blueprint(bp, url_prefix=\"/a\")\n    app.register_blueprint(bp, url_prefix=\"/b\", name=\"alt\")\n\n    assert client.get(\"/a/\").data == b\"bp.index\"\n    assert client.get(\"/b/\").data == b\"alt.index\"\n    assert client.get(\"/a/a/\").data == b\"bp.sub.index2\"\n    assert client.get(\"/b/a/\").data == b\"alt.sub.index2\"\n    assert client.get(\"/a/error\").data == b\"Error\"\n    assert client.get(\"/b/error\").data == b\"Error\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/a/').data == b'bp.index'",
                "assert client.get('/b/').data == b'alt.index'",
                "assert client.get('/a/a/').data == b'bp.sub.index2'",
                "assert client.get('/b/a/').data == b'alt.sub.index2'",
                "assert client.get('/a/error').data == b'Error'",
                "assert client.get('/b/error').data == b'Error'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_blueprint_renaming",
            "module": "test_blueprints",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_blueprints.py",
            "line_number": 1017,
            "end_line_number": 1046,
            "source_code": "def test_blueprint_renaming(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    bp2 = flask.Blueprint(\"bp2\", __name__)\n\n    @bp.get(\"/\")\n    def index():\n        return flask.request.endpoint\n\n    @bp.get(\"/error\")\n    def error():\n        flask.abort(403)\n\n    @bp.errorhandler(403)\n    def forbidden(_: Exception):\n        return \"Error\", 403\n\n    @bp2.get(\"/\")\n    def index2():\n        return flask.request.endpoint\n\n    bp.register_blueprint(bp2, url_prefix=\"/a\", name=\"sub\")\n    app.register_blueprint(bp, url_prefix=\"/a\")\n    app.register_blueprint(bp, url_prefix=\"/b\", name=\"alt\")\n\n    assert client.get(\"/a/\").data == b\"bp.index\"\n    assert client.get(\"/b/\").data == b\"alt.index\"\n    assert client.get(\"/a/a/\").data == b\"bp.sub.index2\"\n    assert client.get(\"/b/a/\").data == b\"alt.sub.index2\"\n    assert client.get(\"/a/error\").data == b\"Error\"\n    assert client.get(\"/b/error\").data == b\"Error\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "jinja2.TemplateNotFound",
                "werkzeug.http.parse_cache_control_header",
                "flask",
                "blueprintapp.app",
                "blueprintapp.app",
                "werkzeug.routing.Rule"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/a/').data == b'bp.index'",
                "assert client.get('/b/').data == b'alt.index'",
                "assert client.get('/a/a/').data == b'bp.sub.index2'",
                "assert client.get('/b/a/').data == b'alt.sub.index2'",
                "assert client.get('/a/error').data == b'Error'",
                "assert client.get('/b/error').data == b'Error'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_max_content_length",
            "module": "test_request",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_request.py",
            "line_number": 9,
            "end_line_number": 22,
            "source_code": "def test_max_content_length(app: Flask, client: FlaskClient) -> None:\n    app.config[\"MAX_CONTENT_LENGTH\"] = 50\n\n    @app.post(\"/\")\n    def index():\n        request.form[\"myfile\"]\n        AssertionError()\n\n    @app.errorhandler(413)\n    def catcher(error):\n        return \"42\"\n\n    rv = client.post(\"/\", data={\"myfile\": \"foo\" * 50})\n    assert rv.data == b\"42\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "__future__.annotations",
                "flask.Flask",
                "flask.Request",
                "flask.request",
                "flask.testing.FlaskClient"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'42'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "app.post",
                    "body": "def post(self):\n    return 'Create'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `app.post` method is designed to handle HTTP POST requests in a Flask application. It allows the application to define routes that respond to POST requests, typically used for creating or updating resources.\n\n**How It Works**:\nThe method is part of the Flask framework, which uses decorators to associate a function with a specific URL route and HTTP method. When a POST request is made to a defined route, the corresponding function is executed. In the provided code snippets, the `create`, `update`, and `delete` functions demonstrate how to handle form submissions and database operations based on POST requests. The `post` method itself returns a simple string 'Create', indicating a placeholder for functionality that would typically involve creating a new resource."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_max_content_length",
            "module": "test_request",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_request.py",
            "line_number": 9,
            "end_line_number": 22,
            "source_code": "def test_max_content_length(app: Flask, client: FlaskClient) -> None:\n    app.config[\"MAX_CONTENT_LENGTH\"] = 50\n\n    @app.post(\"/\")\n    def index():\n        request.form[\"myfile\"]\n        AssertionError()\n\n    @app.errorhandler(413)\n    def catcher(error):\n        return \"42\"\n\n    rv = client.post(\"/\", data={\"myfile\": \"foo\" * 50})\n    assert rv.data == b\"42\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "__future__.annotations",
                "flask.Flask",
                "flask.Request",
                "flask.request",
                "flask.testing.FlaskClient"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'42'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.post",
                    "body": "def post(self):\n    return 'Create'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is designed to simulate an HTTP POST request to a specified endpoint, allowing developers to send data to the server, typically for creating or updating resources.\n\n**How It Works**:\nWhen invoked, `client.post` sends a request to the server at the specified URL with the provided data. In the context of the code snippets, it is used to test various functionalities such as creating a new post, updating an existing post, and validating input data. The method returns a response indicating the result of the operation, which can be further inspected for status codes or response data. The method is part of a testing framework that helps ensure the application's endpoints behave as expected."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_trusted_hosts_config",
            "module": "test_request",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_request.py",
            "line_number": 57,
            "end_line_number": 70,
            "source_code": "def test_trusted_hosts_config(app: Flask) -> None:\n    app.config[\"TRUSTED_HOSTS\"] = [\"example.test\", \".other.test\"]\n\n    @app.get(\"/\")\n    def index() -> str:\n        return \"\"\n\n    client = app.test_client()\n    r = client.get(base_url=\"http://example.test\")\n    assert r.status_code == 200\n    r = client.get(base_url=\"http://a.other.test\")\n    assert r.status_code == 200\n    r = client.get(base_url=\"http://bad.test\")\n    assert r.status_code == 400",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "__future__.annotations",
                "flask.Flask",
                "flask.Request",
                "flask.request",
                "flask.testing.FlaskClient"
            ],
            "fixtures": [],
            "assertions": [
                "assert r.status_code == 200",
                "assert r.status_code == 200",
                "assert r.status_code == 400"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "app.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `app.get` method is used to define a route in a Flask web application that responds to HTTP GET requests. Specifically, the route `/get` retrieves a value from the session, returning it to the client.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, it attempts to retrieve the value associated with the key `'value'` from the Flask session. If the key does not exist, it defaults to returning the string `'None'`. The retrieved value is then sent back as the response to the client. This method leverages Flask's session management to store and retrieve user-specific data across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_trusted_hosts_config",
            "module": "test_request",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_request.py",
            "line_number": 57,
            "end_line_number": 70,
            "source_code": "def test_trusted_hosts_config(app: Flask) -> None:\n    app.config[\"TRUSTED_HOSTS\"] = [\"example.test\", \".other.test\"]\n\n    @app.get(\"/\")\n    def index() -> str:\n        return \"\"\n\n    client = app.test_client()\n    r = client.get(base_url=\"http://example.test\")\n    assert r.status_code == 200\n    r = client.get(base_url=\"http://a.other.test\")\n    assert r.status_code == 200\n    r = client.get(base_url=\"http://bad.test\")\n    assert r.status_code == 400",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "__future__.annotations",
                "flask.Flask",
                "flask.Request",
                "flask.request",
                "flask.testing.FlaskClient"
            ],
            "fixtures": [],
            "assertions": [
                "assert r.status_code == 200",
                "assert r.status_code == 200",
                "assert r.status_code == 400"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_trusted_hosts_config",
            "module": "test_request",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_request.py",
            "line_number": 57,
            "end_line_number": 70,
            "source_code": "def test_trusted_hosts_config(app: Flask) -> None:\n    app.config[\"TRUSTED_HOSTS\"] = [\"example.test\", \".other.test\"]\n\n    @app.get(\"/\")\n    def index() -> str:\n        return \"\"\n\n    client = app.test_client()\n    r = client.get(base_url=\"http://example.test\")\n    assert r.status_code == 200\n    r = client.get(base_url=\"http://a.other.test\")\n    assert r.status_code == 200\n    r = client.get(base_url=\"http://bad.test\")\n    assert r.status_code == 400",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "__future__.annotations",
                "flask.Flask",
                "flask.Request",
                "flask.request",
                "flask.testing.FlaskClient"
            ],
            "fixtures": [],
            "assertions": [
                "assert r.status_code == 200",
                "assert r.status_code == 200",
                "assert r.status_code == 400"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_trusted_hosts_config",
            "module": "test_request",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_request.py",
            "line_number": 57,
            "end_line_number": 70,
            "source_code": "def test_trusted_hosts_config(app: Flask) -> None:\n    app.config[\"TRUSTED_HOSTS\"] = [\"example.test\", \".other.test\"]\n\n    @app.get(\"/\")\n    def index() -> str:\n        return \"\"\n\n    client = app.test_client()\n    r = client.get(base_url=\"http://example.test\")\n    assert r.status_code == 200\n    r = client.get(base_url=\"http://a.other.test\")\n    assert r.status_code == 200\n    r = client.get(base_url=\"http://bad.test\")\n    assert r.status_code == 400",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "__future__.annotations",
                "flask.Flask",
                "flask.Request",
                "flask.request",
                "flask.testing.FlaskClient"
            ],
            "fixtures": [],
            "assertions": [
                "assert r.status_code == 200",
                "assert r.status_code == 200",
                "assert r.status_code == 400"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is used to define a route in a Flask web application that retrieves a value stored in the session. If the session does not contain the specified value, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nThe method is decorated with `@app.route('/get')`, which maps the URL path `/get` to the `get` function. When a GET request is made to this endpoint, the function accesses the session using `flask.session.get('value', 'None')`. This retrieves the value associated with the key `'value'` from the session; if it does not exist, it returns `'None'`. The retrieved value is then returned as the response to the client. This allows for session data to be accessed and utilized in web applications, facilitating state management across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_config_from_pyfile",
            "module": "test_config",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_config.py",
            "line_number": 19,
            "end_line_number": 22,
            "source_code": "def test_config_from_pyfile():\n    app = flask.Flask(__name__)\n    app.config.from_pyfile(f\"{__file__.rsplit('.', 1)[0]}.py\")\n    common_object_test(app)",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "json",
                "os",
                "pytest",
                "flask"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "common_object_test",
                    "body": "def common_object_test(app):\n    assert app.secret_key == 'config'\n    assert app.config['TEST_KEY'] == 'foo'\n    assert 'TestConfig' not in app.config",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `common_object_test` method is designed to validate specific configuration settings of a Flask application instance. It checks that the application's secret key and a specific configuration key are set to expected values, and it ensures that a certain configuration key is not present.\n\n**How It Works**:\nThe method takes a Flask application object as an argument and performs three assertions:\n1. It asserts that the `secret_key` of the application is equal to the string `'config'`.\n2. It checks that the value of `TEST_KEY` in the application's configuration is equal to `'foo'`.\n3. It verifies that the key `'TestConfig'` is not present in the application's configuration dictionary.\n\nIf any of these assertions fail, an `AssertionError` will be raised, indicating that the application configuration does not meet the expected criteria. This method is typically called after setting up the application configuration to ensure it has been correctly applied."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_config_from_object",
            "module": "test_config",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_config.py",
            "line_number": 25,
            "end_line_number": 28,
            "source_code": "def test_config_from_object():\n    app = flask.Flask(__name__)\n    app.config.from_object(__name__)\n    common_object_test(app)",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "json",
                "os",
                "pytest",
                "flask"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "common_object_test",
                    "body": "def common_object_test(app):\n    assert app.secret_key == 'config'\n    assert app.config['TEST_KEY'] == 'foo'\n    assert 'TestConfig' not in app.config",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `common_object_test` method is designed to validate the configuration of a Flask application instance. It checks that the application's `secret_key` is set to 'config', that a specific configuration key (`TEST_KEY`) is set to 'foo', and that a certain configuration (`TestConfig`) is not present in the application's configuration dictionary.\n\n**How It Works**:\nThe method takes a single argument, `app`, which is expected to be a Flask application instance. It uses assertions to verify three conditions:\n1. `app.secret_key` must equal 'config'.\n2. The value of `app.config['TEST_KEY']` must be 'foo'.\n3. The string 'TestConfig' should not be a key in `app.config`.\n\nIf any of these assertions fail, an `AssertionError` will be raised, indicating that the application configuration does not meet the expected criteria. This method is typically called after setting up the application configuration to ensure it has been correctly applied."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_config_from_file_json",
            "module": "test_config",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_config.py",
            "line_number": 31,
            "end_line_number": 35,
            "source_code": "def test_config_from_file_json():\n    app = flask.Flask(__name__)\n    current_dir = os.path.dirname(os.path.abspath(__file__))\n    app.config.from_file(os.path.join(current_dir, \"static\", \"config.json\"), json.load)\n    common_object_test(app)",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "json",
                "os",
                "pytest",
                "flask"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "common_object_test",
                    "body": "def common_object_test(app):\n    assert app.secret_key == 'config'\n    assert app.config['TEST_KEY'] == 'foo'\n    assert 'TestConfig' not in app.config",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `common_object_test` method is designed to validate the configuration of a Flask application instance. It checks that the application's `secret_key` is set to 'config', that a specific configuration key (`TEST_KEY`) is set to 'foo', and that a certain configuration (`TestConfig`) is not present in the application's configuration.\n\n**How It Works**:\nThe method takes a single argument, `app`, which is expected to be a Flask application instance. It uses assertions to verify three conditions:\n1. `app.secret_key` must equal 'config'.\n2. The value of `app.config['TEST_KEY']` must be 'foo'.\n3. The string 'TestConfig' should not be found in `app.config`.\n\nIf any of these assertions fail, an `AssertionError` will be raised, indicating that the application configuration does not meet the expected criteria. This method is typically called after setting up the application configuration to ensure it has been correctly applied."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_config_from_file_toml",
            "module": "test_config",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_config.py",
            "line_number": 38,
            "end_line_number": 45,
            "source_code": "def test_config_from_file_toml():\n    tomllib = pytest.importorskip(\"tomllib\", reason=\"tomllib added in 3.11\")\n    app = flask.Flask(__name__)\n    current_dir = os.path.dirname(os.path.abspath(__file__))\n    app.config.from_file(\n        os.path.join(current_dir, \"static\", \"config.toml\"), tomllib.load, text=False\n    )\n    common_object_test(app)",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "json",
                "os",
                "pytest",
                "flask"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "common_object_test",
                    "body": "def common_object_test(app):\n    assert app.secret_key == 'config'\n    assert app.config['TEST_KEY'] == 'foo'\n    assert 'TestConfig' not in app.config",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `common_object_test` method is designed to validate the configuration of a Flask application instance. It checks that the application's secret key and a specific configuration key are set to expected values, and it ensures that a certain configuration class is not present in the app's configuration.\n\n**How It Works**:\nThe method takes a Flask application instance (`app`) as an argument and performs three assertions:\n1. It asserts that `app.secret_key` is equal to the string `'config'`.\n2. It checks that the value of `app.config['TEST_KEY']` is `'foo'`.\n3. It verifies that the string `'TestConfig'` is not present in `app.config`.\n\nIf any of these assertions fail, an `AssertionError` will be raised, indicating that the application's configuration does not meet the expected criteria. This method is typically called after setting up the application configuration to ensure it has been correctly applied."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_config_from_mapping",
            "module": "test_config",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_config.py",
            "line_number": 110,
            "end_line_number": 129,
            "source_code": "def test_config_from_mapping():\n    app = flask.Flask(__name__)\n    app.config.from_mapping({\"SECRET_KEY\": \"config\", \"TEST_KEY\": \"foo\"})\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    app.config.from_mapping([(\"SECRET_KEY\", \"config\"), (\"TEST_KEY\", \"foo\")])\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    app.config.from_mapping(SECRET_KEY=\"config\", TEST_KEY=\"foo\")\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    app.config.from_mapping(SECRET_KEY=\"config\", TEST_KEY=\"foo\", skip_key=\"skip\")\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    with pytest.raises(TypeError):\n        app.config.from_mapping({}, {})",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "json",
                "os",
                "pytest",
                "flask"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "common_object_test",
                    "body": "def common_object_test(app):\n    assert app.secret_key == 'config'\n    assert app.config['TEST_KEY'] == 'foo'\n    assert 'TestConfig' not in app.config",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `common_object_test` method is designed to validate the configuration of a Flask application instance. It checks that the application's secret key and a specific configuration key (`TEST_KEY`) are set to expected values, and it ensures that a certain configuration class (`TestConfig`) is not present in the application's configuration.\n\n**How It Works**:\nThe method takes a Flask application instance (`app`) as an argument and performs three assertions:\n1. It asserts that `app.secret_key` is equal to the string `'config'`.\n2. It checks that the value of `app.config['TEST_KEY']` is `'foo'`.\n3. It verifies that the string `'TestConfig'` is not a key in `app.config`.\n\nIf any of these assertions fail, an `AssertionError` will be raised, indicating that the application's configuration does not meet the expected criteria. This method is typically called after setting up the application configuration to ensure that it has been correctly applied."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_config_from_mapping",
            "module": "test_config",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_config.py",
            "line_number": 110,
            "end_line_number": 129,
            "source_code": "def test_config_from_mapping():\n    app = flask.Flask(__name__)\n    app.config.from_mapping({\"SECRET_KEY\": \"config\", \"TEST_KEY\": \"foo\"})\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    app.config.from_mapping([(\"SECRET_KEY\", \"config\"), (\"TEST_KEY\", \"foo\")])\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    app.config.from_mapping(SECRET_KEY=\"config\", TEST_KEY=\"foo\")\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    app.config.from_mapping(SECRET_KEY=\"config\", TEST_KEY=\"foo\", skip_key=\"skip\")\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    with pytest.raises(TypeError):\n        app.config.from_mapping({}, {})",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "json",
                "os",
                "pytest",
                "flask"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "common_object_test",
                    "body": "def common_object_test(app):\n    assert app.secret_key == 'config'\n    assert app.config['TEST_KEY'] == 'foo'\n    assert 'TestConfig' not in app.config",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `common_object_test` method is designed to validate the configuration of a Flask application instance. It checks that the application's secret key is set to a specific value and that a particular configuration key is present with the expected value. Additionally, it ensures that a specific configuration class is not included in the app's configuration.\n\n**How It Works**:  \nThe method takes a Flask application instance (`app`) as an argument and performs three assertions:\n1. It asserts that `app.secret_key` is equal to `'config'`, ensuring that the application has a defined secret key for session management and security.\n2. It checks that `app.config['TEST_KEY']` is equal to `'foo'`, confirming that the application has the expected test configuration value.\n3. It asserts that `'TestConfig'` is not present in `app.config`, which ensures that the application is not using a specific configuration class that might interfere with the expected setup.\n\nThese assertions help ensure that the application is correctly configured for testing scenarios, providing a safeguard against misconfigurations."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_config_from_mapping",
            "module": "test_config",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_config.py",
            "line_number": 110,
            "end_line_number": 129,
            "source_code": "def test_config_from_mapping():\n    app = flask.Flask(__name__)\n    app.config.from_mapping({\"SECRET_KEY\": \"config\", \"TEST_KEY\": \"foo\"})\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    app.config.from_mapping([(\"SECRET_KEY\", \"config\"), (\"TEST_KEY\", \"foo\")])\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    app.config.from_mapping(SECRET_KEY=\"config\", TEST_KEY=\"foo\")\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    app.config.from_mapping(SECRET_KEY=\"config\", TEST_KEY=\"foo\", skip_key=\"skip\")\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    with pytest.raises(TypeError):\n        app.config.from_mapping({}, {})",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "json",
                "os",
                "pytest",
                "flask"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "common_object_test",
                    "body": "def common_object_test(app):\n    assert app.secret_key == 'config'\n    assert app.config['TEST_KEY'] == 'foo'\n    assert 'TestConfig' not in app.config",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `common_object_test` method is designed to validate the configuration of a Flask application instance. It checks that the application's secret key and a specific configuration key (`TEST_KEY`) are set to expected values, and it ensures that a certain configuration class (`TestConfig`) is not present in the application's configuration.\n\n**How It Works**:\nThe method takes a Flask application instance (`app`) as an argument and performs three assertions:\n1. It asserts that `app.secret_key` is equal to the string `'config'`.\n2. It checks that the value of `app.config['TEST_KEY']` is `'foo'`.\n3. It verifies that the string `'TestConfig'` is not a key in `app.config`.\n\nIf any of these assertions fail, an `AssertionError` will be raised, indicating that the application's configuration does not meet the expected criteria. This method is typically called after setting up the application configuration to ensure that it has been correctly applied."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_config_from_mapping",
            "module": "test_config",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_config.py",
            "line_number": 110,
            "end_line_number": 129,
            "source_code": "def test_config_from_mapping():\n    app = flask.Flask(__name__)\n    app.config.from_mapping({\"SECRET_KEY\": \"config\", \"TEST_KEY\": \"foo\"})\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    app.config.from_mapping([(\"SECRET_KEY\", \"config\"), (\"TEST_KEY\", \"foo\")])\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    app.config.from_mapping(SECRET_KEY=\"config\", TEST_KEY=\"foo\")\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    app.config.from_mapping(SECRET_KEY=\"config\", TEST_KEY=\"foo\", skip_key=\"skip\")\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    with pytest.raises(TypeError):\n        app.config.from_mapping({}, {})",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "json",
                "os",
                "pytest",
                "flask"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "common_object_test",
                    "body": "def common_object_test(app):\n    assert app.secret_key == 'config'\n    assert app.config['TEST_KEY'] == 'foo'\n    assert 'TestConfig' not in app.config",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `common_object_test` method is designed to validate the configuration settings of a Flask application instance. It checks that the `secret_key` is set to 'config', the `TEST_KEY` in the app's configuration is 'foo', and that 'TestConfig' is not present in the app's configuration.\n\n**How It Works**:\nThe method takes a Flask application object as an argument and uses assertions to verify specific configuration values. If any of the assertions fail, an `AssertionError` will be raised, indicating that the application is not configured as expected. This method is typically called after setting up the app's configuration to ensure that the expected values are correctly applied, helping to catch configuration errors early in the testing process."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_config_from_class",
            "module": "test_config",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_config.py",
            "line_number": 132,
            "end_line_number": 141,
            "source_code": "def test_config_from_class():\n    class Base:\n        TEST_KEY = \"foo\"\n\n    class Test(Base):\n        SECRET_KEY = \"config\"\n\n    app = flask.Flask(__name__)\n    app.config.from_object(Test)\n    common_object_test(app)",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "json",
                "os",
                "pytest",
                "flask"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "common_object_test",
                    "body": "def common_object_test(app):\n    assert app.secret_key == 'config'\n    assert app.config['TEST_KEY'] == 'foo'\n    assert 'TestConfig' not in app.config",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `common_object_test` method is designed to validate the configuration of a Flask application instance. It checks that the application's secret key and a specific configuration key (`TEST_KEY`) are set to expected values, and it ensures that a certain configuration class (`TestConfig`) is not present in the application's configuration.\n\n**How It Works**:\nThe method takes a Flask application instance (`app`) as an argument and performs three assertions:\n1. It asserts that `app.secret_key` is equal to the string `'config'`.\n2. It checks that the value of `app.config['TEST_KEY']` is `'foo'`.\n3. It verifies that the string `'TestConfig'` is not a key in `app.config`.\n\nIf any of these assertions fail, an `AssertionError` will be raised, indicating that the application's configuration does not meet the expected criteria. This method is typically called after setting up the application configuration to ensure that it has been correctly applied."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_config_from_envvar",
            "module": "test_config",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_config.py",
            "line_number": 144,
            "end_line_number": 158,
            "source_code": "def test_config_from_envvar(monkeypatch):\n    monkeypatch.setattr(\"os.environ\", {})\n    app = flask.Flask(__name__)\n\n    with pytest.raises(RuntimeError) as e:\n        app.config.from_envvar(\"FOO_SETTINGS\")\n\n    assert \"'FOO_SETTINGS' is not set\" in str(e.value)\n    assert not app.config.from_envvar(\"FOO_SETTINGS\", silent=True)\n\n    monkeypatch.setattr(\n        \"os.environ\", {\"FOO_SETTINGS\": f\"{__file__.rsplit('.', 1)[0]}.py\"}\n    )\n    assert app.config.from_envvar(\"FOO_SETTINGS\")\n    common_object_test(app)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "monkeypatch"
            ],
            "imports": [
                "json",
                "os",
                "pytest",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert \"'FOO_SETTINGS' is not set\" in str(e.value)",
                "assert not app.config.from_envvar('FOO_SETTINGS', silent=True)",
                "assert app.config.from_envvar('FOO_SETTINGS')"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "common_object_test",
                    "body": "def common_object_test(app):\n    assert app.secret_key == 'config'\n    assert app.config['TEST_KEY'] == 'foo'\n    assert 'TestConfig' not in app.config",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `common_object_test` method is designed to validate the configuration of a Flask application instance. It checks that the application's secret key and a specific configuration key are set to expected values, and it ensures that a certain configuration class is not present in the app's configuration.\n\n**How It Works**:\nThe method takes a Flask application instance (`app`) as an argument and performs three assertions:\n1. It asserts that `app.secret_key` is equal to the string `'config'`.\n2. It checks that the value of `app.config['TEST_KEY']` is `'foo'`.\n3. It verifies that the string `'TestConfig'` is not present in `app.config`.\n\nIf any of these assertions fail, an `AssertionError` will be raised, indicating that the application's configuration does not meet the expected criteria. This method is typically called after setting up the application configuration to ensure it has been correctly applied."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_custom_config_class",
            "module": "test_config",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_config.py",
            "line_number": 198,
            "end_line_number": 208,
            "source_code": "def test_custom_config_class():\n    class Config(flask.Config):\n        pass\n\n    class Flask(flask.Flask):\n        config_class = Config\n\n    app = Flask(__name__)\n    assert isinstance(app.config, Config)\n    app.config.from_object(__name__)\n    common_object_test(app)",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "json",
                "os",
                "pytest",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert isinstance(app.config, Config)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "common_object_test",
                    "body": "def common_object_test(app):\n    assert app.secret_key == 'config'\n    assert app.config['TEST_KEY'] == 'foo'\n    assert 'TestConfig' not in app.config",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `common_object_test` method is designed to validate the configuration settings of a Flask application instance. It checks that the `secret_key` is set to 'config', the `TEST_KEY` in the app's configuration is 'foo', and that 'TestConfig' is not present in the app's configuration.\n\n**How It Works**:\nThe method takes a single argument, `app`, which is expected to be a Flask application instance. It uses assertions to verify three conditions:\n1. `app.secret_key` must equal 'config'.\n2. `app.config['TEST_KEY']` must equal 'foo'.\n3. The string 'TestConfig' should not be a key in `app.config`.\n\nIf any of these assertions fail, an `AssertionError` will be raised, indicating that the application configuration does not meet the expected criteria. This method is typically called after setting up the app's configuration to ensure it has been correctly applied."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_basic_view",
            "module": "test_views",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_views.py",
            "line_number": 17,
            "end_line_number": 25,
            "source_code": "def test_basic_view(app):\n    class Index(flask.views.View):\n        methods = [\"GET\", \"POST\"]\n\n        def dispatch_request(self):\n            return flask.request.method\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n    common_test(app)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "pytest",
                "werkzeug.http.parse_set_header",
                "flask.views"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "common_test",
                    "body": "def common_test(app):\n    c = app.test_client()\n    assert c.get('/').data == b'GET'\n    assert c.post('/').data == b'POST'\n    assert c.put('/').status_code == 405\n    meths = parse_set_header(c.open('/', method='OPTIONS').headers['Allow'])\n    assert sorted(meths) == ['GET', 'HEAD', 'OPTIONS', 'POST']",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `common_test` method is designed to validate the behavior of a Flask application by testing its HTTP methods and responses. It ensures that the application correctly handles GET, POST, and OPTIONS requests, and verifies the allowed methods for a specific route.\n\n**How It Works**:\n1. **Test Client Creation**: It creates a test client instance (`c`) from the provided Flask `app`, allowing simulated requests to be made to the application.\n2. **GET Request Validation**: It asserts that a GET request to the root URL (`/`) returns the byte string `b'GET'`.\n3. **POST Request Validation**: It asserts that a POST request to the root URL returns the byte string `b'POST'`.\n4. **PUT Request Validation**: It checks that a PUT request to the root URL results in a 405 status code, indicating that the method is not allowed.\n5. **OPTIONS Request Validation**: It sends an OPTIONS request to the root URL and parses the `Allow` header to retrieve the supported HTTP methods. It then asserts that the sorted list of allowed methods matches the expected methods: `['GET', 'HEAD', 'OPTIONS', 'POST']`.\n\nThis method is typically called within various test functions to ensure that the defined routes in the Flask application behave as expected for different HTTP methods."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_method_based_view",
            "module": "test_views",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_views.py",
            "line_number": 28,
            "end_line_number": 38,
            "source_code": "def test_method_based_view(app):\n    class Index(flask.views.MethodView):\n        def get(self):\n            return \"GET\"\n\n        def post(self):\n            return \"POST\"\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n\n    common_test(app)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "pytest",
                "werkzeug.http.parse_set_header",
                "flask.views"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "common_test",
                    "body": "def common_test(app):\n    c = app.test_client()\n    assert c.get('/').data == b'GET'\n    assert c.post('/').data == b'POST'\n    assert c.put('/').status_code == 405\n    meths = parse_set_header(c.open('/', method='OPTIONS').headers['Allow'])\n    assert sorted(meths) == ['GET', 'HEAD', 'OPTIONS', 'POST']",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `common_test` method is designed to validate the behavior of a Flask application by testing its HTTP methods and responses. It ensures that the application correctly handles GET, POST, and OPTIONS requests, and verifies the allowed methods for a specific route.\n\n**How It Works**:\n1. **Test Client Creation**: It creates a test client (`c`) for the Flask application, allowing simulated requests to be made.\n2. **GET Request Test**: It asserts that a GET request to the root URL (`/`) returns the byte string `b'GET'`.\n3. **POST Request Test**: It asserts that a POST request to the root URL returns the byte string `b'POST'`.\n4. **PUT Request Test**: It checks that a PUT request results in a 405 status code, indicating that the method is not allowed.\n5. **OPTIONS Request Test**: It sends an OPTIONS request to the root URL and parses the `Allow` header to retrieve the supported methods. It then asserts that the sorted list of allowed methods matches the expected methods: `['GET', 'HEAD', 'OPTIONS', 'POST']`.\n\nThis method is typically called within other test functions to ensure that the defined routes in the Flask application behave as expected."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_view_patching",
            "module": "test_views",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_views.py",
            "line_number": 41,
            "end_line_number": 59,
            "source_code": "def test_view_patching(app):\n    class Index(flask.views.MethodView):\n        def get(self):\n            raise ZeroDivisionError\n\n        def post(self):\n            raise ZeroDivisionError\n\n    class Other(Index):\n        def get(self):\n            return \"GET\"\n\n        def post(self):\n            return \"POST\"\n\n    view = Index.as_view(\"index\")\n    view.view_class = Other\n    app.add_url_rule(\"/\", view_func=view)\n    common_test(app)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "pytest",
                "werkzeug.http.parse_set_header",
                "flask.views"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "common_test",
                    "body": "def common_test(app):\n    c = app.test_client()\n    assert c.get('/').data == b'GET'\n    assert c.post('/').data == b'POST'\n    assert c.put('/').status_code == 405\n    meths = parse_set_header(c.open('/', method='OPTIONS').headers['Allow'])\n    assert sorted(meths) == ['GET', 'HEAD', 'OPTIONS', 'POST']",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `common_test` method is designed to validate the behavior of a Flask application by testing its HTTP methods and responses. It ensures that the application correctly handles GET, POST, and OPTIONS requests, and verifies the allowed methods for a specific route.\n\n**How It Works**:\n1. **Test Client Creation**: It creates a test client (`c`) for the Flask application, allowing simulated HTTP requests.\n2. **GET Request Test**: It asserts that a GET request to the root URL (`/`) returns the byte string `b'GET'`.\n3. **POST Request Test**: It asserts that a POST request to the root URL returns the byte string `b'POST'`.\n4. **PUT Request Test**: It asserts that a PUT request to the root URL results in a 405 status code, indicating that the method is not allowed.\n5. **OPTIONS Request Test**: It sends an OPTIONS request to the root URL and parses the `Allow` header to check which methods are permitted. It asserts that the sorted list of allowed methods matches `['GET', 'HEAD', 'OPTIONS', 'POST']`.\n\nThis method is typically called within other test functions to ensure that the defined routes in the Flask application behave as expected."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_view_decorators",
            "module": "test_views",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_views.py",
            "line_number": 80,
            "end_line_number": 98,
            "source_code": "def test_view_decorators(app, client):\n    def add_x_parachute(f):\n        def new_function(*args, **kwargs):\n            resp = flask.make_response(f(*args, **kwargs))\n            resp.headers[\"X-Parachute\"] = \"awesome\"\n            return resp\n\n        return new_function\n\n    class Index(flask.views.View):\n        decorators = [add_x_parachute]\n\n        def dispatch_request(self):\n            return \"Awesome\"\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n    rv = client.get(\"/\")\n    assert rv.headers[\"X-Parachute\"] == \"awesome\"\n    assert rv.data == b\"Awesome\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "werkzeug.http.parse_set_header",
                "flask.views"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.headers['X-Parachute'] == 'awesome'",
                "assert rv.data == b'Awesome'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called, which attempts to fetch the value stored in the session under the key `'value'`. If this key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve user-specific data across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_implicit_head",
            "module": "test_views",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_views.py",
            "line_number": 141,
            "end_line_number": 152,
            "source_code": "def test_implicit_head(app, client):\n    class Index(flask.views.MethodView):\n        def get(self):\n            return flask.Response(\"Blub\", headers={\"X-Method\": flask.request.method})\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n    rv = client.get(\"/\")\n    assert rv.data == b\"Blub\"\n    assert rv.headers[\"X-Method\"] == \"GET\"\n    rv = client.head(\"/\")\n    assert rv.data == b\"\"\n    assert rv.headers[\"X-Method\"] == \"HEAD\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "werkzeug.http.parse_set_header",
                "flask.views"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'Blub'",
                "assert rv.headers['X-Method'] == 'GET'",
                "assert rv.data == b''",
                "assert rv.headers['X-Method'] == 'HEAD'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. Finally, the retrieved value is returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_implicit_head",
            "module": "test_views",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_views.py",
            "line_number": 141,
            "end_line_number": 152,
            "source_code": "def test_implicit_head(app, client):\n    class Index(flask.views.MethodView):\n        def get(self):\n            return flask.Response(\"Blub\", headers={\"X-Method\": flask.request.method})\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n    rv = client.get(\"/\")\n    assert rv.data == b\"Blub\"\n    assert rv.headers[\"X-Method\"] == \"GET\"\n    rv = client.head(\"/\")\n    assert rv.data == b\"\"\n    assert rv.headers[\"X-Method\"] == \"HEAD\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "werkzeug.http.parse_set_header",
                "flask.views"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'Blub'",
                "assert rv.headers['X-Method'] == 'GET'",
                "assert rv.data == b''",
                "assert rv.headers['X-Method'] == 'HEAD'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.head",
                    "body": "def head(self):\n    return flask.Response('', headers={'X-Method': 'HEAD'})",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.head` method is designed to handle HTTP HEAD requests in a Flask application. It returns a response with no body but includes headers, allowing clients to retrieve metadata about a resource without transferring the entire content.\n\n**How It Works**:  \nWhen the `head` method is called, it creates and returns a `flask.Response` object with an empty string as the body and a custom header `X-Method` set to `'HEAD'`. This method is typically used in conjunction with a route defined in a Flask application, allowing clients to make HEAD requests to check the status or metadata of a resource without downloading the full content. The method can be explicitly defined in a view class, as shown in the `test_explicit_head` test case, where it is tested alongside a GET method to ensure proper functionality."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_explicit_head",
            "module": "test_views",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_views.py",
            "line_number": 155,
            "end_line_number": 168,
            "source_code": "def test_explicit_head(app, client):\n    class Index(flask.views.MethodView):\n        def get(self):\n            return \"GET\"\n\n        def head(self):\n            return flask.Response(\"\", headers={\"X-Method\": \"HEAD\"})\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n    rv = client.get(\"/\")\n    assert rv.data == b\"GET\"\n    rv = client.head(\"/\")\n    assert rv.data == b\"\"\n    assert rv.headers[\"X-Method\"] == \"HEAD\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "werkzeug.http.parse_set_header",
                "flask.views"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'GET'",
                "assert rv.data == b''",
                "assert rv.headers['X-Method'] == 'HEAD'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_explicit_head",
            "module": "test_views",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_views.py",
            "line_number": 155,
            "end_line_number": 168,
            "source_code": "def test_explicit_head(app, client):\n    class Index(flask.views.MethodView):\n        def get(self):\n            return \"GET\"\n\n        def head(self):\n            return flask.Response(\"\", headers={\"X-Method\": \"HEAD\"})\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n    rv = client.get(\"/\")\n    assert rv.data == b\"GET\"\n    rv = client.head(\"/\")\n    assert rv.data == b\"\"\n    assert rv.headers[\"X-Method\"] == \"HEAD\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "werkzeug.http.parse_set_header",
                "flask.views"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'GET'",
                "assert rv.data == b''",
                "assert rv.headers['X-Method'] == 'HEAD'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.head",
                    "body": "def head(self):\n    return flask.Response('', headers={'X-Method': 'HEAD'})",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.head` method is designed to handle HTTP HEAD requests in a Flask application. It returns a response with no body but includes headers, allowing clients to retrieve metadata about a resource without transferring the entire content.\n\n**How It Works**:  \nWhen the `head` method is called, it creates and returns a `flask.Response` object with an empty string as the body and a custom header `X-Method` set to `'HEAD'`. This is useful for clients that want to check the existence or properties of a resource without downloading the full content, as HEAD requests are typically used for this purpose. The method can be explicitly defined in a view class, allowing for tailored responses based on the application's needs."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_endpoint_override",
            "module": "test_views",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_views.py",
            "line_number": 171,
            "end_line_number": 186,
            "source_code": "def test_endpoint_override(app):\n    app.debug = True\n\n    class Index(flask.views.View):\n        methods = [\"GET\", \"POST\"]\n\n        def dispatch_request(self):\n            return flask.request.method\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n\n    with pytest.raises(AssertionError):\n        app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n\n    # But these tests should still pass. We just log a warning.\n    common_test(app)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "pytest",
                "werkzeug.http.parse_set_header",
                "flask.views"
            ],
            "fixtures": [],
            "assertions": [],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "common_test",
                    "body": "def common_test(app):\n    c = app.test_client()\n    assert c.get('/').data == b'GET'\n    assert c.post('/').data == b'POST'\n    assert c.put('/').status_code == 405\n    meths = parse_set_header(c.open('/', method='OPTIONS').headers['Allow'])\n    assert sorted(meths) == ['GET', 'HEAD', 'OPTIONS', 'POST']",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `common_test` method is designed to validate the behavior of a Flask application by testing its HTTP methods and responses. It ensures that the application correctly handles GET, POST, and OPTIONS requests, and verifies the allowed methods for a specific route.\n\n**How It Works**:\n1. **Test Client Creation**: It creates a test client (`c`) for the Flask application, allowing simulated HTTP requests.\n2. **GET Request Test**: It asserts that a GET request to the root URL (`/`) returns the byte string `b'GET'`.\n3. **POST Request Test**: It asserts that a POST request to the root URL returns the byte string `b'POST'`.\n4. **PUT Request Test**: It asserts that a PUT request to the root URL returns a 405 status code, indicating that the method is not allowed.\n5. **OPTIONS Request Test**: It sends an OPTIONS request to the root URL and checks the `Allow` header to ensure it includes the expected methods (`GET`, `HEAD`, `OPTIONS`, `POST`), sorted in alphabetical order.\n\nThis method is typically called within other test functions to ensure that the defined routes in the Flask application behave as expected."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_methods_var_inheritance",
            "module": "test_views",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_views.py",
            "line_number": 189,
            "end_line_number": 204,
            "source_code": "def test_methods_var_inheritance(app, client):\n    class BaseView(flask.views.MethodView):\n        methods = [\"GET\", \"PROPFIND\"]\n\n    class ChildView(BaseView):\n        def get(self):\n            return \"GET\"\n\n        def propfind(self):\n            return \"PROPFIND\"\n\n    app.add_url_rule(\"/\", view_func=ChildView.as_view(\"index\"))\n\n    assert client.get(\"/\").data == b\"GET\"\n    assert client.open(\"/\", method=\"PROPFIND\").data == b\"PROPFIND\"\n    assert ChildView.methods == {\"PROPFIND\", \"GET\"}",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "werkzeug.http.parse_set_header",
                "flask.views"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').data == b'GET'",
                "assert client.open('/', method='PROPFIND').data == b'PROPFIND'",
                "assert ChildView.methods == {'PROPFIND', 'GET'}"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to define a route in a Flask web application that retrieves a value stored in the session. If the session does not contain the specified value, it defaults to returning the string 'None'.\n\n**How It Works**:\nThe method is decorated with `@app.route('/get')`, which maps the URL path `/get` to the `get` function. Inside the function, `flask.session.get('value', 'None')` attempts to retrieve the value associated with the key `'value'` from the session. If the key does not exist, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request made to the `/get` endpoint. This allows clients to access session data easily through a simple GET request."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_multiple_inheritance",
            "module": "test_views",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_views.py",
            "line_number": 207,
            "end_line_number": 223,
            "source_code": "def test_multiple_inheritance(app, client):\n    class GetView(flask.views.MethodView):\n        def get(self):\n            return \"GET\"\n\n    class DeleteView(flask.views.MethodView):\n        def delete(self):\n            return \"DELETE\"\n\n    class GetDeleteView(GetView, DeleteView):\n        pass\n\n    app.add_url_rule(\"/\", view_func=GetDeleteView.as_view(\"index\"))\n\n    assert client.get(\"/\").data == b\"GET\"\n    assert client.delete(\"/\").data == b\"DELETE\"\n    assert sorted(GetDeleteView.methods) == [\"DELETE\", \"GET\"]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "werkzeug.http.parse_set_header",
                "flask.views"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').data == b'GET'",
                "assert client.delete('/').data == b'DELETE'",
                "assert sorted(GetDeleteView.methods) == ['DELETE', 'GET']"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_multiple_inheritance",
            "module": "test_views",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_views.py",
            "line_number": 207,
            "end_line_number": 223,
            "source_code": "def test_multiple_inheritance(app, client):\n    class GetView(flask.views.MethodView):\n        def get(self):\n            return \"GET\"\n\n    class DeleteView(flask.views.MethodView):\n        def delete(self):\n            return \"DELETE\"\n\n    class GetDeleteView(GetView, DeleteView):\n        pass\n\n    app.add_url_rule(\"/\", view_func=GetDeleteView.as_view(\"index\"))\n\n    assert client.get(\"/\").data == b\"GET\"\n    assert client.delete(\"/\").data == b\"DELETE\"\n    assert sorted(GetDeleteView.methods) == [\"DELETE\", \"GET\"]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "werkzeug.http.parse_set_header",
                "flask.views"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').data == b'GET'",
                "assert client.delete('/').data == b'DELETE'",
                "assert sorted(GetDeleteView.methods) == ['DELETE', 'GET']"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.delete",
                    "body": "def delete(self):\n    return 'DELETE'",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.delete` method is designed to simulate an HTTP DELETE request in a web application context, returning a string indicating the type of request made.\n\n**How It Works**:  \nWhen the `delete` method is called, it simply returns the string `'DELETE'`. This method is likely part of a testing framework that allows developers to verify the behavior of their application when handling DELETE requests. In the context of the provided code snippets, it is used in the `test_delete` function to check if a post can be successfully deleted from the database and to confirm that the response redirects to the home page."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_remove_method_from_parent",
            "module": "test_views",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_views.py",
            "line_number": 226,
            "end_line_number": 242,
            "source_code": "def test_remove_method_from_parent(app, client):\n    class GetView(flask.views.MethodView):\n        def get(self):\n            return \"GET\"\n\n    class OtherView(flask.views.MethodView):\n        def post(self):\n            return \"POST\"\n\n    class View(GetView, OtherView):\n        methods = [\"GET\"]\n\n    app.add_url_rule(\"/\", view_func=View.as_view(\"index\"))\n\n    assert client.get(\"/\").data == b\"GET\"\n    assert client.post(\"/\").status_code == 405\n    assert sorted(View.methods) == [\"GET\"]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "werkzeug.http.parse_set_header",
                "flask.views"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').data == b'GET'",
                "assert client.post('/').status_code == 405",
                "assert sorted(View.methods) == ['GET']"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_remove_method_from_parent",
            "module": "test_views",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_views.py",
            "line_number": 226,
            "end_line_number": 242,
            "source_code": "def test_remove_method_from_parent(app, client):\n    class GetView(flask.views.MethodView):\n        def get(self):\n            return \"GET\"\n\n    class OtherView(flask.views.MethodView):\n        def post(self):\n            return \"POST\"\n\n    class View(GetView, OtherView):\n        methods = [\"GET\"]\n\n    app.add_url_rule(\"/\", view_func=View.as_view(\"index\"))\n\n    assert client.get(\"/\").data == b\"GET\"\n    assert client.post(\"/\").status_code == 405\n    assert sorted(View.methods) == [\"GET\"]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "werkzeug.http.parse_set_header",
                "flask.views"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').data == b'GET'",
                "assert client.post('/').status_code == 405",
                "assert sorted(View.methods) == ['GET']"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.post",
                    "body": "def post(self):\n    return 'Create'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is designed to simulate an HTTP POST request to a specified endpoint, allowing developers to test the behavior of their web application when data is submitted.\n\n**How It Works**:\nWhen invoked, `client.post` sends a POST request to the specified URL, optionally including data in the request body. In the provided code snippets, this method is used to update a post's title, validate input during creation or updating, and delete a post. The method returns a response object that can be inspected for status codes and response data, enabling assertions in tests to verify that the application behaves as expected."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_init_once",
            "module": "test_views",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_views.py",
            "line_number": 245,
            "end_line_number": 260,
            "source_code": "def test_init_once(app, client):\n    n = 0\n\n    class CountInit(flask.views.View):\n        init_every_request = False\n\n        def __init__(self):\n            nonlocal n\n            n += 1\n\n        def dispatch_request(self):\n            return str(n)\n\n    app.add_url_rule(\"/\", view_func=CountInit.as_view(\"index\"))\n    assert client.get(\"/\").data == b\"1\"\n    assert client.get(\"/\").data == b\"1\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "werkzeug.http.parse_set_header",
                "flask.views"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').data == b'1'",
                "assert client.get('/').data == b'1'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called, which attempts to fetch the value stored in the session under the key `'value'`. If this key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve user-specific data across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_init_once",
            "module": "test_views",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_views.py",
            "line_number": 245,
            "end_line_number": 260,
            "source_code": "def test_init_once(app, client):\n    n = 0\n\n    class CountInit(flask.views.View):\n        init_every_request = False\n\n        def __init__(self):\n            nonlocal n\n            n += 1\n\n        def dispatch_request(self):\n            return str(n)\n\n    app.add_url_rule(\"/\", view_func=CountInit.as_view(\"index\"))\n    assert client.get(\"/\").data == b\"1\"\n    assert client.get(\"/\").data == b\"1\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "werkzeug.http.parse_set_header",
                "flask.views"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/').data == b'1'",
                "assert client.get('/').data == b'1'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it as a response.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` attempts to fetch the value stored in the session under the key `'value'`. If this key does not exist, it defaults to returning the string `'None'`. The retrieved value is then returned as the HTTP response. This method relies on Flask's session management to store and retrieve user-specific data across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_error_handler_no_match",
            "module": "test_user_error_handler",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 10,
            "end_line_number": 58,
            "source_code": "def test_error_handler_no_match(app, client):\n    class CustomException(Exception):\n        pass\n\n    @app.errorhandler(CustomException)\n    def custom_exception_handler(e):\n        assert isinstance(e, CustomException)\n        return \"custom\"\n\n    with pytest.raises(TypeError) as exc_info:\n        app.register_error_handler(CustomException(), None)\n\n    assert \"CustomException() is an instance, not a class.\" in str(exc_info.value)\n\n    with pytest.raises(ValueError) as exc_info:\n        app.register_error_handler(list, None)\n\n    assert \"'list' is not a subclass of Exception.\" in str(exc_info.value)\n\n    @app.errorhandler(500)\n    def handle_500(e):\n        assert isinstance(e, InternalServerError)\n\n        if e.original_exception is not None:\n            return f\"wrapped {type(e.original_exception).__name__}\"\n\n        return \"direct\"\n\n    with pytest.raises(ValueError) as exc_info:\n        app.register_error_handler(999, None)\n\n    assert \"Use a subclass of HTTPException\" in str(exc_info.value)\n\n    @app.route(\"/custom\")\n    def custom_test():\n        raise CustomException()\n\n    @app.route(\"/keyerror\")\n    def key_error():\n        raise KeyError()\n\n    @app.route(\"/abort\")\n    def do_abort():\n        flask.abort(500)\n\n    app.testing = False\n    assert client.get(\"/custom\").data == b\"custom\"\n    assert client.get(\"/keyerror\").data == b\"wrapped KeyError\"\n    assert client.get(\"/abort\").data == b\"direct\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'CustomException() is an instance, not a class.' in str(exc_info.value)",
                "assert \"'list' is not a subclass of Exception.\" in str(exc_info.value)",
                "assert 'Use a subclass of HTTPException' in str(exc_info.value)",
                "assert client.get('/custom').data == b'custom'",
                "assert client.get('/keyerror').data == b'wrapped KeyError'",
                "assert client.get('/abort').data == b'direct'",
                "assert isinstance(e, CustomException)",
                "assert isinstance(e, InternalServerError)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called, which attempts to fetch the value stored in the session under the key `'value'`. If this key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve user-specific data across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_error_handler_no_match",
            "module": "test_user_error_handler",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 10,
            "end_line_number": 58,
            "source_code": "def test_error_handler_no_match(app, client):\n    class CustomException(Exception):\n        pass\n\n    @app.errorhandler(CustomException)\n    def custom_exception_handler(e):\n        assert isinstance(e, CustomException)\n        return \"custom\"\n\n    with pytest.raises(TypeError) as exc_info:\n        app.register_error_handler(CustomException(), None)\n\n    assert \"CustomException() is an instance, not a class.\" in str(exc_info.value)\n\n    with pytest.raises(ValueError) as exc_info:\n        app.register_error_handler(list, None)\n\n    assert \"'list' is not a subclass of Exception.\" in str(exc_info.value)\n\n    @app.errorhandler(500)\n    def handle_500(e):\n        assert isinstance(e, InternalServerError)\n\n        if e.original_exception is not None:\n            return f\"wrapped {type(e.original_exception).__name__}\"\n\n        return \"direct\"\n\n    with pytest.raises(ValueError) as exc_info:\n        app.register_error_handler(999, None)\n\n    assert \"Use a subclass of HTTPException\" in str(exc_info.value)\n\n    @app.route(\"/custom\")\n    def custom_test():\n        raise CustomException()\n\n    @app.route(\"/keyerror\")\n    def key_error():\n        raise KeyError()\n\n    @app.route(\"/abort\")\n    def do_abort():\n        flask.abort(500)\n\n    app.testing = False\n    assert client.get(\"/custom\").data == b\"custom\"\n    assert client.get(\"/keyerror\").data == b\"wrapped KeyError\"\n    assert client.get(\"/abort\").data == b\"direct\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'CustomException() is an instance, not a class.' in str(exc_info.value)",
                "assert \"'list' is not a subclass of Exception.\" in str(exc_info.value)",
                "assert 'Use a subclass of HTTPException' in str(exc_info.value)",
                "assert client.get('/custom').data == b'custom'",
                "assert client.get('/keyerror').data == b'wrapped KeyError'",
                "assert client.get('/abort').data == b'direct'",
                "assert isinstance(e, CustomException)",
                "assert isinstance(e, InternalServerError)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. Finally, the retrieved value is returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_error_handler_no_match",
            "module": "test_user_error_handler",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 10,
            "end_line_number": 58,
            "source_code": "def test_error_handler_no_match(app, client):\n    class CustomException(Exception):\n        pass\n\n    @app.errorhandler(CustomException)\n    def custom_exception_handler(e):\n        assert isinstance(e, CustomException)\n        return \"custom\"\n\n    with pytest.raises(TypeError) as exc_info:\n        app.register_error_handler(CustomException(), None)\n\n    assert \"CustomException() is an instance, not a class.\" in str(exc_info.value)\n\n    with pytest.raises(ValueError) as exc_info:\n        app.register_error_handler(list, None)\n\n    assert \"'list' is not a subclass of Exception.\" in str(exc_info.value)\n\n    @app.errorhandler(500)\n    def handle_500(e):\n        assert isinstance(e, InternalServerError)\n\n        if e.original_exception is not None:\n            return f\"wrapped {type(e.original_exception).__name__}\"\n\n        return \"direct\"\n\n    with pytest.raises(ValueError) as exc_info:\n        app.register_error_handler(999, None)\n\n    assert \"Use a subclass of HTTPException\" in str(exc_info.value)\n\n    @app.route(\"/custom\")\n    def custom_test():\n        raise CustomException()\n\n    @app.route(\"/keyerror\")\n    def key_error():\n        raise KeyError()\n\n    @app.route(\"/abort\")\n    def do_abort():\n        flask.abort(500)\n\n    app.testing = False\n    assert client.get(\"/custom\").data == b\"custom\"\n    assert client.get(\"/keyerror\").data == b\"wrapped KeyError\"\n    assert client.get(\"/abort\").data == b\"direct\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'CustomException() is an instance, not a class.' in str(exc_info.value)",
                "assert \"'list' is not a subclass of Exception.\" in str(exc_info.value)",
                "assert 'Use a subclass of HTTPException' in str(exc_info.value)",
                "assert client.get('/custom').data == b'custom'",
                "assert client.get('/keyerror').data == b'wrapped KeyError'",
                "assert client.get('/abort').data == b'direct'",
                "assert isinstance(e, CustomException)",
                "assert isinstance(e, InternalServerError)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is used to define a route in a Flask web application that retrieves a value stored in the session. If the session does not contain the specified value, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nThe method is decorated with `@app.route('/get')`, which maps the URL path `/get` to the `get` function. When a GET request is made to this endpoint, the function accesses the session using `flask.session.get('value', 'None')`. This retrieves the value associated with the key `'value'` from the session; if it does not exist, it returns `'None'`. The retrieved value is then returned as the response to the client. This allows for session data to be accessed and utilized in web applications, facilitating state management across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_error_handler_subclass",
            "module": "test_user_error_handler",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 61,
            "end_line_number": 97,
            "source_code": "def test_error_handler_subclass(app):\n    class ParentException(Exception):\n        pass\n\n    class ChildExceptionUnregistered(ParentException):\n        pass\n\n    class ChildExceptionRegistered(ParentException):\n        pass\n\n    @app.errorhandler(ParentException)\n    def parent_exception_handler(e):\n        assert isinstance(e, ParentException)\n        return \"parent\"\n\n    @app.errorhandler(ChildExceptionRegistered)\n    def child_exception_handler(e):\n        assert isinstance(e, ChildExceptionRegistered)\n        return \"child-registered\"\n\n    @app.route(\"/parent\")\n    def parent_test():\n        raise ParentException()\n\n    @app.route(\"/child-unregistered\")\n    def unregistered_test():\n        raise ChildExceptionUnregistered()\n\n    @app.route(\"/child-registered\")\n    def registered_test():\n        raise ChildExceptionRegistered()\n\n    c = app.test_client()\n\n    assert c.get(\"/parent\").data == b\"parent\"\n    assert c.get(\"/child-unregistered\").data == b\"parent\"\n    assert c.get(\"/child-registered\").data == b\"child-registered\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert c.get('/parent').data == b'parent'",
                "assert c.get('/child-unregistered').data == b'parent'",
                "assert c.get('/child-registered').data == b'child-registered'",
                "assert isinstance(e, ParentException)",
                "assert isinstance(e, ChildExceptionRegistered)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "c.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get` method is a Flask route handler that retrieves a value from the session, specifically the value associated with the key `'value'`. If this key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the method uses `flask.session.get()` to access the session data. The `get` method takes two arguments: the key to look for (`'value'`) and a default value (`'None'`) to return if the key is not found. The retrieved value is then returned as the response to the request. This allows for session-based data retrieval in a web application context."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_error_handler_subclass",
            "module": "test_user_error_handler",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 61,
            "end_line_number": 97,
            "source_code": "def test_error_handler_subclass(app):\n    class ParentException(Exception):\n        pass\n\n    class ChildExceptionUnregistered(ParentException):\n        pass\n\n    class ChildExceptionRegistered(ParentException):\n        pass\n\n    @app.errorhandler(ParentException)\n    def parent_exception_handler(e):\n        assert isinstance(e, ParentException)\n        return \"parent\"\n\n    @app.errorhandler(ChildExceptionRegistered)\n    def child_exception_handler(e):\n        assert isinstance(e, ChildExceptionRegistered)\n        return \"child-registered\"\n\n    @app.route(\"/parent\")\n    def parent_test():\n        raise ParentException()\n\n    @app.route(\"/child-unregistered\")\n    def unregistered_test():\n        raise ChildExceptionUnregistered()\n\n    @app.route(\"/child-registered\")\n    def registered_test():\n        raise ChildExceptionRegistered()\n\n    c = app.test_client()\n\n    assert c.get(\"/parent\").data == b\"parent\"\n    assert c.get(\"/child-unregistered\").data == b\"parent\"\n    assert c.get(\"/child-registered\").data == b\"child-registered\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert c.get('/parent').data == b'parent'",
                "assert c.get('/child-unregistered').data == b'parent'",
                "assert c.get('/child-registered').data == b'child-registered'",
                "assert isinstance(e, ParentException)",
                "assert isinstance(e, ChildExceptionRegistered)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "c.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get` method is a Flask route handler that retrieves a value from the session, specifically the value associated with the key `'value'`. If this key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the method uses `flask.session.get()` to access the session data. The `get` method takes two arguments: the key `'value'` and a default value `'None'`. If the key is found, it returns the corresponding value; otherwise, it returns the default value. This allows for safe retrieval of session data without raising an error if the key is absent. The result is then returned as the HTTP response."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_error_handler_subclass",
            "module": "test_user_error_handler",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 61,
            "end_line_number": 97,
            "source_code": "def test_error_handler_subclass(app):\n    class ParentException(Exception):\n        pass\n\n    class ChildExceptionUnregistered(ParentException):\n        pass\n\n    class ChildExceptionRegistered(ParentException):\n        pass\n\n    @app.errorhandler(ParentException)\n    def parent_exception_handler(e):\n        assert isinstance(e, ParentException)\n        return \"parent\"\n\n    @app.errorhandler(ChildExceptionRegistered)\n    def child_exception_handler(e):\n        assert isinstance(e, ChildExceptionRegistered)\n        return \"child-registered\"\n\n    @app.route(\"/parent\")\n    def parent_test():\n        raise ParentException()\n\n    @app.route(\"/child-unregistered\")\n    def unregistered_test():\n        raise ChildExceptionUnregistered()\n\n    @app.route(\"/child-registered\")\n    def registered_test():\n        raise ChildExceptionRegistered()\n\n    c = app.test_client()\n\n    assert c.get(\"/parent\").data == b\"parent\"\n    assert c.get(\"/child-unregistered\").data == b\"parent\"\n    assert c.get(\"/child-registered\").data == b\"child-registered\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert c.get('/parent').data == b'parent'",
                "assert c.get('/child-unregistered').data == b'parent'",
                "assert c.get('/child-registered').data == b'child-registered'",
                "assert isinstance(e, ParentException)",
                "assert isinstance(e, ChildExceptionRegistered)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "c.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get` method is a Flask route handler that retrieves a value from the session, specifically the value associated with the key `'value'`. If this key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the method uses `flask.session.get()` to access the session data. The `get` method takes two arguments: the key to look for (`'value'`) and a default value (`'None'`) to return if the key is not found. The retrieved value is then returned as the response to the HTTP request. This allows the application to maintain state across requests by storing and retrieving data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_error_handler_http_subclass",
            "module": "test_user_error_handler",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 100,
            "end_line_number": 133,
            "source_code": "def test_error_handler_http_subclass(app):\n    class ForbiddenSubclassRegistered(Forbidden):\n        pass\n\n    class ForbiddenSubclassUnregistered(Forbidden):\n        pass\n\n    @app.errorhandler(403)\n    def code_exception_handler(e):\n        assert isinstance(e, Forbidden)\n        return \"forbidden\"\n\n    @app.errorhandler(ForbiddenSubclassRegistered)\n    def subclass_exception_handler(e):\n        assert isinstance(e, ForbiddenSubclassRegistered)\n        return \"forbidden-registered\"\n\n    @app.route(\"/forbidden\")\n    def forbidden_test():\n        raise Forbidden()\n\n    @app.route(\"/forbidden-registered\")\n    def registered_test():\n        raise ForbiddenSubclassRegistered()\n\n    @app.route(\"/forbidden-unregistered\")\n    def unregistered_test():\n        raise ForbiddenSubclassUnregistered()\n\n    c = app.test_client()\n\n    assert c.get(\"/forbidden\").data == b\"forbidden\"\n    assert c.get(\"/forbidden-unregistered\").data == b\"forbidden\"\n    assert c.get(\"/forbidden-registered\").data == b\"forbidden-registered\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert c.get('/forbidden').data == b'forbidden'",
                "assert c.get('/forbidden-unregistered').data == b'forbidden'",
                "assert c.get('/forbidden-registered').data == b'forbidden-registered'",
                "assert isinstance(e, Forbidden)",
                "assert isinstance(e, ForbiddenSubclassRegistered)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "c.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get` method is a Flask route handler that retrieves a value from the session, specifically the value associated with the key `'value'`. If this key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the method uses `flask.session.get` to access the session data. The `get` method of the session object takes two arguments: the key to look for (`'value'`) and a default value (`'None'`) to return if the key is not found. The retrieved value is then returned as the response to the HTTP request. This allows the application to maintain state across requests by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_error_handler_http_subclass",
            "module": "test_user_error_handler",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 100,
            "end_line_number": 133,
            "source_code": "def test_error_handler_http_subclass(app):\n    class ForbiddenSubclassRegistered(Forbidden):\n        pass\n\n    class ForbiddenSubclassUnregistered(Forbidden):\n        pass\n\n    @app.errorhandler(403)\n    def code_exception_handler(e):\n        assert isinstance(e, Forbidden)\n        return \"forbidden\"\n\n    @app.errorhandler(ForbiddenSubclassRegistered)\n    def subclass_exception_handler(e):\n        assert isinstance(e, ForbiddenSubclassRegistered)\n        return \"forbidden-registered\"\n\n    @app.route(\"/forbidden\")\n    def forbidden_test():\n        raise Forbidden()\n\n    @app.route(\"/forbidden-registered\")\n    def registered_test():\n        raise ForbiddenSubclassRegistered()\n\n    @app.route(\"/forbidden-unregistered\")\n    def unregistered_test():\n        raise ForbiddenSubclassUnregistered()\n\n    c = app.test_client()\n\n    assert c.get(\"/forbidden\").data == b\"forbidden\"\n    assert c.get(\"/forbidden-unregistered\").data == b\"forbidden\"\n    assert c.get(\"/forbidden-registered\").data == b\"forbidden-registered\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert c.get('/forbidden').data == b'forbidden'",
                "assert c.get('/forbidden-unregistered').data == b'forbidden'",
                "assert c.get('/forbidden-registered').data == b'forbidden-registered'",
                "assert isinstance(e, Forbidden)",
                "assert isinstance(e, ForbiddenSubclassRegistered)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "c.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get` method is a Flask route handler that retrieves a value from the session, specifically the value associated with the key `'value'`. If this key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the method uses `flask.session.get()` to access the session data. The `get` method takes two arguments: the key `'value'` and a default value `'None'`. If the key is found, it returns the corresponding value; otherwise, it returns the default value. This allows for safe retrieval of session data without raising an error if the key is absent. The result is then returned as the HTTP response."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_error_handler_http_subclass",
            "module": "test_user_error_handler",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 100,
            "end_line_number": 133,
            "source_code": "def test_error_handler_http_subclass(app):\n    class ForbiddenSubclassRegistered(Forbidden):\n        pass\n\n    class ForbiddenSubclassUnregistered(Forbidden):\n        pass\n\n    @app.errorhandler(403)\n    def code_exception_handler(e):\n        assert isinstance(e, Forbidden)\n        return \"forbidden\"\n\n    @app.errorhandler(ForbiddenSubclassRegistered)\n    def subclass_exception_handler(e):\n        assert isinstance(e, ForbiddenSubclassRegistered)\n        return \"forbidden-registered\"\n\n    @app.route(\"/forbidden\")\n    def forbidden_test():\n        raise Forbidden()\n\n    @app.route(\"/forbidden-registered\")\n    def registered_test():\n        raise ForbiddenSubclassRegistered()\n\n    @app.route(\"/forbidden-unregistered\")\n    def unregistered_test():\n        raise ForbiddenSubclassUnregistered()\n\n    c = app.test_client()\n\n    assert c.get(\"/forbidden\").data == b\"forbidden\"\n    assert c.get(\"/forbidden-unregistered\").data == b\"forbidden\"\n    assert c.get(\"/forbidden-registered\").data == b\"forbidden-registered\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert c.get('/forbidden').data == b'forbidden'",
                "assert c.get('/forbidden-unregistered').data == b'forbidden'",
                "assert c.get('/forbidden-registered').data == b'forbidden-registered'",
                "assert isinstance(e, Forbidden)",
                "assert isinstance(e, ForbiddenSubclassRegistered)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "c.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get` method is a Flask route handler that retrieves a value from the session, specifically the value associated with the key `'value'`. If this key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the method uses `flask.session.get()` to access the session data. The `get` method takes two arguments: the key to look for (`'value'`) and a default value (`'None'`) to return if the key is not found. The retrieved value is then returned as the response to the HTTP request. This allows for session-based data retrieval in a web application context."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_error_handler_blueprint",
            "module": "test_user_error_handler",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 136,
            "end_line_number": 160,
            "source_code": "def test_error_handler_blueprint(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.errorhandler(500)\n    def bp_exception_handler(e):\n        return \"bp-error\"\n\n    @bp.route(\"/error\")\n    def bp_test():\n        raise InternalServerError()\n\n    @app.errorhandler(500)\n    def app_exception_handler(e):\n        return \"app-error\"\n\n    @app.route(\"/error\")\n    def app_test():\n        raise InternalServerError()\n\n    app.register_blueprint(bp, url_prefix=\"/bp\")\n\n    c = app.test_client()\n\n    assert c.get(\"/error\").data == b\"app-error\"\n    assert c.get(\"/bp/error\").data == b\"bp-error\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert c.get('/error').data == b'app-error'",
                "assert c.get('/bp/error').data == b'bp-error'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "c.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get` method is a Flask route handler that retrieves a value from the session, specifically the value associated with the key `'value'`. If this key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the method uses `flask.session.get()` to access the session data. The `get` method takes two arguments: the key to look for (`'value'`) and a default value (`'None'`) to return if the key is not found. The retrieved value is then returned as the response to the HTTP request. This allows the application to maintain state across requests by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_error_handler_blueprint",
            "module": "test_user_error_handler",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 136,
            "end_line_number": 160,
            "source_code": "def test_error_handler_blueprint(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.errorhandler(500)\n    def bp_exception_handler(e):\n        return \"bp-error\"\n\n    @bp.route(\"/error\")\n    def bp_test():\n        raise InternalServerError()\n\n    @app.errorhandler(500)\n    def app_exception_handler(e):\n        return \"app-error\"\n\n    @app.route(\"/error\")\n    def app_test():\n        raise InternalServerError()\n\n    app.register_blueprint(bp, url_prefix=\"/bp\")\n\n    c = app.test_client()\n\n    assert c.get(\"/error\").data == b\"app-error\"\n    assert c.get(\"/bp/error\").data == b\"bp-error\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert c.get('/error').data == b'app-error'",
                "assert c.get('/bp/error').data == b'bp-error'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "c.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get` method is a Flask route handler that retrieves a value from the session, specifically the value associated with the key `'value'`. If this key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the method uses `flask.session.get()` to access the session data. The `get` method takes two arguments: the key `'value'` and a default value `'None'`. If the key is found in the session, its corresponding value is returned; otherwise, the default value `'None'` is returned. This allows for safe retrieval of session data without raising an error if the key is absent."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_default_error_handler",
            "module": "test_user_error_handler",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 163,
            "end_line_number": 214,
            "source_code": "def test_default_error_handler():\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.errorhandler(HTTPException)\n    def bp_exception_handler(e):\n        assert isinstance(e, HTTPException)\n        assert isinstance(e, NotFound)\n        return \"bp-default\"\n\n    @bp.errorhandler(Forbidden)\n    def bp_forbidden_handler(e):\n        assert isinstance(e, Forbidden)\n        return \"bp-forbidden\"\n\n    @bp.route(\"/undefined\")\n    def bp_registered_test():\n        raise NotFound()\n\n    @bp.route(\"/forbidden\")\n    def bp_forbidden_test():\n        raise Forbidden()\n\n    app = flask.Flask(__name__)\n\n    @app.errorhandler(HTTPException)\n    def catchall_exception_handler(e):\n        assert isinstance(e, HTTPException)\n        assert isinstance(e, NotFound)\n        return \"default\"\n\n    @app.errorhandler(Forbidden)\n    def catchall_forbidden_handler(e):\n        assert isinstance(e, Forbidden)\n        return \"forbidden\"\n\n    @app.route(\"/forbidden\")\n    def forbidden():\n        raise Forbidden()\n\n    @app.route(\"/slash/\")\n    def slash():\n        return \"slash\"\n\n    app.register_blueprint(bp, url_prefix=\"/bp\")\n\n    c = app.test_client()\n    assert c.get(\"/bp/undefined\").data == b\"bp-default\"\n    assert c.get(\"/bp/forbidden\").data == b\"bp-forbidden\"\n    assert c.get(\"/undefined\").data == b\"default\"\n    assert c.get(\"/forbidden\").data == b\"forbidden\"\n    # Don't handle RequestRedirect raised when adding slash.\n    assert c.get(\"/slash\", follow_redirects=True).data == b\"slash\"",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert c.get('/bp/undefined').data == b'bp-default'",
                "assert c.get('/bp/forbidden').data == b'bp-forbidden'",
                "assert c.get('/undefined').data == b'default'",
                "assert c.get('/forbidden').data == b'forbidden'",
                "assert c.get('/slash', follow_redirects=True).data == b'slash'",
                "assert isinstance(e, HTTPException)",
                "assert isinstance(e, NotFound)",
                "assert isinstance(e, Forbidden)",
                "assert isinstance(e, HTTPException)",
                "assert isinstance(e, NotFound)",
                "assert isinstance(e, Forbidden)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "c.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get` method is a Flask route handler that retrieves a value from the session, specifically the value associated with the key `'value'`. If this key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the method uses `flask.session.get()` to access the session data. The `get` method takes two arguments: the key `'value'` and a default value `'None'`. If the key is found, it returns the corresponding value; otherwise, it returns the default value. This allows for safe retrieval of session data without raising an error if the key is absent. The response is then sent back to the client."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_default_error_handler",
            "module": "test_user_error_handler",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 163,
            "end_line_number": 214,
            "source_code": "def test_default_error_handler():\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.errorhandler(HTTPException)\n    def bp_exception_handler(e):\n        assert isinstance(e, HTTPException)\n        assert isinstance(e, NotFound)\n        return \"bp-default\"\n\n    @bp.errorhandler(Forbidden)\n    def bp_forbidden_handler(e):\n        assert isinstance(e, Forbidden)\n        return \"bp-forbidden\"\n\n    @bp.route(\"/undefined\")\n    def bp_registered_test():\n        raise NotFound()\n\n    @bp.route(\"/forbidden\")\n    def bp_forbidden_test():\n        raise Forbidden()\n\n    app = flask.Flask(__name__)\n\n    @app.errorhandler(HTTPException)\n    def catchall_exception_handler(e):\n        assert isinstance(e, HTTPException)\n        assert isinstance(e, NotFound)\n        return \"default\"\n\n    @app.errorhandler(Forbidden)\n    def catchall_forbidden_handler(e):\n        assert isinstance(e, Forbidden)\n        return \"forbidden\"\n\n    @app.route(\"/forbidden\")\n    def forbidden():\n        raise Forbidden()\n\n    @app.route(\"/slash/\")\n    def slash():\n        return \"slash\"\n\n    app.register_blueprint(bp, url_prefix=\"/bp\")\n\n    c = app.test_client()\n    assert c.get(\"/bp/undefined\").data == b\"bp-default\"\n    assert c.get(\"/bp/forbidden\").data == b\"bp-forbidden\"\n    assert c.get(\"/undefined\").data == b\"default\"\n    assert c.get(\"/forbidden\").data == b\"forbidden\"\n    # Don't handle RequestRedirect raised when adding slash.\n    assert c.get(\"/slash\", follow_redirects=True).data == b\"slash\"",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert c.get('/bp/undefined').data == b'bp-default'",
                "assert c.get('/bp/forbidden').data == b'bp-forbidden'",
                "assert c.get('/undefined').data == b'default'",
                "assert c.get('/forbidden').data == b'forbidden'",
                "assert c.get('/slash', follow_redirects=True).data == b'slash'",
                "assert isinstance(e, HTTPException)",
                "assert isinstance(e, NotFound)",
                "assert isinstance(e, Forbidden)",
                "assert isinstance(e, HTTPException)",
                "assert isinstance(e, NotFound)",
                "assert isinstance(e, Forbidden)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "c.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get` method is a Flask route handler that retrieves a value from the session, specifically the value associated with the key `'value'`. If this key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the method uses `flask.session.get()` to access the session data. The `get` method takes two arguments: the key to look for (`'value'`) and a default value (`'None'`) to return if the key is not found. The retrieved value is then returned as the response to the HTTP request. This allows the application to maintain state across requests by storing and retrieving data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_default_error_handler",
            "module": "test_user_error_handler",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 163,
            "end_line_number": 214,
            "source_code": "def test_default_error_handler():\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.errorhandler(HTTPException)\n    def bp_exception_handler(e):\n        assert isinstance(e, HTTPException)\n        assert isinstance(e, NotFound)\n        return \"bp-default\"\n\n    @bp.errorhandler(Forbidden)\n    def bp_forbidden_handler(e):\n        assert isinstance(e, Forbidden)\n        return \"bp-forbidden\"\n\n    @bp.route(\"/undefined\")\n    def bp_registered_test():\n        raise NotFound()\n\n    @bp.route(\"/forbidden\")\n    def bp_forbidden_test():\n        raise Forbidden()\n\n    app = flask.Flask(__name__)\n\n    @app.errorhandler(HTTPException)\n    def catchall_exception_handler(e):\n        assert isinstance(e, HTTPException)\n        assert isinstance(e, NotFound)\n        return \"default\"\n\n    @app.errorhandler(Forbidden)\n    def catchall_forbidden_handler(e):\n        assert isinstance(e, Forbidden)\n        return \"forbidden\"\n\n    @app.route(\"/forbidden\")\n    def forbidden():\n        raise Forbidden()\n\n    @app.route(\"/slash/\")\n    def slash():\n        return \"slash\"\n\n    app.register_blueprint(bp, url_prefix=\"/bp\")\n\n    c = app.test_client()\n    assert c.get(\"/bp/undefined\").data == b\"bp-default\"\n    assert c.get(\"/bp/forbidden\").data == b\"bp-forbidden\"\n    assert c.get(\"/undefined\").data == b\"default\"\n    assert c.get(\"/forbidden\").data == b\"forbidden\"\n    # Don't handle RequestRedirect raised when adding slash.\n    assert c.get(\"/slash\", follow_redirects=True).data == b\"slash\"",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert c.get('/bp/undefined').data == b'bp-default'",
                "assert c.get('/bp/forbidden').data == b'bp-forbidden'",
                "assert c.get('/undefined').data == b'default'",
                "assert c.get('/forbidden').data == b'forbidden'",
                "assert c.get('/slash', follow_redirects=True).data == b'slash'",
                "assert isinstance(e, HTTPException)",
                "assert isinstance(e, NotFound)",
                "assert isinstance(e, Forbidden)",
                "assert isinstance(e, HTTPException)",
                "assert isinstance(e, NotFound)",
                "assert isinstance(e, Forbidden)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "c.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get` method is a Flask route handler that retrieves a value from the session, specifically the value associated with the key `'value'`. If this key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the method uses `flask.session.get()` to access the session data. The `get` method takes two arguments: the key `'value'` and a default value `'None'`. If the key is found, it returns the corresponding value; otherwise, it returns the default value. This allows for safe retrieval of session data without raising an error if the key is absent. The result is then returned as the HTTP response."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_default_error_handler",
            "module": "test_user_error_handler",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 163,
            "end_line_number": 214,
            "source_code": "def test_default_error_handler():\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.errorhandler(HTTPException)\n    def bp_exception_handler(e):\n        assert isinstance(e, HTTPException)\n        assert isinstance(e, NotFound)\n        return \"bp-default\"\n\n    @bp.errorhandler(Forbidden)\n    def bp_forbidden_handler(e):\n        assert isinstance(e, Forbidden)\n        return \"bp-forbidden\"\n\n    @bp.route(\"/undefined\")\n    def bp_registered_test():\n        raise NotFound()\n\n    @bp.route(\"/forbidden\")\n    def bp_forbidden_test():\n        raise Forbidden()\n\n    app = flask.Flask(__name__)\n\n    @app.errorhandler(HTTPException)\n    def catchall_exception_handler(e):\n        assert isinstance(e, HTTPException)\n        assert isinstance(e, NotFound)\n        return \"default\"\n\n    @app.errorhandler(Forbidden)\n    def catchall_forbidden_handler(e):\n        assert isinstance(e, Forbidden)\n        return \"forbidden\"\n\n    @app.route(\"/forbidden\")\n    def forbidden():\n        raise Forbidden()\n\n    @app.route(\"/slash/\")\n    def slash():\n        return \"slash\"\n\n    app.register_blueprint(bp, url_prefix=\"/bp\")\n\n    c = app.test_client()\n    assert c.get(\"/bp/undefined\").data == b\"bp-default\"\n    assert c.get(\"/bp/forbidden\").data == b\"bp-forbidden\"\n    assert c.get(\"/undefined\").data == b\"default\"\n    assert c.get(\"/forbidden\").data == b\"forbidden\"\n    # Don't handle RequestRedirect raised when adding slash.\n    assert c.get(\"/slash\", follow_redirects=True).data == b\"slash\"",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert c.get('/bp/undefined').data == b'bp-default'",
                "assert c.get('/bp/forbidden').data == b'bp-forbidden'",
                "assert c.get('/undefined').data == b'default'",
                "assert c.get('/forbidden').data == b'forbidden'",
                "assert c.get('/slash', follow_redirects=True).data == b'slash'",
                "assert isinstance(e, HTTPException)",
                "assert isinstance(e, NotFound)",
                "assert isinstance(e, Forbidden)",
                "assert isinstance(e, HTTPException)",
                "assert isinstance(e, NotFound)",
                "assert isinstance(e, Forbidden)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "c.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get` method is a Flask route handler that retrieves a value from the session, specifically the value associated with the key `'value'`. If this key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the method uses `flask.session.get()` to access the session data. The `get` method takes two arguments: the key to look for (`'value'`) and a default value (`'None'`) to return if the key is not found. The retrieved value is then returned as the response to the HTTP request. This allows for session-based data retrieval in a web application context."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_default_error_handler",
            "module": "test_user_error_handler",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 163,
            "end_line_number": 214,
            "source_code": "def test_default_error_handler():\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.errorhandler(HTTPException)\n    def bp_exception_handler(e):\n        assert isinstance(e, HTTPException)\n        assert isinstance(e, NotFound)\n        return \"bp-default\"\n\n    @bp.errorhandler(Forbidden)\n    def bp_forbidden_handler(e):\n        assert isinstance(e, Forbidden)\n        return \"bp-forbidden\"\n\n    @bp.route(\"/undefined\")\n    def bp_registered_test():\n        raise NotFound()\n\n    @bp.route(\"/forbidden\")\n    def bp_forbidden_test():\n        raise Forbidden()\n\n    app = flask.Flask(__name__)\n\n    @app.errorhandler(HTTPException)\n    def catchall_exception_handler(e):\n        assert isinstance(e, HTTPException)\n        assert isinstance(e, NotFound)\n        return \"default\"\n\n    @app.errorhandler(Forbidden)\n    def catchall_forbidden_handler(e):\n        assert isinstance(e, Forbidden)\n        return \"forbidden\"\n\n    @app.route(\"/forbidden\")\n    def forbidden():\n        raise Forbidden()\n\n    @app.route(\"/slash/\")\n    def slash():\n        return \"slash\"\n\n    app.register_blueprint(bp, url_prefix=\"/bp\")\n\n    c = app.test_client()\n    assert c.get(\"/bp/undefined\").data == b\"bp-default\"\n    assert c.get(\"/bp/forbidden\").data == b\"bp-forbidden\"\n    assert c.get(\"/undefined\").data == b\"default\"\n    assert c.get(\"/forbidden\").data == b\"forbidden\"\n    # Don't handle RequestRedirect raised when adding slash.\n    assert c.get(\"/slash\", follow_redirects=True).data == b\"slash\"",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert c.get('/bp/undefined').data == b'bp-default'",
                "assert c.get('/bp/forbidden').data == b'bp-forbidden'",
                "assert c.get('/undefined').data == b'default'",
                "assert c.get('/forbidden').data == b'forbidden'",
                "assert c.get('/slash', follow_redirects=True).data == b'slash'",
                "assert isinstance(e, HTTPException)",
                "assert isinstance(e, NotFound)",
                "assert isinstance(e, Forbidden)",
                "assert isinstance(e, HTTPException)",
                "assert isinstance(e, NotFound)",
                "assert isinstance(e, Forbidden)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "c.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get` method is a Flask route handler that retrieves a value from the session, specifically the value associated with the key `'value'`. If this key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the method uses `flask.session.get` to access the session data. The `get` method of the session object takes two arguments: the key to look for (`'value'`) and a default value (`'None'`) to return if the key is not found. The retrieved value is then returned as the response to the HTTP request. This allows the application to maintain state across requests by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_handle_class_or_code",
            "module": "test_user_error_handler",
            "class_name": "TestGenericHandlers",
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 253,
            "end_line_number": 267,
            "source_code": "def test_handle_class_or_code(self, app, client, to_handle):\n        \"\"\"``InternalServerError`` and ``500`` are aliases, they should\n        have the same behavior. Both should only receive\n        ``InternalServerError``, which might wrap another error.\n        \"\"\"\n\n        @app.errorhandler(to_handle)\n        def handle_500(e):\n            assert isinstance(e, InternalServerError)\n            return self.report_error(e)\n\n        assert client.get(\"/custom\").data == b\"wrapped Custom\"\n        assert client.get(\"/error\").data == b\"wrapped KeyError\"\n        assert client.get(\"/abort\").data == b\"direct InternalServerError\"\n        assert client.get(\"/raise\").data == b\"direct InternalServerError\"",
            "docstring": "``InternalServerError`` and ``500`` are aliases, they should\nhave the same behavior. Both should only receive\n``InternalServerError``, which might wrap another error.",
            "decorators": [
                "pytest.mark.parametrize('to_handle', (InternalServerError, 500))"
            ],
            "arguments": [
                "self",
                "app",
                "client",
                "to_handle"
            ],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/custom').data == b'wrapped Custom'",
                "assert client.get('/error').data == b'wrapped KeyError'",
                "assert client.get('/abort').data == b'direct InternalServerError'",
                "assert client.get('/raise').data == b'direct InternalServerError'",
                "assert isinstance(e, InternalServerError)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.report_error",
                    "body": "def report_error(self, e):\n    original = getattr(e, 'original_exception', None)\n    if original is not None:\n        return f'wrapped {type(original).__name__}'\n    return f'direct {type(e).__name__}'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `report_error` method is designed to provide a string representation of an error, indicating whether the error is a direct instance of an exception or a wrapped exception (i.e., an exception that has been caught and re-raised, potentially by another exception).\n\n**How It Works**:\nThe method takes an exception object `e` as an argument. It first attempts to retrieve an attribute named `original_exception` from `e`. If this attribute exists and is not `None`, it indicates that `e` is a wrapped exception, and the method returns a string stating that it is a \"wrapped\" exception along with the type of the original exception. If `original_exception` is not present, the method concludes that `e` is a direct exception and returns a string indicating that it is a \"direct\" exception along with its type. This method is useful for error handling and logging, providing clarity on the nature of the exceptions encountered."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_handle_class_or_code",
            "module": "test_user_error_handler",
            "class_name": "TestGenericHandlers",
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 253,
            "end_line_number": 267,
            "source_code": "def test_handle_class_or_code(self, app, client, to_handle):\n        \"\"\"``InternalServerError`` and ``500`` are aliases, they should\n        have the same behavior. Both should only receive\n        ``InternalServerError``, which might wrap another error.\n        \"\"\"\n\n        @app.errorhandler(to_handle)\n        def handle_500(e):\n            assert isinstance(e, InternalServerError)\n            return self.report_error(e)\n\n        assert client.get(\"/custom\").data == b\"wrapped Custom\"\n        assert client.get(\"/error\").data == b\"wrapped KeyError\"\n        assert client.get(\"/abort\").data == b\"direct InternalServerError\"\n        assert client.get(\"/raise\").data == b\"direct InternalServerError\"",
            "docstring": "``InternalServerError`` and ``500`` are aliases, they should\nhave the same behavior. Both should only receive\n``InternalServerError``, which might wrap another error.",
            "decorators": [
                "pytest.mark.parametrize('to_handle', (InternalServerError, 500))"
            ],
            "arguments": [
                "self",
                "app",
                "client",
                "to_handle"
            ],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/custom').data == b'wrapped Custom'",
                "assert client.get('/error').data == b'wrapped KeyError'",
                "assert client.get('/abort').data == b'direct InternalServerError'",
                "assert client.get('/raise').data == b'direct InternalServerError'",
                "assert isinstance(e, InternalServerError)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_handle_class_or_code",
            "module": "test_user_error_handler",
            "class_name": "TestGenericHandlers",
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 253,
            "end_line_number": 267,
            "source_code": "def test_handle_class_or_code(self, app, client, to_handle):\n        \"\"\"``InternalServerError`` and ``500`` are aliases, they should\n        have the same behavior. Both should only receive\n        ``InternalServerError``, which might wrap another error.\n        \"\"\"\n\n        @app.errorhandler(to_handle)\n        def handle_500(e):\n            assert isinstance(e, InternalServerError)\n            return self.report_error(e)\n\n        assert client.get(\"/custom\").data == b\"wrapped Custom\"\n        assert client.get(\"/error\").data == b\"wrapped KeyError\"\n        assert client.get(\"/abort\").data == b\"direct InternalServerError\"\n        assert client.get(\"/raise\").data == b\"direct InternalServerError\"",
            "docstring": "``InternalServerError`` and ``500`` are aliases, they should\nhave the same behavior. Both should only receive\n``InternalServerError``, which might wrap another error.",
            "decorators": [
                "pytest.mark.parametrize('to_handle', (InternalServerError, 500))"
            ],
            "arguments": [
                "self",
                "app",
                "client",
                "to_handle"
            ],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/custom').data == b'wrapped Custom'",
                "assert client.get('/error').data == b'wrapped KeyError'",
                "assert client.get('/abort').data == b'direct InternalServerError'",
                "assert client.get('/raise').data == b'direct InternalServerError'",
                "assert isinstance(e, InternalServerError)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_handle_class_or_code",
            "module": "test_user_error_handler",
            "class_name": "TestGenericHandlers",
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 253,
            "end_line_number": 267,
            "source_code": "def test_handle_class_or_code(self, app, client, to_handle):\n        \"\"\"``InternalServerError`` and ``500`` are aliases, they should\n        have the same behavior. Both should only receive\n        ``InternalServerError``, which might wrap another error.\n        \"\"\"\n\n        @app.errorhandler(to_handle)\n        def handle_500(e):\n            assert isinstance(e, InternalServerError)\n            return self.report_error(e)\n\n        assert client.get(\"/custom\").data == b\"wrapped Custom\"\n        assert client.get(\"/error\").data == b\"wrapped KeyError\"\n        assert client.get(\"/abort\").data == b\"direct InternalServerError\"\n        assert client.get(\"/raise\").data == b\"direct InternalServerError\"",
            "docstring": "``InternalServerError`` and ``500`` are aliases, they should\nhave the same behavior. Both should only receive\n``InternalServerError``, which might wrap another error.",
            "decorators": [
                "pytest.mark.parametrize('to_handle', (InternalServerError, 500))"
            ],
            "arguments": [
                "self",
                "app",
                "client",
                "to_handle"
            ],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/custom').data == b'wrapped Custom'",
                "assert client.get('/error').data == b'wrapped KeyError'",
                "assert client.get('/abort').data == b'direct InternalServerError'",
                "assert client.get('/raise').data == b'direct InternalServerError'",
                "assert isinstance(e, InternalServerError)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it as a response.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` attempts to fetch the value stored in the session under the key `'value'`. If this key does not exist, it defaults to returning the string `'None'`. The retrieved value is then returned as the HTTP response. This method relies on Flask's session management to store and retrieve user-specific data across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_handle_class_or_code",
            "module": "test_user_error_handler",
            "class_name": "TestGenericHandlers",
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 253,
            "end_line_number": 267,
            "source_code": "def test_handle_class_or_code(self, app, client, to_handle):\n        \"\"\"``InternalServerError`` and ``500`` are aliases, they should\n        have the same behavior. Both should only receive\n        ``InternalServerError``, which might wrap another error.\n        \"\"\"\n\n        @app.errorhandler(to_handle)\n        def handle_500(e):\n            assert isinstance(e, InternalServerError)\n            return self.report_error(e)\n\n        assert client.get(\"/custom\").data == b\"wrapped Custom\"\n        assert client.get(\"/error\").data == b\"wrapped KeyError\"\n        assert client.get(\"/abort\").data == b\"direct InternalServerError\"\n        assert client.get(\"/raise\").data == b\"direct InternalServerError\"",
            "docstring": "``InternalServerError`` and ``500`` are aliases, they should\nhave the same behavior. Both should only receive\n``InternalServerError``, which might wrap another error.",
            "decorators": [
                "pytest.mark.parametrize('to_handle', (InternalServerError, 500))"
            ],
            "arguments": [
                "self",
                "app",
                "client",
                "to_handle"
            ],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/custom').data == b'wrapped Custom'",
                "assert client.get('/error').data == b'wrapped KeyError'",
                "assert client.get('/abort').data == b'direct InternalServerError'",
                "assert client.get('/raise').data == b'direct InternalServerError'",
                "assert isinstance(e, InternalServerError)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it as a response.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. It uses `flask.session.get` to attempt to retrieve the session variable `'value'`. If this variable does not exist, it defaults to returning the string `'None'`. The retrieved value is then returned as the HTTP response. This method is useful for accessing session data in a web application context, allowing for stateful interactions with users."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_handle_generic_http",
            "module": "test_user_error_handler",
            "class_name": "TestGenericHandlers",
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 269,
            "end_line_number": 281,
            "source_code": "def test_handle_generic_http(self, app, client):\n        \"\"\"``HTTPException`` should only receive ``HTTPException``\n        subclasses. It will receive ``404`` routing exceptions.\n        \"\"\"\n\n        @app.errorhandler(HTTPException)\n        def handle_http(e):\n            assert isinstance(e, HTTPException)\n            return str(e.code)\n\n        assert client.get(\"/error\").data == b\"500\"\n        assert client.get(\"/abort\").data == b\"500\"\n        assert client.get(\"/not-found\").data == b\"404\"",
            "docstring": "``HTTPException`` should only receive ``HTTPException``\nsubclasses. It will receive ``404`` routing exceptions.",
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/error').data == b'500'",
                "assert client.get('/abort').data == b'500'",
                "assert client.get('/not-found').data == b'404'",
                "assert isinstance(e, HTTPException)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, defaulting to `'None'` if the key `'value'` does not exist.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. It uses `flask.session.get` to access the session data, specifically looking for the key `'value'`. If this key is found, its associated value is returned; otherwise, the string `'None'` is returned. This method is useful for retrieving session-specific data in a web application context."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_handle_generic_http",
            "module": "test_user_error_handler",
            "class_name": "TestGenericHandlers",
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 269,
            "end_line_number": 281,
            "source_code": "def test_handle_generic_http(self, app, client):\n        \"\"\"``HTTPException`` should only receive ``HTTPException``\n        subclasses. It will receive ``404`` routing exceptions.\n        \"\"\"\n\n        @app.errorhandler(HTTPException)\n        def handle_http(e):\n            assert isinstance(e, HTTPException)\n            return str(e.code)\n\n        assert client.get(\"/error\").data == b\"500\"\n        assert client.get(\"/abort\").data == b\"500\"\n        assert client.get(\"/not-found\").data == b\"404\"",
            "docstring": "``HTTPException`` should only receive ``HTTPException``\nsubclasses. It will receive ``404`` routing exceptions.",
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/error').data == b'500'",
                "assert client.get('/abort').data == b'500'",
                "assert client.get('/not-found').data == b'404'",
                "assert isinstance(e, HTTPException)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, defaulting to `'None'` if the key `'value'` does not exist.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. It uses `flask.session.get` to access the session data, specifically looking for the key `'value'`. If this key is found, its associated value is returned; if not, the string `'None'` is returned. This method is useful for retrieving session-specific data in a web application context."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_handle_generic_http",
            "module": "test_user_error_handler",
            "class_name": "TestGenericHandlers",
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 269,
            "end_line_number": 281,
            "source_code": "def test_handle_generic_http(self, app, client):\n        \"\"\"``HTTPException`` should only receive ``HTTPException``\n        subclasses. It will receive ``404`` routing exceptions.\n        \"\"\"\n\n        @app.errorhandler(HTTPException)\n        def handle_http(e):\n            assert isinstance(e, HTTPException)\n            return str(e.code)\n\n        assert client.get(\"/error\").data == b\"500\"\n        assert client.get(\"/abort\").data == b\"500\"\n        assert client.get(\"/not-found\").data == b\"404\"",
            "docstring": "``HTTPException`` should only receive ``HTTPException``\nsubclasses. It will receive ``404`` routing exceptions.",
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/error').data == b'500'",
                "assert client.get('/abort').data == b'500'",
                "assert client.get('/not-found').data == b'404'",
                "assert isinstance(e, HTTPException)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_handle_generic",
            "module": "test_user_error_handler",
            "class_name": "TestGenericHandlers",
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 283,
            "end_line_number": 295,
            "source_code": "def test_handle_generic(self, app, client):\n        \"\"\"Generic ``Exception`` will handle all exceptions directly,\n        including ``HTTPExceptions``.\n        \"\"\"\n\n        @app.errorhandler(Exception)\n        def handle_exception(e):\n            return self.report_error(e)\n\n        assert client.get(\"/custom\").data == b\"direct Custom\"\n        assert client.get(\"/error\").data == b\"direct KeyError\"\n        assert client.get(\"/abort\").data == b\"direct InternalServerError\"\n        assert client.get(\"/not-found\").data == b\"direct NotFound\"",
            "docstring": "Generic ``Exception`` will handle all exceptions directly,\nincluding ``HTTPExceptions``.",
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/custom').data == b'direct Custom'",
                "assert client.get('/error').data == b'direct KeyError'",
                "assert client.get('/abort').data == b'direct InternalServerError'",
                "assert client.get('/not-found').data == b'direct NotFound'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.report_error",
                    "body": "def report_error(self, e):\n    original = getattr(e, 'original_exception', None)\n    if original is not None:\n        return f'wrapped {type(original).__name__}'\n    return f'direct {type(e).__name__}'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `report_error` method is designed to provide a string representation of an error, indicating whether the error is a direct instance of an exception or a wrapped exception that contains an original exception.\n\n**How It Works**:\nThe method takes an exception object `e` as an argument. It first attempts to retrieve an attribute `original_exception` from `e`. If this attribute exists and is not `None`, it indicates that `e` is a wrapped exception, and the method returns a string stating that it is a \"wrapped\" exception along with the type of the original exception. If `original_exception` is not present, the method concludes that `e` is a direct exception and returns a string indicating that it is a \"direct\" exception along with its type. This method is useful for error handling in applications, allowing developers to distinguish between different types of exceptions easily."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_handle_generic",
            "module": "test_user_error_handler",
            "class_name": "TestGenericHandlers",
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 283,
            "end_line_number": 295,
            "source_code": "def test_handle_generic(self, app, client):\n        \"\"\"Generic ``Exception`` will handle all exceptions directly,\n        including ``HTTPExceptions``.\n        \"\"\"\n\n        @app.errorhandler(Exception)\n        def handle_exception(e):\n            return self.report_error(e)\n\n        assert client.get(\"/custom\").data == b\"direct Custom\"\n        assert client.get(\"/error\").data == b\"direct KeyError\"\n        assert client.get(\"/abort\").data == b\"direct InternalServerError\"\n        assert client.get(\"/not-found\").data == b\"direct NotFound\"",
            "docstring": "Generic ``Exception`` will handle all exceptions directly,\nincluding ``HTTPExceptions``.",
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/custom').data == b'direct Custom'",
                "assert client.get('/error').data == b'direct KeyError'",
                "assert client.get('/abort').data == b'direct InternalServerError'",
                "assert client.get('/not-found').data == b'direct NotFound'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it as a response.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` attempts to fetch the value stored in the session under the key `'value'`. If this key does not exist, it defaults to returning the string `'None'`. The retrieved value is then returned as the HTTP response. This method relies on Flask's session management to store and retrieve user-specific data across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_handle_generic",
            "module": "test_user_error_handler",
            "class_name": "TestGenericHandlers",
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 283,
            "end_line_number": 295,
            "source_code": "def test_handle_generic(self, app, client):\n        \"\"\"Generic ``Exception`` will handle all exceptions directly,\n        including ``HTTPExceptions``.\n        \"\"\"\n\n        @app.errorhandler(Exception)\n        def handle_exception(e):\n            return self.report_error(e)\n\n        assert client.get(\"/custom\").data == b\"direct Custom\"\n        assert client.get(\"/error\").data == b\"direct KeyError\"\n        assert client.get(\"/abort\").data == b\"direct InternalServerError\"\n        assert client.get(\"/not-found\").data == b\"direct NotFound\"",
            "docstring": "Generic ``Exception`` will handle all exceptions directly,\nincluding ``HTTPExceptions``.",
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/custom').data == b'direct Custom'",
                "assert client.get('/error').data == b'direct KeyError'",
                "assert client.get('/abort').data == b'direct InternalServerError'",
                "assert client.get('/not-found').data == b'direct NotFound'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called, which attempts to fetch the value stored in the session under the key `'value'`. If this key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve user-specific data across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_handle_generic",
            "module": "test_user_error_handler",
            "class_name": "TestGenericHandlers",
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 283,
            "end_line_number": 295,
            "source_code": "def test_handle_generic(self, app, client):\n        \"\"\"Generic ``Exception`` will handle all exceptions directly,\n        including ``HTTPExceptions``.\n        \"\"\"\n\n        @app.errorhandler(Exception)\n        def handle_exception(e):\n            return self.report_error(e)\n\n        assert client.get(\"/custom\").data == b\"direct Custom\"\n        assert client.get(\"/error\").data == b\"direct KeyError\"\n        assert client.get(\"/abort\").data == b\"direct InternalServerError\"\n        assert client.get(\"/not-found\").data == b\"direct NotFound\"",
            "docstring": "Generic ``Exception`` will handle all exceptions directly,\nincluding ``HTTPExceptions``.",
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/custom').data == b'direct Custom'",
                "assert client.get('/error').data == b'direct KeyError'",
                "assert client.get('/abort').data == b'direct InternalServerError'",
                "assert client.get('/not-found').data == b'direct NotFound'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it as a response.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` attempts to fetch the value stored in the session under the key `'value'`. If this key does not exist, it defaults to returning the string `'None'`. The retrieved value is then returned as the HTTP response. This method relies on Flask's session management to store and retrieve user-specific data across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_handle_generic",
            "module": "test_user_error_handler",
            "class_name": "TestGenericHandlers",
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 283,
            "end_line_number": 295,
            "source_code": "def test_handle_generic(self, app, client):\n        \"\"\"Generic ``Exception`` will handle all exceptions directly,\n        including ``HTTPExceptions``.\n        \"\"\"\n\n        @app.errorhandler(Exception)\n        def handle_exception(e):\n            return self.report_error(e)\n\n        assert client.get(\"/custom\").data == b\"direct Custom\"\n        assert client.get(\"/error\").data == b\"direct KeyError\"\n        assert client.get(\"/abort\").data == b\"direct InternalServerError\"\n        assert client.get(\"/not-found\").data == b\"direct NotFound\"",
            "docstring": "Generic ``Exception`` will handle all exceptions directly,\nincluding ``HTTPExceptions``.",
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/custom').data == b'direct Custom'",
                "assert client.get('/error').data == b'direct KeyError'",
                "assert client.get('/abort').data == b'direct InternalServerError'",
                "assert client.get('/not-found').data == b'direct NotFound'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_handle_class_or_code",
            "module": "test_user_error_handler",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 253,
            "end_line_number": 267,
            "source_code": "def test_handle_class_or_code(self, app, client, to_handle):\n        \"\"\"``InternalServerError`` and ``500`` are aliases, they should\n        have the same behavior. Both should only receive\n        ``InternalServerError``, which might wrap another error.\n        \"\"\"\n\n        @app.errorhandler(to_handle)\n        def handle_500(e):\n            assert isinstance(e, InternalServerError)\n            return self.report_error(e)\n\n        assert client.get(\"/custom\").data == b\"wrapped Custom\"\n        assert client.get(\"/error\").data == b\"wrapped KeyError\"\n        assert client.get(\"/abort\").data == b\"direct InternalServerError\"\n        assert client.get(\"/raise\").data == b\"direct InternalServerError\"",
            "docstring": "``InternalServerError`` and ``500`` are aliases, they should\nhave the same behavior. Both should only receive\n``InternalServerError``, which might wrap another error.",
            "decorators": [
                "pytest.mark.parametrize('to_handle', (InternalServerError, 500))"
            ],
            "arguments": [
                "self",
                "app",
                "client",
                "to_handle"
            ],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/custom').data == b'wrapped Custom'",
                "assert client.get('/error').data == b'wrapped KeyError'",
                "assert client.get('/abort').data == b'direct InternalServerError'",
                "assert client.get('/raise').data == b'direct InternalServerError'",
                "assert isinstance(e, InternalServerError)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.report_error",
                    "body": "def report_error(self, e):\n    original = getattr(e, 'original_exception', None)\n    if original is not None:\n        return f'wrapped {type(original).__name__}'\n    return f'direct {type(e).__name__}'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `report_error` method is designed to provide a string representation of an error, indicating whether the error is a direct instance of an exception or a wrapped exception (i.e., an exception that has been caught and re-raised, potentially by another exception).\n\n**How It Works**:\nThe method takes an exception object `e` as an argument. It first attempts to retrieve an attribute `original_exception` from `e`. If this attribute exists and is not `None`, it indicates that `e` is a wrapped exception, and the method returns a string stating that it is a \"wrapped\" exception along with the type of the original exception. If `original_exception` is not present, the method concludes that `e` is a direct exception and returns a string indicating that it is a \"direct\" exception along with its type. This method is useful for error handling and logging, providing clarity on the nature of the exceptions encountered."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_handle_class_or_code",
            "module": "test_user_error_handler",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 253,
            "end_line_number": 267,
            "source_code": "def test_handle_class_or_code(self, app, client, to_handle):\n        \"\"\"``InternalServerError`` and ``500`` are aliases, they should\n        have the same behavior. Both should only receive\n        ``InternalServerError``, which might wrap another error.\n        \"\"\"\n\n        @app.errorhandler(to_handle)\n        def handle_500(e):\n            assert isinstance(e, InternalServerError)\n            return self.report_error(e)\n\n        assert client.get(\"/custom\").data == b\"wrapped Custom\"\n        assert client.get(\"/error\").data == b\"wrapped KeyError\"\n        assert client.get(\"/abort\").data == b\"direct InternalServerError\"\n        assert client.get(\"/raise\").data == b\"direct InternalServerError\"",
            "docstring": "``InternalServerError`` and ``500`` are aliases, they should\nhave the same behavior. Both should only receive\n``InternalServerError``, which might wrap another error.",
            "decorators": [
                "pytest.mark.parametrize('to_handle', (InternalServerError, 500))"
            ],
            "arguments": [
                "self",
                "app",
                "client",
                "to_handle"
            ],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/custom').data == b'wrapped Custom'",
                "assert client.get('/error').data == b'wrapped KeyError'",
                "assert client.get('/abort').data == b'direct InternalServerError'",
                "assert client.get('/raise').data == b'direct InternalServerError'",
                "assert isinstance(e, InternalServerError)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called, which attempts to fetch the value stored in the session under the key `'value'`. If this key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method relies on Flask's session management to store and retrieve user-specific data across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_handle_class_or_code",
            "module": "test_user_error_handler",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 253,
            "end_line_number": 267,
            "source_code": "def test_handle_class_or_code(self, app, client, to_handle):\n        \"\"\"``InternalServerError`` and ``500`` are aliases, they should\n        have the same behavior. Both should only receive\n        ``InternalServerError``, which might wrap another error.\n        \"\"\"\n\n        @app.errorhandler(to_handle)\n        def handle_500(e):\n            assert isinstance(e, InternalServerError)\n            return self.report_error(e)\n\n        assert client.get(\"/custom\").data == b\"wrapped Custom\"\n        assert client.get(\"/error\").data == b\"wrapped KeyError\"\n        assert client.get(\"/abort\").data == b\"direct InternalServerError\"\n        assert client.get(\"/raise\").data == b\"direct InternalServerError\"",
            "docstring": "``InternalServerError`` and ``500`` are aliases, they should\nhave the same behavior. Both should only receive\n``InternalServerError``, which might wrap another error.",
            "decorators": [
                "pytest.mark.parametrize('to_handle', (InternalServerError, 500))"
            ],
            "arguments": [
                "self",
                "app",
                "client",
                "to_handle"
            ],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/custom').data == b'wrapped Custom'",
                "assert client.get('/error').data == b'wrapped KeyError'",
                "assert client.get('/abort').data == b'direct InternalServerError'",
                "assert client.get('/raise').data == b'direct InternalServerError'",
                "assert isinstance(e, InternalServerError)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, defaulting to `'None'` if the key `'value'` does not exist.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. It uses `flask.session.get` to access the session data, specifically looking for the key `'value'`. If this key is found, its associated value is returned; otherwise, the string `'None'` is returned. This method is useful for retrieving session-specific data in a web application context."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_handle_class_or_code",
            "module": "test_user_error_handler",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 253,
            "end_line_number": 267,
            "source_code": "def test_handle_class_or_code(self, app, client, to_handle):\n        \"\"\"``InternalServerError`` and ``500`` are aliases, they should\n        have the same behavior. Both should only receive\n        ``InternalServerError``, which might wrap another error.\n        \"\"\"\n\n        @app.errorhandler(to_handle)\n        def handle_500(e):\n            assert isinstance(e, InternalServerError)\n            return self.report_error(e)\n\n        assert client.get(\"/custom\").data == b\"wrapped Custom\"\n        assert client.get(\"/error\").data == b\"wrapped KeyError\"\n        assert client.get(\"/abort\").data == b\"direct InternalServerError\"\n        assert client.get(\"/raise\").data == b\"direct InternalServerError\"",
            "docstring": "``InternalServerError`` and ``500`` are aliases, they should\nhave the same behavior. Both should only receive\n``InternalServerError``, which might wrap another error.",
            "decorators": [
                "pytest.mark.parametrize('to_handle', (InternalServerError, 500))"
            ],
            "arguments": [
                "self",
                "app",
                "client",
                "to_handle"
            ],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/custom').data == b'wrapped Custom'",
                "assert client.get('/error').data == b'wrapped KeyError'",
                "assert client.get('/abort').data == b'direct InternalServerError'",
                "assert client.get('/raise').data == b'direct InternalServerError'",
                "assert isinstance(e, InternalServerError)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, defaulting to `'None'` if the key `'value'` does not exist.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. It uses `flask.session.get` to access the session data, specifically looking for the key `'value'`. If this key is found, its associated value is returned; if not, the string `'None'` is returned. This method is useful for retrieving session-specific data in a web application context."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_handle_class_or_code",
            "module": "test_user_error_handler",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 253,
            "end_line_number": 267,
            "source_code": "def test_handle_class_or_code(self, app, client, to_handle):\n        \"\"\"``InternalServerError`` and ``500`` are aliases, they should\n        have the same behavior. Both should only receive\n        ``InternalServerError``, which might wrap another error.\n        \"\"\"\n\n        @app.errorhandler(to_handle)\n        def handle_500(e):\n            assert isinstance(e, InternalServerError)\n            return self.report_error(e)\n\n        assert client.get(\"/custom\").data == b\"wrapped Custom\"\n        assert client.get(\"/error\").data == b\"wrapped KeyError\"\n        assert client.get(\"/abort\").data == b\"direct InternalServerError\"\n        assert client.get(\"/raise\").data == b\"direct InternalServerError\"",
            "docstring": "``InternalServerError`` and ``500`` are aliases, they should\nhave the same behavior. Both should only receive\n``InternalServerError``, which might wrap another error.",
            "decorators": [
                "pytest.mark.parametrize('to_handle', (InternalServerError, 500))"
            ],
            "arguments": [
                "self",
                "app",
                "client",
                "to_handle"
            ],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/custom').data == b'wrapped Custom'",
                "assert client.get('/error').data == b'wrapped KeyError'",
                "assert client.get('/abort').data == b'direct InternalServerError'",
                "assert client.get('/raise').data == b'direct InternalServerError'",
                "assert isinstance(e, InternalServerError)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_handle_generic_http",
            "module": "test_user_error_handler",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 269,
            "end_line_number": 281,
            "source_code": "def test_handle_generic_http(self, app, client):\n        \"\"\"``HTTPException`` should only receive ``HTTPException``\n        subclasses. It will receive ``404`` routing exceptions.\n        \"\"\"\n\n        @app.errorhandler(HTTPException)\n        def handle_http(e):\n            assert isinstance(e, HTTPException)\n            return str(e.code)\n\n        assert client.get(\"/error\").data == b\"500\"\n        assert client.get(\"/abort\").data == b\"500\"\n        assert client.get(\"/not-found\").data == b\"404\"",
            "docstring": "``HTTPException`` should only receive ``HTTPException``\nsubclasses. It will receive ``404`` routing exceptions.",
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/error').data == b'500'",
                "assert client.get('/abort').data == b'500'",
                "assert client.get('/not-found').data == b'404'",
                "assert isinstance(e, HTTPException)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_handle_generic_http",
            "module": "test_user_error_handler",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 269,
            "end_line_number": 281,
            "source_code": "def test_handle_generic_http(self, app, client):\n        \"\"\"``HTTPException`` should only receive ``HTTPException``\n        subclasses. It will receive ``404`` routing exceptions.\n        \"\"\"\n\n        @app.errorhandler(HTTPException)\n        def handle_http(e):\n            assert isinstance(e, HTTPException)\n            return str(e.code)\n\n        assert client.get(\"/error\").data == b\"500\"\n        assert client.get(\"/abort\").data == b\"500\"\n        assert client.get(\"/not-found\").data == b\"404\"",
            "docstring": "``HTTPException`` should only receive ``HTTPException``\nsubclasses. It will receive ``404`` routing exceptions.",
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/error').data == b'500'",
                "assert client.get('/abort').data == b'500'",
                "assert client.get('/not-found').data == b'404'",
                "assert isinstance(e, HTTPException)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is used to define a route in a Flask web application that retrieves a value stored in the session. If the session does not contain the specified value, it defaults to returning the string `'None'`.\n\n**How It Works**:\nThe method is decorated with `@app.route('/get')`, which maps the URL path `/get` to the `get` function. Inside the function, `flask.session.get('value', 'None')` attempts to retrieve the value associated with the key `'value'` from the session. If the key does not exist, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request made to the `/get` endpoint. This allows clients to access session data easily through a simple GET request."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_handle_generic_http",
            "module": "test_user_error_handler",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 269,
            "end_line_number": 281,
            "source_code": "def test_handle_generic_http(self, app, client):\n        \"\"\"``HTTPException`` should only receive ``HTTPException``\n        subclasses. It will receive ``404`` routing exceptions.\n        \"\"\"\n\n        @app.errorhandler(HTTPException)\n        def handle_http(e):\n            assert isinstance(e, HTTPException)\n            return str(e.code)\n\n        assert client.get(\"/error\").data == b\"500\"\n        assert client.get(\"/abort\").data == b\"500\"\n        assert client.get(\"/not-found\").data == b\"404\"",
            "docstring": "``HTTPException`` should only receive ``HTTPException``\nsubclasses. It will receive ``404`` routing exceptions.",
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/error').data == b'500'",
                "assert client.get('/abort').data == b'500'",
                "assert client.get('/not-found').data == b'404'",
                "assert isinstance(e, HTTPException)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_handle_generic",
            "module": "test_user_error_handler",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 283,
            "end_line_number": 295,
            "source_code": "def test_handle_generic(self, app, client):\n        \"\"\"Generic ``Exception`` will handle all exceptions directly,\n        including ``HTTPExceptions``.\n        \"\"\"\n\n        @app.errorhandler(Exception)\n        def handle_exception(e):\n            return self.report_error(e)\n\n        assert client.get(\"/custom\").data == b\"direct Custom\"\n        assert client.get(\"/error\").data == b\"direct KeyError\"\n        assert client.get(\"/abort\").data == b\"direct InternalServerError\"\n        assert client.get(\"/not-found\").data == b\"direct NotFound\"",
            "docstring": "Generic ``Exception`` will handle all exceptions directly,\nincluding ``HTTPExceptions``.",
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/custom').data == b'direct Custom'",
                "assert client.get('/error').data == b'direct KeyError'",
                "assert client.get('/abort').data == b'direct InternalServerError'",
                "assert client.get('/not-found').data == b'direct NotFound'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.report_error",
                    "body": "def report_error(self, e):\n    original = getattr(e, 'original_exception', None)\n    if original is not None:\n        return f'wrapped {type(original).__name__}'\n    return f'direct {type(e).__name__}'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `report_error` method is designed to provide a string representation of an error, indicating whether the error is a direct instance of an exception or a wrapped exception (i.e., an exception that has been caught and re-raised, potentially by another exception).\n\n**How It Works**:\nThe method takes an exception object `e` as an argument. It first attempts to retrieve an attribute named `original_exception` from `e`. If this attribute exists and is not `None`, it indicates that `e` is a wrapped exception, and the method returns a string stating that it is a \"wrapped\" exception along with the type of the original exception. If `original_exception` is not present, the method concludes that `e` is a direct exception and returns a string indicating that it is a \"direct\" exception along with its type. This method is useful for error handling and logging, providing clarity on the nature of the exceptions encountered."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_handle_generic",
            "module": "test_user_error_handler",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 283,
            "end_line_number": 295,
            "source_code": "def test_handle_generic(self, app, client):\n        \"\"\"Generic ``Exception`` will handle all exceptions directly,\n        including ``HTTPExceptions``.\n        \"\"\"\n\n        @app.errorhandler(Exception)\n        def handle_exception(e):\n            return self.report_error(e)\n\n        assert client.get(\"/custom\").data == b\"direct Custom\"\n        assert client.get(\"/error\").data == b\"direct KeyError\"\n        assert client.get(\"/abort\").data == b\"direct InternalServerError\"\n        assert client.get(\"/not-found\").data == b\"direct NotFound\"",
            "docstring": "Generic ``Exception`` will handle all exceptions directly,\nincluding ``HTTPExceptions``.",
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/custom').data == b'direct Custom'",
                "assert client.get('/error').data == b'direct KeyError'",
                "assert client.get('/abort').data == b'direct InternalServerError'",
                "assert client.get('/not-found').data == b'direct NotFound'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. Finally, the retrieved value is returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_handle_generic",
            "module": "test_user_error_handler",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 283,
            "end_line_number": 295,
            "source_code": "def test_handle_generic(self, app, client):\n        \"\"\"Generic ``Exception`` will handle all exceptions directly,\n        including ``HTTPExceptions``.\n        \"\"\"\n\n        @app.errorhandler(Exception)\n        def handle_exception(e):\n            return self.report_error(e)\n\n        assert client.get(\"/custom\").data == b\"direct Custom\"\n        assert client.get(\"/error\").data == b\"direct KeyError\"\n        assert client.get(\"/abort\").data == b\"direct InternalServerError\"\n        assert client.get(\"/not-found\").data == b\"direct NotFound\"",
            "docstring": "Generic ``Exception`` will handle all exceptions directly,\nincluding ``HTTPExceptions``.",
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/custom').data == b'direct Custom'",
                "assert client.get('/error').data == b'direct KeyError'",
                "assert client.get('/abort').data == b'direct InternalServerError'",
                "assert client.get('/not-found').data == b'direct NotFound'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_handle_generic",
            "module": "test_user_error_handler",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 283,
            "end_line_number": 295,
            "source_code": "def test_handle_generic(self, app, client):\n        \"\"\"Generic ``Exception`` will handle all exceptions directly,\n        including ``HTTPExceptions``.\n        \"\"\"\n\n        @app.errorhandler(Exception)\n        def handle_exception(e):\n            return self.report_error(e)\n\n        assert client.get(\"/custom\").data == b\"direct Custom\"\n        assert client.get(\"/error\").data == b\"direct KeyError\"\n        assert client.get(\"/abort\").data == b\"direct InternalServerError\"\n        assert client.get(\"/not-found\").data == b\"direct NotFound\"",
            "docstring": "Generic ``Exception`` will handle all exceptions directly,\nincluding ``HTTPExceptions``.",
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/custom').data == b'direct Custom'",
                "assert client.get('/error').data == b'direct KeyError'",
                "assert client.get('/abort').data == b'direct InternalServerError'",
                "assert client.get('/not-found').data == b'direct NotFound'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is used to define a route in a Flask web application that retrieves a value stored in the session. If the session does not contain the specified value, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nThe method is decorated with `@app.route('/get')`, which maps the URL path `/get` to the `get` function. When a GET request is made to this endpoint, the function attempts to access the session variable `'value'` using `flask.session.get('value', 'None')`. If `'value'` exists in the session, its value is returned; otherwise, the string `'None'` is returned. This allows for easy retrieval of session data, providing a fallback value if the data is not present."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_handle_generic",
            "module": "test_user_error_handler",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
            "line_number": 283,
            "end_line_number": 295,
            "source_code": "def test_handle_generic(self, app, client):\n        \"\"\"Generic ``Exception`` will handle all exceptions directly,\n        including ``HTTPExceptions``.\n        \"\"\"\n\n        @app.errorhandler(Exception)\n        def handle_exception(e):\n            return self.report_error(e)\n\n        assert client.get(\"/custom\").data == b\"direct Custom\"\n        assert client.get(\"/error\").data == b\"direct KeyError\"\n        assert client.get(\"/abort\").data == b\"direct InternalServerError\"\n        assert client.get(\"/not-found\").data == b\"direct NotFound\"",
            "docstring": "Generic ``Exception`` will handle all exceptions directly,\nincluding ``HTTPExceptions``.",
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "werkzeug.exceptions.Forbidden",
                "werkzeug.exceptions.HTTPException",
                "werkzeug.exceptions.InternalServerError",
                "werkzeug.exceptions.NotFound",
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/custom').data == b'direct Custom'",
                "assert client.get('/error').data == b'direct KeyError'",
                "assert client.get('/abort').data == b'direct InternalServerError'",
                "assert client.get('/not-found').data == b'direct NotFound'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. Finally, the retrieved value is returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_custom_converters",
            "module": "test_converters",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_converters.py",
            "line_number": 8,
            "end_line_number": 26,
            "source_code": "def test_custom_converters(app, client):\n    class ListConverter(BaseConverter):\n        def to_python(self, value):\n            return value.split(\",\")\n\n        def to_url(self, value):\n            base_to_url = super().to_url\n            return \",\".join(base_to_url(x) for x in value)\n\n    app.url_map.converters[\"list\"] = ListConverter\n\n    @app.route(\"/<list:args>\")\n    def index(args):\n        return \"|\".join(args)\n\n    assert client.get(\"/1,2,3\").data == b\"1|2|3\"\n\n    with app.test_request_context():\n        assert url_for(\"index\", args=[4, 5, 6]) == \"/4,5,6\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "werkzeug.routing.BaseConverter",
                "flask.request",
                "flask.session",
                "flask.url_for"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/1,2,3').data == b'1|2|3'",
                "assert url_for('index', args=[4, 5, 6]) == '/4,5,6'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_context_available",
            "module": "test_converters",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_converters.py",
            "line_number": 29,
            "end_line_number": 42,
            "source_code": "def test_context_available(app, client):\n    class ContextConverter(BaseConverter):\n        def to_python(self, value):\n            assert request is not None\n            assert session is not None\n            return value\n\n    app.url_map.converters[\"ctx\"] = ContextConverter\n\n    @app.get(\"/<ctx:name>\")\n    def index(name):\n        return name\n\n    assert client.get(\"/admin\").data == b\"admin\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "werkzeug.routing.BaseConverter",
                "flask.request",
                "flask.session",
                "flask.url_for"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/admin').data == b'admin'",
                "assert request is not None",
                "assert session is not None"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "app.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `app.get` method is used to define a route in a Flask web application that responds to HTTP GET requests. Specifically, the route `/get` retrieves a value from the session, returning it to the client.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` attempts to retrieve the value associated with the key `'value'` from the session. If the key does not exist, it defaults to returning the string `'None'`. The retrieved value is then returned as the response to the client. This method leverages Flask's session management to store and retrieve user-specific data across requests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_context_available",
            "module": "test_converters",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_converters.py",
            "line_number": 29,
            "end_line_number": 42,
            "source_code": "def test_context_available(app, client):\n    class ContextConverter(BaseConverter):\n        def to_python(self, value):\n            assert request is not None\n            assert session is not None\n            return value\n\n    app.url_map.converters[\"ctx\"] = ContextConverter\n\n    @app.get(\"/<ctx:name>\")\n    def index(name):\n        return name\n\n    assert client.get(\"/admin\").data == b\"admin\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "werkzeug.routing.BaseConverter",
                "flask.request",
                "flask.session",
                "flask.url_for"
            ],
            "fixtures": [],
            "assertions": [
                "assert client.get('/admin').data == b'admin'",
                "assert request is not None",
                "assert session is not None"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_aborting",
            "module": "test_regression",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_regression.py",
            "line_number": 4,
            "end_line_number": 30,
            "source_code": "def test_aborting(app):\n    class Foo(Exception):\n        whatever = 42\n\n    @app.errorhandler(Foo)\n    def handle_foo(e):\n        return str(e.whatever)\n\n    @app.route(\"/\")\n    def index():\n        raise flask.abort(flask.redirect(flask.url_for(\"test\")))\n\n    @app.route(\"/test\")\n    def test():\n        raise Foo()\n\n    with app.test_client() as c:\n        rv = c.get(\"/\")\n        location_parts = rv.headers[\"Location\"].rpartition(\"/\")\n\n        if location_parts[0]:\n            # For older Werkzeug that used absolute redirects.\n            assert location_parts[0] == \"http://localhost\"\n\n        assert location_parts[2] == \"test\"\n        rv = c.get(\"/test\")\n        assert rv.data == b\"42\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert location_parts[2] == 'test'",
                "assert rv.data == b'42'",
                "assert location_parts[0] == 'http://localhost'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "c.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get` method is a Flask route handler that retrieves a value from the session, specifically the value associated with the key `'value'`. If this key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the method uses `flask.session.get()` to access the session data. The `get` method takes two arguments: the key `'value'` and a default value `'None'`. If the key is found, it returns the corresponding value; otherwise, it returns the default value. This allows for safe retrieval of session data without raising an error if the key is absent. The result is then returned as the HTTP response."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_aborting",
            "module": "test_regression",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_regression.py",
            "line_number": 4,
            "end_line_number": 30,
            "source_code": "def test_aborting(app):\n    class Foo(Exception):\n        whatever = 42\n\n    @app.errorhandler(Foo)\n    def handle_foo(e):\n        return str(e.whatever)\n\n    @app.route(\"/\")\n    def index():\n        raise flask.abort(flask.redirect(flask.url_for(\"test\")))\n\n    @app.route(\"/test\")\n    def test():\n        raise Foo()\n\n    with app.test_client() as c:\n        rv = c.get(\"/\")\n        location_parts = rv.headers[\"Location\"].rpartition(\"/\")\n\n        if location_parts[0]:\n            # For older Werkzeug that used absolute redirects.\n            assert location_parts[0] == \"http://localhost\"\n\n        assert location_parts[2] == \"test\"\n        rv = c.get(\"/test\")\n        assert rv.data == b\"42\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "flask"
            ],
            "fixtures": [],
            "assertions": [
                "assert location_parts[2] == 'test'",
                "assert rv.data == b'42'",
                "assert location_parts[0] == 'http://localhost'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "c.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get` method is a Flask route handler that retrieves a value from the session, specifically the value associated with the key `'value'`. If this key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the method uses `flask.session.get()` to access the session data. The `get` method takes two arguments: the key `'value'` and a default value `'None'`. If the key is found in the session, its corresponding value is returned; otherwise, the default value `'None'` is returned. This allows for safe retrieval of session data without raising an error if the key is absent."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_app_tearing_down_with_handled_exception_by_app_handler",
            "module": "test_appctx",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_appctx.py",
            "line_number": 91,
            "end_line_number": 110,
            "source_code": "def test_app_tearing_down_with_handled_exception_by_app_handler(app, client):\n    app.config[\"PROPAGATE_EXCEPTIONS\"] = True\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    @app.route(\"/\")\n    def index():\n        raise Exception(\"dummy\")\n\n    @app.errorhandler(Exception)\n    def handler(f):\n        return flask.jsonify(str(f))\n\n    with app.app_context():\n        client.get(\"/\")\n\n    assert cleanup_stuff == [None]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "flask",
                "flask.globals.app_ctx",
                "flask.globals.request_ctx"
            ],
            "fixtures": [],
            "assertions": [
                "assert cleanup_stuff == [None]"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_app_tearing_down_with_unhandled_exception",
            "module": "test_appctx",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_appctx.py",
            "line_number": 113,
            "end_line_number": 131,
            "source_code": "def test_app_tearing_down_with_unhandled_exception(app, client):\n    app.config[\"PROPAGATE_EXCEPTIONS\"] = True\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    @app.route(\"/\")\n    def index():\n        raise ValueError(\"dummy\")\n\n    with pytest.raises(ValueError, match=\"dummy\"):\n        with app.app_context():\n            client.get(\"/\")\n\n    assert len(cleanup_stuff) == 1\n    assert isinstance(cleanup_stuff[0], ValueError)\n    assert str(cleanup_stuff[0]) == \"dummy\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "flask",
                "flask.globals.app_ctx",
                "flask.globals.request_ctx"
            ],
            "fixtures": [],
            "assertions": [
                "assert len(cleanup_stuff) == 1",
                "assert isinstance(cleanup_stuff[0], ValueError)",
                "assert str(cleanup_stuff[0]) == 'dummy'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. Finally, the retrieved value is returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_context_refcounts",
            "module": "test_appctx",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_appctx.py",
            "line_number": 167,
            "end_line_number": 190,
            "source_code": "def test_context_refcounts(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_req(error=None):\n        called.append(\"request\")\n\n    @app.teardown_appcontext\n    def teardown_app(error=None):\n        called.append(\"app\")\n\n    @app.route(\"/\")\n    def index():\n        with app_ctx:\n            with request_ctx:\n                pass\n\n        assert flask.request.environ[\"werkzeug.request\"] is not None\n        return \"\"\n\n    res = client.get(\"/\")\n    assert res.status_code == 200\n    assert res.data == b\"\"\n    assert called == [\"request\", \"app\"]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "pytest",
                "flask",
                "flask.globals.app_ctx",
                "flask.globals.request_ctx"
            ],
            "fixtures": [],
            "assertions": [
                "assert res.status_code == 200",
                "assert res.data == b''",
                "assert called == ['request', 'app']",
                "assert flask.request.environ['werkzeug.request'] is not None"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. Finally, the retrieved value is returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_bad_request_debug_message",
            "module": "test_json",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_json.py",
            "line_number": 15,
            "end_line_number": 27,
            "source_code": "def test_bad_request_debug_message(app, client, debug):\n    app.config[\"DEBUG\"] = debug\n    app.config[\"TRAP_BAD_REQUEST_ERRORS\"] = False\n\n    @app.route(\"/json\", methods=[\"POST\"])\n    def post_json():\n        flask.request.get_json()\n        return None\n\n    rv = client.post(\"/json\", data=None, content_type=\"application/json\")\n    assert rv.status_code == 400\n    contains = b\"Failed to decode JSON object\" in rv.data\n    assert contains == debug",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('debug', (True, False))"
            ],
            "arguments": [
                "app",
                "client",
                "debug"
            ],
            "imports": [
                "datetime",
                "decimal",
                "io",
                "uuid",
                "pytest",
                "werkzeug.http.http_date",
                "flask",
                "flask.json",
                "flask.json.provider.DefaultJSONProvider",
                "codecs"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.status_code == 400",
                "assert contains == debug"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.post",
                    "body": "def post(self):\n    return 'Create'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is designed to simulate an HTTP POST request to a specified endpoint, allowing developers to send data to the server, typically for creating or updating resources.\n\n**How It Works**:\nWhen invoked, `client.post` sends a request to the server at the specified URL with the provided data. In the context of the provided code snippets, it is used to test various functionalities such as creating a new post, updating an existing post, and deleting a post. The method returns a response indicating the result of the operation, which can be further validated in tests to ensure the expected behavior of the application. The method's implementation in the example simply returns the string 'Create', but in a real application, it would handle the logic for processing the POST request and returning an appropriate response."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_json_bad_requests",
            "module": "test_json",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_json.py",
            "line_number": 30,
            "end_line_number": 36,
            "source_code": "def test_json_bad_requests(app, client):\n    @app.route(\"/json\", methods=[\"POST\"])\n    def return_json():\n        return flask.jsonify(foo=str(flask.request.get_json()))\n\n    rv = client.post(\"/json\", data=\"malformed\", content_type=\"application/json\")\n    assert rv.status_code == 400",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "datetime",
                "decimal",
                "io",
                "uuid",
                "pytest",
                "werkzeug.http.http_date",
                "flask",
                "flask.json",
                "flask.json.provider.DefaultJSONProvider",
                "codecs"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.status_code == 400"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.post",
                    "body": "def post(self):\n    return 'Create'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is designed to simulate an HTTP POST request to a specified endpoint, allowing developers to test the behavior of their web application when data is submitted.\n\n**How It Works**:\nWhen invoked, `client.post` sends a POST request to the specified URL, optionally including data in the request body. In the provided code snippets, this method is used to update a post's title, validate input during creation or updating, and delete a post. The method returns a response object that can be inspected for status codes, headers, and response data, enabling assertions in tests to verify that the application behaves as expected."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_json_custom_mimetypes",
            "module": "test_json",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_json.py",
            "line_number": 39,
            "end_line_number": 45,
            "source_code": "def test_json_custom_mimetypes(app, client):\n    @app.route(\"/json\", methods=[\"POST\"])\n    def return_json():\n        return flask.request.get_json()\n\n    rv = client.post(\"/json\", data='\"foo\"', content_type=\"application/x+json\")\n    assert rv.data == b\"foo\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "datetime",
                "decimal",
                "io",
                "uuid",
                "pytest",
                "werkzeug.http.http_date",
                "flask",
                "flask.json",
                "flask.json.provider.DefaultJSONProvider",
                "codecs"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'foo'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.post",
                    "body": "def post(self):\n    return 'Create'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is designed to simulate an HTTP POST request to a specified endpoint, allowing developers to send data to the server, typically for creating or updating resources.\n\n**How It Works**:\nWhen invoked, `client.post` sends a request to the server at the specified URL with the provided data. In the context of the provided code snippets, it is used to test various functionalities such as creating a new post, updating an existing post, and validating input data. The method returns a response indicating the result of the operation, which can be further inspected for status codes or response data. The method is part of a testing framework that helps ensure the application's endpoints behave as expected."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_jsonify_basic_types",
            "module": "test_json",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_json.py",
            "line_number": 70,
            "end_line_number": 75,
            "source_code": "def test_jsonify_basic_types(test_value, app, client):\n    url = \"/jsonify_basic_types\"\n    app.add_url_rule(url, url, lambda x=test_value: flask.jsonify(x))\n    rv = client.get(url)\n    assert rv.mimetype == \"application/json\"\n    assert flask.json.loads(rv.data) == test_value",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('test_value', [0, -1, 1, 23, 3.14, 's', 'longer string', True, False, None])"
            ],
            "arguments": [
                "test_value",
                "app",
                "client"
            ],
            "imports": [
                "datetime",
                "decimal",
                "io",
                "uuid",
                "pytest",
                "werkzeug.http.http_date",
                "flask",
                "flask.json",
                "flask.json.provider.DefaultJSONProvider",
                "codecs"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.mimetype == 'application/json'",
                "assert flask.json.loads(rv.data) == test_value"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, defaulting to `'None'` if the key `'value'` does not exist.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. It uses `flask.session.get` to access the session data, specifically looking for the key `'value'`. If this key is found, its associated value is returned; otherwise, the string `'None'` is returned. This method is useful for retrieving session-specific data in a web application context."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_jsonify_dicts",
            "module": "test_json",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_json.py",
            "line_number": 78,
            "end_line_number": 102,
            "source_code": "def test_jsonify_dicts(app, client):\n    d = {\n        \"a\": 0,\n        \"b\": 23,\n        \"c\": 3.14,\n        \"d\": \"t\",\n        \"e\": \"Hi\",\n        \"f\": True,\n        \"g\": False,\n        \"h\": [\"test list\", 10, False],\n        \"i\": {\"test\": \"dict\"},\n    }\n\n    @app.route(\"/kw\")\n    def return_kwargs():\n        return flask.jsonify(**d)\n\n    @app.route(\"/dict\")\n    def return_dict():\n        return flask.jsonify(d)\n\n    for url in \"/kw\", \"/dict\":\n        rv = client.get(url)\n        assert rv.mimetype == \"application/json\"\n        assert flask.json.loads(rv.data) == d",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "datetime",
                "decimal",
                "io",
                "uuid",
                "pytest",
                "werkzeug.http.http_date",
                "flask",
                "flask.json",
                "flask.json.provider.DefaultJSONProvider",
                "codecs"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.mimetype == 'application/json'",
                "assert flask.json.loads(rv.data) == d"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_jsonify_arrays",
            "module": "test_json",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_json.py",
            "line_number": 105,
            "end_line_number": 130,
            "source_code": "def test_jsonify_arrays(app, client):\n    \"\"\"Test jsonify of lists and args unpacking.\"\"\"\n    a_list = [\n        0,\n        42,\n        3.14,\n        \"t\",\n        \"hello\",\n        True,\n        False,\n        [\"test list\", 2, False],\n        {\"test\": \"dict\"},\n    ]\n\n    @app.route(\"/args_unpack\")\n    def return_args_unpack():\n        return flask.jsonify(*a_list)\n\n    @app.route(\"/array\")\n    def return_array():\n        return flask.jsonify(a_list)\n\n    for url in \"/args_unpack\", \"/array\":\n        rv = client.get(url)\n        assert rv.mimetype == \"application/json\"\n        assert flask.json.loads(rv.data) == a_list",
            "docstring": "Test jsonify of lists and args unpacking.",
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "datetime",
                "decimal",
                "io",
                "uuid",
                "pytest",
                "werkzeug.http.http_date",
                "flask",
                "flask.json",
                "flask.json.provider.DefaultJSONProvider",
                "codecs"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.mimetype == 'application/json'",
                "assert flask.json.loads(rv.data) == a_list"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_jsonify_datetime",
            "module": "test_json",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_json.py",
            "line_number": 136,
            "end_line_number": 142,
            "source_code": "def test_jsonify_datetime(app, client, value):\n    @app.route(\"/\")\n    def index():\n        return flask.jsonify(value=value)\n\n    r = client.get()\n    assert r.json[\"value\"] == http_date(value)",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('value', [datetime.datetime(1973, 3, 11, 6, 30, 45), datetime.date(1975, 1, 5)])"
            ],
            "arguments": [
                "app",
                "client",
                "value"
            ],
            "imports": [
                "datetime",
                "decimal",
                "io",
                "uuid",
                "pytest",
                "werkzeug.http.http_date",
                "flask",
                "flask.json",
                "flask.json.provider.DefaultJSONProvider",
                "codecs"
            ],
            "fixtures": [],
            "assertions": [
                "assert r.json['value'] == http_date(value)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_jsonify_uuid_types",
            "module": "test_json",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_json.py",
            "line_number": 176,
            "end_line_number": 188,
            "source_code": "def test_jsonify_uuid_types(app, client):\n    \"\"\"Test jsonify with uuid.UUID types\"\"\"\n\n    test_uuid = uuid.UUID(bytes=b\"\\xde\\xad\\xbe\\xef\" * 4)\n    url = \"/uuid_test\"\n    app.add_url_rule(url, url, lambda: flask.jsonify(x=test_uuid))\n\n    rv = client.get(url)\n\n    rv_x = flask.json.loads(rv.data)[\"x\"]\n    assert rv_x == str(test_uuid)\n    rv_uuid = uuid.UUID(rv_x)\n    assert rv_uuid == test_uuid",
            "docstring": "Test jsonify with uuid.UUID types",
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "datetime",
                "decimal",
                "io",
                "uuid",
                "pytest",
                "werkzeug.http.http_date",
                "flask",
                "flask.json",
                "flask.json.provider.DefaultJSONProvider",
                "codecs"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv_x == str(test_uuid)",
                "assert rv_uuid == test_uuid"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. Finally, the retrieved value is returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_json_attr",
            "module": "test_json",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_json.py",
            "line_number": 196,
            "end_line_number": 207,
            "source_code": "def test_json_attr(app, client):\n    @app.route(\"/add\", methods=[\"POST\"])\n    def add():\n        json = flask.request.get_json()\n        return str(json[\"a\"] + json[\"b\"])\n\n    rv = client.post(\n        \"/add\",\n        data=flask.json.dumps({\"a\": 1, \"b\": 2}),\n        content_type=\"application/json\",\n    )\n    assert rv.data == b\"3\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "datetime",
                "decimal",
                "io",
                "uuid",
                "pytest",
                "werkzeug.http.http_date",
                "flask",
                "flask.json",
                "flask.json.provider.DefaultJSONProvider",
                "codecs"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'3'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.post",
                    "body": "def post(self):\n    return 'Create'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is designed to simulate an HTTP POST request to a specified endpoint, allowing developers to send data to the server, typically for creating or updating resources.\n\n**How It Works**:\nWhen invoked, `client.post` sends a request to the server at the specified URL with the provided data. In the context of the provided code snippets, it is used to test various functionalities such as creating a new post, updating an existing post, and deleting a post. The method returns a response indicating the result of the operation, which can be further validated in tests to ensure the expected behavior of the application. The method body currently returns a simple string 'Create', but in a real application, it would typically handle the request and return a response object."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_json_customization",
            "module": "test_json",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_json.py",
            "line_number": 223,
            "end_line_number": 257,
            "source_code": "def test_json_customization(app, client):\n    class X:  # noqa: B903, for Python2 compatibility\n        def __init__(self, val):\n            self.val = val\n\n    def default(o):\n        if isinstance(o, X):\n            return f\"<{o.val}>\"\n\n        return DefaultJSONProvider.default(o)\n\n    class CustomProvider(DefaultJSONProvider):\n        def object_hook(self, obj):\n            if len(obj) == 1 and \"_foo\" in obj:\n                return X(obj[\"_foo\"])\n\n            return obj\n\n        def loads(self, s, **kwargs):\n            kwargs.setdefault(\"object_hook\", self.object_hook)\n            return super().loads(s, **kwargs)\n\n    app.json = CustomProvider(app)\n    app.json.default = default\n\n    @app.route(\"/\", methods=[\"POST\"])\n    def index():\n        return flask.json.dumps(flask.request.get_json()[\"x\"])\n\n    rv = client.post(\n        \"/\",\n        data=flask.json.dumps({\"x\": {\"_foo\": 42}}),\n        content_type=\"application/json\",\n    )\n    assert rv.data == b'\"<42>\"'",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "datetime",
                "decimal",
                "io",
                "uuid",
                "pytest",
                "werkzeug.http.http_date",
                "flask",
                "flask.json",
                "flask.json.provider.DefaultJSONProvider",
                "codecs"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'\"<42>\"'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.post",
                    "body": "def post(self):\n    return 'Create'",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.post` method is designed to simulate an HTTP POST request to a specified endpoint, allowing developers to send data to the server, typically for creating or updating resources.\n\n**How It Works**:\nWhen invoked, `client.post` sends a request to the server at the specified URL with the provided data. In the context of the provided code snippets, it is used to test various functionalities such as creating a new post, updating an existing post, and deleting a post. The method returns a response indicating the result of the operation, which can be further validated in tests to ensure the expected behavior of the application."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_json_customization",
            "module": "test_json",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_json.py",
            "line_number": 223,
            "end_line_number": 257,
            "source_code": "def test_json_customization(app, client):\n    class X:  # noqa: B903, for Python2 compatibility\n        def __init__(self, val):\n            self.val = val\n\n    def default(o):\n        if isinstance(o, X):\n            return f\"<{o.val}>\"\n\n        return DefaultJSONProvider.default(o)\n\n    class CustomProvider(DefaultJSONProvider):\n        def object_hook(self, obj):\n            if len(obj) == 1 and \"_foo\" in obj:\n                return X(obj[\"_foo\"])\n\n            return obj\n\n        def loads(self, s, **kwargs):\n            kwargs.setdefault(\"object_hook\", self.object_hook)\n            return super().loads(s, **kwargs)\n\n    app.json = CustomProvider(app)\n    app.json.default = default\n\n    @app.route(\"/\", methods=[\"POST\"])\n    def index():\n        return flask.json.dumps(flask.request.get_json()[\"x\"])\n\n    rv = client.post(\n        \"/\",\n        data=flask.json.dumps({\"x\": {\"_foo\": 42}}),\n        content_type=\"application/json\",\n    )\n    assert rv.data == b'\"<42>\"'",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "datetime",
                "decimal",
                "io",
                "uuid",
                "pytest",
                "werkzeug.http.http_date",
                "flask",
                "flask.json",
                "flask.json.provider.DefaultJSONProvider",
                "codecs"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'\"<42>\"'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "DefaultJSONProvider.default",
                    "body": "def default(o):\n    if isinstance(o, X):\n        return f'<{o.val}>'\n    return DefaultJSONProvider.default(o)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `DefaultJSONProvider.default` method is designed to provide a custom serialization mechanism for objects that are not natively serializable to JSON. Specifically, it handles instances of a custom class `X` by returning a formatted string representation of its value.\n\n**How It Works**:  \nThe method checks if the object `o` is an instance of class `X`. If it is, it returns a string formatted as `'<{o.val}>'`, where `o.val` is the value of the instance. If `o` is not an instance of `X`, it delegates the serialization to the parent class's `default` method, which handles other types of objects, including dates, decimals, UUIDs, and dataclasses, or raises a `TypeError` if the object is not serializable. This allows for extensible and customizable JSON serialization in applications that require special handling for certain object types."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_json_customization",
            "module": "test_json",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_json.py",
            "line_number": 223,
            "end_line_number": 257,
            "source_code": "def test_json_customization(app, client):\n    class X:  # noqa: B903, for Python2 compatibility\n        def __init__(self, val):\n            self.val = val\n\n    def default(o):\n        if isinstance(o, X):\n            return f\"<{o.val}>\"\n\n        return DefaultJSONProvider.default(o)\n\n    class CustomProvider(DefaultJSONProvider):\n        def object_hook(self, obj):\n            if len(obj) == 1 and \"_foo\" in obj:\n                return X(obj[\"_foo\"])\n\n            return obj\n\n        def loads(self, s, **kwargs):\n            kwargs.setdefault(\"object_hook\", self.object_hook)\n            return super().loads(s, **kwargs)\n\n    app.json = CustomProvider(app)\n    app.json.default = default\n\n    @app.route(\"/\", methods=[\"POST\"])\n    def index():\n        return flask.json.dumps(flask.request.get_json()[\"x\"])\n\n    rv = client.post(\n        \"/\",\n        data=flask.json.dumps({\"x\": {\"_foo\": 42}}),\n        content_type=\"application/json\",\n    )\n    assert rv.data == b'\"<42>\"'",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "datetime",
                "decimal",
                "io",
                "uuid",
                "pytest",
                "werkzeug.http.http_date",
                "flask",
                "flask.json",
                "flask.json.provider.DefaultJSONProvider",
                "codecs"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'\"<42>\"'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "kwargs.setdefault",
                    "body": "@app.route('/setdefault')\ndef setdefault():\n    return flask.session.setdefault('test', 'default')",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `setdefault` method is used to retrieve a value from a session in Flask, and if that value does not exist, it sets a default value. This is particularly useful for initializing session variables without overwriting existing values.\n\n**How It Works**:\nIn the provided code, `flask.session.setdefault('test', 'default')` checks if the key `'test'` exists in the session. If it does, it returns the current value associated with that key. If it does not exist, it sets the key `'test'` to the value `'default'` and then returns `'default'`. This method ensures that session data can be safely initialized without losing any previously stored values."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_json_key_sorting",
            "module": "test_json",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_json.py",
            "line_number": 270,
            "end_line_number": 337,
            "source_code": "def test_json_key_sorting(app, client):\n    app.debug = True\n    assert app.json.sort_keys\n    d = dict.fromkeys(range(20), \"foo\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.jsonify(values=d)\n\n    rv = client.get(\"/\")\n    lines = [x.strip() for x in rv.data.strip().decode(\"utf-8\").splitlines()]\n    sorted_by_str = [\n        \"{\",\n        '\"values\": {',\n        '\"0\": \"foo\",',\n        '\"1\": \"foo\",',\n        '\"10\": \"foo\",',\n        '\"11\": \"foo\",',\n        '\"12\": \"foo\",',\n        '\"13\": \"foo\",',\n        '\"14\": \"foo\",',\n        '\"15\": \"foo\",',\n        '\"16\": \"foo\",',\n        '\"17\": \"foo\",',\n        '\"18\": \"foo\",',\n        '\"19\": \"foo\",',\n        '\"2\": \"foo\",',\n        '\"3\": \"foo\",',\n        '\"4\": \"foo\",',\n        '\"5\": \"foo\",',\n        '\"6\": \"foo\",',\n        '\"7\": \"foo\",',\n        '\"8\": \"foo\",',\n        '\"9\": \"foo\"',\n        \"}\",\n        \"}\",\n    ]\n    sorted_by_int = [\n        \"{\",\n        '\"values\": {',\n        '\"0\": \"foo\",',\n        '\"1\": \"foo\",',\n        '\"2\": \"foo\",',\n        '\"3\": \"foo\",',\n        '\"4\": \"foo\",',\n        '\"5\": \"foo\",',\n        '\"6\": \"foo\",',\n        '\"7\": \"foo\",',\n        '\"8\": \"foo\",',\n        '\"9\": \"foo\",',\n        '\"10\": \"foo\",',\n        '\"11\": \"foo\",',\n        '\"12\": \"foo\",',\n        '\"13\": \"foo\",',\n        '\"14\": \"foo\",',\n        '\"15\": \"foo\",',\n        '\"16\": \"foo\",',\n        '\"17\": \"foo\",',\n        '\"18\": \"foo\",',\n        '\"19\": \"foo\"',\n        \"}\",\n        \"}\",\n    ]\n\n    try:\n        assert lines == sorted_by_int\n    except AssertionError:\n        assert lines == sorted_by_str",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "datetime",
                "decimal",
                "io",
                "uuid",
                "pytest",
                "werkzeug.http.http_date",
                "flask",
                "flask.json",
                "flask.json.provider.DefaultJSONProvider",
                "codecs"
            ],
            "fixtures": [],
            "assertions": [
                "assert app.json.sort_keys",
                "assert lines == sorted_by_int",
                "assert lines == sorted_by_str"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_wsgi_errors_stream",
            "module": "test_logging",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_logging.py",
            "line_number": 54,
            "end_line_number": 67,
            "source_code": "def test_wsgi_errors_stream(app, client):\n    @app.route(\"/\")\n    def index():\n        app.logger.error(\"test\")\n        return \"\"\n\n    stream = StringIO()\n    client.get(\"/\", errors_stream=stream)\n    assert \"ERROR in test_logging: test\" in stream.getvalue()\n\n    assert wsgi_errors_stream._get_current_object() is sys.stderr\n\n    with app.test_request_context(errors_stream=stream):\n        assert wsgi_errors_stream._get_current_object() is stream",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "logging",
                "sys",
                "io.StringIO",
                "pytest",
                "flask.logging.default_handler",
                "flask.logging.has_level_handler",
                "flask.logging.wsgi_errors_stream"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'ERROR in test_logging: test' in stream.getvalue()",
                "assert wsgi_errors_stream._get_current_object() is sys.stderr",
                "assert wsgi_errors_stream._get_current_object() is stream"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, defaulting to `'None'` if the key `'value'` does not exist.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. It uses `flask.session.get` to access the session data, specifically looking for the key `'value'`. If this key is found, its associated value is returned; otherwise, the string `'None'` is returned. This allows the application to maintain state across requests by storing and retrieving session data."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_wsgi_errors_stream",
            "module": "test_logging",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_logging.py",
            "line_number": 54,
            "end_line_number": 67,
            "source_code": "def test_wsgi_errors_stream(app, client):\n    @app.route(\"/\")\n    def index():\n        app.logger.error(\"test\")\n        return \"\"\n\n    stream = StringIO()\n    client.get(\"/\", errors_stream=stream)\n    assert \"ERROR in test_logging: test\" in stream.getvalue()\n\n    assert wsgi_errors_stream._get_current_object() is sys.stderr\n\n    with app.test_request_context(errors_stream=stream):\n        assert wsgi_errors_stream._get_current_object() is stream",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "logging",
                "sys",
                "io.StringIO",
                "pytest",
                "flask.logging.default_handler",
                "flask.logging.has_level_handler",
                "flask.logging.wsgi_errors_stream"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'ERROR in test_logging: test' in stream.getvalue()",
                "assert wsgi_errors_stream._get_current_object() is sys.stderr",
                "assert wsgi_errors_stream._get_current_object() is stream"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "app.logger.error",
                    "body": "@app.route('/error')\ndef error():\n    raise ZeroDivisionError",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `app.logger.error` method is used to log error messages in a Flask application. It helps developers track issues by recording error events, which can be crucial for debugging and monitoring application health.\n\n**How It Works**:\nWhen an error occurs in a Flask route (like the `error` function that raises a `ZeroDivisionError`), the Flask application can catch this exception and log it using `app.logger.error`. The logger is configured to capture messages at the error level and above. The logging configuration is typically set up in the `create_logger` function, which ensures that the logger is properly initialized and has the appropriate handlers. This allows the application to log detailed error information, including the type of error and the context in which it occurred, facilitating easier debugging and maintenance."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_log_view_exception",
            "module": "test_logging",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_logging.py",
            "line_number": 86,
            "end_line_number": 98,
            "source_code": "def test_log_view_exception(app, client):\n    @app.route(\"/\")\n    def index():\n        raise Exception(\"test\")\n\n    app.testing = False\n    stream = StringIO()\n    rv = client.get(\"/\", errors_stream=stream)\n    assert rv.status_code == 500\n    assert rv.data\n    err = stream.getvalue()\n    assert \"Exception on / [GET]\" in err\n    assert \"Exception: test\" in err",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "logging",
                "sys",
                "io.StringIO",
                "pytest",
                "flask.logging.default_handler",
                "flask.logging.has_level_handler",
                "flask.logging.wsgi_errors_stream"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.status_code == 500",
                "assert rv.data",
                "assert 'Exception on / [GET]' in err",
                "assert 'Exception: test' in err"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_app_cli_has_app_context",
            "module": "test_cli",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 289,
            "end_line_number": 304,
            "source_code": "def test_app_cli_has_app_context(app, runner):\n    def _param_cb(ctx, param, value):\n        # current_app should be available in parameter callbacks\n        return bool(current_app)\n\n    @app.cli.command()\n    @click.argument(\"value\", callback=_param_cb)\n    def check(value):\n        app = click.get_current_context().obj.load_app()\n        # the loaded app should be the same as current_app\n        same_app = current_app._get_current_object() is app\n        return same_app, value\n\n    cli = FlaskGroup(create_app=lambda: app)\n    result = runner.invoke(cli, [\"check\", \"x\"], standalone_mode=False)\n    assert result.return_value == (True, True)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "runner"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert result.return_value == (True, True)"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "runner.invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `invoke` method is a pytest fixture that creates a callable for invoking CLI commands on a Flask application using the `CliRunner`. It allows for testing of command-line interface (CLI) commands defined in the Flask application.\n\n**How It Works**:  \nThe `invoke` method uses the `FlaskGroup` class to create a CLI group associated with the provided Flask application. It leverages `functools.partial` to bind the `runner.invoke` method to this CLI group, enabling the execution of CLI commands with the specified application context. When called, it returns a function that can be used to run CLI commands and capture their output, making it easier to test various command-line functionalities of the Flask app."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_with_appcontext",
            "module": "test_cli",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 307,
            "end_line_number": 317,
            "source_code": "def test_with_appcontext(runner):\n    @click.command()\n    @with_appcontext\n    def testcmd():\n        click.echo(current_app.name)\n\n    obj = ScriptInfo(create_app=lambda: Flask(\"testapp\"))\n\n    result = runner.invoke(testcmd, obj=obj)\n    assert result.exit_code == 0\n    assert result.output == \"testapp\\n\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "runner"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert result.exit_code == 0",
                "assert result.output == 'testapp\\n'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "runner.invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `invoke` method is a pytest fixture that facilitates the testing of Flask CLI commands by creating a callable that can execute these commands within the context of a specified Flask application.\n\n**How It Works**:  \nThe `invoke` method uses the `FlaskGroup` class to create a CLI group associated with the provided Flask application. It leverages `functools.partial` to bind the `runner.invoke` method to this CLI group, allowing for easy invocation of CLI commands during tests. When called, it executes the specified command and returns the result, which includes the command's output and exit status, enabling assertions in test cases."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_appgroup_app_context",
            "module": "test_cli",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 320,
            "end_line_number": 345,
            "source_code": "def test_appgroup_app_context(runner):\n    @click.group(cls=AppGroup)\n    def cli():\n        pass\n\n    @cli.command()\n    def test():\n        click.echo(current_app.name)\n\n    @cli.group()\n    def subgroup():\n        pass\n\n    @subgroup.command()\n    def test2():\n        click.echo(current_app.name)\n\n    obj = ScriptInfo(create_app=lambda: Flask(\"testappgroup\"))\n\n    result = runner.invoke(cli, [\"test\"], obj=obj)\n    assert result.exit_code == 0\n    assert result.output == \"testappgroup\\n\"\n\n    result = runner.invoke(cli, [\"subgroup\", \"test2\"], obj=obj)\n    assert result.exit_code == 0\n    assert result.output == \"testappgroup\\n\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "runner"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert result.exit_code == 0",
                "assert result.output == 'testappgroup\\n'",
                "assert result.exit_code == 0",
                "assert result.output == 'testappgroup\\n'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "runner.invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `invoke` method is a pytest fixture that facilitates the testing of Flask CLI commands by creating a command-line interface (CLI) group associated with a Flask application. It allows developers to easily invoke CLI commands in their tests.\n\n**How It Works**:  \nThe `invoke` method uses the `FlaskGroup` class to create a CLI instance for the provided Flask application. It leverages `functools.partial` to bind the `runner.invoke` method to this CLI instance, enabling the execution of CLI commands with the specified application context. When called, it returns a callable that can be used in tests to simulate command-line interactions with the Flask app, capturing the output and exit status for assertions."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_appgroup_app_context",
            "module": "test_cli",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 320,
            "end_line_number": 345,
            "source_code": "def test_appgroup_app_context(runner):\n    @click.group(cls=AppGroup)\n    def cli():\n        pass\n\n    @cli.command()\n    def test():\n        click.echo(current_app.name)\n\n    @cli.group()\n    def subgroup():\n        pass\n\n    @subgroup.command()\n    def test2():\n        click.echo(current_app.name)\n\n    obj = ScriptInfo(create_app=lambda: Flask(\"testappgroup\"))\n\n    result = runner.invoke(cli, [\"test\"], obj=obj)\n    assert result.exit_code == 0\n    assert result.output == \"testappgroup\\n\"\n\n    result = runner.invoke(cli, [\"subgroup\", \"test2\"], obj=obj)\n    assert result.exit_code == 0\n    assert result.output == \"testappgroup\\n\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "runner"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert result.exit_code == 0",
                "assert result.output == 'testappgroup\\n'",
                "assert result.exit_code == 0",
                "assert result.output == 'testappgroup\\n'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "runner.invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `invoke` method is a pytest fixture that facilitates the testing of Flask CLI commands by creating a callable that can execute these commands within the context of a specified Flask application.\n\n**How It Works**:  \nThe `invoke` method uses the `FlaskGroup` class to create a CLI group associated with the provided Flask application. It leverages `functools.partial` to bind the `runner.invoke` method to this CLI group, allowing for easy invocation of CLI commands during tests. When called, it executes the specified command and returns the result, which includes the command's output and exit status, enabling assertions in test cases."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_flaskgroup_app_context",
            "module": "test_cli",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 348,
            "end_line_number": 362,
            "source_code": "def test_flaskgroup_app_context(runner):\n    def create_app():\n        return Flask(\"flaskgroup\")\n\n    @click.group(cls=FlaskGroup, create_app=create_app)\n    def cli(**params):\n        pass\n\n    @cli.command()\n    def test():\n        click.echo(current_app.name)\n\n    result = runner.invoke(cli, [\"test\"])\n    assert result.exit_code == 0\n    assert result.output == \"flaskgroup\\n\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "runner"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert result.exit_code == 0",
                "assert result.output == 'flaskgroup\\n'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "runner.invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `invoke` method is a pytest fixture that facilitates the testing of Flask CLI commands by creating a command-line interface (CLI) group associated with a Flask application. It allows developers to easily invoke CLI commands in their tests.\n\n**How It Works**:  \nThe `invoke` method uses the `FlaskGroup` class to create a CLI instance for the provided Flask application. It leverages `functools.partial` to bind the `runner.invoke` method to this CLI instance, enabling the execution of CLI commands with the specified application context. When called, it returns a callable that can be used in tests to simulate command-line interactions, capturing the output and exit status of the commands executed. This setup is particularly useful for testing various CLI functionalities, such as command options and output formatting."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_flaskgroup_debug",
            "module": "test_cli",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 366,
            "end_line_number": 382,
            "source_code": "def test_flaskgroup_debug(runner, set_debug_flag):\n    def create_app():\n        app = Flask(\"flaskgroup\")\n        app.debug = True\n        return app\n\n    @click.group(cls=FlaskGroup, create_app=create_app, set_debug_flag=set_debug_flag)\n    def cli(**params):\n        pass\n\n    @cli.command()\n    def test():\n        click.echo(str(current_app.debug))\n\n    result = runner.invoke(cli, [\"test\"])\n    assert result.exit_code == 0\n    assert result.output == f\"{not set_debug_flag}\\n\"",
            "docstring": null,
            "decorators": [
                "pytest.mark.parametrize('set_debug_flag', (True, False))"
            ],
            "arguments": [
                "runner",
                "set_debug_flag"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert result.exit_code == 0",
                "assert result.output == f'{not set_debug_flag}\\n'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "runner.invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `invoke` method is a pytest fixture that facilitates the testing of Flask CLI commands by creating a command-line interface (CLI) group associated with a Flask application. It allows developers to easily invoke CLI commands in their tests.\n\n**How It Works**:  \nThe `invoke` method uses the `FlaskGroup` class to create a CLI instance for the provided Flask application. It leverages `functools.partial` to bind the `runner.invoke` method to this CLI instance, enabling the execution of CLI commands with the specified application context. When called, it returns a callable that can be used in tests to simulate command-line interactions, capturing the output and exit status of the commands executed. This setup is particularly useful for testing various CLI functionalities, such as command options and output formatting."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_flaskgroup_nested",
            "module": "test_cli",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 385,
            "end_line_number": 395,
            "source_code": "def test_flaskgroup_nested(app, runner):\n    cli = click.Group(\"cli\")\n    flask_group = FlaskGroup(name=\"flask\", create_app=lambda: app)\n    cli.add_command(flask_group)\n\n    @flask_group.command()\n    def show():\n        click.echo(current_app.name)\n\n    result = runner.invoke(cli, [\"flask\", \"show\"])\n    assert result.output == \"flask_test\\n\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "runner"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert result.output == 'flask_test\\n'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "runner.invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `invoke` method is a pytest fixture that facilitates the testing of Flask CLI commands by creating a callable that can simulate command-line interactions with a Flask application.\n\n**How It Works**:  \nThe `invoke` method uses the `FlaskGroup` class to create a CLI instance for the provided Flask application. It leverages `functools.partial` to bind the `runner.invoke` method to this CLI instance, allowing tests to easily invoke CLI commands as if they were run from the command line. This setup enables the execution of commands and the capture of their output and exit codes, which can be asserted in test cases."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_no_command_echo_loading_error",
            "module": "test_cli",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 398,
            "end_line_number": 410,
            "source_code": "def test_no_command_echo_loading_error():\n    from flask.cli import cli\n\n    try:\n        runner = CliRunner(mix_stderr=False)\n    except (DeprecationWarning, TypeError):\n        # Click >= 8.2\n        runner = CliRunner()\n\n    result = runner.invoke(cli, [\"missing\"])\n    assert result.exit_code == 2\n    assert \"FLASK_APP\" in result.stderr\n    assert \"Usage:\" in result.stderr",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert result.exit_code == 2",
                "assert 'FLASK_APP' in result.stderr",
                "assert 'Usage:' in result.stderr"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "runner.invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `invoke` method is a pytest fixture that facilitates the testing of Flask CLI commands by creating a callable that can execute these commands within the context of a specified Flask application.\n\n**How It Works**:  \nThe `invoke` method uses the `FlaskGroup` class to create a CLI group associated with the provided Flask application. It leverages `functools.partial` to bind the `runner.invoke` method to this CLI group, allowing for easy invocation of CLI commands during tests. When called, it executes the specified command and returns the result, which includes the command's output and exit status, enabling assertions in test cases."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_help_echo_loading_error",
            "module": "test_cli",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 413,
            "end_line_number": 425,
            "source_code": "def test_help_echo_loading_error():\n    from flask.cli import cli\n\n    try:\n        runner = CliRunner(mix_stderr=False)\n    except (DeprecationWarning, TypeError):\n        # Click >= 8.2\n        runner = CliRunner()\n\n    result = runner.invoke(cli, [\"--help\"])\n    assert result.exit_code == 0\n    assert \"FLASK_APP\" in result.stderr\n    assert \"Usage:\" in result.stdout",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert result.exit_code == 0",
                "assert 'FLASK_APP' in result.stderr",
                "assert 'Usage:' in result.stdout"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "runner.invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `invoke` method is a pytest fixture that facilitates the testing of Flask CLI commands by creating a command-line interface (CLI) group associated with a Flask application. It allows developers to easily invoke CLI commands in their tests.\n\n**How It Works**:  \nThe `invoke` method uses the `FlaskGroup` class to create a CLI instance for the provided Flask application. It leverages `functools.partial` to bind the `runner.invoke` method to this CLI instance, enabling the execution of CLI commands with the specified application context. When called, it returns a callable that can be used to run CLI commands and capture their output, making it straightforward to test various command-line functionalities of the Flask app."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_help_echo_exception",
            "module": "test_cli",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 428,
            "end_line_number": 443,
            "source_code": "def test_help_echo_exception():\n    def create_app():\n        raise Exception(\"oh no\")\n\n    cli = FlaskGroup(create_app=create_app)\n\n    try:\n        runner = CliRunner(mix_stderr=False)\n    except (DeprecationWarning, TypeError):\n        # Click >= 8.2\n        runner = CliRunner()\n\n    result = runner.invoke(cli, [\"--help\"])\n    assert result.exit_code == 0\n    assert \"Exception: oh no\" in result.stderr\n    assert \"Usage:\" in result.stdout",
            "docstring": null,
            "decorators": [],
            "arguments": [],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert result.exit_code == 0",
                "assert 'Exception: oh no' in result.stderr",
                "assert 'Usage:' in result.stdout"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "runner.invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `invoke` method is a pytest fixture that facilitates the testing of Flask CLI commands by creating a command-line interface (CLI) group associated with a Flask application. It allows developers to easily invoke CLI commands in their tests.\n\n**How It Works**:  \nThe `invoke` method uses the `FlaskGroup` class to create a CLI instance for the provided Flask application. It leverages `functools.partial` to bind the `runner.invoke` method to this CLI instance, enabling the execution of CLI commands with the specified application context. When called, it returns a callable that can be used in tests to simulate command-line interactions, capturing the output and exit status of the commands executed. This setup is particularly useful for testing various CLI functionalities, such as command options and output formatting."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_simple",
            "module": "test_cli",
            "class_name": "TestRoutes",
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 469,
            "end_line_number": 472,
            "source_code": "def test_simple(self, invoke):\n        result = invoke([\"routes\"])\n        assert result.exit_code == 0\n        self.expect_order([\"aaa_post\", \"static\", \"yyy_get_post\"], result.output)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "invoke"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert result.exit_code == 0"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `invoke` method is a pytest fixture designed to facilitate the testing of Flask command-line interface (CLI) commands. It creates a callable that allows tests to invoke CLI commands with a specified Flask application context.\n\n**How It Works**:\nThe method uses `FlaskGroup`, which is a subclass of `AppGroup` that manages CLI commands for a Flask application. It takes the `app` and `runner` as parameters. Inside the method, a `FlaskGroup` instance is created with a lambda function that returns the provided `app`. The method then returns a partially applied function of `runner.invoke`, which allows tests to easily call CLI commands by passing the command name and any arguments directly. This setup ensures that the CLI commands are executed within the context of the specified Flask application, making it easier to test their behavior."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_simple",
            "module": "test_cli",
            "class_name": "TestRoutes",
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 469,
            "end_line_number": 472,
            "source_code": "def test_simple(self, invoke):\n        result = invoke([\"routes\"])\n        assert result.exit_code == 0\n        self.expect_order([\"aaa_post\", \"static\", \"yyy_get_post\"], result.output)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "invoke"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert result.exit_code == 0"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.expect_order",
                    "body": "def expect_order(self, order, output):\n    for (expect, line) in zip(order, output.splitlines()[2:]):\n        assert line[:len(expect)] == expect",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `expect_order` method is designed to verify that the output of a command matches an expected order of strings, typically used in testing the routes of a Flask application. It checks that each line of the output starts with the corresponding expected string, allowing for a structured comparison of results.\n\n**How It Works**:\nThe method takes two parameters: `order`, a list of expected strings, and `output`, a string containing the actual output (which may include multiple lines). It splits the output into lines, skipping the first two lines (often headers), and then iterates through the expected strings and the corresponding lines of output. For each pair, it asserts that the beginning of the output line matches the expected string. This approach provides clearer error messages in pytest when assertions fail, as it checks for a prefix match rather than using `startswith`."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_sort",
            "module": "test_cli",
            "class_name": "TestRoutes",
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 474,
            "end_line_number": 487,
            "source_code": "def test_sort(self, app, invoke):\n        default_output = invoke([\"routes\"]).output\n        endpoint_output = invoke([\"routes\", \"-s\", \"endpoint\"]).output\n        assert default_output == endpoint_output\n        self.expect_order(\n            [\"static\", \"yyy_get_post\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"methods\"]).output,\n        )\n        self.expect_order(\n            [\"yyy_get_post\", \"static\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"rule\"]).output,\n        )\n        match_order = [r.endpoint for r in app.url_map.iter_rules()]\n        self.expect_order(match_order, invoke([\"routes\", \"-s\", \"match\"]).output)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "invoke"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert default_output == endpoint_output"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.expect_order",
                    "body": "def expect_order(self, order, output):\n    for (expect, line) in zip(order, output.splitlines()[2:]):\n        assert line[:len(expect)] == expect",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `expect_order` method is designed to verify that the output of a command matches an expected order of strings, typically used in testing the routes of a Flask application. It checks that each line of the output starts with the corresponding expected string, allowing for a structured comparison of results.\n\n**How It Works**:\nThe method takes two parameters: `order`, a list of expected strings, and `output`, a string containing the actual output (which may include headers). It splits the output into lines, skipping the first two lines (usually headers), and then iterates through the expected strings and the corresponding lines of output. For each pair, it asserts that the beginning of the output line matches the expected string. This approach provides clearer error messages in pytest when assertions fail, as it checks for a prefix match rather than using `startswith`."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_sort",
            "module": "test_cli",
            "class_name": "TestRoutes",
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 474,
            "end_line_number": 487,
            "source_code": "def test_sort(self, app, invoke):\n        default_output = invoke([\"routes\"]).output\n        endpoint_output = invoke([\"routes\", \"-s\", \"endpoint\"]).output\n        assert default_output == endpoint_output\n        self.expect_order(\n            [\"static\", \"yyy_get_post\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"methods\"]).output,\n        )\n        self.expect_order(\n            [\"yyy_get_post\", \"static\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"rule\"]).output,\n        )\n        match_order = [r.endpoint for r in app.url_map.iter_rules()]\n        self.expect_order(match_order, invoke([\"routes\", \"-s\", \"match\"]).output)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "invoke"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert default_output == endpoint_output"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.expect_order",
                    "body": "def expect_order(self, order, output):\n    for (expect, line) in zip(order, output.splitlines()[2:]):\n        assert line[:len(expect)] == expect",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `expect_order` method is designed to verify that the output of a command matches an expected order of strings, typically used in testing the routes of a Flask application. It checks that each line of the output starts with the corresponding expected string, allowing for a structured comparison of results.\n\n**How It Works**:\nThe method takes two parameters: `order`, a list of expected strings, and `output`, a string containing the actual output (which may include multiple lines). It splits the output into lines, skipping the first two lines (often headers), and then iterates through the expected strings and the corresponding lines of output. For each pair, it asserts that the beginning of the output line matches the expected string. This approach provides clearer error messages in pytest when assertions fail, as it checks for a prefix match rather than using `startswith`."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_sort",
            "module": "test_cli",
            "class_name": "TestRoutes",
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 474,
            "end_line_number": 487,
            "source_code": "def test_sort(self, app, invoke):\n        default_output = invoke([\"routes\"]).output\n        endpoint_output = invoke([\"routes\", \"-s\", \"endpoint\"]).output\n        assert default_output == endpoint_output\n        self.expect_order(\n            [\"static\", \"yyy_get_post\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"methods\"]).output,\n        )\n        self.expect_order(\n            [\"yyy_get_post\", \"static\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"rule\"]).output,\n        )\n        match_order = [r.endpoint for r in app.url_map.iter_rules()]\n        self.expect_order(match_order, invoke([\"routes\", \"-s\", \"match\"]).output)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "invoke"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert default_output == endpoint_output"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.expect_order",
                    "body": "def expect_order(self, order, output):\n    for (expect, line) in zip(order, output.splitlines()[2:]):\n        assert line[:len(expect)] == expect",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `expect_order` method is designed to verify that the output of a command matches an expected order of strings, typically used in testing routes in a Flask application. It checks that each line of the output starts with the corresponding expected string, allowing for a structured comparison of results.\n\n**How It Works**:\nThe method takes two parameters: `order`, a list of expected strings, and `output`, a string containing the actual output (which may include multiple lines). It splits the output into lines, skipping the first two lines (often headers), and then iterates through the expected strings and the corresponding lines of output. For each pair, it asserts that the beginning of the output line matches the expected string. This approach provides clearer error messages in pytest when assertions fail, as it checks for a prefix match rather than using `startswith`."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_sort",
            "module": "test_cli",
            "class_name": "TestRoutes",
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 474,
            "end_line_number": 487,
            "source_code": "def test_sort(self, app, invoke):\n        default_output = invoke([\"routes\"]).output\n        endpoint_output = invoke([\"routes\", \"-s\", \"endpoint\"]).output\n        assert default_output == endpoint_output\n        self.expect_order(\n            [\"static\", \"yyy_get_post\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"methods\"]).output,\n        )\n        self.expect_order(\n            [\"yyy_get_post\", \"static\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"rule\"]).output,\n        )\n        match_order = [r.endpoint for r in app.url_map.iter_rules()]\n        self.expect_order(match_order, invoke([\"routes\", \"-s\", \"match\"]).output)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "invoke"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert default_output == endpoint_output"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `invoke` method is a pytest fixture designed to facilitate the testing of Flask command-line interface (CLI) commands. It creates a callable that allows tests to invoke CLI commands with a specified Flask application context.\n\n**How It Works**:\nThe method uses `FlaskGroup`, which is a subclass of `AppGroup` that manages CLI commands for a Flask application. It takes the `app` and `runner` as parameters. Inside the method, a `FlaskGroup` instance is created with a lambda function that returns the provided `app`. The method then returns a partially applied function of `runner.invoke`, which allows tests to easily call CLI commands by passing the command name and any arguments directly. This setup ensures that the CLI commands are executed within the context of the specified Flask application, making it easier to test their behavior and output."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_sort",
            "module": "test_cli",
            "class_name": "TestRoutes",
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 474,
            "end_line_number": 487,
            "source_code": "def test_sort(self, app, invoke):\n        default_output = invoke([\"routes\"]).output\n        endpoint_output = invoke([\"routes\", \"-s\", \"endpoint\"]).output\n        assert default_output == endpoint_output\n        self.expect_order(\n            [\"static\", \"yyy_get_post\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"methods\"]).output,\n        )\n        self.expect_order(\n            [\"yyy_get_post\", \"static\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"rule\"]).output,\n        )\n        match_order = [r.endpoint for r in app.url_map.iter_rules()]\n        self.expect_order(match_order, invoke([\"routes\", \"-s\", \"match\"]).output)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "invoke"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert default_output == endpoint_output"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `invoke` method is a pytest fixture designed to facilitate the testing of Flask command-line interface (CLI) commands. It creates a callable that allows tests to invoke CLI commands with a specified Flask application context.\n\n**How It Works**:\nThe method uses `FlaskGroup`, which is a subclass of `AppGroup` that manages CLI commands for a Flask application. It takes the `app` and `runner` as parameters. Inside the method, a `FlaskGroup` instance is created with a lambda function that returns the provided `app`. The method then returns a partially applied function of `runner.invoke`, which allows tests to easily call CLI commands by passing the command name and any arguments. This setup ensures that the CLI commands are executed within the context of the specified Flask application, making it easier to test their behavior and output."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_sort",
            "module": "test_cli",
            "class_name": "TestRoutes",
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 474,
            "end_line_number": 487,
            "source_code": "def test_sort(self, app, invoke):\n        default_output = invoke([\"routes\"]).output\n        endpoint_output = invoke([\"routes\", \"-s\", \"endpoint\"]).output\n        assert default_output == endpoint_output\n        self.expect_order(\n            [\"static\", \"yyy_get_post\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"methods\"]).output,\n        )\n        self.expect_order(\n            [\"yyy_get_post\", \"static\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"rule\"]).output,\n        )\n        match_order = [r.endpoint for r in app.url_map.iter_rules()]\n        self.expect_order(match_order, invoke([\"routes\", \"-s\", \"match\"]).output)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "invoke"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert default_output == endpoint_output"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `invoke` method is a pytest fixture designed to facilitate the testing of Flask command-line interface (CLI) commands. It creates a callable that allows tests to invoke CLI commands with a specified Flask application context.\n\n**How It Works**:\nThe method uses `FlaskGroup`, which is a subclass of `AppGroup` that manages CLI commands for a Flask application. It takes a Flask app instance and a CLI runner as parameters. The `invoke` method returns a partially applied function (using `functools.partial`) that binds the CLI instance to the runner's `invoke` method. This allows tests to easily execute CLI commands while ensuring the correct application context is used, making it straightforward to test various command-line functionalities of the Flask app."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_sort",
            "module": "test_cli",
            "class_name": "TestRoutes",
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 474,
            "end_line_number": 487,
            "source_code": "def test_sort(self, app, invoke):\n        default_output = invoke([\"routes\"]).output\n        endpoint_output = invoke([\"routes\", \"-s\", \"endpoint\"]).output\n        assert default_output == endpoint_output\n        self.expect_order(\n            [\"static\", \"yyy_get_post\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"methods\"]).output,\n        )\n        self.expect_order(\n            [\"yyy_get_post\", \"static\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"rule\"]).output,\n        )\n        match_order = [r.endpoint for r in app.url_map.iter_rules()]\n        self.expect_order(match_order, invoke([\"routes\", \"-s\", \"match\"]).output)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "invoke"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert default_output == endpoint_output"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `invoke` method is a pytest fixture designed to facilitate the testing of Flask command-line interface (CLI) commands. It creates a callable that allows tests to invoke CLI commands with a specified Flask application context.\n\n**How It Works**:\nThe method uses `FlaskGroup`, which is a subclass of `AppGroup` that manages CLI commands for a Flask application. It takes the `app` and `runner` as parameters. Inside the method, a `FlaskGroup` instance is created with a lambda function that returns the provided `app`. The method then returns a partially applied function of `runner.invoke`, which allows tests to easily call CLI commands by passing the command name and any arguments. This setup ensures that the CLI commands are executed within the context of the specified Flask application, making it easier to test their behavior."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_sort",
            "module": "test_cli",
            "class_name": "TestRoutes",
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 474,
            "end_line_number": 487,
            "source_code": "def test_sort(self, app, invoke):\n        default_output = invoke([\"routes\"]).output\n        endpoint_output = invoke([\"routes\", \"-s\", \"endpoint\"]).output\n        assert default_output == endpoint_output\n        self.expect_order(\n            [\"static\", \"yyy_get_post\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"methods\"]).output,\n        )\n        self.expect_order(\n            [\"yyy_get_post\", \"static\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"rule\"]).output,\n        )\n        match_order = [r.endpoint for r in app.url_map.iter_rules()]\n        self.expect_order(match_order, invoke([\"routes\", \"-s\", \"match\"]).output)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "invoke"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert default_output == endpoint_output"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `invoke` method is a pytest fixture designed to facilitate the testing of Flask command-line interface (CLI) commands. It creates a callable that allows tests to invoke CLI commands with a specified Flask application context.\n\n**How It Works**:\nThe method uses `FlaskGroup`, which is a subclass of `AppGroup` that manages CLI commands for a Flask application. It takes the `app` and `runner` as parameters. Inside the method, a `FlaskGroup` instance is created with a lambda function that returns the provided `app`. The method then returns a partially applied function of `runner.invoke`, which allows tests to easily call CLI commands by passing the command name and any arguments directly. This setup ensures that the CLI commands are executed within the context of the specified Flask application, making it easier to test their behavior."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_all_methods",
            "module": "test_cli",
            "class_name": "TestRoutes",
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 489,
            "end_line_number": 493,
            "source_code": "def test_all_methods(self, invoke):\n        output = invoke([\"routes\"]).output\n        assert \"GET, HEAD, OPTIONS, POST\" not in output\n        output = invoke([\"routes\", \"--all-methods\"]).output\n        assert \"GET, HEAD, OPTIONS, POST\" in output",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "invoke"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'GET, HEAD, OPTIONS, POST' not in output",
                "assert 'GET, HEAD, OPTIONS, POST' in output"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `invoke` method is a pytest fixture designed to facilitate the testing of Flask command-line interface (CLI) commands. It creates a callable that allows tests to invoke CLI commands with a specified Flask application context.\n\n**How It Works**:\nThe method uses `FlaskGroup`, which is a subclass of `AppGroup` that manages CLI commands for a Flask application. It takes the `app` and `runner` as parameters. Inside the method, a `FlaskGroup` instance is created with a lambda function that returns the provided `app`. The `partial` function from the `functools` module is then used to bind the `runner.invoke` method to this `FlaskGroup` instance, allowing for easy invocation of CLI commands during tests. This setup ensures that the CLI commands can be executed in the context of the specified Flask application, making it easier to test their behavior and output."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_all_methods",
            "module": "test_cli",
            "class_name": "TestRoutes",
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 489,
            "end_line_number": 493,
            "source_code": "def test_all_methods(self, invoke):\n        output = invoke([\"routes\"]).output\n        assert \"GET, HEAD, OPTIONS, POST\" not in output\n        output = invoke([\"routes\", \"--all-methods\"]).output\n        assert \"GET, HEAD, OPTIONS, POST\" in output",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "invoke"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'GET, HEAD, OPTIONS, POST' not in output",
                "assert 'GET, HEAD, OPTIONS, POST' in output"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `invoke` method is a pytest fixture designed to facilitate the testing of Flask command-line interface (CLI) commands. It creates a callable that allows tests to invoke CLI commands with a specified Flask application context.\n\n**How It Works**:\nThe method uses `FlaskGroup`, which is a subclass of `AppGroup` that manages CLI commands for a Flask application. It takes a Flask app instance and a CLI runner as parameters. The `invoke` method returns a partially applied function (using `functools.partial`) that binds the CLI runner to the `FlaskGroup` instance. This allows tests to easily execute CLI commands by calling the returned function with the desired command and arguments, ensuring that the appropriate application context is used during the command execution."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_no_routes",
            "module": "test_cli",
            "class_name": "TestRoutes",
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 495,
            "end_line_number": 500,
            "source_code": "def test_no_routes(self, runner):\n        app = Flask(__name__, static_folder=None)\n        cli = FlaskGroup(create_app=lambda: app)\n        result = runner.invoke(cli, [\"routes\"])\n        assert result.exit_code == 0\n        assert \"No routes were registered.\" in result.output",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "runner"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert result.exit_code == 0",
                "assert 'No routes were registered.' in result.output"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "runner.invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `invoke` method is a pytest fixture that facilitates the testing of Flask CLI commands by creating a command-line interface (CLI) group associated with a Flask application. It allows developers to easily invoke CLI commands in their tests.\n\n**How It Works**:  \nThe `invoke` method uses the `FlaskGroup` class to create a CLI instance for the provided Flask application. It leverages `functools.partial` to bind the `runner.invoke` method to this CLI instance, enabling the execution of CLI commands with the specified application context. When called, it returns a callable that can be used in tests to simulate command-line interactions, capturing the output and exit status of the commands executed. This setup is particularly useful for testing various CLI functionalities, such as command options and output formatting."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_subdomain",
            "module": "test_cli",
            "class_name": "TestRoutes",
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 502,
            "end_line_number": 509,
            "source_code": "def test_subdomain(self, runner):\n        app = Flask(__name__, static_folder=None)\n        app.add_url_rule(\"/a\", subdomain=\"a\", endpoint=\"a\")\n        app.add_url_rule(\"/b\", subdomain=\"b\", endpoint=\"b\")\n        cli = FlaskGroup(create_app=lambda: app)\n        result = runner.invoke(cli, [\"routes\"])\n        assert result.exit_code == 0\n        assert \"Subdomain\" in result.output",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "runner"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert result.exit_code == 0",
                "assert 'Subdomain' in result.output"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "runner.invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `invoke` method is a pytest fixture that facilitates the testing of Flask CLI commands by creating a callable that can execute these commands within the context of a specified Flask application.\n\n**How It Works**:  \nThe `invoke` method uses the `FlaskGroup` class to create a command-line interface (CLI) for the provided Flask application. It leverages `partial` from the `functools` module to bind the `runner.invoke` method to the `cli` instance, allowing for easy invocation of CLI commands during tests. When called, it returns a function that can be used to run CLI commands, capturing their output and exit status, which can then be asserted in test cases. This setup enables developers to test various CLI functionalities in a controlled environment."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_host",
            "module": "test_cli",
            "class_name": "TestRoutes",
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 511,
            "end_line_number": 518,
            "source_code": "def test_host(self, runner):\n        app = Flask(__name__, static_folder=None, host_matching=True)\n        app.add_url_rule(\"/a\", host=\"a\", endpoint=\"a\")\n        app.add_url_rule(\"/b\", host=\"b\", endpoint=\"b\")\n        cli = FlaskGroup(create_app=lambda: app)\n        result = runner.invoke(cli, [\"routes\"])\n        assert result.exit_code == 0\n        assert \"Host\" in result.output",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "runner"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert result.exit_code == 0",
                "assert 'Host' in result.output"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "runner.invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `invoke` method is a pytest fixture that creates a callable for invoking CLI commands on a Flask application using the `CliRunner`. It allows for testing of command-line interface (CLI) commands defined in the Flask app.\n\n**How It Works**:  \nThe `invoke` method uses the `FlaskGroup` class to create a CLI group associated with the provided Flask application. It leverages `functools.partial` to bind the `runner.invoke` method to this CLI group, enabling the execution of CLI commands with the specified app context. When called, it returns a function that can be used to run CLI commands and capture their output, making it easier to test various command-line functionalities of the Flask application."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_disable_dotenv_from_env",
            "module": "test_cli",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 577,
            "end_line_number": 581,
            "source_code": "def test_disable_dotenv_from_env(monkeypatch, runner):\n    monkeypatch.chdir(test_path)\n    monkeypatch.setitem(os.environ, \"FLASK_SKIP_DOTENV\", \"1\")\n    runner.invoke(FlaskGroup())\n    assert \"FOO\" not in os.environ",
            "docstring": null,
            "decorators": [
                "need_dotenv"
            ],
            "arguments": [
                "monkeypatch",
                "runner"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'FOO' not in os.environ"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "runner.invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `invoke` method is a pytest fixture that facilitates the testing of Flask CLI commands by creating a command-line interface (CLI) group associated with a Flask application. It allows developers to easily invoke CLI commands in their tests.\n\n**How It Works**:  \nThe `invoke` method uses the `FlaskGroup` class to create a CLI instance for the provided Flask application. It leverages `functools.partial` to bind the `runner.invoke` method to this CLI instance, enabling the execution of CLI commands with the specified application context. When called, it returns a callable that can be used in tests to simulate command-line interactions, capturing the output and exit status of the commands executed. This setup is particularly useful for testing various CLI functionalities, such as command options and output formatting."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_cli_blueprints",
            "module": "test_cli",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 648,
            "end_line_number": 688,
            "source_code": "def test_cli_blueprints(app):\n    \"\"\"Test blueprint commands register correctly to the application\"\"\"\n    custom = Blueprint(\"custom\", __name__, cli_group=\"customized\")\n    nested = Blueprint(\"nested\", __name__)\n    merged = Blueprint(\"merged\", __name__, cli_group=None)\n    late = Blueprint(\"late\", __name__)\n\n    @custom.cli.command(\"custom\")\n    def custom_command():\n        click.echo(\"custom_result\")\n\n    @nested.cli.command(\"nested\")\n    def nested_command():\n        click.echo(\"nested_result\")\n\n    @merged.cli.command(\"merged\")\n    def merged_command():\n        click.echo(\"merged_result\")\n\n    @late.cli.command(\"late\")\n    def late_command():\n        click.echo(\"late_result\")\n\n    app.register_blueprint(custom)\n    app.register_blueprint(nested)\n    app.register_blueprint(merged)\n    app.register_blueprint(late, cli_group=\"late_registration\")\n\n    app_runner = app.test_cli_runner()\n\n    result = app_runner.invoke(args=[\"customized\", \"custom\"])\n    assert \"custom_result\" in result.output\n\n    result = app_runner.invoke(args=[\"nested\", \"nested\"])\n    assert \"nested_result\" in result.output\n\n    result = app_runner.invoke(args=[\"merged\"])\n    assert \"merged_result\" in result.output\n\n    result = app_runner.invoke(args=[\"late_registration\", \"late\"])\n    assert \"late_result\" in result.output",
            "docstring": "Test blueprint commands register correctly to the application",
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'custom_result' in result.output",
                "assert 'nested_result' in result.output",
                "assert 'merged_result' in result.output",
                "assert 'late_result' in result.output"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "app_runner.invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `invoke` method is a pytest fixture that facilitates the testing of Flask command-line interface (CLI) commands by creating a callable that can invoke these commands within a test context.\n\n**How It Works**:\nThe method uses `FlaskGroup`, which is a subclass of `AppGroup` designed to manage CLI commands for a Flask application. It takes an `app` and a `runner` as parameters. Inside the method, a `FlaskGroup` instance is created with a lambda function that returns the provided `app`. The `partial` function from the `functools` module is then used to bind the `runner.invoke` method to this `FlaskGroup` instance, allowing tests to easily invoke CLI commands by calling the returned function. This setup ensures that the application context is correctly managed during the command execution, making it suitable for testing CLI commands in a Flask application."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_cli_blueprints",
            "module": "test_cli",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 648,
            "end_line_number": 688,
            "source_code": "def test_cli_blueprints(app):\n    \"\"\"Test blueprint commands register correctly to the application\"\"\"\n    custom = Blueprint(\"custom\", __name__, cli_group=\"customized\")\n    nested = Blueprint(\"nested\", __name__)\n    merged = Blueprint(\"merged\", __name__, cli_group=None)\n    late = Blueprint(\"late\", __name__)\n\n    @custom.cli.command(\"custom\")\n    def custom_command():\n        click.echo(\"custom_result\")\n\n    @nested.cli.command(\"nested\")\n    def nested_command():\n        click.echo(\"nested_result\")\n\n    @merged.cli.command(\"merged\")\n    def merged_command():\n        click.echo(\"merged_result\")\n\n    @late.cli.command(\"late\")\n    def late_command():\n        click.echo(\"late_result\")\n\n    app.register_blueprint(custom)\n    app.register_blueprint(nested)\n    app.register_blueprint(merged)\n    app.register_blueprint(late, cli_group=\"late_registration\")\n\n    app_runner = app.test_cli_runner()\n\n    result = app_runner.invoke(args=[\"customized\", \"custom\"])\n    assert \"custom_result\" in result.output\n\n    result = app_runner.invoke(args=[\"nested\", \"nested\"])\n    assert \"nested_result\" in result.output\n\n    result = app_runner.invoke(args=[\"merged\"])\n    assert \"merged_result\" in result.output\n\n    result = app_runner.invoke(args=[\"late_registration\", \"late\"])\n    assert \"late_result\" in result.output",
            "docstring": "Test blueprint commands register correctly to the application",
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'custom_result' in result.output",
                "assert 'nested_result' in result.output",
                "assert 'merged_result' in result.output",
                "assert 'late_result' in result.output"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "app_runner.invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `invoke` method is a pytest fixture that facilitates the testing of Flask command-line interface (CLI) commands by creating a callable that can invoke these commands within a test context.\n\n**How It Works**:\nThe method uses `FlaskGroup`, which is a subclass of `AppGroup` designed to manage Flask CLI commands. It takes an `app` and a `runner` as parameters. Inside the method, a `FlaskGroup` instance is created with a lambda function that returns the provided `app`. The `partial` function from the `functools` module is then used to bind the `runner.invoke` method to this `FlaskGroup` instance, allowing tests to easily invoke CLI commands by calling the returned function. This setup ensures that the application context is correctly managed during the command execution, making it suitable for testing CLI commands in a Flask application."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_cli_blueprints",
            "module": "test_cli",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 648,
            "end_line_number": 688,
            "source_code": "def test_cli_blueprints(app):\n    \"\"\"Test blueprint commands register correctly to the application\"\"\"\n    custom = Blueprint(\"custom\", __name__, cli_group=\"customized\")\n    nested = Blueprint(\"nested\", __name__)\n    merged = Blueprint(\"merged\", __name__, cli_group=None)\n    late = Blueprint(\"late\", __name__)\n\n    @custom.cli.command(\"custom\")\n    def custom_command():\n        click.echo(\"custom_result\")\n\n    @nested.cli.command(\"nested\")\n    def nested_command():\n        click.echo(\"nested_result\")\n\n    @merged.cli.command(\"merged\")\n    def merged_command():\n        click.echo(\"merged_result\")\n\n    @late.cli.command(\"late\")\n    def late_command():\n        click.echo(\"late_result\")\n\n    app.register_blueprint(custom)\n    app.register_blueprint(nested)\n    app.register_blueprint(merged)\n    app.register_blueprint(late, cli_group=\"late_registration\")\n\n    app_runner = app.test_cli_runner()\n\n    result = app_runner.invoke(args=[\"customized\", \"custom\"])\n    assert \"custom_result\" in result.output\n\n    result = app_runner.invoke(args=[\"nested\", \"nested\"])\n    assert \"nested_result\" in result.output\n\n    result = app_runner.invoke(args=[\"merged\"])\n    assert \"merged_result\" in result.output\n\n    result = app_runner.invoke(args=[\"late_registration\", \"late\"])\n    assert \"late_result\" in result.output",
            "docstring": "Test blueprint commands register correctly to the application",
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'custom_result' in result.output",
                "assert 'nested_result' in result.output",
                "assert 'merged_result' in result.output",
                "assert 'late_result' in result.output"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "app_runner.invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `invoke` method is a pytest fixture that facilitates the testing of Flask command-line interface (CLI) commands by creating a callable that can invoke these commands within a test context.\n\n**How It Works**:\nThe method uses `FlaskGroup`, which is a subclass of `AppGroup` designed to manage Flask CLI commands. It takes an `app` and a `runner` as parameters. Inside the method, a `FlaskGroup` instance is created with a lambda function that returns the provided `app`. The `partial` function from the `functools` module is then used to bind the `runner.invoke` method to this `FlaskGroup` instance, allowing tests to easily invoke CLI commands associated with the Flask application. This setup enables developers to write tests that simulate command-line interactions with their Flask apps."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_cli_blueprints",
            "module": "test_cli",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 648,
            "end_line_number": 688,
            "source_code": "def test_cli_blueprints(app):\n    \"\"\"Test blueprint commands register correctly to the application\"\"\"\n    custom = Blueprint(\"custom\", __name__, cli_group=\"customized\")\n    nested = Blueprint(\"nested\", __name__)\n    merged = Blueprint(\"merged\", __name__, cli_group=None)\n    late = Blueprint(\"late\", __name__)\n\n    @custom.cli.command(\"custom\")\n    def custom_command():\n        click.echo(\"custom_result\")\n\n    @nested.cli.command(\"nested\")\n    def nested_command():\n        click.echo(\"nested_result\")\n\n    @merged.cli.command(\"merged\")\n    def merged_command():\n        click.echo(\"merged_result\")\n\n    @late.cli.command(\"late\")\n    def late_command():\n        click.echo(\"late_result\")\n\n    app.register_blueprint(custom)\n    app.register_blueprint(nested)\n    app.register_blueprint(merged)\n    app.register_blueprint(late, cli_group=\"late_registration\")\n\n    app_runner = app.test_cli_runner()\n\n    result = app_runner.invoke(args=[\"customized\", \"custom\"])\n    assert \"custom_result\" in result.output\n\n    result = app_runner.invoke(args=[\"nested\", \"nested\"])\n    assert \"nested_result\" in result.output\n\n    result = app_runner.invoke(args=[\"merged\"])\n    assert \"merged_result\" in result.output\n\n    result = app_runner.invoke(args=[\"late_registration\", \"late\"])\n    assert \"late_result\" in result.output",
            "docstring": "Test blueprint commands register correctly to the application",
            "decorators": [],
            "arguments": [
                "app"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'custom_result' in result.output",
                "assert 'nested_result' in result.output",
                "assert 'merged_result' in result.output",
                "assert 'late_result' in result.output"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "app_runner.invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `invoke` method is a pytest fixture that facilitates the testing of Flask command-line interface (CLI) commands by creating a callable that can invoke these commands within a test context.\n\n**How It Works**:\nThe method uses `FlaskGroup`, which is a subclass of `AppGroup` designed to manage Flask CLI commands. It takes an `app` and a `runner` as parameters. The `runner` is an instance of `CliRunner`, which provides utilities for testing CLI applications. The `invoke` method creates a partial function that binds the `runner.invoke` method to a new `FlaskGroup` instance initialized with the provided `app`. This allows tests to easily call CLI commands as if they were executed in the command line, capturing the output and exit status for assertions."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_simple",
            "module": "test_cli",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 469,
            "end_line_number": 472,
            "source_code": "def test_simple(self, invoke):\n        result = invoke([\"routes\"])\n        assert result.exit_code == 0\n        self.expect_order([\"aaa_post\", \"static\", \"yyy_get_post\"], result.output)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "invoke"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert result.exit_code == 0"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `invoke` method is a pytest fixture designed to facilitate the testing of Flask command-line interface (CLI) commands. It creates a callable that allows tests to invoke CLI commands with a specified Flask application context.\n\n**How It Works**:\nThe method uses `FlaskGroup`, which is a subclass of `AppGroup` that manages CLI commands for a Flask application. It takes a Flask app instance and a CLI runner as parameters. The `invoke` method returns a partially applied function (using `functools.partial`) that binds the CLI instance to the runner's `invoke` method. This allows tests to easily execute CLI commands while ensuring the correct application context is used, making it straightforward to test various command-line functionalities of the Flask app."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_simple",
            "module": "test_cli",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 469,
            "end_line_number": 472,
            "source_code": "def test_simple(self, invoke):\n        result = invoke([\"routes\"])\n        assert result.exit_code == 0\n        self.expect_order([\"aaa_post\", \"static\", \"yyy_get_post\"], result.output)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "invoke"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert result.exit_code == 0"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.expect_order",
                    "body": "def expect_order(self, order, output):\n    for (expect, line) in zip(order, output.splitlines()[2:]):\n        assert line[:len(expect)] == expect",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `expect_order` method is designed to verify that the output of a command matches an expected order of strings, specifically by checking that each line of the output starts with the corresponding expected string from a provided list.\n\n**How It Works**:\nThe method takes two parameters: `order`, a list of expected strings, and `output`, a string containing the actual output (which may include multiple lines). It splits the output into lines, skipping the first two lines (presumably headers), and then iterates through the expected strings and the corresponding lines of output. For each pair, it asserts that the beginning of the output line matches the expected string, ensuring that the output is in the correct order. This approach provides clearer error messages in pytest when assertions fail, as it checks for a substring match rather than using `startswith`."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_sort",
            "module": "test_cli",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 474,
            "end_line_number": 487,
            "source_code": "def test_sort(self, app, invoke):\n        default_output = invoke([\"routes\"]).output\n        endpoint_output = invoke([\"routes\", \"-s\", \"endpoint\"]).output\n        assert default_output == endpoint_output\n        self.expect_order(\n            [\"static\", \"yyy_get_post\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"methods\"]).output,\n        )\n        self.expect_order(\n            [\"yyy_get_post\", \"static\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"rule\"]).output,\n        )\n        match_order = [r.endpoint for r in app.url_map.iter_rules()]\n        self.expect_order(match_order, invoke([\"routes\", \"-s\", \"match\"]).output)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "invoke"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert default_output == endpoint_output"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.expect_order",
                    "body": "def expect_order(self, order, output):\n    for (expect, line) in zip(order, output.splitlines()[2:]):\n        assert line[:len(expect)] == expect",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `expect_order` method is designed to verify that the output of a command matches an expected order of strings, typically used in testing the routes of a Flask application. It checks that each line of the output starts with the corresponding expected string, allowing for a structured comparison of results.\n\n**How It Works**:\nThe method takes two parameters: `order`, a list of expected strings, and `output`, a string containing the actual output (usually from a command). It splits the output into lines, skipping the first two lines (often headers), and then iterates through the expected strings and the corresponding lines of output. For each pair, it asserts that the beginning of the output line matches the expected string. This approach provides clearer error messages in pytest when the assertion fails, as it checks for a prefix match rather than using `startswith`."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_sort",
            "module": "test_cli",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 474,
            "end_line_number": 487,
            "source_code": "def test_sort(self, app, invoke):\n        default_output = invoke([\"routes\"]).output\n        endpoint_output = invoke([\"routes\", \"-s\", \"endpoint\"]).output\n        assert default_output == endpoint_output\n        self.expect_order(\n            [\"static\", \"yyy_get_post\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"methods\"]).output,\n        )\n        self.expect_order(\n            [\"yyy_get_post\", \"static\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"rule\"]).output,\n        )\n        match_order = [r.endpoint for r in app.url_map.iter_rules()]\n        self.expect_order(match_order, invoke([\"routes\", \"-s\", \"match\"]).output)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "invoke"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert default_output == endpoint_output"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.expect_order",
                    "body": "def expect_order(self, order, output):\n    for (expect, line) in zip(order, output.splitlines()[2:]):\n        assert line[:len(expect)] == expect",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `expect_order` method is designed to verify that the output of a command matches an expected order of strings, specifically by checking that each line of the output starts with the corresponding expected string from a provided list.\n\n**How It Works**:\nThe method takes two parameters: `order`, a list of expected strings, and `output`, a string containing the command output. It splits the output into lines, skipping the first two lines (typically headers). It then iterates through pairs of expected strings and corresponding output lines, asserting that each output line starts with the expected string. This is done using slicing instead of `startswith` to provide clearer error messages in pytest if the assertion fails."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_sort",
            "module": "test_cli",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 474,
            "end_line_number": 487,
            "source_code": "def test_sort(self, app, invoke):\n        default_output = invoke([\"routes\"]).output\n        endpoint_output = invoke([\"routes\", \"-s\", \"endpoint\"]).output\n        assert default_output == endpoint_output\n        self.expect_order(\n            [\"static\", \"yyy_get_post\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"methods\"]).output,\n        )\n        self.expect_order(\n            [\"yyy_get_post\", \"static\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"rule\"]).output,\n        )\n        match_order = [r.endpoint for r in app.url_map.iter_rules()]\n        self.expect_order(match_order, invoke([\"routes\", \"-s\", \"match\"]).output)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "invoke"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert default_output == endpoint_output"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "self.expect_order",
                    "body": "def expect_order(self, order, output):\n    for (expect, line) in zip(order, output.splitlines()[2:]):\n        assert line[:len(expect)] == expect",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `expect_order` method is designed to verify that the output of a command matches an expected order of strings, typically used in testing the routes of a Flask application. It checks that each line of the output starts with the corresponding expected string, allowing for a structured comparison of results.\n\n**How It Works**:\nThe method takes two parameters: `order`, a list of expected strings, and `output`, a string containing the actual output (which may include multiple lines). It splits the output into lines, skipping the first two lines (often headers), and then iterates through the expected strings and the corresponding lines of output. For each pair, it asserts that the beginning of the output line matches the expected string. This approach provides clearer error messages in case of assertion failures compared to using `startswith`."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_sort",
            "module": "test_cli",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 474,
            "end_line_number": 487,
            "source_code": "def test_sort(self, app, invoke):\n        default_output = invoke([\"routes\"]).output\n        endpoint_output = invoke([\"routes\", \"-s\", \"endpoint\"]).output\n        assert default_output == endpoint_output\n        self.expect_order(\n            [\"static\", \"yyy_get_post\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"methods\"]).output,\n        )\n        self.expect_order(\n            [\"yyy_get_post\", \"static\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"rule\"]).output,\n        )\n        match_order = [r.endpoint for r in app.url_map.iter_rules()]\n        self.expect_order(match_order, invoke([\"routes\", \"-s\", \"match\"]).output)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "invoke"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert default_output == endpoint_output"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `invoke` method is a pytest fixture designed to facilitate the testing of Flask command-line interface (CLI) commands. It creates a callable that allows tests to invoke CLI commands with a specified Flask application context.\n\n**How It Works**:\nThe method uses `FlaskGroup`, which is a subclass of `AppGroup` that manages CLI commands for a Flask application. It takes the `app` and `runner` as parameters. Inside the method, a `FlaskGroup` instance is created with a lambda function that returns the provided `app`. The method then returns a partially applied function of `runner.invoke`, which allows tests to easily call CLI commands by passing the command name and any arguments directly. This setup ensures that the CLI commands are executed within the context of the specified Flask application, making it easier to test their behavior and output."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_sort",
            "module": "test_cli",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 474,
            "end_line_number": 487,
            "source_code": "def test_sort(self, app, invoke):\n        default_output = invoke([\"routes\"]).output\n        endpoint_output = invoke([\"routes\", \"-s\", \"endpoint\"]).output\n        assert default_output == endpoint_output\n        self.expect_order(\n            [\"static\", \"yyy_get_post\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"methods\"]).output,\n        )\n        self.expect_order(\n            [\"yyy_get_post\", \"static\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"rule\"]).output,\n        )\n        match_order = [r.endpoint for r in app.url_map.iter_rules()]\n        self.expect_order(match_order, invoke([\"routes\", \"-s\", \"match\"]).output)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "invoke"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert default_output == endpoint_output"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `invoke` method is a pytest fixture designed to facilitate the testing of Flask command-line interface (CLI) commands by creating a callable that can invoke these commands within a test context.\n\n**How It Works**:\nThe method uses the `FlaskGroup` class to create a CLI instance for the provided Flask application (`app`). It then returns a partially applied function (using `functools.partial`) that binds the `runner.invoke` method to this CLI instance. This allows tests to easily execute CLI commands by calling the returned function with the desired command and arguments, while automatically handling the application context and command execution setup."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_sort",
            "module": "test_cli",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 474,
            "end_line_number": 487,
            "source_code": "def test_sort(self, app, invoke):\n        default_output = invoke([\"routes\"]).output\n        endpoint_output = invoke([\"routes\", \"-s\", \"endpoint\"]).output\n        assert default_output == endpoint_output\n        self.expect_order(\n            [\"static\", \"yyy_get_post\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"methods\"]).output,\n        )\n        self.expect_order(\n            [\"yyy_get_post\", \"static\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"rule\"]).output,\n        )\n        match_order = [r.endpoint for r in app.url_map.iter_rules()]\n        self.expect_order(match_order, invoke([\"routes\", \"-s\", \"match\"]).output)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "invoke"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert default_output == endpoint_output"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `invoke` method is a pytest fixture designed to facilitate the testing of Flask command-line interface (CLI) commands. It creates a callable that allows tests to invoke CLI commands with a specified Flask application context.\n\n**How It Works**:\nThe method uses `FlaskGroup`, which is a subclass of `AppGroup` that manages CLI commands for a Flask application. It takes the `app` and `runner` parameters, where `app` is the Flask application instance and `runner` is a `CliRunner` instance used for testing CLI commands. The method returns a partially applied function (using `functools.partial`) that binds the `runner.invoke` method to the `cli` instance created from `FlaskGroup`. This allows tests to easily invoke CLI commands while ensuring the correct application context is used."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_sort",
            "module": "test_cli",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 474,
            "end_line_number": 487,
            "source_code": "def test_sort(self, app, invoke):\n        default_output = invoke([\"routes\"]).output\n        endpoint_output = invoke([\"routes\", \"-s\", \"endpoint\"]).output\n        assert default_output == endpoint_output\n        self.expect_order(\n            [\"static\", \"yyy_get_post\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"methods\"]).output,\n        )\n        self.expect_order(\n            [\"yyy_get_post\", \"static\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"rule\"]).output,\n        )\n        match_order = [r.endpoint for r in app.url_map.iter_rules()]\n        self.expect_order(match_order, invoke([\"routes\", \"-s\", \"match\"]).output)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "invoke"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert default_output == endpoint_output"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `invoke` method is a pytest fixture designed to facilitate the testing of Flask command-line interface (CLI) commands. It creates a callable that allows tests to invoke CLI commands with a specified Flask application context.\n\n**How It Works**:\nThe method uses `FlaskGroup`, which is a subclass of `AppGroup` that manages CLI commands for a Flask application. It takes the Flask app instance as an argument through a lambda function. The `partial` function from the `functools` module is used to create a new function that pre-fixes the `runner.invoke` method with the `cli` instance. This allows tests to easily call CLI commands by simply invoking the returned function with the desired command and arguments, while ensuring the correct application context is used during the invocation."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_sort",
            "module": "test_cli",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 474,
            "end_line_number": 487,
            "source_code": "def test_sort(self, app, invoke):\n        default_output = invoke([\"routes\"]).output\n        endpoint_output = invoke([\"routes\", \"-s\", \"endpoint\"]).output\n        assert default_output == endpoint_output\n        self.expect_order(\n            [\"static\", \"yyy_get_post\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"methods\"]).output,\n        )\n        self.expect_order(\n            [\"yyy_get_post\", \"static\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"rule\"]).output,\n        )\n        match_order = [r.endpoint for r in app.url_map.iter_rules()]\n        self.expect_order(match_order, invoke([\"routes\", \"-s\", \"match\"]).output)",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "app",
                "invoke"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert default_output == endpoint_output"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `invoke` method is a pytest fixture designed to facilitate the testing of Flask command-line interface (CLI) commands. It creates a callable that allows tests to invoke CLI commands with a specified Flask application context.\n\n**How It Works**:\nThe method uses `FlaskGroup`, which is a subclass of `AppGroup` that manages CLI commands for a Flask application. It takes the `app` and `runner` as parameters. Inside the method, a `FlaskGroup` instance is created with a lambda function that returns the provided `app`. The method then returns a partially applied function of `runner.invoke`, which allows tests to easily call CLI commands by passing the command name and any arguments. This setup ensures that the CLI commands are executed within the context of the specified Flask application, making it easier to test their behavior."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_all_methods",
            "module": "test_cli",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 489,
            "end_line_number": 493,
            "source_code": "def test_all_methods(self, invoke):\n        output = invoke([\"routes\"]).output\n        assert \"GET, HEAD, OPTIONS, POST\" not in output\n        output = invoke([\"routes\", \"--all-methods\"]).output\n        assert \"GET, HEAD, OPTIONS, POST\" in output",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "invoke"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'GET, HEAD, OPTIONS, POST' not in output",
                "assert 'GET, HEAD, OPTIONS, POST' in output"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `invoke` method is a pytest fixture designed to facilitate the testing of Flask command-line interface (CLI) commands. It creates a callable that allows tests to invoke CLI commands with a specified Flask application context.\n\n**How It Works**:\nThe method uses `FlaskGroup`, which is a subclass of `AppGroup` that manages CLI commands for a Flask application. It takes the `app` and `runner` as parameters. Inside the method, a `FlaskGroup` instance is created with a lambda function that returns the provided `app`. The method then returns a partially applied function of `runner.invoke`, which allows for easy invocation of CLI commands associated with the `FlaskGroup`. This setup enables tests to run CLI commands in a controlled environment, ensuring that the application context is correctly set up for each command execution."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_all_methods",
            "module": "test_cli",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 489,
            "end_line_number": 493,
            "source_code": "def test_all_methods(self, invoke):\n        output = invoke([\"routes\"]).output\n        assert \"GET, HEAD, OPTIONS, POST\" not in output\n        output = invoke([\"routes\", \"--all-methods\"]).output\n        assert \"GET, HEAD, OPTIONS, POST\" in output",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "invoke"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert 'GET, HEAD, OPTIONS, POST' not in output",
                "assert 'GET, HEAD, OPTIONS, POST' in output"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `invoke` method is a pytest fixture designed to facilitate the testing of Flask command-line interface (CLI) commands. It creates a callable that allows tests to invoke CLI commands with a specified Flask application context.\n\n**How It Works**:\nThe method uses `FlaskGroup`, which is a subclass of `AppGroup` that manages CLI commands for a Flask application. It takes the `app` and `runner` as parameters. Inside the method, a `FlaskGroup` instance is created with a lambda function that returns the provided `app`. The method then returns a partially applied function of `runner.invoke`, which allows tests to easily call CLI commands by passing the command name and any arguments. This setup ensures that the CLI commands are executed within the context of the specified Flask application, making it easier to test their behavior."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_no_routes",
            "module": "test_cli",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 495,
            "end_line_number": 500,
            "source_code": "def test_no_routes(self, runner):\n        app = Flask(__name__, static_folder=None)\n        cli = FlaskGroup(create_app=lambda: app)\n        result = runner.invoke(cli, [\"routes\"])\n        assert result.exit_code == 0\n        assert \"No routes were registered.\" in result.output",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "runner"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert result.exit_code == 0",
                "assert 'No routes were registered.' in result.output"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "runner.invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `invoke` method is a pytest fixture that facilitates the testing of Flask CLI commands by creating a command-line interface (CLI) group associated with a Flask application. It allows developers to easily invoke CLI commands in their tests.\n\n**How It Works**:  \nThe `invoke` method uses the `FlaskGroup` class to create a CLI instance for the provided Flask application. It leverages `functools.partial` to bind the `runner.invoke` method to this CLI instance, enabling the execution of CLI commands with the specified application context. When called, it returns a callable that can be used to run CLI commands and capture their output, exit codes, and other relevant information during testing. This setup is particularly useful for testing various CLI functionalities, such as command options and output formatting."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_subdomain",
            "module": "test_cli",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 502,
            "end_line_number": 509,
            "source_code": "def test_subdomain(self, runner):\n        app = Flask(__name__, static_folder=None)\n        app.add_url_rule(\"/a\", subdomain=\"a\", endpoint=\"a\")\n        app.add_url_rule(\"/b\", subdomain=\"b\", endpoint=\"b\")\n        cli = FlaskGroup(create_app=lambda: app)\n        result = runner.invoke(cli, [\"routes\"])\n        assert result.exit_code == 0\n        assert \"Subdomain\" in result.output",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "runner"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert result.exit_code == 0",
                "assert 'Subdomain' in result.output"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "runner.invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `invoke` method is a pytest fixture that creates a callable for invoking CLI commands on a Flask application using the `CliRunner`. It allows for testing of command-line interface (CLI) commands defined in the Flask application.\n\n**How It Works**:  \nThe `invoke` method uses the `FlaskGroup` class to create a CLI group associated with the provided Flask application. It leverages `functools.partial` to bind the `runner.invoke` method to this CLI group, enabling the execution of CLI commands with the specified application context. When called, it returns a function that can be used to invoke CLI commands, capturing their output and exit status for assertions in tests."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_host",
            "module": "test_cli",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_cli.py",
            "line_number": 511,
            "end_line_number": 518,
            "source_code": "def test_host(self, runner):\n        app = Flask(__name__, static_folder=None, host_matching=True)\n        app.add_url_rule(\"/a\", host=\"a\", endpoint=\"a\")\n        app.add_url_rule(\"/b\", host=\"b\", endpoint=\"b\")\n        cli = FlaskGroup(create_app=lambda: app)\n        result = runner.invoke(cli, [\"routes\"])\n        assert result.exit_code == 0\n        assert \"Host\" in result.output",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "self",
                "runner"
            ],
            "imports": [
                "importlib.metadata",
                "os",
                "platform",
                "ssl",
                "sys",
                "types",
                "functools.partial",
                "pathlib.Path",
                "click",
                "pytest",
                "_pytest.monkeypatch.notset",
                "click.testing.CliRunner",
                "flask.Blueprint",
                "flask.current_app",
                "flask.Flask",
                "flask.cli.AppGroup",
                "flask.cli.find_best_app",
                "flask.cli.FlaskGroup",
                "flask.cli.get_version",
                "flask.cli.load_dotenv",
                "flask.cli.locate_app",
                "flask.cli.NoAppException",
                "flask.cli.prepare_import",
                "flask.cli.run_command",
                "flask.cli.ScriptInfo",
                "flask.cli.with_appcontext",
                "cliapp.app.testapp",
                "flask.cli.cli",
                "flask.cli.cli",
                "dotenv"
            ],
            "fixtures": [],
            "assertions": [
                "assert result.exit_code == 0",
                "assert 'Host' in result.output"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "runner.invoke",
                    "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `invoke` method is a pytest fixture that facilitates the testing of Flask CLI commands by creating a callable that can execute these commands within the context of a specified Flask application.\n\n**How It Works**:  \nThe `invoke` method uses the `FlaskGroup` class to create a CLI group associated with the provided Flask application. It leverages `functools.partial` to bind the `runner.invoke` method to this CLI group, allowing for easy invocation of CLI commands during tests. When called, it executes the specified command and returns the result, which includes the command's output and exit status, enabling assertions in test cases."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_context_processing",
            "module": "test_templating",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_templating.py",
            "line_number": 11,
            "end_line_number": 21,
            "source_code": "def test_context_processing(app, client):\n    @app.context_processor\n    def context_processor():\n        return {\"injected_value\": 42}\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"context_template.html\", value=23)\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"<p>23|42\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "logging",
                "pytest",
                "werkzeug.serving",
                "jinja2.TemplateNotFound",
                "markupsafe.Markup",
                "flask",
                "blueprintapp.app",
                "jinja2.DictLoader"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'<p>23|42'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_original_win",
            "module": "test_templating",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_templating.py",
            "line_number": 24,
            "end_line_number": 30,
            "source_code": "def test_original_win(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.render_template_string(\"{{ config }}\", config=42)\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"42\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "logging",
                "pytest",
                "werkzeug.serving",
                "jinja2.TemplateNotFound",
                "markupsafe.Markup",
                "flask",
                "blueprintapp.app",
                "jinja2.DictLoader"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'42'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_simple_stream",
            "module": "test_templating",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_templating.py",
            "line_number": 33,
            "end_line_number": 39,
            "source_code": "def test_simple_stream(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.stream_template_string(\"{{ config }}\", config=42)\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"42\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "logging",
                "pytest",
                "werkzeug.serving",
                "jinja2.TemplateNotFound",
                "markupsafe.Markup",
                "flask",
                "blueprintapp.app",
                "jinja2.DictLoader"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'42'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_standard_context",
            "module": "test_templating",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_templating.py",
            "line_number": 53,
            "end_line_number": 68,
            "source_code": "def test_standard_context(app, client):\n    @app.route(\"/\")\n    def index():\n        flask.g.foo = 23\n        flask.session[\"test\"] = \"aha\"\n        return flask.render_template_string(\n            \"\"\"\n            {{ request.args.foo }}\n            {{ g.foo }}\n            {{ config.DEBUG }}\n            {{ session.test }}\n        \"\"\"\n        )\n\n    rv = client.get(\"/?foo=42\")\n    assert rv.data.split() == [b\"42\", b\"23\", b\"False\", b\"aha\"]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "logging",
                "pytest",
                "werkzeug.serving",
                "jinja2.TemplateNotFound",
                "markupsafe.Markup",
                "flask",
                "blueprintapp.app",
                "jinja2.DictLoader"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data.split() == [b'42', b'23', b'False', b'aha']"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. Finally, the retrieved value is returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_escaping",
            "module": "test_templating",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_templating.py",
            "line_number": 71,
            "end_line_number": 88,
            "source_code": "def test_escaping(app, client):\n    text = \"<p>Hello World!\"\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\n            \"escaping_template.html\", text=text, html=Markup(text)\n        )\n\n    lines = client.get(\"/\").data.splitlines()\n    assert lines == [\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n    ]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "logging",
                "pytest",
                "werkzeug.serving",
                "jinja2.TemplateNotFound",
                "markupsafe.Markup",
                "flask",
                "blueprintapp.app",
                "jinja2.DictLoader"
            ],
            "fixtures": [],
            "assertions": [
                "assert lines == [b'&lt;p&gt;Hello World!', b'<p>Hello World!', b'<p>Hello World!', b'<p>Hello World!', b'&lt;p&gt;Hello World!', b'<p>Hello World!']"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_no_escaping",
            "module": "test_templating",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_templating.py",
            "line_number": 91,
            "end_line_number": 110,
            "source_code": "def test_no_escaping(app, client):\n    text = \"<p>Hello World!\"\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\n            \"non_escaping_template.txt\", text=text, html=Markup(text)\n        )\n\n    lines = client.get(\"/\").data.splitlines()\n    assert lines == [\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n    ]",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "logging",
                "pytest",
                "werkzeug.serving",
                "jinja2.TemplateNotFound",
                "markupsafe.Markup",
                "flask",
                "blueprintapp.app",
                "jinja2.DictLoader"
            ],
            "fixtures": [],
            "assertions": [
                "assert lines == [b'<p>Hello World!', b'<p>Hello World!', b'<p>Hello World!', b'<p>Hello World!', b'&lt;p&gt;Hello World!', b'<p>Hello World!', b'<p>Hello World!', b'<p>Hello World!']"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_template_filter_with_template",
            "module": "test_templating",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_templating.py",
            "line_number": 163,
            "end_line_number": 173,
            "source_code": "def test_template_filter_with_template(app, client):\n    @app.template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "logging",
                "pytest",
                "werkzeug.serving",
                "jinja2.TemplateNotFound",
                "markupsafe.Markup",
                "flask",
                "blueprintapp.app",
                "jinja2.DictLoader"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'dcba'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. Finally, the retrieved value is returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_add_template_filter_with_template",
            "module": "test_templating",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_templating.py",
            "line_number": 176,
            "end_line_number": 187,
            "source_code": "def test_add_template_filter_with_template(app, client):\n    def super_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(super_reverse)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "logging",
                "pytest",
                "werkzeug.serving",
                "jinja2.TemplateNotFound",
                "markupsafe.Markup",
                "flask",
                "blueprintapp.app",
                "jinja2.DictLoader"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'dcba'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_template_filter_with_name_and_template",
            "module": "test_templating",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_templating.py",
            "line_number": 190,
            "end_line_number": 200,
            "source_code": "def test_template_filter_with_name_and_template(app, client):\n    @app.template_filter(\"super_reverse\")\n    def my_reverse(s):\n        return s[::-1]\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "logging",
                "pytest",
                "werkzeug.serving",
                "jinja2.TemplateNotFound",
                "markupsafe.Markup",
                "flask",
                "blueprintapp.app",
                "jinja2.DictLoader"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'dcba'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_add_template_filter_with_name_and_template",
            "module": "test_templating",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_templating.py",
            "line_number": 203,
            "end_line_number": 214,
            "source_code": "def test_add_template_filter_with_name_and_template(app, client):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse, \"super_reverse\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "logging",
                "pytest",
                "werkzeug.serving",
                "jinja2.TemplateNotFound",
                "markupsafe.Markup",
                "flask",
                "blueprintapp.app",
                "jinja2.DictLoader"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'dcba'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. Finally, the retrieved value is returned as the response to the HTTP request. This method is useful for accessing session data in a web application context."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_template_test_with_template",
            "module": "test_templating",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_templating.py",
            "line_number": 257,
            "end_line_number": 267,
            "source_code": "def test_template_test_with_template(app, client):\n    @app.template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "logging",
                "pytest",
                "werkzeug.serving",
                "jinja2.TemplateNotFound",
                "markupsafe.Markup",
                "flask",
                "blueprintapp.app",
                "jinja2.DictLoader"
            ],
            "fixtures": [],
            "assertions": [
                "assert b'Success!' in rv.data"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, defaulting to `'None'` if the key `'value'` does not exist.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. It uses `flask.session.get` to access the session data, specifically looking for the key `'value'`. If this key is found, its associated value is returned; otherwise, the string `'None'` is returned. This method is useful for retrieving session-specific data in a web application context."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_add_template_test_with_template",
            "module": "test_templating",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_templating.py",
            "line_number": 270,
            "end_line_number": 281,
            "source_code": "def test_add_template_test_with_template(app, client):\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(boolean)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "logging",
                "pytest",
                "werkzeug.serving",
                "jinja2.TemplateNotFound",
                "markupsafe.Markup",
                "flask",
                "blueprintapp.app",
                "jinja2.DictLoader"
            ],
            "fixtures": [],
            "assertions": [
                "assert b'Success!' in rv.data"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:  \nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:  \nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the HTTP request. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_template_test_with_name_and_template",
            "module": "test_templating",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_templating.py",
            "line_number": 284,
            "end_line_number": 294,
            "source_code": "def test_template_test_with_name_and_template(app, client):\n    @app.template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "logging",
                "pytest",
                "werkzeug.serving",
                "jinja2.TemplateNotFound",
                "markupsafe.Markup",
                "flask",
                "blueprintapp.app",
                "jinja2.DictLoader"
            ],
            "fixtures": [],
            "assertions": [
                "assert b'Success!' in rv.data"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, defaulting to `'None'` if the key `'value'` does not exist.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. It uses `flask.session.get` to access the session data, specifically looking for the key `'value'`. If this key is found, its associated value is returned; if not, the string `'None'` is returned. This method is useful for retrieving session-specific data in a web application context."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_add_template_test_with_name_and_template",
            "module": "test_templating",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_templating.py",
            "line_number": 297,
            "end_line_number": 308,
            "source_code": "def test_add_template_test_with_name_and_template(app, client):\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(is_boolean, \"boolean\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "logging",
                "pytest",
                "werkzeug.serving",
                "jinja2.TemplateNotFound",
                "markupsafe.Markup",
                "flask",
                "blueprintapp.app",
                "jinja2.DictLoader"
            ],
            "fixtures": [],
            "assertions": [
                "assert b'Success!' in rv.data"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, defaulting to `'None'` if the key `'value'` does not exist.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. It uses `flask.session.get` to access the session data, specifically looking for the key `'value'`. If this key is found, its associated value is returned; otherwise, the string `'None'` is returned. This method is useful for retrieving session-specific data in a web application context."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_custom_template_loader",
            "module": "test_templating",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_templating.py",
            "line_number": 324,
            "end_line_number": 339,
            "source_code": "def test_custom_template_loader(client):\n    class MyFlask(flask.Flask):\n        def create_global_jinja_loader(self):\n            from jinja2 import DictLoader\n\n            return DictLoader({\"index.html\": \"Hello Custom World!\"})\n\n    app = MyFlask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"index.html\")\n\n    c = app.test_client()\n    rv = c.get(\"/\")\n    assert rv.data == b\"Hello Custom World!\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "client"
            ],
            "imports": [
                "logging",
                "pytest",
                "werkzeug.serving",
                "jinja2.TemplateNotFound",
                "markupsafe.Markup",
                "flask",
                "blueprintapp.app",
                "jinja2.DictLoader"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'Hello Custom World!'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "c.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get` method is a Flask route handler that retrieves a value from the session, specifically the value associated with the key `'value'`. If this key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the method uses `flask.session.get` to access the session data. The `get` method of the session object takes two arguments: the key to look for (`'value'`) and a default value (`'None'`) to return if the key is not found. The retrieved value is then returned as the response to the HTTP request. This allows the application to maintain state across requests by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_iterable_loader",
            "module": "test_templating",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_templating.py",
            "line_number": 342,
            "end_line_number": 359,
            "source_code": "def test_iterable_loader(app, client):\n    @app.context_processor\n    def context_processor():\n        return {\"whiskey\": \"Jameson\"}\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\n            [\n                \"no_template.xml\",  # should skip this one\n                \"simple_template.html\",  # should render this\n                \"context_template.html\",\n            ],\n            value=23,\n        )\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"<h1>Jameson</h1>\"",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "app",
                "client"
            ],
            "imports": [
                "logging",
                "pytest",
                "werkzeug.serving",
                "jinja2.TemplateNotFound",
                "markupsafe.Markup",
                "flask",
                "blueprintapp.app",
                "jinja2.DictLoader"
            ],
            "fixtures": [],
            "assertions": [
                "assert rv.data == b'<h1>Jameson</h1>'"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "client.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `client.get` method is designed to handle HTTP GET requests to the `/get` endpoint in a Flask application. It retrieves a value from the session, specifically the value associated with the key `'value'`, and returns it. If the key does not exist, it defaults to returning the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` route, the `get` function is invoked. Inside this function, `flask.session.get('value', 'None')` is called to access the session data. The `get` method of the session object attempts to retrieve the value associated with the key `'value'`. If the key is not found, it returns the default value `'None'`. The retrieved value is then returned as the response to the client. This method is useful for maintaining state across requests in a web application by storing and retrieving user-specific data in the session."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_template_loader_debugging",
            "module": "test_templating",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_templating.py",
            "line_number": 407,
            "end_line_number": 440,
            "source_code": "def test_template_loader_debugging(test_apps, monkeypatch):\n    from blueprintapp import app\n\n    called = []\n\n    class _TestHandler(logging.Handler):\n        def handle(self, record):\n            called.append(True)\n            text = str(record.msg)\n            assert \"1: trying loader of application 'blueprintapp'\" in text\n            assert (\n                \"2: trying loader of blueprint 'admin' (blueprintapp.apps.admin)\"\n            ) in text\n            assert (\n                \"trying loader of blueprint 'frontend' (blueprintapp.apps.frontend)\"\n            ) in text\n            assert \"Error: the template could not be found\" in text\n            assert (\n                \"looked up from an endpoint that belongs to the blueprint 'frontend'\"\n            ) in text\n            assert \"See https://flask.palletsprojects.com/blueprints/#templates\" in text\n\n    with app.test_client() as c:\n        monkeypatch.setitem(app.config, \"EXPLAIN_TEMPLATE_LOADING\", True)\n        monkeypatch.setattr(\n            logging.getLogger(\"blueprintapp\"), \"handlers\", [_TestHandler()]\n        )\n\n        with pytest.raises(TemplateNotFound) as excinfo:\n            c.get(\"/missing\")\n\n        assert \"missing_template.html\" in str(excinfo.value)\n\n    assert len(called) == 1",
            "docstring": null,
            "decorators": [],
            "arguments": [
                "test_apps",
                "monkeypatch"
            ],
            "imports": [
                "logging",
                "pytest",
                "werkzeug.serving",
                "jinja2.TemplateNotFound",
                "markupsafe.Markup",
                "flask",
                "blueprintapp.app",
                "jinja2.DictLoader"
            ],
            "fixtures": [],
            "assertions": [
                "assert len(called) == 1",
                "assert 'missing_template.html' in str(excinfo.value)",
                "assert \"1: trying loader of application 'blueprintapp'\" in text",
                "assert \"2: trying loader of blueprint 'admin' (blueprintapp.apps.admin)\" in text",
                "assert \"trying loader of blueprint 'frontend' (blueprintapp.apps.frontend)\" in text",
                "assert 'Error: the template could not be found' in text",
                "assert \"looked up from an endpoint that belongs to the blueprint 'frontend'\" in text",
                "assert 'See https://flask.palletsprojects.com/blueprints/#templates' in text"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "c.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `get` method is a Flask route handler that retrieves a value from the session, specifically the value associated with the key `'value'`. If this key does not exist in the session, it returns the string `'None'`.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the method uses `flask.session.get()` to access the session data. The `get` method takes two arguments: the key `'value'` and a default value `'None'`. If the key is found, it returns the corresponding value; otherwise, it returns the default value. This allows for safe retrieval of session data without raising an error if the key is missing. The result is then returned as the HTTP response."
                }
            ]
        },
        {
            "repo_name": "flask",
            "name": "test_open_session_with_endpoint",
            "module": "test_session_interface",
            "class_name": null,
            "file_path": "__internal__/data/flask/tests/test_session_interface.py",
            "line_number": 6,
            "end_line_number": 28,
            "source_code": "def test_open_session_with_endpoint():\n    \"\"\"If request.endpoint (or other URL matching behavior) is needed\n    while loading the session, RequestContext.match_request() can be\n    called manually.\n    \"\"\"\n\n    class MySessionInterface(SessionInterface):\n        def save_session(self, app, session, response):\n            pass\n\n        def open_session(self, app, request):\n            request_ctx.match_request()\n            assert request.endpoint is not None\n\n    app = flask.Flask(__name__)\n    app.session_interface = MySessionInterface()\n\n    @app.get(\"/\")\n    def index():\n        return \"Hello, World!\"\n\n    response = app.test_client().get(\"/\")\n    assert response.status_code == 200",
            "docstring": "If request.endpoint (or other URL matching behavior) is needed\nwhile loading the session, RequestContext.match_request() can be\ncalled manually.",
            "decorators": [],
            "arguments": [],
            "imports": [
                "flask",
                "flask.globals.request_ctx",
                "flask.sessions.SessionInterface"
            ],
            "fixtures": [],
            "assertions": [
                "assert response.status_code == 200",
                "assert request.endpoint is not None"
            ],
            "setup_method": null,
            "teardown_method": null,
            "mocks": [],
            "methods_under_test": [
                {
                    "name": "app.get",
                    "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v",
                    "method_explanation": "**Main Purpose of the Method**:\nThe `app.get` method is used to define a route in a Flask web application that responds to HTTP GET requests. Specifically, the route `/get` retrieves a value from the session, returning it to the client.\n\n**How It Works**:\nWhen a GET request is made to the `/get` endpoint, the `get` function is invoked. Inside this function, it attempts to retrieve the value associated with the key `'value'` from the Flask session. If the key does not exist, it defaults to returning the string `'None'`. The retrieved value is then sent back as the response to the client. This method leverages Flask's session management to store and retrieve user-specific data across requests."
                }
            ]
        }
    ]
}