{
  "tests": [
    {
      "name": "test_dump_load_unchanged",
      "module": "test_json_tag",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json_tag.py",
      "line_number": 27,
      "end_line_number": 29,
      "source_code": "def test_dump_load_unchanged(data):\n    s = TaggedJSONSerializer()\n    assert s.loads(s.dumps(data)) == data",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('data', ({' t': (1, 2, 3)}, {' t__': b'a'}, {' di': ' di'}, {'x': (1, 2, 3), 'y': 4}, (1, 2, 3), [(1, 2, 3)], b'\\xff', Markup('<html>'), uuid4(), datetime.now(tz=timezone.utc).replace(microsecond=0)))"
      ],
      "arguments": [
        "data"
      ],
      "imports": [
        "datetime.datetime",
        "datetime.timezone",
        "uuid.uuid4",
        "pytest",
        "markupsafe.Markup",
        "flask.json.tag.JSONTag",
        "flask.json.tag.TaggedJSONSerializer"
      ],
      "fixtures": [],
      "assertions": [
        "assert s.loads(s.dumps(data)) == data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "s.loads",
          "body": "def loads(self, s, **kwargs):\n    kwargs.setdefault('object_hook', self.object_hook)\n    return super().loads(s, **kwargs)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_dump_load_unchanged` test is to verify the integrity of the serialization and deserialization process in the `TaggedJSONSerializer` class. It ensures that when an object is serialized (converted to a JSON string) and then deserialized (converted back to its original form), the resulting object is identical to the original.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `loads` method of the `TaggedJSONSerializer` class correctly reconstructs the original data from its serialized form produced by the `dumps` method. The assertion `assert s.loads(s.dumps(data)) == data` confirms that the output of the deserialization matches the input data, indicating that no information is lost or altered during the process.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `TaggedJSONSerializer` class, which has two key methods: `dumps` and `loads`. The `dumps` method serializes a Python object into a JSON string, while the `loads` method deserializes a JSON string back into a Python object. The test creates an instance of `TaggedJSONSerializer`, serializes the input `data` using `s.dumps(data)`, and then immediately deserializes it with `s.loads(...)`. The test checks that the final output matches the original `data`, ensuring the serialization and deserialization processes are functioning correctly.\n\n**Notable Testing Patterns or Techniques Used**:  \nThis test employs a straightforward assertion pattern to validate the expected outcome of a function. It uses the principle of round-trip testing, where data is serialized and then deserialized to confirm that the original and final outputs are equivalent. This technique is particularly effective in testing serialization libraries, as it directly assesses the correctness of the transformation processes involved. Additionally, the use of fixtures in the broader test suite (though not directly in this test) indicates a structured approach to setting up test environments, which enhances maintainability and clarity in testing."
    },
    {
      "name": "test_duplicate_tag",
      "module": "test_json_tag",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json_tag.py",
      "line_number": 32,
      "end_line_number": 40,
      "source_code": "def test_duplicate_tag():\n    class TagDict(JSONTag):\n        key = \" d\"\n\n    s = TaggedJSONSerializer()\n    pytest.raises(KeyError, s.register, TagDict)\n    s.register(TagDict, force=True, index=0)\n    assert isinstance(s.tags[\" d\"], TagDict)\n    assert isinstance(s.order[0], TagDict)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timezone",
        "uuid.uuid4",
        "pytest",
        "markupsafe.Markup",
        "flask.json.tag.JSONTag",
        "flask.json.tag.TaggedJSONSerializer"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(s.tags[' d'], TagDict)",
        "assert isinstance(s.order[0], TagDict)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_custom_tag",
      "module": "test_json_tag",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json_tag.py",
      "line_number": 43,
      "end_line_number": 63,
      "source_code": "def test_custom_tag():\n    class Foo:  # noqa: B903, for Python2 compatibility\n        def __init__(self, data):\n            self.data = data\n\n    class TagFoo(JSONTag):\n        __slots__ = ()\n        key = \" f\"\n\n        def check(self, value):\n            return isinstance(value, Foo)\n\n        def to_json(self, value):\n            return self.serializer.tag(value.data)\n\n        def to_python(self, value):\n            return Foo(value)\n\n    s = TaggedJSONSerializer()\n    s.register(TagFoo)\n    assert s.loads(s.dumps(Foo(\"bar\"))).data == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timezone",
        "uuid.uuid4",
        "pytest",
        "markupsafe.Markup",
        "flask.json.tag.JSONTag",
        "flask.json.tag.TaggedJSONSerializer"
      ],
      "fixtures": [],
      "assertions": [
        "assert s.loads(s.dumps(Foo('bar'))).data == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "s.loads",
          "body": "def loads(self, s, **kwargs):\n    kwargs.setdefault('object_hook', self.object_hook)\n    return super().loads(s, **kwargs)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_custom_tag` function is designed to verify the functionality of a custom tagging mechanism within the `TaggedJSONSerializer` class. Specifically, it tests whether the serializer can correctly serialize and deserialize an instance of a user-defined class (`Foo`) using a custom tag (`TagFoo`).\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that an instance of `Foo` containing the string \"bar\" can be serialized into a JSON format and then deserialized back into a `Foo` object, ensuring that the `data` attribute of the resulting object matches the original input. The assertion `assert s.loads(s.dumps(Foo(\"bar\"))).data == \"bar\"` confirms this behavior.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `TaggedJSONSerializer` and its ability to handle custom tags. The `TagFoo` class extends `JSONTag` and implements the methods `check`, `to_json`, and `to_python`. The `check` method determines if a value is an instance of `Foo`, `to_json` converts a `Foo` instance to a JSON-compatible format, and `to_python` reconstructs a `Foo` instance from its JSON representation. The serializer is registered with the custom tag, allowing it to process `Foo` objects correctly.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern to validate the expected outcome of serialization and deserialization. It also utilizes class definitions within the test function to encapsulate the custom behavior being tested, which is a common practice in unit tests to keep the test environment self-contained. Additionally, the use of `assert` statements provides immediate feedback on the correctness of the implementation, which is a fundamental aspect of unit testing."
    },
    {
      "name": "test_tag_interface",
      "module": "test_json_tag",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json_tag.py",
      "line_number": 66,
      "end_line_number": 70,
      "source_code": "def test_tag_interface():\n    t = JSONTag(None)\n    pytest.raises(NotImplementedError, t.check, None)\n    pytest.raises(NotImplementedError, t.to_json, None)\n    pytest.raises(NotImplementedError, t.to_python, None)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timezone",
        "uuid.uuid4",
        "pytest",
        "markupsafe.Markup",
        "flask.json.tag.JSONTag",
        "flask.json.tag.TaggedJSONSerializer"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_tag_order",
      "module": "test_json_tag",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json_tag.py",
      "line_number": 73,
      "end_line_number": 86,
      "source_code": "def test_tag_order():\n    class Tag1(JSONTag):\n        key = \" 1\"\n\n    class Tag2(JSONTag):\n        key = \" 2\"\n\n    s = TaggedJSONSerializer()\n\n    s.register(Tag1, index=-1)\n    assert isinstance(s.order[-2], Tag1)\n\n    s.register(Tag2, index=None)\n    assert isinstance(s.order[-1], Tag2)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timezone",
        "uuid.uuid4",
        "pytest",
        "markupsafe.Markup",
        "flask.json.tag.JSONTag",
        "flask.json.tag.TaggedJSONSerializer"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(s.order[-2], Tag1)",
        "assert isinstance(s.order[-1], Tag2)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_environ_defaults_from_config",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 15,
      "end_line_number": 27,
      "source_code": "def test_environ_defaults_from_config(app, client):\n    app.config[\"SERVER_NAME\"] = \"example.com:1234\"\n    app.config[\"APPLICATION_ROOT\"] = \"/foo\"\n\n    @app.route(\"/\")\n    def index():\n        return flask.request.url\n\n    ctx = app.test_request_context()\n    assert ctx.request.url == \"http://example.com:1234/foo/\"\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"http://example.com:1234/foo/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert ctx.request.url == 'http://example.com:1234/foo/'",
        "assert rv.data == b'http://example.com:1234/foo/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_environ_defaults_from_config` unit test is designed to verify that the Flask application correctly constructs the request URL based on the configuration settings for `SERVER_NAME` and `APPLICATION_ROOT`. It ensures that the application uses these settings to generate the expected URL when handling requests.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the URL generated by the application matches the expected format when the application is accessed. It verifies that the URL is constructed correctly as `http://example.com:1234/foo/` when the root route (`/`) is accessed, reflecting the configured server name and application root.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Flask application with specific configuration values for `SERVER_NAME` and `APPLICATION_ROOT`. It defines a route (`/`) that returns the current request URL. The test then creates a request context and asserts that the constructed URL matches the expected value. It also uses the test client to make a GET request to the root route and checks that the response data matches the expected URL. The relevant code being tested is the Flask routing and request context handling, which utilizes the configuration settings to build the request URL.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The test uses `app.test_request_context()` to create a simulated request context, allowing the test to assert the behavior of the application as if it were handling an actual request.\n- **Client Interaction**: The test employs the Flask test client (`client.get(\"/\")`) to simulate a real HTTP request to the application, enabling verification of the response data.\n- **Assertions**: The test uses assertions to validate that both the constructed URL in the context and the response data from the client match the expected output, ensuring that the application behaves as intended under the specified configuration."
    },
    {
      "name": "test_environ_defaults",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 30,
      "end_line_number": 39,
      "source_code": "def test_environ_defaults(app, client, app_ctx, req_ctx):\n    @app.route(\"/\")\n    def index():\n        return flask.request.url\n\n    ctx = app.test_request_context()\n    assert ctx.request.url == \"http://localhost/\"\n    with client:\n        rv = client.get(\"/\")\n        assert rv.data == b\"http://localhost/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client",
        "app_ctx",
        "req_ctx"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert ctx.request.url == 'http://localhost/'",
        "assert rv.data == b'http://localhost/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_environ_defaults` function is designed to verify that the Flask application correctly constructs the request URL in different contexts, specifically ensuring that the default URL is set to \"http://localhost/\" when no specific URL scheme or host is provided.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main behaviors: \n1. It asserts that the request context created with `app.test_request_context()` has the expected URL of \"http://localhost/\".\n2. It verifies that when a client makes a GET request to the root endpoint (\"/\"), the response data matches the expected URL, confirming that the application correctly handles requests and returns the appropriate URL.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the Flask route defined by `@app.route(\"/\")`, which returns the current request URL using `flask.request.url`. The test first creates a request context and checks the URL directly. Then, it uses the test client to simulate a GET request to the same route and checks that the response data matches the expected URL. This ensures that both the context and the client request yield consistent results.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Context Management**: It uses Flask's `test_request_context()` to create a simulated request context, allowing the test to access request-specific data without needing to run a full server.\n- **Client Simulation**: The test utilizes Flask's test client to simulate HTTP requests, enabling the verification of application behavior in response to those requests.\n- **Assertions**: It uses assertions to validate that the expected outcomes (the request URL and response data) match the actual results, which is a fundamental practice in unit testing to ensure correctness."
    },
    {
      "name": "test_environ_base_default",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 42,
      "end_line_number": 54,
      "source_code": "def test_environ_base_default(app, client):\n    @app.route(\"/\")\n    def index():\n        flask.g.remote_addr = flask.request.remote_addr\n        flask.g.user_agent = flask.request.user_agent.string\n        return \"\"\n\n    with client:\n        client.get(\"/\")\n        assert flask.g.remote_addr == \"127.0.0.1\"\n        assert flask.g.user_agent == (\n            f\"Werkzeug/{importlib.metadata.version('werkzeug')}\"\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.g.remote_addr == '127.0.0.1'",
        "assert flask.g.user_agent == f\"Werkzeug/{importlib.metadata.version('werkzeug')}\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_environ_base_default` test verifies that the Flask application correctly sets the `remote_addr` and `user_agent` attributes in the `flask.g` context during a request to the root endpoint (\"/\"). This ensures that the application can accurately capture and utilize request-specific information.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that after making a GET request to the root endpoint, the `flask.g.remote_addr` is set to \"127.0.0.1\" (the default address for local requests) and that `flask.g.user_agent` reflects the version of Werkzeug being used. This confirms that the application is correctly populating the global context with request data.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `index` function defined within the `test_environ_base_default` test. This function assigns the `remote_addr` and `user_agent` from the incoming request to the `flask.g` context. The test uses the Flask test client to simulate a request to the root endpoint, allowing it to assert the expected values in the `flask.g` context after the request is processed.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of Flask's test client to simulate HTTP requests, which is a common pattern in testing web applications. It also utilizes assertions to verify the state of the application after the request, ensuring that the expected values are correctly set in the application context. The use of `flask.g` for storing request-specific data is a notable aspect of Flask's context management, allowing for clean and efficient access to request-related information throughout the application."
    },
    {
      "name": "test_environ_base_modified",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 57,
      "end_line_number": 70,
      "source_code": "def test_environ_base_modified(app, client):\n    @app.route(\"/\")\n    def index():\n        flask.g.remote_addr = flask.request.remote_addr\n        flask.g.user_agent = flask.request.user_agent.string\n        return \"\"\n\n    client.environ_base[\"REMOTE_ADDR\"] = \"192.168.0.22\"\n    client.environ_base[\"HTTP_USER_AGENT\"] = \"Foo\"\n\n    with client:\n        client.get(\"/\")\n        assert flask.g.remote_addr == \"192.168.0.22\"\n        assert flask.g.user_agent == \"Foo\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.g.remote_addr == '192.168.0.22'",
        "assert flask.g.user_agent == 'Foo'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_environ_base_modified` test verifies that the Flask test client can correctly modify the request environment, specifically the `REMOTE_ADDR` and `HTTP_USER_AGENT` headers, and that these modifications are reflected in the Flask application context during a request.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when the `client.environ_base` dictionary is updated with specific values for `REMOTE_ADDR` and `HTTP_USER_AGENT`, these values are accessible in the Flask application context (`flask.g`) after a request is made to the root endpoint (`/`). It ensures that the application correctly captures and utilizes the modified request environment.\n\n**Code Being Tested and How It Works**:  \nThe test defines a simple route (`index`) that assigns the `remote_addr` and `user_agent` from the request to the global context (`flask.g`). The test client modifies the `environ_base` to set `REMOTE_ADDR` to `\"192.168.0.22\"` and `HTTP_USER_AGENT` to `\"Foo\"`. When the client makes a GET request to the root endpoint, the test asserts that `flask.g.remote_addr` and `flask.g.user_agent` reflect these modified values, confirming that the application correctly processes the custom environment settings.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of Flask's test client, which allows for simulating requests to the application in a controlled environment. It utilizes context management (`with client:`) to ensure that the request context is properly set up and torn down. The test also leverages assertions to validate the expected state of the application context after the request, which is a common pattern in unit testing to ensure that the code behaves as intended."
    },
    {
      "name": "test_client_open_environ",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 73,
      "end_line_number": 87,
      "source_code": "def test_client_open_environ(app, client, request):\n    @app.route(\"/index\")\n    def index():\n        return flask.request.remote_addr\n\n    builder = EnvironBuilder(app, path=\"/index\", method=\"GET\")\n    request.addfinalizer(builder.close)\n\n    rv = client.open(builder)\n    assert rv.data == b\"127.0.0.1\"\n\n    environ = builder.get_environ()\n    client.environ_base[\"REMOTE_ADDR\"] = \"127.0.0.2\"\n    rv = client.open(environ)\n    assert rv.data == b\"127.0.0.2\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client",
        "request"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'127.0.0.1'",
        "assert rv.data == b'127.0.0.2'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_specify_url_scheme",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 90,
      "end_line_number": 99,
      "source_code": "def test_specify_url_scheme(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.request.url\n\n    ctx = app.test_request_context(url_scheme=\"https\")\n    assert ctx.request.url == \"https://localhost/\"\n\n    rv = client.get(\"/\", url_scheme=\"https\")\n    assert rv.data == b\"https://localhost/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert ctx.request.url == 'https://localhost/'",
        "assert rv.data == b'https://localhost/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_specify_url_scheme` function is designed to verify that the Flask application correctly generates URLs with a specified URL scheme (in this case, \"https\"). It ensures that both the request context and the response from the client reflect this scheme.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks two main behaviors: \n1. It verifies that when a request context is created with a specific URL scheme, the generated URL matches the expected format (i.e., \"https://localhost/\").\n2. It confirms that when a client makes a GET request to the root endpoint (\"/\") with the same URL scheme, the response data also reflects the correct URL.\n\n**Code Being Tested and How It Works**:  \nThe test defines a simple route (`index`) that returns the current request's URL. It then creates a request context with the `url_scheme` parameter set to \"https\" and asserts that the generated URL is \"https://localhost/\". Following this, it uses the test client to perform a GET request to the same route, again specifying the \"https\" scheme, and checks that the response data is the expected byte string `b\"https://localhost/\"`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The test utilizes Flask's `test_request_context` to simulate a request context with a specific URL scheme, allowing for controlled testing of request-related behaviors.\n- **Assertions**: It employs assertions to validate the expected outcomes, ensuring that both the request context and the client response behave as intended.\n- **Client Interaction**: The test leverages Flask's test client to simulate actual HTTP requests, providing a realistic environment for testing the application's routing and response generation."
    },
    {
      "name": "test_path_is_url",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 102,
      "end_line_number": 107,
      "source_code": "def test_path_is_url(app):\n    eb = EnvironBuilder(app, \"https://example.com/\")\n    assert eb.url_scheme == \"https\"\n    assert eb.host == \"example.com\"\n    assert eb.script_root == \"\"\n    assert eb.path == \"/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert eb.url_scheme == 'https'",
        "assert eb.host == 'example.com'",
        "assert eb.script_root == ''",
        "assert eb.path == '/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_environbuilder_json_dumps",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 110,
      "end_line_number": 114,
      "source_code": "def test_environbuilder_json_dumps(app):\n    \"\"\"EnvironBuilder.json_dumps() takes settings from the app.\"\"\"\n    app.json.ensure_ascii = False\n    eb = EnvironBuilder(app, json=\"\\u20ac\")\n    assert eb.input_stream.read().decode(\"utf8\") == '\"\\u20ac\"'",
      "docstring": "EnvironBuilder.json_dumps() takes settings from the app.",
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert eb.input_stream.read().decode('utf8') == '\"\u20ac\"'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "eb.input_stream.read",
          "body": "@app.route('/read')\ndef read():\n    return str(flask.session.get('foo', 0))"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_environbuilder_json_dumps` test is to verify that the `EnvironBuilder` class correctly serializes JSON data when provided with specific application settings, particularly ensuring that the `json_dumps` method respects the application's configuration regarding ASCII encoding.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `input_stream` of the `EnvironBuilder` instance correctly reads and decodes a JSON string containing a non-ASCII character (the Euro sign, `\u20ac`). It asserts that the output matches the expected JSON representation of the Euro sign, confirming that the `json_dumps` method is functioning as intended.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `EnvironBuilder` class from the `werkzeug.test` module, which is designed to create a test environment for Flask applications. The `json` parameter in the `EnvironBuilder` constructor is serialized as JSON and passed as the request body. The test sets `app.json.ensure_ascii` to `False`, allowing non-ASCII characters to be included in the JSON output. The `input_stream.read()` method is then called to read the serialized JSON data, which is expected to decode to the string representation of the Euro sign.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the expected output against the actual output, a common practice in unit testing. It also utilizes dependency injection by passing the `app` fixture, which provides a configured Flask application context for the test. This approach allows for isolated testing of the `EnvironBuilder` functionality without requiring a full application runtime, thus adhering to best practices in unit testing."
    },
    {
      "name": "test_blueprint_with_subdomain",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 117,
      "end_line_number": 138,
      "source_code": "def test_blueprint_with_subdomain():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"example.com:1234\"\n    app.config[\"APPLICATION_ROOT\"] = \"/foo\"\n    client = app.test_client()\n\n    bp = flask.Blueprint(\"company\", __name__, subdomain=\"xxx\")\n\n    @bp.route(\"/\")\n    def index():\n        return flask.request.url\n\n    app.register_blueprint(bp)\n\n    ctx = app.test_request_context(\"/\", subdomain=\"xxx\")\n    assert ctx.request.url == \"http://xxx.example.com:1234/foo/\"\n\n    with ctx:\n        assert ctx.request.blueprint == bp.name\n\n    rv = client.get(\"/\", subdomain=\"xxx\")\n    assert rv.data == b\"http://xxx.example.com:1234/foo/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert ctx.request.url == 'http://xxx.example.com:1234/foo/'",
        "assert rv.data == b'http://xxx.example.com:1234/foo/'",
        "assert ctx.request.blueprint == bp.name"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_blueprint_with_subdomain` function is designed to verify the correct behavior of Flask blueprints when used with subdomains. It ensures that requests to a specific subdomain are routed correctly and that the application responds with the expected URL and blueprint information.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a request is made to the subdomain \"xxx\", the application returns the correct URL and identifies the active blueprint. It asserts that the constructed request URL matches the expected format and that the blueprint context is correctly set during the request.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Flask application with subdomain support and registers a blueprint with a specified subdomain. It creates a test request context for the subdomain \"xxx\" and checks the constructed URL. The test also uses a test client to simulate a GET request to the blueprint's route and verifies that the response data matches the expected URL. The relevant code being tested includes the Flask app's routing and blueprint registration mechanisms.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several key testing techniques:\n- **Context Management**: It uses `app.test_request_context()` to create a context for simulating requests, allowing for assertions on request properties.\n- **Assertions**: It includes multiple assertions to validate the expected outcomes, ensuring that both the URL and blueprint context are correct.\n- **Blueprint Registration**: The test demonstrates the use of Flask blueprints, showcasing how they can be registered with specific subdomains and how routing works in that context."
    },
    {
      "name": "test_redirect_keep_session",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 141,
      "end_line_number": 166,
      "source_code": "def test_redirect_keep_session(app, client, app_ctx):\n    @app.route(\"/\", methods=[\"GET\", \"POST\"])\n    def index():\n        if flask.request.method == \"POST\":\n            return flask.redirect(\"/getsession\")\n        flask.session[\"data\"] = \"foo\"\n        return \"index\"\n\n    @app.route(\"/getsession\")\n    def get_session():\n        return flask.session.get(\"data\", \"<missing>\")\n\n    with client:\n        rv = client.get(\"/getsession\")\n        assert rv.data == b\"<missing>\"\n\n        rv = client.get(\"/\")\n        assert rv.data == b\"index\"\n        assert flask.session.get(\"data\") == \"foo\"\n\n        rv = client.post(\"/\", data={}, follow_redirects=True)\n        assert rv.data == b\"foo\"\n        assert flask.session.get(\"data\") == \"foo\"\n\n        rv = client.get(\"/getsession\")\n        assert rv.data == b\"foo\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client",
        "app_ctx"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'<missing>'",
        "assert rv.data == b'index'",
        "assert flask.session.get('data') == 'foo'",
        "assert rv.data == b'foo'",
        "assert flask.session.get('data') == 'foo'",
        "assert rv.data == b'foo'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "flask.session.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "flask.redirect",
          "body": "def redirect(location, code=302):\n    raise ValueError"
        },
        {
          "name": "flask.session.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "flask.session.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_redirect_keep_session` function is designed to verify that session data is preserved across redirects in a Flask application. It ensures that when a user interacts with the application, the session state remains consistent and accessible after a redirect.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks the following behaviors:\n1. Initially, accessing the `/getsession` route returns a default value indicating that the session data is missing.\n2. When a GET request is made to the root route (`/`), it sets a session variable and returns a response.\n3. A POST request to the root route redirects to `/getsession`, and the session data should still be accessible, confirming that the session persists across the redirect.\n\n**Code Being Tested and How It Works**:  \nThe test defines two routes:\n- The `index` route handles both GET and POST requests. For GET requests, it sets a session variable `data` to \"foo\" and returns \"index\". For POST requests, it redirects to the `/getsession` route.\n- The `get_session` route retrieves the session variable `data` and returns its value or a default message if it is not set.\n\nThe test uses the Flask test client to simulate requests to these routes and checks the responses and session state at various points.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The test uses a context manager (`with client:`) to ensure that the test client is properly set up and torn down, maintaining the application context.\n- **Assertions**: Multiple assertions are employed to verify the expected outcomes after each request, ensuring that the session behaves as intended.\n- **Follow Redirects**: The test checks the behavior of the application when following redirects, which is crucial for validating session persistence in web applications."
    },
    {
      "name": "test_session_transactions",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 169,
      "end_line_number": 183,
      "source_code": "def test_session_transactions(app, client):\n    @app.route(\"/\")\n    def index():\n        return str(flask.session[\"foo\"])\n\n    with client:\n        with client.session_transaction() as sess:\n            assert len(sess) == 0\n            sess[\"foo\"] = [42]\n            assert len(sess) == 1\n        rv = client.get(\"/\")\n        assert rv.data == b\"[42]\"\n        with client.session_transaction() as sess:\n            assert len(sess) == 1\n            assert sess[\"foo\"] == [42]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'[42]'",
        "assert len(sess) == 0",
        "assert len(sess) == 1",
        "assert len(sess) == 1",
        "assert sess['foo'] == [42]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_session_transactions` function is designed to verify the correct behavior of session transactions in a Flask application. It ensures that session data can be modified and accessed correctly within a request context.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. A session can be initialized and modified within a `session_transaction` context.\n2. The session data persists across requests.\n3. The session behaves as expected when accessed after modifications.\n\n**Code Being Tested and How It Works**:  \nThe test defines a simple Flask route (`index`) that returns the value of a session variable `foo`. It uses the Flask test client to:\n1. Open a session transaction, check its initial state, and set `foo` to a list containing the integer 42.\n2. Make a GET request to the index route and assert that the response data matches the expected string representation of the list.\n3. Open another session transaction to verify that the session still contains the expected data after the GET request.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The use of `with client.session_transaction()` allows for safe modification of session data within a controlled context, ensuring that changes are applied correctly and automatically cleaned up afterward.\n- **Assertions**: The test employs assertions to validate the state of the session before and after modifications, as well as the correctness of the response from the route.\n- **Isolation of Tests**: Each test is self-contained, ensuring that the session state does not leak between tests, which is crucial for reliable unit testing."
    },
    {
      "name": "test_session_transactions_no_null_sessions",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 186,
      "end_line_number": 193,
      "source_code": "def test_session_transactions_no_null_sessions():\n    app = flask.Flask(__name__)\n\n    with app.test_client() as c:\n        with pytest.raises(RuntimeError) as e:\n            with c.session_transaction():\n                pass\n        assert \"Session backend did not open a session\" in str(e.value)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'Session backend did not open a session' in str(e.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_session_transactions_keep_context",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 196,
      "end_line_number": 201,
      "source_code": "def test_session_transactions_keep_context(app, client, req_ctx):\n    client.get(\"/\")\n    req = flask.request._get_current_object()\n    assert req is not None\n    with client.session_transaction():\n        assert req is flask.request._get_current_object()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client",
        "req_ctx"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert req is not None",
        "assert req is flask.request._get_current_object()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_session_transactions_keep_context` test is designed to verify that the request context is preserved when using Flask's session transactions. This ensures that any modifications made to the session within the transaction block are associated with the correct request context.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the request object retrieved before entering the session transaction remains the same after entering the transaction. This confirms that the session transaction does not alter the current request context, which is crucial for maintaining the integrity of request-specific data during session modifications.\n\n**Code Being Tested and How It Works**:  \nThe test first makes a GET request to the root endpoint (\"/\"), which initializes the request context. It then retrieves the current request object using `flask.request._get_current_object()`. Inside the `with client.session_transaction():` block, it again retrieves the current request object and asserts that it is the same as the one obtained before entering the block. This is facilitated by Flask's test client, which manages the request and session contexts appropriately.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The use of `with` statements to manage the session transaction and request context ensures that resources are properly handled and that the context is correctly pushed and popped.\n- **Assertions**: The test employs assertions to validate that the request object remains consistent before and after the session transaction, which is a common practice in unit testing to confirm expected behavior.\n- **Isolation of Tests**: By using Flask's test client, the test is isolated from the actual application environment, allowing for safe manipulation of session data without affecting the real application state."
    },
    {
      "name": "test_session_transaction_needs_cookies",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 204,
      "end_line_number": 209,
      "source_code": "def test_session_transaction_needs_cookies(app):\n    c = app.test_client(use_cookies=False)\n\n    with pytest.raises(TypeError, match=\"Cookies are disabled.\"):\n        with c.session_transaction():\n            pass",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_test_client_context_binding",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 212,
      "end_line_number": 238,
      "source_code": "def test_test_client_context_binding(app, client):\n    app.testing = False\n\n    @app.route(\"/\")\n    def index():\n        flask.g.value = 42\n        return \"Hello World!\"\n\n    @app.route(\"/other\")\n    def other():\n        raise ZeroDivisionError\n\n    with client:\n        resp = client.get(\"/\")\n        assert flask.g.value == 42\n        assert resp.data == b\"Hello World!\"\n        assert resp.status_code == 200\n\n    with client:\n        resp = client.get(\"/other\")\n        assert not hasattr(flask.g, \"value\")\n        assert b\"Internal Server Error\" in resp.data\n        assert resp.status_code == 500\n        flask.g.value = 23\n\n    with pytest.raises(RuntimeError):\n        flask.g.value",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.g.value == 42",
        "assert resp.data == b'Hello World!'",
        "assert resp.status_code == 200",
        "assert not hasattr(flask.g, 'value')",
        "assert b'Internal Server Error' in resp.data",
        "assert resp.status_code == 500"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_test_client_context_binding` function is designed to verify the behavior of Flask's application context and the request context when using the test client. It ensures that the context is correctly bound to the client requests and that the application behaves as expected when handling requests that manipulate the global context (`flask.g`) and when exceptions occur.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main scenarios: \n1. When a valid request is made to the root endpoint (\"/\"), it verifies that the global variable `flask.g.value` is set correctly and that the response data and status code are as expected.\n2. When a request is made to an endpoint that raises an exception (\"/other\"), it verifies that the global variable `flask.g.value` is not present, the response indicates an internal server error, and the status code reflects the error.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes two Flask route handlers:\n- The `index` function sets `flask.g.value` to 42 and returns \"Hello World!\" when the root endpoint is accessed.\n- The `other` function raises a `ZeroDivisionError`, simulating an error scenario. \n\nThe test client is used to make GET requests to these endpoints, and assertions are made to check the state of `flask.g` and the response data and status codes.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The test uses the `with client:` context manager to ensure that the request context is properly set up and torn down for each request.\n- **Assertions**: The test employs assertions to validate the expected outcomes, including checking for the presence of attributes in `flask.g`, response data, and status codes.\n- **Exception Handling**: The test checks for the correct handling of exceptions by asserting that a `RuntimeError` is raised when attempting to access `flask.g.value` after it has been cleared due to an error in the request. \n\nOverall, this test effectively demonstrates the use of Flask's testing capabilities to validate application behavior in different scenarios."
    },
    {
      "name": "test_reuse_client",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 241,
      "end_line_number": 248,
      "source_code": "def test_reuse_client(client):\n    c = client\n\n    with c:\n        assert client.get(\"/\").status_code == 404\n\n    with c:\n        assert client.get(\"/\").status_code == 404",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "client"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/').status_code == 404",
        "assert client.get('/').status_code == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_reuse_client` function is designed to verify that the Flask test client can be reused across multiple requests within the same context. It checks that the client maintains its state and behaves consistently when making repeated requests.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically verifies that when the client makes a GET request to the root endpoint (\"/\"), it consistently returns a 404 status code. This indicates that the endpoint is not found, which is expected behavior since there is no route defined for the root URL in the provided code.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the Flask application\u2019s routing mechanism, particularly the handling of requests to the root URL (\"/\"). The test uses the `client.get(\"/\")` method to send a GET request to the root URL. The expected behavior is that the application responds with a 404 status code, which is asserted in the test. The test client (`client`) is passed as an argument, allowing it to be reused in a context manager (`with c:`), which ensures that the client is properly managed and closed after use.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The use of the `with` statement allows for proper management of the client\u2019s context, ensuring that resources are cleaned up after the test completes.\n- **Reusability**: The test demonstrates the ability to reuse the same client instance for multiple requests, which is a common pattern in testing web applications to ensure that state is preserved across requests.\n- **Assertions**: The test employs assertions to validate the expected outcome (404 status code), which is a fundamental aspect of unit testing to confirm that the code behaves as intended."
    },
    {
      "name": "test_full_url_request",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 251,
      "end_line_number": 260,
      "source_code": "def test_full_url_request(app, client):\n    @app.route(\"/action\", methods=[\"POST\"])\n    def action():\n        return \"x\"\n\n    with client:\n        rv = client.post(\"http://domain.com/action?vodka=42\", data={\"gin\": 43})\n        assert rv.status_code == 200\n        assert \"gin\" in flask.request.form\n        assert \"vodka\" in flask.request.args",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 200",
        "assert 'gin' in flask.request.form",
        "assert 'vodka' in flask.request.args"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_full_url_request` unit test is designed to verify the behavior of a Flask application when handling a POST request to a specific route (`/action`). It checks that the application correctly processes form data and query parameters, ensuring that the expected data is accessible within the request context.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically verifies that:\n1. The status code of the response is 200, indicating a successful request.\n2. The form data sent in the request contains the key \"gin\".\n3. The query parameters in the request contain the key \"vodka\".\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a Flask route defined within the test itself, which responds to POST requests at the `/action` endpoint. The test uses the Flask test client to simulate a POST request to this endpoint with a URL that includes a query parameter (`vodka=42`) and form data (`gin=43`). The assertions check that the response status is 200 and that the expected keys are present in the request context.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The test uses a `with` statement to manage the Flask test client context, ensuring that the application context is properly set up and torn down.\n- **Assertions**: The test employs assertions to validate the response status and the presence of specific keys in the request context, which is a common practice in unit testing to confirm expected outcomes.\n- **Inline Route Definition**: The route for the action is defined inline within the test, allowing for isolated testing of the specific functionality without affecting the global application state."
    },
    {
      "name": "test_json_request_and_response",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 263,
      "end_line_number": 279,
      "source_code": "def test_json_request_and_response(app, client):\n    @app.route(\"/echo\", methods=[\"POST\"])\n    def echo():\n        return jsonify(flask.request.get_json())\n\n    with client:\n        json_data = {\"drink\": {\"gin\": 1, \"tonic\": True}, \"price\": 10}\n        rv = client.post(\"/echo\", json=json_data)\n\n        # Request should be in JSON\n        assert flask.request.is_json\n        assert flask.request.get_json() == json_data\n\n        # Response should be in JSON\n        assert rv.status_code == 200\n        assert rv.is_json\n        assert rv.get_json() == json_data",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.request.is_json",
        "assert flask.request.get_json() == json_data",
        "assert rv.status_code == 200",
        "assert rv.is_json",
        "assert rv.get_json() == json_data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_json_request_and_response` test is to verify that the Flask application correctly handles JSON requests and responses. It ensures that the application can accept JSON data in a POST request and return the same data in the response, confirming the integrity of the data transfer.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks two main behaviors: \n1. It verifies that the incoming request is correctly identified as JSON and that the data received matches the expected JSON structure.\n2. It confirms that the response from the server is also in JSON format and that it contains the same data that was sent in the request.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a Flask route defined at `/echo` that accepts POST requests. The route uses `flask.request.get_json()` to retrieve the JSON data sent in the request and returns it using `jsonify()`, which serializes the data into a JSON response. The test uses a test client to simulate a POST request with a JSON payload, checking both the request and response properties.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Context Management**: It uses a context manager (`with client:`) to ensure that the test client is properly set up and torn down, allowing for clean request handling.\n- **Assertions**: Multiple assertions are used to validate the expected outcomes, including checking the status code, content type, and the actual data returned.\n- **Isolation**: The test is isolated from other tests, ensuring that it does not depend on any external state or data, which is a key principle in unit testing."
    },
    {
      "name": "test_client_json_no_app_context",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 282,
      "end_line_number": 299,
      "source_code": "def test_client_json_no_app_context(app, client):\n    @app.route(\"/hello\", methods=[\"POST\"])\n    def hello():\n        return f\"Hello, {flask.request.json['name']}!\"\n\n    class Namespace:\n        count = 0\n\n        def add(self, app):\n            self.count += 1\n\n    ns = Namespace()\n\n    with appcontext_popped.connected_to(ns.add, app):\n        rv = client.post(\"/hello\", json={\"name\": \"Flask\"})\n\n    assert rv.get_data(as_text=True) == \"Hello, Flask!\"\n    assert ns.count == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.get_data(as_text=True) == 'Hello, Flask!'",
        "assert ns.count == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_client_json_no_app_context` test is designed to verify the behavior of a Flask application route when handling a JSON POST request without an active application context. It ensures that the application can correctly process the request and return the expected response while also testing the interaction with a custom context manager.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the `/hello` route correctly responds with a greeting message that includes the name provided in the JSON payload. Additionally, it verifies that a custom namespace's `count` attribute is incremented when the application context is popped and connected to the `add` method of the `Namespace` class.\n\n**Code Being Tested and How It Works**:  \nThe code under test defines a Flask route `/hello` that expects a JSON payload containing a `name` key. When a POST request is made to this route with a JSON body (e.g., `{\"name\": \"Flask\"}`), the route handler constructs a greeting string using the provided name. The test also utilizes a custom `Namespace` class to track how many times the `add` method is called, which is triggered by the `appcontext_popped.connected_to(ns.add, app)` context manager.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The test employs Flask's context management features, specifically using `appcontext_popped.connected_to`, to manage the application context and ensure that the `add` method is called correctly.\n- **Assertions**: The test includes assertions to verify both the response data from the POST request and the state of the `Namespace` instance, ensuring that the expected behavior occurs.\n- **JSON Handling**: The test demonstrates how to send and receive JSON data in Flask, validating that the application can correctly parse incoming JSON requests and generate appropriate responses."
    },
    {
      "name": "test_subdomain",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 302,
      "end_line_number": 318,
      "source_code": "def test_subdomain():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"example.com\"\n    client = app.test_client()\n\n    @app.route(\"/\", subdomain=\"<company_id>\")\n    def view(company_id):\n        return company_id\n\n    with app.test_request_context():\n        url = flask.url_for(\"view\", company_id=\"xxx\")\n\n    with client:\n        response = client.get(url)\n\n    assert 200 == response.status_code\n    assert b\"xxx\" == response.data",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert 200 == response.status_code",
        "assert b'xxx' == response.data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_subdomain` function is designed to verify that a Flask application correctly handles requests to a route that is defined with a subdomain parameter. It ensures that the application can properly route requests based on subdomain information and return the expected response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a request is made to the root route (\"/\") with a subdomain parameter (`company_id`), the application returns the correct HTTP status code (200) and the expected response data (the value of `company_id`).\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a Flask route defined as `@app.route(\"/\", subdomain=\"<company_id>\")`, which captures the subdomain as a parameter. The test creates a Flask application with subdomain matching enabled and sets the server name to \"example.com\". It constructs a URL for the route using `flask.url_for` with a specific `company_id` (\"xxx\"). The test then sends a GET request to this URL using the test client and asserts that the response status code is 200 and the response data matches the expected byte string `b\"xxx\"`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Test Client**: The test utilizes Flask's built-in test client to simulate HTTP requests to the application, allowing for easy verification of responses.\n- **Request Context**: The test employs `app.test_request_context()` to create a context for the request, which is necessary for generating URLs with `flask.url_for` that depend on the application's routing configuration.\n- **Assertions**: The test uses assertions to validate the response's status code and data, ensuring that the application behaves as expected under the defined conditions."
    },
    {
      "name": "test_nosubdomain",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 321,
      "end_line_number": 335,
      "source_code": "def test_nosubdomain(app, client):\n    app.config[\"SERVER_NAME\"] = \"example.com\"\n\n    @app.route(\"/<company_id>\")\n    def view(company_id):\n        return company_id\n\n    with app.test_request_context():\n        url = flask.url_for(\"view\", company_id=\"xxx\")\n\n    with client:\n        response = client.get(url)\n\n    assert 200 == response.status_code\n    assert b\"xxx\" == response.data",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert 200 == response.status_code",
        "assert b'xxx' == response.data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_nosubdomain` function is designed to verify that the Flask application correctly handles requests to a route that does not utilize subdomains. It ensures that the application can successfully return the expected response when accessed via a specific URL pattern.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a GET request is made to the route defined by `/<company_id>`, the application returns a status code of 200 (indicating success) and that the response data matches the expected company ID (\"xxx\"). This confirms that the routing and request handling are functioning as intended without subdomain considerations.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a Flask route defined as `@app.route(\"/<company_id>\")`, which captures a variable part of the URL (the `company_id`). When a request is made to this route, the `view` function is invoked, returning the `company_id` as the response. The test sets up a request context and constructs the URL using `flask.url_for`, then sends a GET request to that URL using the test client. The assertions check both the response status and the content.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Test Request Context**: It uses `app.test_request_context()` to simulate a request context, allowing the use of `url_for` to generate the correct URL for the route.\n- **Client Simulation**: The `client` is used to simulate HTTP requests to the application, enabling the testing of response behavior.\n- **Assertions**: The test includes assertions to validate the response status code and data, ensuring that the application behaves as expected under the defined conditions."
    },
    {
      "name": "test_cli_runner_class",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 338,
      "end_line_number": 347,
      "source_code": "def test_cli_runner_class(app):\n    runner = app.test_cli_runner()\n    assert isinstance(runner, FlaskCliRunner)\n\n    class SubRunner(FlaskCliRunner):\n        pass\n\n    app.test_cli_runner_class = SubRunner\n    runner = app.test_cli_runner()\n    assert isinstance(runner, SubRunner)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(runner, FlaskCliRunner)",
        "assert isinstance(runner, SubRunner)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_cli_invoke",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 350,
      "end_line_number": 361,
      "source_code": "def test_cli_invoke(app):\n    @app.cli.command(\"hello\")\n    def hello_command():\n        click.echo(\"Hello, World!\")\n\n    runner = app.test_cli_runner()\n    # invoke with command name\n    result = runner.invoke(args=[\"hello\"])\n    assert \"Hello\" in result.output\n    # invoke with command object\n    result = runner.invoke(hello_command)\n    assert \"Hello\" in result.output",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'Hello' in result.output",
        "assert 'Hello' in result.output"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        },
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_cli_invoke` function is designed to verify the functionality of a command-line interface (CLI) command defined in a Flask application. Specifically, it tests that the command correctly outputs the expected string when invoked.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that invoking the `hello` command, both by its name and directly as a command object, produces output that contains the string \"Hello\". This ensures that the command is registered correctly and behaves as intended when executed.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `hello_command` function, which is registered as a CLI command using the `@app.cli.command(\"hello\")` decorator. When this command is invoked, it uses `click.echo` to print \"Hello, World!\" to the output. The test uses the `app.test_cli_runner()` to create a test runner that simulates command-line invocations. The `runner.invoke` method is called twice: first with the command name as an argument and second with the command object directly.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of the `FlaskCliRunner`, which is a specialized test runner for Flask CLI commands. It also utilizes assertions to verify that the expected output is present in the result of the command invocation. The test structure follows a clear pattern of setup (defining the command), execution (invoking the command), and verification (asserting the output), which is a common practice in unit testing to ensure clarity and maintainability."
    },
    {
      "name": "test_cli_custom_obj",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 364,
      "end_line_number": 379,
      "source_code": "def test_cli_custom_obj(app):\n    class NS:\n        called = False\n\n    def create_app():\n        NS.called = True\n        return app\n\n    @app.cli.command(\"hello\")\n    def hello_command():\n        click.echo(\"Hello, World!\")\n\n    script_info = ScriptInfo(create_app=create_app)\n    runner = app.test_cli_runner()\n    runner.invoke(hello_command, obj=script_info)\n    assert NS.called",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert NS.called"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_cli_custom_obj` function is designed to verify that a custom application context can be created and utilized within a Flask CLI command. Specifically, it checks whether the `create_app` function is called when invoking the CLI command, ensuring that the application context is properly set up.\n\n**Specific Functionality or Behavior Verified**:  \nThis test confirms that the `create_app` function is executed when the CLI command `hello_command` is invoked. It asserts that the `NS.called` flag is set to `True`, indicating that the application creation logic was triggered as expected.\n\n**Code Being Tested and How It Works**:  \nThe test defines a class `NS` with a class variable `called`, which is initially set to `False`. The `create_app` function modifies this variable to `True` when called. The `hello_command` function is a simple CLI command that outputs \"Hello, World!\" to the console. The test uses `app.test_cli_runner()` to create a CLI runner and invokes the `hello_command` with a `ScriptInfo` object that includes the `create_app` function. After the command is executed, the test checks if `NS.called` is `True`, confirming that `create_app` was invoked.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Class Variable for State Tracking**: The use of a class variable (`NS.called`) allows the test to track whether the `create_app` function was called without needing to modify the global state or use more complex mocking.\n- **Flask CLI Testing**: The test leverages Flask's built-in CLI testing capabilities (`test_cli_runner`) to simulate command-line interactions, which is a common pattern in testing CLI applications.\n- **Separation of Concerns**: The test clearly separates the command definition, application creation, and invocation logic, making it easier to understand and maintain."
    },
    {
      "name": "test_client_pop_all_preserved",
      "module": "test_testing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_testing.py",
      "line_number": 382,
      "end_line_number": 396,
      "source_code": "def test_client_pop_all_preserved(app, req_ctx, client):\n    @app.route(\"/\")\n    def index():\n        # stream_with_context pushes a third context, preserved by response\n        return flask.stream_with_context(\"hello\")\n\n    # req_ctx fixture pushed an initial context\n    with client:\n        # request pushes a second request context, preserved by client\n        rv = client.get(\"/\")\n\n    # close the response, releasing the context held by stream_with_context\n    rv.close()\n    # only req_ctx fixture should still be pushed\n    assert _cv_request.get(None) is req_ctx",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "req_ctx",
        "client"
      ],
      "imports": [
        "importlib.metadata",
        "click",
        "pytest",
        "flask",
        "flask.appcontext_popped",
        "flask.cli.ScriptInfo",
        "flask.globals._cv_request",
        "flask.json.jsonify",
        "flask.testing.EnvironBuilder",
        "flask.testing.FlaskCliRunner"
      ],
      "fixtures": [],
      "assertions": [
        "assert _cv_request.get(None) is req_ctx"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "_cv_request.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_client_pop_all_preserved` is designed to verify that the Flask request context behaves correctly when using `stream_with_context`. Specifically, it checks that after a response is closed, only the initial request context remains active, ensuring that the context management is functioning as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThe test confirms that when a response generated by `stream_with_context` is closed, the request context created by the client is properly released, and only the request context pushed by the `req_ctx` fixture remains. This ensures that the context management does not leak or retain unnecessary contexts after the response is completed.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `client.get(\"/\")` method, which triggers the route defined in the test. The route uses `flask.stream_with_context` to create a streaming response. After the response is obtained, `rv.close()` is called to close the response, which should release the context held by `stream_with_context`. The assertion checks that the current request context (`_cv_request.get(None)`) is the same as the initial context (`req_ctx`), indicating that the other contexts have been properly cleaned up.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs context management patterns, specifically using Flask's context stack to manage request and application contexts. It also utilizes assertions to validate the state of the context after performing operations that should modify it. The use of fixtures (`app`, `req_ctx`, `client`) is a notable technique that helps set up the necessary environment for the test, ensuring isolation and repeatability."
    },
    {
      "name": "test_explicit_instance_paths",
      "module": "test_instance_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_instance_config.py",
      "line_number": 8,
      "end_line_number": 13,
      "source_code": "def test_explicit_instance_paths(modules_tmp_path):\n    with pytest.raises(ValueError, match=\".*must be absolute\"):\n        flask.Flask(__name__, instance_path=\"instance\")\n\n    app = flask.Flask(__name__, instance_path=os.fspath(modules_tmp_path))\n    assert app.instance_path == os.fspath(modules_tmp_path)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "modules_tmp_path"
      ],
      "imports": [
        "os",
        "pytest",
        "flask",
        "config_module_app.app",
        "config_package_app.app",
        "namespace.package2.app",
        "site_app.app",
        "installed_package.app",
        "site_package"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.instance_path == os.fspath(modules_tmp_path)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_uninstalled_module_paths",
      "module": "test_instance_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_instance_config.py",
      "line_number": 16,
      "end_line_number": 27,
      "source_code": "def test_uninstalled_module_paths(modules_tmp_path, purge_module):\n    (modules_tmp_path / \"config_module_app.py\").write_text(\n        \"import os\\n\"\n        \"import flask\\n\"\n        \"here = os.path.abspath(os.path.dirname(__file__))\\n\"\n        \"app = flask.Flask(__name__)\\n\"\n    )\n    purge_module(\"config_module_app\")\n\n    from config_module_app import app\n\n    assert app.instance_path == os.fspath(modules_tmp_path / \"instance\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "modules_tmp_path",
        "purge_module"
      ],
      "imports": [
        "os",
        "pytest",
        "flask",
        "config_module_app.app",
        "config_package_app.app",
        "namespace.package2.app",
        "site_app.app",
        "installed_package.app",
        "site_package"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.instance_path == os.fspath(modules_tmp_path / 'instance')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "purge_module",
          "body": "@pytest.fixture\ndef purge_module(request):\n\n    def inner(name):\n        request.addfinalizer(lambda : sys.modules.pop(name, None))\n    return inner"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_uninstalled_module_paths` function aims to verify that a Flask application can be correctly instantiated from a dynamically created module, even when that module is not installed in the standard Python package structure. This ensures that the application behaves as expected when loaded from a temporary path.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that the `instance_path` attribute of the Flask application instance (`app`) is set correctly to the expected temporary directory path. This is crucial for Flask applications that rely on instance-specific configurations and resources.\n\n**Code Being Tested and How It Works**:  \nThe test creates a temporary Python module named `config_module_app.py` that imports Flask and initializes a Flask application. The `purge_module` fixture is used to remove the module from `sys.modules` after it is imported, simulating a scenario where the module is not installed. The test then imports the `app` object from this module and asserts that its `instance_path` matches the expected path derived from `modules_tmp_path`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Dynamic Module Creation**: The test dynamically creates a module and writes it to a temporary path, allowing for testing of module loading behavior without needing a physical installation.\n- **Fixture Usage**: The `purge_module` fixture is employed to ensure that the module is removed from the module cache after the test, preventing side effects on subsequent tests.\n- **Path Manipulation**: The test uses `os.fspath` to ensure compatibility with different filesystem path representations, enhancing portability across platforms."
    },
    {
      "name": "test_uninstalled_package_paths",
      "module": "test_instance_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_instance_config.py",
      "line_number": 30,
      "end_line_number": 43,
      "source_code": "def test_uninstalled_package_paths(modules_tmp_path, purge_module):\n    app = modules_tmp_path / \"config_package_app\"\n    app.mkdir()\n    (app / \"__init__.py\").write_text(\n        \"import os\\n\"\n        \"import flask\\n\"\n        \"here = os.path.abspath(os.path.dirname(__file__))\\n\"\n        \"app = flask.Flask(__name__)\\n\"\n    )\n    purge_module(\"config_package_app\")\n\n    from config_package_app import app\n\n    assert app.instance_path == os.fspath(modules_tmp_path / \"instance\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "modules_tmp_path",
        "purge_module"
      ],
      "imports": [
        "os",
        "pytest",
        "flask",
        "config_module_app.app",
        "config_package_app.app",
        "namespace.package2.app",
        "site_app.app",
        "installed_package.app",
        "site_package"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.instance_path == os.fspath(modules_tmp_path / 'instance')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "purge_module",
          "body": "@pytest.fixture\ndef purge_module(request):\n\n    def inner(name):\n        request.addfinalizer(lambda : sys.modules.pop(name, None))\n    return inner"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_uninstalled_package_paths` function is designed to verify that a Flask application can be correctly instantiated from an uninstalled package, ensuring that the application's instance path is set as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a Flask application is created from a package that is not installed in the standard Python environment, the `instance_path` attribute of the application object is correctly set to a specific temporary directory. This is crucial for applications that rely on instance-specific configurations or data.\n\n**Code Being Tested and How It Works**:  \nThe test creates a temporary directory structure that mimics an uninstalled package named `config_package_app`. It writes a minimal `__init__.py` file that imports Flask and initializes an app instance. The `purge_module` fixture is used to ensure that any previous imports of `config_package_app` are removed from `sys.modules`, allowing the test to import the freshly created module. After importing the app, the test asserts that the `instance_path` of the app matches the expected path derived from `modules_tmp_path`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The test utilizes the `purge_module` fixture to manage module imports, ensuring a clean state for each test run.\n- **Temporary Path Management**: The `modules_tmp_path` fixture creates a temporary directory structure, allowing for isolated testing without affecting the global Python environment.\n- **Dynamic Module Creation**: The test dynamically creates a package structure and imports it, which is a common pattern in testing scenarios where the code under test may not be installed or available in the standard library."
    },
    {
      "name": "test_uninstalled_namespace_paths",
      "module": "test_instance_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_instance_config.py",
      "line_number": 46,
      "end_line_number": 62,
      "source_code": "def test_uninstalled_namespace_paths(tmp_path, monkeypatch, purge_module):\n    def create_namespace(package):\n        project = tmp_path / f\"project-{package}\"\n        monkeypatch.syspath_prepend(os.fspath(project))\n        ns = project / \"namespace\" / package\n        ns.mkdir(parents=True)\n        (ns / \"__init__.py\").write_text(\"import flask\\napp = flask.Flask(__name__)\\n\")\n        return project\n\n    _ = create_namespace(\"package1\")\n    project2 = create_namespace(\"package2\")\n    purge_module(\"namespace.package2\")\n    purge_module(\"namespace\")\n\n    from namespace.package2 import app\n\n    assert app.instance_path == os.fspath(project2 / \"instance\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmp_path",
        "monkeypatch",
        "purge_module"
      ],
      "imports": [
        "os",
        "pytest",
        "flask",
        "config_module_app.app",
        "config_package_app.app",
        "namespace.package2.app",
        "site_app.app",
        "installed_package.app",
        "site_package"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.instance_path == os.fspath(project2 / 'instance')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "create_namespace",
          "body": "def create_namespace(package):\n    project = tmp_path / f'project-{package}'\n    monkeypatch.syspath_prepend(os.fspath(project))\n    ns = project / 'namespace' / package\n    ns.mkdir(parents=True)\n    (ns / '__init__.py').write_text('import flask\\napp = flask.Flask(__name__)\\n')\n    return project"
        },
        {
          "name": "create_namespace",
          "body": "def create_namespace(package):\n    project = tmp_path / f'project-{package}'\n    monkeypatch.syspath_prepend(os.fspath(project))\n    ns = project / 'namespace' / package\n    ns.mkdir(parents=True)\n    (ns / '__init__.py').write_text('import flask\\napp = flask.Flask(__name__)\\n')\n    return project"
        },
        {
          "name": "purge_module",
          "body": "@pytest.fixture\ndef purge_module(request):\n\n    def inner(name):\n        request.addfinalizer(lambda : sys.modules.pop(name, None))\n    return inner"
        },
        {
          "name": "purge_module",
          "body": "@pytest.fixture\ndef purge_module(request):\n\n    def inner(name):\n        request.addfinalizer(lambda : sys.modules.pop(name, None))\n    return inner"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_uninstalled_namespace_paths` test is designed to verify the behavior of Flask applications when dealing with uninstalled namespace packages. Specifically, it checks that the application instance path is correctly set when importing from a namespace package that has not been installed in the standard Python package directories.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the `app.instance_path` attribute of a Flask application is correctly resolved to the expected directory path when the application is created within a namespace package. It verifies that the application can be instantiated and that the instance path reflects the temporary project structure created during the test.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `create_namespace` helper function to create a temporary directory structure that simulates a namespace package. It uses `monkeypatch` to prepend the temporary project path to `sys.path`, allowing the test to import the Flask application from the namespace package. The `purge_module` fixture is used to ensure that any previously loaded modules are removed from `sys.modules`, allowing for a clean import of the application. Finally, the test asserts that the `app.instance_path` matches the expected path based on the temporary project structure.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Temporary File System**: The use of `tmp_path` allows for the creation of a temporary file system structure that is cleaned up after the test, ensuring isolation and preventing side effects on other tests.\n- **Monkeypatching**: The `monkeypatch` fixture is employed to modify `sys.path` dynamically, enabling the test to import the application from the created namespace without affecting the global state.\n- **Module Purging**: The `purge_module` fixture is a useful pattern for ensuring that the module is freshly imported, which is critical for tests that rely on module state.\n- **Assertions**: The test concludes with an assertion that checks the correctness of the `app.instance_path`, which is a direct verification of the expected behavior of the Flask application in the context of namespace packages."
    },
    {
      "name": "test_installed_module_paths",
      "module": "test_instance_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_instance_config.py",
      "line_number": 65,
      "end_line_number": 77,
      "source_code": "def test_installed_module_paths(\n    modules_tmp_path, modules_tmp_path_prefix, purge_module, site_packages, limit_loader\n):\n    (site_packages / \"site_app.py\").write_text(\n        \"import flask\\napp = flask.Flask(__name__)\\n\"\n    )\n    purge_module(\"site_app\")\n\n    from site_app import app\n\n    assert app.instance_path == os.fspath(\n        modules_tmp_path / \"var\" / \"site_app-instance\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "modules_tmp_path",
        "modules_tmp_path_prefix",
        "purge_module",
        "site_packages",
        "limit_loader"
      ],
      "imports": [
        "os",
        "pytest",
        "flask",
        "config_module_app.app",
        "config_package_app.app",
        "namespace.package2.app",
        "site_app.app",
        "installed_package.app",
        "site_package"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.instance_path == os.fspath(modules_tmp_path / 'var' / 'site_app-instance')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "purge_module",
          "body": "@pytest.fixture\ndef purge_module(request):\n\n    def inner(name):\n        request.addfinalizer(lambda : sys.modules.pop(name, None))\n    return inner"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_installed_module_paths` test verifies that a Flask application correctly sets its `instance_path` when the application is imported from a dynamically created module. This ensures that the application can locate its instance folder, which is crucial for storing instance-specific data.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the `instance_path` of the Flask app instance matches the expected path derived from a temporary directory structure. It ensures that the app's instance path is correctly set to `modules_tmp_path / \"var\" / \"site_app-instance\"` after the module is purged and re-imported.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves creating a temporary Python module (`site_app.py`) that imports Flask and initializes an app instance. The `purge_module` fixture is used to remove the module from `sys.modules`, allowing it to be re-imported fresh. After the app is imported, the test asserts that the `instance_path` property of the app matches the expected path, which is constructed using the `modules_tmp_path` fixture.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The test utilizes several fixtures (`modules_tmp_path`, `purge_module`, etc.) to set up the environment and clean up after the test, promoting reusability and isolation.\n- **Dynamic Module Creation**: The test dynamically creates a module to simulate real-world scenarios where Flask apps might be loaded from various sources.\n- **Path Assertions**: The test employs assertions to validate that the app's configuration is set correctly, ensuring that the behavior of the Flask app aligns with expectations in a controlled environment."
    },
    {
      "name": "test_installed_package_paths",
      "module": "test_instance_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_instance_config.py",
      "line_number": 80,
      "end_line_number": 96,
      "source_code": "def test_installed_package_paths(\n    limit_loader, modules_tmp_path, modules_tmp_path_prefix, purge_module, monkeypatch\n):\n    installed_path = modules_tmp_path / \"path\"\n    installed_path.mkdir()\n    monkeypatch.syspath_prepend(installed_path)\n\n    app = installed_path / \"installed_package\"\n    app.mkdir()\n    (app / \"__init__.py\").write_text(\"import flask\\napp = flask.Flask(__name__)\\n\")\n    purge_module(\"installed_package\")\n\n    from installed_package import app\n\n    assert app.instance_path == os.fspath(\n        modules_tmp_path / \"var\" / \"installed_package-instance\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "limit_loader",
        "modules_tmp_path",
        "modules_tmp_path_prefix",
        "purge_module",
        "monkeypatch"
      ],
      "imports": [
        "os",
        "pytest",
        "flask",
        "config_module_app.app",
        "config_package_app.app",
        "namespace.package2.app",
        "site_app.app",
        "installed_package.app",
        "site_package"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.instance_path == os.fspath(modules_tmp_path / 'var' / 'installed_package-instance')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "purge_module",
          "body": "@pytest.fixture\ndef purge_module(request):\n\n    def inner(name):\n        request.addfinalizer(lambda : sys.modules.pop(name, None))\n    return inner"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_installed_package_paths` function is designed to verify that a Flask application can be correctly instantiated from a dynamically created package located in a temporary directory. It ensures that the application instance's path is set correctly based on the temporary module's location.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the `instance_path` attribute of the Flask application instance matches the expected path derived from the temporary module's location. This confirms that the application is aware of its environment and can correctly resolve its instance path.\n\n**Code Being Tested and How It Works**:  \nThe test creates a temporary directory structure that mimics a Python package. It uses `monkeypatch` to prepend this directory to `sys.path`, allowing the test to import the `installed_package` module. The `purge_module` fixture is used to ensure that any previous imports of `installed_package` are cleared from `sys.modules`, allowing for a fresh import. The application is then instantiated, and the test asserts that the `instance_path` is correctly set to a path that combines the temporary module path with a specific subdirectory.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The test leverages several pytest fixtures (`purge_module`, `monkeypatch`, etc.) to manage the test environment, ensuring isolation and cleanup.\n- **Dynamic Module Creation**: It dynamically creates a package structure and modifies `sys.path` to simulate the installation of a package, which is a common pattern in testing Python applications.\n- **Assertions**: The test uses assertions to validate the expected behavior, specifically checking the `instance_path` of the Flask app, which is crucial for ensuring that the app can locate its resources correctly."
    },
    {
      "name": "test_prefix_package_paths",
      "module": "test_instance_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_instance_config.py",
      "line_number": 99,
      "end_line_number": 111,
      "source_code": "def test_prefix_package_paths(\n    limit_loader, modules_tmp_path, modules_tmp_path_prefix, purge_module, site_packages\n):\n    app = site_packages / \"site_package\"\n    app.mkdir()\n    (app / \"__init__.py\").write_text(\"import flask\\napp = flask.Flask(__name__)\\n\")\n    purge_module(\"site_package\")\n\n    import site_package\n\n    assert site_package.app.instance_path == os.fspath(\n        modules_tmp_path / \"var\" / \"site_package-instance\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "limit_loader",
        "modules_tmp_path",
        "modules_tmp_path_prefix",
        "purge_module",
        "site_packages"
      ],
      "imports": [
        "os",
        "pytest",
        "flask",
        "config_module_app.app",
        "config_package_app.app",
        "namespace.package2.app",
        "site_app.app",
        "installed_package.app",
        "site_package"
      ],
      "fixtures": [],
      "assertions": [
        "assert site_package.app.instance_path == os.fspath(modules_tmp_path / 'var' / 'site_package-instance')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "purge_module",
          "body": "@pytest.fixture\ndef purge_module(request):\n\n    def inner(name):\n        request.addfinalizer(lambda : sys.modules.pop(name, None))\n    return inner"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_prefix_package_paths` unit test is designed to verify that a Flask application instance's `instance_path` is correctly set when the application is imported from a package located in a temporary site-packages directory. This ensures that the application can correctly determine its instance path based on its location in the filesystem.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that the `instance_path` attribute of the Flask application instance (`site_package.app`) matches the expected path constructed from the temporary module path. This validates that the application is aware of its environment and can correctly resolve its instance path, which is crucial for functionalities like storing instance-specific data.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves creating a temporary directory structure that mimics a Python package (`site_package`). The test first creates this package and writes a minimal Flask application to its `__init__.py` file. It then uses the `purge_module` fixture to ensure that any previous imports of `site_package` are removed from `sys.modules`, allowing for a fresh import. After importing `site_package`, the test asserts that the `instance_path` of the Flask app matches the expected path, which is derived from the temporary module path.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The test utilizes several fixtures (`purge_module`, `modules_tmp_path`, `site_packages`) to set up the environment, ensuring that the test runs in isolation and does not affect other tests.\n- **Dynamic Module Management**: The `purge_module` fixture dynamically removes the module from `sys.modules`, allowing for re-importing without stale state, which is a common pattern in testing to avoid side effects from previous tests.\n- **Path Manipulation**: The test constructs paths using `os.fspath` and `pathlib`, which is a modern and robust way to handle filesystem paths in Python, ensuring compatibility across different operating systems."
    },
    {
      "name": "test_teardown_on_pop",
      "module": "test_reqctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_reqctx.py",
      "line_number": 16,
      "end_line_number": 27,
      "source_code": "def test_teardown_on_pop(app):\n    buffer = []\n\n    @app.teardown_request\n    def end_of_request(exception):\n        buffer.append(exception)\n\n    ctx = app.test_request_context()\n    ctx.push()\n    assert buffer == []\n    ctx.pop()\n    assert buffer == [None]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "warnings",
        "pytest",
        "flask",
        "flask.globals.request_ctx",
        "flask.sessions.SecureCookieSessionInterface",
        "flask.sessions.SessionInterface",
        "greenlet.greenlet",
        "flask.testing.EnvironBuilder",
        "flask.testing.EnvironBuilder"
      ],
      "fixtures": [],
      "assertions": [
        "assert buffer == []",
        "assert buffer == [None]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_teardown_with_previous_exception",
      "module": "test_reqctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_reqctx.py",
      "line_number": 30,
      "end_line_number": 44,
      "source_code": "def test_teardown_with_previous_exception(app):\n    buffer = []\n\n    @app.teardown_request\n    def end_of_request(exception):\n        buffer.append(exception)\n\n    try:\n        raise Exception(\"dummy\")\n    except Exception:\n        pass\n\n    with app.test_request_context():\n        assert buffer == []\n    assert buffer == [None]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "warnings",
        "pytest",
        "flask",
        "flask.globals.request_ctx",
        "flask.sessions.SecureCookieSessionInterface",
        "flask.sessions.SessionInterface",
        "greenlet.greenlet",
        "flask.testing.EnvironBuilder",
        "flask.testing.EnvironBuilder"
      ],
      "fixtures": [],
      "assertions": [
        "assert buffer == [None]",
        "assert buffer == []"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_teardown_with_handled_exception",
      "module": "test_reqctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_reqctx.py",
      "line_number": 47,
      "end_line_number": 60,
      "source_code": "def test_teardown_with_handled_exception(app):\n    buffer = []\n\n    @app.teardown_request\n    def end_of_request(exception):\n        buffer.append(exception)\n\n    with app.test_request_context():\n        assert buffer == []\n        try:\n            raise Exception(\"dummy\")\n        except Exception:\n            pass\n    assert buffer == [None]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "warnings",
        "pytest",
        "flask",
        "flask.globals.request_ctx",
        "flask.sessions.SecureCookieSessionInterface",
        "flask.sessions.SessionInterface",
        "greenlet.greenlet",
        "flask.testing.EnvironBuilder",
        "flask.testing.EnvironBuilder"
      ],
      "fixtures": [],
      "assertions": [
        "assert buffer == [None]",
        "assert buffer == []"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_proper_test_request_context",
      "module": "test_reqctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_reqctx.py",
      "line_number": 63,
      "end_line_number": 104,
      "source_code": "def test_proper_test_request_context(app):\n    app.config.update(SERVER_NAME=\"localhost.localdomain:5000\")\n\n    @app.route(\"/\")\n    def index():\n        return None\n\n    @app.route(\"/\", subdomain=\"foo\")\n    def sub():\n        return None\n\n    with app.test_request_context(\"/\"):\n        assert (\n            flask.url_for(\"index\", _external=True)\n            == \"http://localhost.localdomain:5000/\"\n        )\n\n    with app.test_request_context(\"/\"):\n        assert (\n            flask.url_for(\"sub\", _external=True)\n            == \"http://foo.localhost.localdomain:5000/\"\n        )\n\n    # suppress Werkzeug 0.15 warning about name mismatch\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\n            \"ignore\", \"Current server name\", UserWarning, \"flask.app\"\n        )\n        with app.test_request_context(\n            \"/\", environ_overrides={\"HTTP_HOST\": \"localhost\"}\n        ):\n            pass\n\n    app.config.update(SERVER_NAME=\"localhost\")\n    with app.test_request_context(\"/\", environ_overrides={\"SERVER_NAME\": \"localhost\"}):\n        pass\n\n    app.config.update(SERVER_NAME=\"localhost:80\")\n    with app.test_request_context(\n        \"/\", environ_overrides={\"SERVER_NAME\": \"localhost:80\"}\n    ):\n        pass",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "warnings",
        "pytest",
        "flask",
        "flask.globals.request_ctx",
        "flask.sessions.SecureCookieSessionInterface",
        "flask.sessions.SessionInterface",
        "greenlet.greenlet",
        "flask.testing.EnvironBuilder",
        "flask.testing.EnvironBuilder"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.url_for('index', _external=True) == 'http://localhost.localdomain:5000/'",
        "assert flask.url_for('sub', _external=True) == 'http://foo.localhost.localdomain:5000/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_context_binding",
      "module": "test_reqctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_reqctx.py",
      "line_number": 107,
      "end_line_number": 120,
      "source_code": "def test_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    @app.route(\"/meh\")\n    def meh():\n        return flask.request.url\n\n    with app.test_request_context(\"/?name=World\"):\n        assert index() == \"Hello World!\"\n    with app.test_request_context(\"/meh\"):\n        assert meh() == \"http://localhost/meh\"\n    assert not flask.request",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "warnings",
        "pytest",
        "flask",
        "flask.globals.request_ctx",
        "flask.sessions.SecureCookieSessionInterface",
        "flask.sessions.SessionInterface",
        "greenlet.greenlet",
        "flask.testing.EnvironBuilder",
        "flask.testing.EnvironBuilder"
      ],
      "fixtures": [],
      "assertions": [
        "assert not flask.request",
        "assert index() == 'Hello World!'",
        "assert meh() == 'http://localhost/meh'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "index",
          "body": "@app.route('/')\ndef index():\n    return flask.request.url"
        },
        {
          "name": "meh",
          "body": "@app.route('/meh')\ndef meh():\n    return flask.request.url"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_context_binding` function is designed to verify the correct behavior of Flask's request context handling. It ensures that the application can correctly bind request data to the context and that the routes return the expected responses based on the request parameters.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main functionalities: \n1. The `index` route correctly retrieves and utilizes query parameters from the request context, specifically returning a greeting that includes the name provided in the query string.\n2. The `meh` route returns the correct URL based on the request context. Additionally, it verifies that after the context is popped, the `flask.request` object is no longer accessible.\n\n**Code Being Tested and How It Works**:  \nThe test defines two routes:\n- The `index` route returns a greeting using the `name` parameter from the request's query string.\n- The `meh` route returns the full URL of the request. \n\nThe test uses `app.test_request_context` to simulate incoming requests to these routes. It first creates a context for the `index` route with a query string `/?name=World`, asserting that the response is \"Hello World!\". Then, it creates a context for the `meh` route, asserting that the response is \"http://localhost/meh\". Finally, it checks that there is no active request context after the contexts are popped.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The test utilizes Flask's `test_request_context` to create a simulated request environment, allowing the test to run without needing an actual HTTP request.\n- **Assertions**: It employs assertions to validate the expected outcomes of the route functions, ensuring that the application behaves as intended.\n- **Isolation of Tests**: Each context is managed within a `with` block, ensuring that the request context is properly pushed and popped, preventing side effects between tests. This pattern is crucial for maintaining test isolation and reliability."
    },
    {
      "name": "test_context_test",
      "module": "test_reqctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_reqctx.py",
      "line_number": 123,
      "end_line_number": 132,
      "source_code": "def test_context_test(app):\n    assert not flask.request\n    assert not flask.has_request_context()\n    ctx = app.test_request_context()\n    ctx.push()\n    try:\n        assert flask.request\n        assert flask.has_request_context()\n    finally:\n        ctx.pop()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "warnings",
        "pytest",
        "flask",
        "flask.globals.request_ctx",
        "flask.sessions.SecureCookieSessionInterface",
        "flask.sessions.SessionInterface",
        "greenlet.greenlet",
        "flask.testing.EnvironBuilder",
        "flask.testing.EnvironBuilder"
      ],
      "fixtures": [],
      "assertions": [
        "assert not flask.request",
        "assert not flask.has_request_context()",
        "assert flask.request",
        "assert flask.has_request_context()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_manual_context_binding",
      "module": "test_reqctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_reqctx.py",
      "line_number": 135,
      "end_line_number": 145,
      "source_code": "def test_manual_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    ctx = app.test_request_context(\"/?name=World\")\n    ctx.push()\n    assert index() == \"Hello World!\"\n    ctx.pop()\n    with pytest.raises(RuntimeError):\n        index()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "warnings",
        "pytest",
        "flask",
        "flask.globals.request_ctx",
        "flask.sessions.SecureCookieSessionInterface",
        "flask.sessions.SessionInterface",
        "greenlet.greenlet",
        "flask.testing.EnvironBuilder",
        "flask.testing.EnvironBuilder"
      ],
      "fixtures": [],
      "assertions": [
        "assert index() == 'Hello World!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "index",
          "body": "@app.route('/')\ndef index():\n    return flask.request.url"
        },
        {
          "name": "index",
          "body": "@app.route('/')\ndef index():\n    return flask.request.url"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_manual_context_binding` function is designed to verify the behavior of Flask's request context management, specifically testing how the application handles manual context binding and the expected behavior when the context is not active.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a request context is manually pushed, the `index` function can access the request arguments correctly. It also verifies that once the context is popped, calling the `index` function raises a `RuntimeError`, indicating that the request context is no longer available.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `index` function, which returns a greeting based on the `name` query parameter from the request. The test creates a request context for the URL `/?name=World`, pushes it onto the stack, and asserts that calling `index()` returns \"Hello World!\". After popping the context, the test expects a `RuntimeError` when `index()` is called again, as there is no active request context.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of Flask's `test_request_context` to simulate a request environment without needing to run a full server. It uses context management (`ctx.push()` and `ctx.pop()`) to manually control the request context, which is a common pattern in testing Flask applications. Additionally, it utilizes `pytest.raises` to assert that an exception is raised when the context is not active, demonstrating effective error handling in tests."
    },
    {
      "name": "test_greenlet_context_copying",
      "module": "test_reqctx",
      "class_name": "TestGreenletContextCopying",
      "file_path": "__internal__/data/flask/tests/test_reqctx.py",
      "line_number": 150,
      "end_line_number": 177,
      "source_code": "def test_greenlet_context_copying(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n            reqctx = request_ctx.copy()\n\n            def g():\n                assert not flask.request\n                assert not flask.current_app\n                with reqctx:\n                    assert flask.request\n                    assert flask.current_app == app\n                    assert flask.request.path == \"/\"\n                    assert flask.request.args[\"foo\"] == \"bar\"\n                    assert flask.session.get(\"fizz\") == \"buzz\"\n                assert not flask.request\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "client"
      ],
      "imports": [
        "warnings",
        "pytest",
        "flask",
        "flask.globals.request_ctx",
        "flask.sessions.SecureCookieSessionInterface",
        "flask.sessions.SessionInterface",
        "greenlet.greenlet",
        "flask.testing.EnvironBuilder",
        "flask.testing.EnvironBuilder"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'Hello World!'",
        "assert result == 42",
        "assert not flask.request",
        "assert not flask.current_app",
        "assert not flask.request",
        "assert flask.request",
        "assert flask.current_app == app",
        "assert flask.request.path == '/'",
        "assert flask.request.args['foo'] == 'bar'",
        "assert flask.session.get('fizz') == 'buzz'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "flask.session.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_greenlet_context_copying` test is to verify that the Flask application correctly handles request contexts when using greenlets. It ensures that the request context can be copied and used in a different execution context (greenlet) without losing the associated request data.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a request is made to the Flask application, the request context is properly set up and can be accessed within a greenlet. It verifies that the request data (like path and arguments) and session data are correctly maintained when the context is copied and used in the greenlet.\n\n**Code Being Tested and How It Works**:  \nThe code being tested includes the Flask route defined in the `index` function, which sets a session variable and creates a copy of the request context. The test then simulates a GET request to the root endpoint (`/`) with a query parameter. After the request is processed, it runs the greenlet function `g`, which asserts the presence of the request context and checks that the expected values are accessible. The assertions confirm that the request context behaves as expected when accessed from the greenlet.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The test utilizes Flask's request context management to ensure that the request context is correctly pushed and popped, allowing for safe access to request-specific data.\n- **Greenlet Usage**: The test employs the `greenlet` library to create a new execution context, demonstrating how Flask's request context can be copied and used across different greenlets.\n- **Assertions**: Multiple assertions are used to validate the state of the request context before and after entering the greenlet, ensuring that the context behaves as expected in both the main thread and the greenlet."
    },
    {
      "name": "test_greenlet_context_copying_api",
      "module": "test_reqctx",
      "class_name": "TestGreenletContextCopying",
      "file_path": "__internal__/data/flask/tests/test_reqctx.py",
      "line_number": 179,
      "end_line_number": 202,
      "source_code": "def test_greenlet_context_copying_api(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n\n            @flask.copy_current_request_context\n            def g():\n                assert flask.request\n                assert flask.current_app == app\n                assert flask.request.path == \"/\"\n                assert flask.request.args[\"foo\"] == \"bar\"\n                assert flask.session.get(\"fizz\") == \"buzz\"\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "client"
      ],
      "imports": [
        "warnings",
        "pytest",
        "flask",
        "flask.globals.request_ctx",
        "flask.sessions.SecureCookieSessionInterface",
        "flask.sessions.SessionInterface",
        "greenlet.greenlet",
        "flask.testing.EnvironBuilder",
        "flask.testing.EnvironBuilder"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'Hello World!'",
        "assert result == 42",
        "assert flask.request",
        "assert flask.current_app == app",
        "assert flask.request.path == '/'",
        "assert flask.request.args['foo'] == 'bar'",
        "assert flask.session.get('fizz') == 'buzz'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "flask.session.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_greenlet_context_copying_api` test is to verify that the Flask framework correctly handles the copying of the current request context when using greenlets. This ensures that the request context is preserved and accessible in a separate execution context, which is crucial for asynchronous operations in Flask applications.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the request context, including the session data and request parameters, is correctly maintained when a function decorated with `@flask.copy_current_request_context` is executed in a greenlet. It asserts that the function can access the same request and session data as the original request handler.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a Flask route defined at the root URL (\"/\"). When a GET request is made to this route with a query parameter (`foo=bar`), the session variable `fizz` is set to \"buzz\". The test then defines a nested function `g()` that is decorated to copy the current request context. Inside `g()`, various assertions are made to ensure that the request context is correctly populated with the expected values. The test then runs the greenlet containing `g()` and checks that it returns the expected result (42).\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The use of `@flask.copy_current_request_context` is a key technique that allows the test to capture the current request context and use it in a different execution context (the greenlet).\n- **Assertions**: Multiple assertions are employed to validate that the request context and session data are as expected, ensuring comprehensive coverage of the functionality being tested.\n- **Greenlet Usage**: The test demonstrates the use of greenlets for concurrent execution, which is a common pattern in asynchronous programming, particularly in web frameworks like Flask that support such operations."
    },
    {
      "name": "test_session_error_pops_context",
      "module": "test_reqctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_reqctx.py",
      "line_number": 205,
      "end_line_number": 226,
      "source_code": "def test_session_error_pops_context():\n    class SessionError(Exception):\n        pass\n\n    class FailingSessionInterface(SessionInterface):\n        def open_session(self, app, request):\n            raise SessionError()\n\n    class CustomFlask(flask.Flask):\n        session_interface = FailingSessionInterface()\n\n    app = CustomFlask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        # shouldn't get here\n        AssertionError()\n\n    response = app.test_client().get(\"/\")\n    assert response.status_code == 500\n    assert not flask.request\n    assert not flask.current_app",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "warnings",
        "pytest",
        "flask",
        "flask.globals.request_ctx",
        "flask.sessions.SecureCookieSessionInterface",
        "flask.sessions.SessionInterface",
        "greenlet.greenlet",
        "flask.testing.EnvironBuilder",
        "flask.testing.EnvironBuilder"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 500",
        "assert not flask.request",
        "assert not flask.current_app"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_session_dynamic_cookie_name",
      "module": "test_reqctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_reqctx.py",
      "line_number": 229,
      "end_line_number": 277,
      "source_code": "def test_session_dynamic_cookie_name():\n    # This session interface will use a cookie with a different name if the\n    # requested url ends with the string \"dynamic_cookie\"\n    class PathAwareSessionInterface(SecureCookieSessionInterface):\n        def get_cookie_name(self, app):\n            if flask.request.url.endswith(\"dynamic_cookie\"):\n                return \"dynamic_cookie_name\"\n            else:\n                return super().get_cookie_name(app)\n\n    class CustomFlask(flask.Flask):\n        session_interface = PathAwareSessionInterface()\n\n    app = CustomFlask(__name__)\n    app.secret_key = \"secret_key\"\n\n    @app.route(\"/set\", methods=[\"POST\"])\n    def set():\n        flask.session[\"value\"] = flask.request.form[\"value\"]\n        return \"value set\"\n\n    @app.route(\"/get\")\n    def get():\n        v = flask.session.get(\"value\", \"None\")\n        return v\n\n    @app.route(\"/set_dynamic_cookie\", methods=[\"POST\"])\n    def set_dynamic_cookie():\n        flask.session[\"value\"] = flask.request.form[\"value\"]\n        return \"value set\"\n\n    @app.route(\"/get_dynamic_cookie\")\n    def get_dynamic_cookie():\n        v = flask.session.get(\"value\", \"None\")\n        return v\n\n    test_client = app.test_client()\n\n    # first set the cookie in both /set urls but each with a different value\n    assert test_client.post(\"/set\", data={\"value\": \"42\"}).data == b\"value set\"\n    assert (\n        test_client.post(\"/set_dynamic_cookie\", data={\"value\": \"616\"}).data\n        == b\"value set\"\n    )\n\n    # now check that the relevant values come back - meaning that different\n    # cookies are being used for the urls that end with \"dynamic cookie\"\n    assert test_client.get(\"/get\").data == b\"42\"\n    assert test_client.get(\"/get_dynamic_cookie\").data == b\"616\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "warnings",
        "pytest",
        "flask",
        "flask.globals.request_ctx",
        "flask.sessions.SecureCookieSessionInterface",
        "flask.sessions.SessionInterface",
        "greenlet.greenlet",
        "flask.testing.EnvironBuilder",
        "flask.testing.EnvironBuilder"
      ],
      "fixtures": [],
      "assertions": [
        "assert test_client.post('/set', data={'value': '42'}).data == b'value set'",
        "assert test_client.post('/set_dynamic_cookie', data={'value': '616'}).data == b'value set'",
        "assert test_client.get('/get').data == b'42'",
        "assert test_client.get('/get_dynamic_cookie').data == b'616'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "flask.session.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "flask.session.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "test_client.post",
          "body": "def post(self):\n    return 'Create'"
        },
        {
          "name": "test_client.post",
          "body": "def post(self):\n    return 'Create'"
        },
        {
          "name": "test_client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "test_client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_session_dynamic_cookie_name` test is to verify that the Flask application correctly uses different session cookie names based on the URL being accessed. Specifically, it checks that when a request is made to a URL ending with \"dynamic_cookie\", a distinct cookie name (\"dynamic_cookie_name\") is used, while other URLs use the default cookie name.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies that the session values set through two different endpoints (`/set` and `/set_dynamic_cookie`) are stored in separate cookies. It ensures that the values retrieved from these endpoints correspond to the values set, confirming that the session management is functioning as intended with the correct cookie names.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a custom session interface (`PathAwareSessionInterface`) that overrides the `get_cookie_name` method to return a different cookie name based on the request URL. The Flask application (`CustomFlask`) uses this custom session interface. The test client is used to simulate HTTP requests to the application, setting session values via POST requests and retrieving them via GET requests. The assertions check that the correct values are returned for each endpoint, indicating that the session management is working correctly.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Custom Session Interface**: It demonstrates the use of a subclass to modify the behavior of session management in Flask.\n- **Test Client**: The use of Flask's test client allows for simulating requests and responses without needing to run a live server, facilitating isolated unit testing.\n- **Assertions**: The test uses assertions to validate expected outcomes, ensuring that the application behaves as intended under different conditions. This is a common practice in unit testing to confirm that the code meets its specifications."
    },
    {
      "name": "test_bad_environ_raises_bad_request",
      "module": "test_reqctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_reqctx.py",
      "line_number": 280,
      "end_line_number": 293,
      "source_code": "def test_bad_environ_raises_bad_request():\n    app = flask.Flask(__name__)\n\n    from flask.testing import EnvironBuilder\n\n    builder = EnvironBuilder(app)\n    environ = builder.get_environ()\n\n    # use a non-printable character in the Host - this is key to this test\n    environ[\"HTTP_HOST\"] = \"\\x8a\"\n\n    with app.request_context(environ):\n        response = app.full_dispatch_request()\n    assert response.status_code == 400",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "warnings",
        "pytest",
        "flask",
        "flask.globals.request_ctx",
        "flask.sessions.SecureCookieSessionInterface",
        "flask.sessions.SessionInterface",
        "greenlet.greenlet",
        "flask.testing.EnvironBuilder",
        "flask.testing.EnvironBuilder"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 400"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_environ_for_valid_idna_completes",
      "module": "test_reqctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_reqctx.py",
      "line_number": 296,
      "end_line_number": 314,
      "source_code": "def test_environ_for_valid_idna_completes():\n    app = flask.Flask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        return \"Hello World!\"\n\n    from flask.testing import EnvironBuilder\n\n    builder = EnvironBuilder(app)\n    environ = builder.get_environ()\n\n    # these characters are all IDNA-compatible\n    environ[\"HTTP_HOST\"] = \"\u0105\u015b\u017a\u00e4\u00fc\u0436\u0160\u00df\u044f.com\"\n\n    with app.request_context(environ):\n        response = app.full_dispatch_request()\n\n    assert response.status_code == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "warnings",
        "pytest",
        "flask",
        "flask.globals.request_ctx",
        "flask.sessions.SecureCookieSessionInterface",
        "flask.sessions.SessionInterface",
        "greenlet.greenlet",
        "flask.testing.EnvironBuilder",
        "flask.testing.EnvironBuilder"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_normal_environ_completes",
      "module": "test_reqctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_reqctx.py",
      "line_number": 317,
      "end_line_number": 325,
      "source_code": "def test_normal_environ_completes():\n    app = flask.Flask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        return \"Hello World!\"\n\n    response = app.test_client().get(\"/\", headers={\"host\": \"xn--on-0ia.com\"})\n    assert response.status_code == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "warnings",
        "pytest",
        "flask",
        "flask.globals.request_ctx",
        "flask.sessions.SecureCookieSessionInterface",
        "flask.sessions.SessionInterface",
        "greenlet.greenlet",
        "flask.testing.EnvironBuilder",
        "flask.testing.EnvironBuilder"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_greenlet_context_copying",
      "module": "test_reqctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_reqctx.py",
      "line_number": 150,
      "end_line_number": 177,
      "source_code": "def test_greenlet_context_copying(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n            reqctx = request_ctx.copy()\n\n            def g():\n                assert not flask.request\n                assert not flask.current_app\n                with reqctx:\n                    assert flask.request\n                    assert flask.current_app == app\n                    assert flask.request.path == \"/\"\n                    assert flask.request.args[\"foo\"] == \"bar\"\n                    assert flask.session.get(\"fizz\") == \"buzz\"\n                assert not flask.request\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "client"
      ],
      "imports": [
        "warnings",
        "pytest",
        "flask",
        "flask.globals.request_ctx",
        "flask.sessions.SecureCookieSessionInterface",
        "flask.sessions.SessionInterface",
        "greenlet.greenlet",
        "flask.testing.EnvironBuilder",
        "flask.testing.EnvironBuilder"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'Hello World!'",
        "assert result == 42",
        "assert not flask.request",
        "assert not flask.current_app",
        "assert not flask.request",
        "assert flask.request",
        "assert flask.current_app == app",
        "assert flask.request.path == '/'",
        "assert flask.request.args['foo'] == 'bar'",
        "assert flask.session.get('fizz') == 'buzz'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "flask.session.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_greenlet_context_copying` test is to verify that the Flask application correctly handles request contexts when using greenlets. It ensures that the request context can be copied and used in a different execution context (greenlet) without losing the associated request data.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a request context is copied and used in a new greenlet, the expected request attributes (like `flask.request`, `flask.current_app`, and session data) are correctly accessible within that greenlet. It also verifies that the original context is not affected after the new context is used.\n\n**Code Being Tested and How It Works**:  \nThe code being tested includes the Flask route defined in the `index` function, which sets a session variable and creates a copy of the request context. The test then simulates a GET request to the root endpoint (`/`) with a query parameter. After the request is processed, it runs the greenlet function `g`, which asserts the presence of the request context and checks the values of various request attributes and session data. The assertions confirm that the copied context behaves as expected.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Greenlet Usage**: The test utilizes the `greenlet` library to create a new execution context, allowing for concurrent execution while maintaining the request context.\n- **Context Management**: The test employs Flask's request context management features, specifically copying the request context and using it within a `with` statement to ensure proper context handling.\n- **Assertions**: Multiple assertions are used to validate the state of the request context and session data before and after the greenlet execution, ensuring that the context copying mechanism works correctly."
    },
    {
      "name": "test_greenlet_context_copying_api",
      "module": "test_reqctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_reqctx.py",
      "line_number": 179,
      "end_line_number": 202,
      "source_code": "def test_greenlet_context_copying_api(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n\n            @flask.copy_current_request_context\n            def g():\n                assert flask.request\n                assert flask.current_app == app\n                assert flask.request.path == \"/\"\n                assert flask.request.args[\"foo\"] == \"bar\"\n                assert flask.session.get(\"fizz\") == \"buzz\"\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "client"
      ],
      "imports": [
        "warnings",
        "pytest",
        "flask",
        "flask.globals.request_ctx",
        "flask.sessions.SecureCookieSessionInterface",
        "flask.sessions.SessionInterface",
        "greenlet.greenlet",
        "flask.testing.EnvironBuilder",
        "flask.testing.EnvironBuilder"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'Hello World!'",
        "assert result == 42",
        "assert flask.request",
        "assert flask.current_app == app",
        "assert flask.request.path == '/'",
        "assert flask.request.args['foo'] == 'bar'",
        "assert flask.session.get('fizz') == 'buzz'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "flask.session.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_greenlet_context_copying_api` test is to verify that the Flask framework correctly handles the copying of the current request context when using greenlets. This ensures that the request context is preserved and accessible in a separate execution context, which is crucial for asynchronous operations in Flask applications.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the request context, including the session data and request parameters, is correctly maintained when a function decorated with `@flask.copy_current_request_context` is executed in a greenlet. It asserts that the function can access the same request and session data as the original request handler.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route (`index`) that sets a session variable and uses the `@flask.copy_current_request_context` decorator to create a function (`g`) that asserts the presence of the request context and checks various properties (like the request path and session data). The test then simulates a client request to the route and verifies that the response is as expected. Finally, it runs the greenlet and checks that the result is correct, confirming that the context was copied successfully.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The use of `@flask.copy_current_request_context` demonstrates a context management pattern that allows for safe access to request-specific data across different execution contexts.\n- **Assertions**: The test employs multiple assertions to validate the integrity of the request context and session data, ensuring that the expected values are present.\n- **Greenlet Usage**: The test utilizes the `greenlet` library to create a separate execution context, showcasing how Flask can work with asynchronous programming paradigms.\n- **Client Simulation**: The use of `client.get` simulates an HTTP request to the Flask application, allowing for end-to-end testing of the route's behavior."
    },
    {
      "name": "test_template_rendered",
      "module": "test_signals",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_signals.py",
      "line_number": 4,
      "end_line_number": 22,
      "source_code": "def test_template_rendered(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"simple_template.html\", whiskey=42)\n\n    recorded = []\n\n    def record(sender, template, context):\n        recorded.append((template, context))\n\n    flask.template_rendered.connect(record, app)\n    try:\n        client.get(\"/\")\n        assert len(recorded) == 1\n        template, context = recorded[0]\n        assert template.name == \"simple_template.html\"\n        assert context[\"whiskey\"] == 42\n    finally:\n        flask.template_rendered.disconnect(record, app)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(recorded) == 1",
        "assert template.name == 'simple_template.html'",
        "assert context['whiskey'] == 42"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_template_rendered` function aims to verify that the Flask application correctly renders a specified template and passes the expected context variables to it. This ensures that the template rendering mechanism is functioning as intended.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when the root route (\"/\") is accessed, the application renders the \"simple_template.html\" template and that the context variable `whiskey` is set to 42. It also confirms that the template rendering signal is triggered exactly once during this process.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the route definition for the index function, which uses `flask.render_template` to render \"simple_template.html\" with a context variable. The test sets up a signal listener for `flask.template_rendered`, which records the template and context whenever a template is rendered. After making a GET request to the root route, the test asserts that the recorded template is the expected one and that the context contains the correct value.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Signal Connection**: The test connects a custom signal handler to `flask.template_rendered` to capture rendering events, allowing for verification of the template and context.\n- **Context Management**: The use of a `try/finally` block ensures that the signal is disconnected after the test, maintaining the integrity of the application state for subsequent tests.\n- **Assertions**: The test employs assertions to validate the expected outcomes, ensuring that both the template name and context variable are as anticipated."
    },
    {
      "name": "test_before_render_template",
      "module": "test_signals",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_signals.py",
      "line_number": 25,
      "end_line_number": 47,
      "source_code": "def test_before_render_template():\n    app = flask.Flask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"simple_template.html\", whiskey=42)\n\n    recorded = []\n\n    def record(sender, template, context):\n        context[\"whiskey\"] = 43\n        recorded.append((template, context))\n\n    flask.before_render_template.connect(record, app)\n    try:\n        rv = app.test_client().get(\"/\")\n        assert len(recorded) == 1\n        template, context = recorded[0]\n        assert template.name == \"simple_template.html\"\n        assert context[\"whiskey\"] == 43\n        assert rv.data == b\"<h1>43</h1>\"\n    finally:\n        flask.before_render_template.disconnect(record, app)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(recorded) == 1",
        "assert template.name == 'simple_template.html'",
        "assert context['whiskey'] == 43",
        "assert rv.data == b'<h1>43</h1>'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_request_signals",
      "module": "test_signals",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_signals.py",
      "line_number": 50,
      "end_line_number": 92,
      "source_code": "def test_request_signals():\n    app = flask.Flask(__name__)\n    calls = []\n\n    def before_request_signal(sender):\n        calls.append(\"before-signal\")\n\n    def after_request_signal(sender, response):\n        assert response.data == b\"stuff\"\n        calls.append(\"after-signal\")\n\n    @app.before_request\n    def before_request_handler():\n        calls.append(\"before-handler\")\n\n    @app.after_request\n    def after_request_handler(response):\n        calls.append(\"after-handler\")\n        response.data = \"stuff\"\n        return response\n\n    @app.route(\"/\")\n    def index():\n        calls.append(\"handler\")\n        return \"ignored anyway\"\n\n    flask.request_started.connect(before_request_signal, app)\n    flask.request_finished.connect(after_request_signal, app)\n\n    try:\n        rv = app.test_client().get(\"/\")\n        assert rv.data == b\"stuff\"\n\n        assert calls == [\n            \"before-signal\",\n            \"before-handler\",\n            \"handler\",\n            \"after-handler\",\n            \"after-signal\",\n        ]\n    finally:\n        flask.request_started.disconnect(before_request_signal, app)\n        flask.request_finished.disconnect(after_request_signal, app)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.data == b'stuff'",
        "assert rv.data == b'stuff'",
        "assert calls == ['before-signal', 'before-handler', 'handler', 'after-handler', 'after-signal']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_request_exception_signal",
      "module": "test_signals",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_signals.py",
      "line_number": 95,
      "end_line_number": 112,
      "source_code": "def test_request_exception_signal():\n    app = flask.Flask(__name__)\n    recorded = []\n\n    @app.route(\"/\")\n    def index():\n        raise ZeroDivisionError\n\n    def record(sender, exception):\n        recorded.append(exception)\n\n    flask.got_request_exception.connect(record, app)\n    try:\n        assert app.test_client().get(\"/\").status_code == 500\n        assert len(recorded) == 1\n        assert isinstance(recorded[0], ZeroDivisionError)\n    finally:\n        flask.got_request_exception.disconnect(record, app)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.test_client().get('/').status_code == 500",
        "assert len(recorded) == 1",
        "assert isinstance(recorded[0], ZeroDivisionError)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_appcontext_signals",
      "module": "test_signals",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_signals.py",
      "line_number": 115,
      "end_line_number": 136,
      "source_code": "def test_appcontext_signals(app, client):\n    recorded = []\n\n    def record_push(sender, **kwargs):\n        recorded.append(\"push\")\n\n    def record_pop(sender, **kwargs):\n        recorded.append(\"pop\")\n\n    @app.route(\"/\")\n    def index():\n        return \"Hello\"\n\n    flask.appcontext_pushed.connect(record_push, app)\n    flask.appcontext_popped.connect(record_pop, app)\n    try:\n        rv = client.get(\"/\")\n        assert rv.data == b\"Hello\"\n        assert recorded == [\"push\", \"pop\"]\n    finally:\n        flask.appcontext_pushed.disconnect(record_push, app)\n        flask.appcontext_popped.disconnect(record_pop, app)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'Hello'",
        "assert recorded == ['push', 'pop']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_appcontext_signals` test is to verify that the Flask application correctly emits signals when the application context is pushed and popped during a request. This ensures that the application context management is functioning as expected, which is crucial for maintaining the state and behavior of the application during request handling.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that the `appcontext_pushed` and `appcontext_popped` signals are triggered when a request is made to the root route (\"/\"). It asserts that the recorded signals match the expected sequence of \"push\" and \"pop\", confirming that the application context is properly managed around the request lifecycle.\n\n**Code Being Tested and How It Works**:  \nThe code being tested includes the Flask route defined by `@app.route(\"/\")`, which returns a simple \"Hello\" response. The test sets up signal handlers (`record_push` and `record_pop`) that append to a list when the respective signals are emitted. The test then makes a GET request to the root route using `client.get(\"/\")`, and it checks that the response data is `b\"Hello\"` and that the recorded signals are `[\"push\", \"pop\"]`. The signals are connected to the Flask app's context management system, which is responsible for pushing and popping the application context during request handling.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns and techniques:\n- **Signal Connection and Disconnection**: It connects signal handlers to the Flask app's context signals before the request and ensures they are disconnected afterward, preventing side effects on other tests.\n- **Use of `try/finally`**: This structure ensures that the disconnection of signals occurs even if an assertion fails or an exception is raised during the test, maintaining test isolation and integrity.\n- **Assertions**: The test uses assertions to verify both the response content and the order of signal emissions, which is a common practice in unit testing to validate expected outcomes against actual results."
    },
    {
      "name": "test_flash_signal",
      "module": "test_signals",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_signals.py",
      "line_number": 139,
      "end_line_number": 160,
      "source_code": "def test_flash_signal(app):\n    @app.route(\"/\")\n    def index():\n        flask.flash(\"This is a flash message\", category=\"notice\")\n        return flask.redirect(\"/other\")\n\n    recorded = []\n\n    def record(sender, message, category):\n        recorded.append((message, category))\n\n    flask.message_flashed.connect(record, app)\n    try:\n        client = app.test_client()\n        with client.session_transaction():\n            client.get(\"/\")\n            assert len(recorded) == 1\n            message, category = recorded[0]\n            assert message == \"This is a flash message\"\n            assert category == \"notice\"\n    finally:\n        flask.message_flashed.disconnect(record, app)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(recorded) == 1",
        "assert message == 'This is a flash message'",
        "assert category == 'notice'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "flask.redirect",
          "body": "def redirect(location, code=302):\n    raise ValueError"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_flash_signal` unit test is designed to verify that the Flask framework correctly handles flash messages. Specifically, it checks that a flash message is properly recorded and can be retrieved after a redirect.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a flash message is created in a route handler (in this case, the `index` function), it is successfully sent to the session and can be accessed in the subsequent request. The test confirms that the message and its category are correctly stored and can be asserted against expected values.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `flask.flash` function, which adds a message to the session for display in the next request, and the `flask.redirect` function, which redirects the user to another route. The test sets up a route that flashes a message and then redirects to another route. The `record` function is connected to the `message_flashed` signal to capture the flashed messages. After making a request to the index route, the test checks that the message was recorded and matches the expected content.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Signal Connection**: The test uses Flask's signal system to connect a custom function (`record`) to the `message_flashed` signal, allowing it to capture flashed messages for verification.\n- **Session Transaction**: The test utilizes `client.session_transaction()` to manipulate the session during the test, ensuring that the flash message is stored correctly.\n- **Assertions**: The test employs assertions to validate that the expected number of messages was recorded and that the content and category of the message match the expected values.\n- **Cleanup**: The test ensures that the signal connection is properly disconnected in a `finally` block, maintaining the integrity of the test environment for subsequent tests."
    },
    {
      "name": "test_appcontext_tearing_down_signal",
      "module": "test_signals",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_signals.py",
      "line_number": 163,
      "end_line_number": 181,
      "source_code": "def test_appcontext_tearing_down_signal(app, client):\n    app.testing = False\n    recorded = []\n\n    def record_teardown(sender, exc):\n        recorded.append(exc)\n\n    @app.route(\"/\")\n    def index():\n        raise ZeroDivisionError\n\n    flask.appcontext_tearing_down.connect(record_teardown, app)\n    try:\n        rv = client.get(\"/\")\n        assert rv.status_code == 500\n        assert len(recorded) == 1\n        assert isinstance(recorded[0], ZeroDivisionError)\n    finally:\n        flask.appcontext_tearing_down.disconnect(record_teardown, app)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 500",
        "assert len(recorded) == 1",
        "assert isinstance(recorded[0], ZeroDivisionError)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_appcontext_tearing_down_signal` test is to verify that the Flask application correctly emits a signal when the application context is torn down, particularly in the event of an unhandled exception during a request. This ensures that any registered teardown handlers can respond appropriately to exceptions.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that when a `ZeroDivisionError` is raised in the route handler, the `appcontext_tearing_down` signal is triggered, and the exception is recorded by the connected signal handler. It asserts that the response status code is 500 (indicating an internal server error) and that the exception is correctly captured in the `recorded` list.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a Flask route (`index`) that intentionally raises a `ZeroDivisionError`. The test connects a signal handler (`record_teardown`) to the `appcontext_tearing_down` signal, which is emitted when the application context is about to be popped. The test then makes a GET request to the route, which triggers the error, and subsequently checks the recorded exceptions. The `finally` block ensures that the signal handler is disconnected after the test, maintaining test isolation.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Signal Connection and Disconnection**: It connects a signal handler to the Flask signal system, allowing for custom behavior when specific events occur (in this case, tearing down the application context).\n- **Exception Handling**: The test deliberately raises an exception to verify that the signal system captures it correctly, demonstrating how Flask handles errors during request processing.\n- **Assertions**: It uses assertions to validate the expected outcomes, such as the response status code and the contents of the recorded exceptions, ensuring that the application behaves as intended under error conditions."
    },
    {
      "name": "test_send_file",
      "module": "test_helpers",
      "class_name": "TestSendfile",
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 34,
      "end_line_number": 43,
      "source_code": "def test_send_file(self, app, req_ctx):\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.direct_passthrough\n        assert rv.mimetype == \"text/html\"\n\n        with app.open_resource(\"static/index.html\") as f:\n            rv.direct_passthrough = False\n            assert rv.data == f.read()\n\n        rv.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "req_ctx"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.direct_passthrough",
        "assert rv.mimetype == 'text/html'",
        "assert rv.data == f.read()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)"
        },
        {
          "name": "f.read",
          "body": "@app.route('/read')\ndef read():\n    return str(flask.session.get('foo', 0))"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_send_file` function is designed to verify the behavior of Flask's `send_file` function when serving a static HTML file. It ensures that the file is sent correctly with the expected properties, such as MIME type and data integrity.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main aspects: \n1. It verifies that the response (`rv`) from `send_file` has the `direct_passthrough` attribute set to `True`, indicating that the file is being sent directly without buffering.\n2. It confirms that the MIME type of the response is `text/html`, which is appropriate for an HTML file. Additionally, it checks that the data returned in the response matches the content of the file being served.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `send_file` function from Flask, which is responsible for sending files to the client. It takes a file path or file-like object as input and returns a response object. The test specifically opens the file `static/index.html` using `app.open_resource`, reads its content, and compares it to the data in the response. The `rv.close()` method is called to ensure that any resources associated with the response are properly released.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The test uses a context manager (`with` statement) to safely open the file resource, ensuring that it is properly closed after reading.\n- **Assertions**: The test employs assertions to validate the expected outcomes, which is a common practice in unit testing to ensure that the code behaves as intended.\n- **Direct Interaction with Flask's Response**: The test directly manipulates the `direct_passthrough` attribute of the response object to simulate different scenarios, showcasing a hands-on approach to testing the behavior of the response."
    },
    {
      "name": "test_static_file",
      "module": "test_helpers",
      "class_name": "TestSendfile",
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 45,
      "end_line_number": 90,
      "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "req_ctx"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.cache_control.max_age is None",
        "assert rv.cache_control.max_age is None",
        "assert rv.cache_control.max_age == 3600",
        "assert rv.cache_control.max_age == 3600",
        "assert rv.cache_control.max_age == 3600",
        "assert rv.cache_control.max_age == 10",
        "assert rv.cache_control.max_age == 10"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)"
        },
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)"
        },
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)"
        },
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)"
        },
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)"
        },
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)"
        },
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:\nThe `test_static_file` function is designed to verify the behavior of Flask's static file serving mechanism, specifically focusing on the `max_age` attribute of the `Cache-Control` header. It ensures that the caching behavior is correctly configured based on the application settings and the specific implementation of the static file handler.\n\n**Specific Functionality or Behavior Verified**:\nThe test checks that:\n1. The default `max_age` for static files is `None`.\n2. When the `SEND_FILE_MAX_AGE_DEFAULT` configuration is set to a specific value (e.g., `3600`), the `max_age` for served static files reflects this value.\n3. The `max_age` can be overridden by a custom implementation in a subclass of `Flask`.\n4. The test also verifies that the static file serving works correctly with different types of file references, including strings and `pathlib.Path` objects.\n\n**Code Being Tested and How It Works**:\nThe code under test includes the `send_static_file` method of the Flask application, which serves static files. The `max_age` attribute is part of the `Cache-Control` header in the response, which dictates how long the file can be cached by the client. The test manipulates the application configuration to set the `SEND_FILE_MAX_AGE_DEFAULT` and checks the resulting `max_age` in the response. It also defines a subclass of `Flask` to demonstrate how custom logic can alter the caching behavior.\n\n**Notable Testing Patterns or Techniques Used**:\n1. **Context Management**: The test uses Flask's `test_request_context()` to simulate a request context, allowing the test to access request-specific features without needing to run a full server.\n2. **Assertions**: The test employs assertions to validate the expected outcomes, ensuring that the `max_age` values are as intended under different configurations.\n3. **Cleanup**: The test ensures that the application configuration is restored to its original state after the test runs, preventing side effects on other tests.\n4. **Custom Class**: The use of a subclass (`StaticFileApp`) to override behavior demonstrates how to extend Flask's functionality in a testable manner."
    },
    {
      "name": "test_send_from_directory",
      "module": "test_helpers",
      "class_name": "TestSendfile",
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 92,
      "end_line_number": 99,
      "source_code": "def test_send_from_directory(self, app, req_ctx):\n        app.root_path = os.path.join(\n            os.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n        )\n        rv = flask.send_from_directory(\"static\", \"hello.txt\")\n        rv.direct_passthrough = False\n        assert rv.data.strip() == b\"Hello Subdomain\"\n        rv.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "req_ctx"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data.strip() == b'Hello Subdomain'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_send_from_directory` unit test is designed to verify the functionality of the `flask.send_from_directory` method, ensuring that it correctly serves a file from a specified directory within the Flask application. This test checks that the file content returned matches the expected data.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically verifies that when a request is made to send the file `hello.txt` from the `static` directory, the response data matches the expected byte string `b\"Hello Subdomain\"`. It also ensures that the `direct_passthrough` attribute of the response is set to `False`, indicating that the response data is being processed rather than passed through directly.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `send_from_directory` function, which is a secure way to serve files from a specified directory. It uses the `werkzeug.security.safe_join` function to prevent directory traversal attacks, ensuring that the requested file is located within the specified directory. The test sets the `app.root_path` to a specific directory and then calls `flask.send_from_directory(\"static\", \"hello.txt\")`, which attempts to retrieve the file `hello.txt` from the `static` directory relative to the application's root path.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the response data, specifically checking that the stripped data from the response matches the expected byte string. It also utilizes the context of a Flask application (`app`) and request context (`req_ctx`) to simulate a real application environment, which is a common pattern in Flask testing. The test ensures proper cleanup by calling `rv.close()` to release any resources associated with the response object."
    },
    {
      "name": "test_url_for_with_anchor",
      "module": "test_helpers",
      "class_name": "TestUrlFor",
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 103,
      "end_line_number": 108,
      "source_code": "def test_url_for_with_anchor(self, app, req_ctx):\n        @app.route(\"/\")\n        def index():\n            return \"42\"\n\n        assert flask.url_for(\"index\", _anchor=\"x y\") == \"/#x%20y\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "req_ctx"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.url_for('index', _anchor='x y') == '/#x%20y'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_url_for_with_scheme",
      "module": "test_helpers",
      "class_name": "TestUrlFor",
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 110,
      "end_line_number": 118,
      "source_code": "def test_url_for_with_scheme(self, app, req_ctx):\n        @app.route(\"/\")\n        def index():\n            return \"42\"\n\n        assert (\n            flask.url_for(\"index\", _external=True, _scheme=\"https\")\n            == \"https://localhost/\"\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "req_ctx"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.url_for('index', _external=True, _scheme='https') == 'https://localhost/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_url_for_with_scheme_not_external",
      "module": "test_helpers",
      "class_name": "TestUrlFor",
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 120,
      "end_line_number": 129,
      "source_code": "def test_url_for_with_scheme_not_external(self, app, req_ctx):\n        app.add_url_rule(\"/\", endpoint=\"index\")\n\n        # Implicit external with scheme.\n        url = flask.url_for(\"index\", _scheme=\"https\")\n        assert url == \"https://localhost/\"\n\n        # Error when external=False with scheme\n        with pytest.raises(ValueError):\n            flask.url_for(\"index\", _scheme=\"https\", _external=False)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "req_ctx"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert url == 'https://localhost/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_url_for_with_alternating_schemes",
      "module": "test_helpers",
      "class_name": "TestUrlFor",
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 131,
      "end_line_number": 141,
      "source_code": "def test_url_for_with_alternating_schemes(self, app, req_ctx):\n        @app.route(\"/\")\n        def index():\n            return \"42\"\n\n        assert flask.url_for(\"index\", _external=True) == \"http://localhost/\"\n        assert (\n            flask.url_for(\"index\", _external=True, _scheme=\"https\")\n            == \"https://localhost/\"\n        )\n        assert flask.url_for(\"index\", _external=True) == \"http://localhost/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "req_ctx"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.url_for('index', _external=True) == 'http://localhost/'",
        "assert flask.url_for('index', _external=True, _scheme='https') == 'https://localhost/'",
        "assert flask.url_for('index', _external=True) == 'http://localhost/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_url_with_method",
      "module": "test_helpers",
      "class_name": "TestUrlFor",
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 143,
      "end_line_number": 162,
      "source_code": "def test_url_with_method(self, app, req_ctx):\n        from flask.views import MethodView\n\n        class MyView(MethodView):\n            def get(self, id=None):\n                if id is None:\n                    return \"List\"\n                return f\"Get {id:d}\"\n\n            def post(self):\n                return \"Create\"\n\n        myview = MyView.as_view(\"myview\")\n        app.add_url_rule(\"/myview/\", methods=[\"GET\"], view_func=myview)\n        app.add_url_rule(\"/myview/<int:id>\", methods=[\"GET\"], view_func=myview)\n        app.add_url_rule(\"/myview/create\", methods=[\"POST\"], view_func=myview)\n\n        assert flask.url_for(\"myview\", _method=\"GET\") == \"/myview/\"\n        assert flask.url_for(\"myview\", id=42, _method=\"GET\") == \"/myview/42\"\n        assert flask.url_for(\"myview\", _method=\"POST\") == \"/myview/create\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "req_ctx"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.url_for('myview', _method='GET') == '/myview/'",
        "assert flask.url_for('myview', id=42, _method='GET') == '/myview/42'",
        "assert flask.url_for('myview', _method='POST') == '/myview/create'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_url_for_with_self",
      "module": "test_helpers",
      "class_name": "TestUrlFor",
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 164,
      "end_line_number": 169,
      "source_code": "def test_url_for_with_self(self, app, req_ctx):\n        @app.route(\"/<self>\")\n        def index(self):\n            return \"42\"\n\n        assert flask.url_for(\"index\", self=\"2\") == \"/2\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "req_ctx"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.url_for('index', self='2') == '/2'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_redirect_no_app",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 172,
      "end_line_number": 175,
      "source_code": "def test_redirect_no_app():\n    response = flask.redirect(\"https://localhost\", 307)\n    assert response.location == \"https://localhost\"\n    assert response.status_code == 307",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.location == 'https://localhost'",
        "assert response.status_code == 307"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "flask.redirect",
          "body": "def redirect(location, code=302):\n    raise ValueError"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_redirect_no_app` function is designed to verify the behavior of the `flask.redirect` function when called without an active Flask application context. It ensures that the function correctly creates a redirect response with the specified location and status code.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the `flask.redirect` function returns a response object with the correct `location` and `status_code` attributes. Specifically, it asserts that the `location` is set to \"https://localhost\" and that the `status_code` is set to 307, which indicates a temporary redirect.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `flask.redirect` function, which is responsible for generating a redirect response. The function takes two parameters: `location`, which is the URL to redirect to, and `code`, which is the HTTP status code for the redirect (defaulting to 302 if not specified). In this test, the function is called with a specific URL and a status code of 307, and the resulting response object is examined to ensure it has the expected properties.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs simple assertions to validate the output of the `flask.redirect` function. It uses direct comparisons to check the values of the `location` and `status_code` attributes of the response object. This straightforward approach is effective for unit testing, as it focuses on verifying specific outputs against expected values without the need for complex setup or teardown procedures. Additionally, the test is self-contained and does not require an application context, which simplifies its execution and enhances its reliability."
    },
    {
      "name": "test_redirect_with_app",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 178,
      "end_line_number": 185,
      "source_code": "def test_redirect_with_app(app):\n    def redirect(location, code=302):\n        raise ValueError\n\n    app.redirect = redirect\n\n    with app.app_context(), pytest.raises(ValueError):\n        flask.redirect(\"other\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "flask.redirect",
          "body": "def redirect(location, code=302):\n    raise ValueError"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_redirect_with_app` unit test is designed to verify the behavior of the `flask.redirect` function when a custom redirect function is assigned to the Flask application context. Specifically, it checks that the application raises a `ValueError` when the redirect function is invoked.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when the `flask.redirect` function is called within the application context, and the redirect function is overridden to raise a `ValueError`, the error is correctly raised as expected. This verifies that the application context properly handles exceptions thrown by the redirect function.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `flask.redirect` function, which is expected to perform a redirect operation. In this test, the `redirect` function is overridden to raise a `ValueError` instead of performing its normal redirect behavior. The test sets up the application context using `app.app_context()` and then calls `flask.redirect(\"other\")`. The test expects that this call will raise a `ValueError`, which is asserted using `pytest.raises(ValueError)`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The test uses the Flask application context (`app.app_context()`) to ensure that the redirect function operates within the correct context, which is crucial for Flask applications.\n- **Exception Assertion**: The test employs `pytest.raises` to assert that a specific exception (`ValueError`) is raised during the execution of the redirect function, demonstrating a common pattern in unit testing where the expected outcome is an error.\n- **Mocking**: The test effectively mocks the `redirect` function by redefining it within the test scope, allowing for controlled testing of error handling without affecting the global behavior of the application."
    },
    {
      "name": "test_abort_no_app",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 188,
      "end_line_number": 193,
      "source_code": "def test_abort_no_app():\n    with pytest.raises(werkzeug.exceptions.Unauthorized):\n        flask.abort(401)\n\n    with pytest.raises(LookupError):\n        flask.abort(900)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_app_aborter_class",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 196,
      "end_line_number": 204,
      "source_code": "def test_app_aborter_class():\n    class MyAborter(werkzeug.exceptions.Aborter):\n        pass\n\n    class MyFlask(flask.Flask):\n        aborter_class = MyAborter\n\n    app = MyFlask(__name__)\n    assert isinstance(app.aborter, MyAborter)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(app.aborter, MyAborter)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_abort_with_app",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 207,
      "end_line_number": 214,
      "source_code": "def test_abort_with_app(app):\n    class My900Error(werkzeug.exceptions.HTTPException):\n        code = 900\n\n    app.aborter.mapping[900] = My900Error\n\n    with app.app_context(), pytest.raises(My900Error):\n        flask.abort(900)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_name_with_import_error",
      "module": "test_helpers",
      "class_name": "TestNoImports",
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 228,
      "end_line_number": 233,
      "source_code": "def test_name_with_import_error(self, modules_tmp_path):\n        (modules_tmp_path / \"importerror.py\").write_text(\"raise NotImplementedError()\")\n        try:\n            flask.Flask(\"importerror\")\n        except NotImplementedError:\n            AssertionError(\"Flask(import_name) is importing import_name.\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "modules_tmp_path"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_streaming_with_context",
      "module": "test_helpers",
      "class_name": "TestStreaming",
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 237,
      "end_line_number": 248,
      "source_code": "def test_streaming_with_context(self, app, client):\n        @app.route(\"/\")\n        def index():\n            def generate():\n                yield \"Hello \"\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(flask.stream_with_context(generate()))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "client"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'Hello World!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "generate",
          "body": "def generate():\n    yield 'Hello '\n    yield flask.request.args['name']\n    yield '!'"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_streaming_with_context` test is to verify that the Flask application can correctly stream responses while maintaining the request context. It ensures that the application can yield multiple parts of a response and that the context (like request arguments) is preserved throughout the streaming process.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the response generated by the `generate` function, which yields parts of a string, correctly concatenates the yielded values into a single response. It verifies that when the client makes a GET request with a query parameter (`name=World`), the final output is `b\"Hello World!\"`, demonstrating that the request context is accessible during the streaming.\n\n**Code Being Tested and How It Works**:  \nThe code being tested includes a Flask route defined in the `index` function, which uses a generator function `generate` to yield parts of a string. The `flask.stream_with_context` function is used to ensure that the request context is available within the generator. When the client makes a GET request to the root URL (`/`), the `generate` function yields \"Hello \", the value of the `name` query parameter, and \"!\", which are then combined into a single response.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Streaming Response**: It uses Flask's streaming capabilities to yield parts of a response incrementally.\n- **Context Management**: The use of `flask.stream_with_context` ensures that the request context is preserved across the generator's execution, which is crucial for accessing request-specific data.\n- **Client Simulation**: The test uses the `client` fixture to simulate HTTP requests to the Flask application, allowing for integration-style testing of the route's behavior.\n- **Assertions**: The test asserts the final output of the response to ensure it matches the expected byte string, confirming the correctness of the streaming logic."
    },
    {
      "name": "test_streaming_with_context_as_decorator",
      "module": "test_helpers",
      "class_name": "TestStreaming",
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 250,
      "end_line_number": 262,
      "source_code": "def test_streaming_with_context_as_decorator(self, app, client):\n        @app.route(\"/\")\n        def index():\n            @flask.stream_with_context\n            def generate(hello):\n                yield hello\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(generate(\"Hello \"))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "client"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'Hello World!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "generate",
          "body": "def generate():\n    yield 'Hello '\n    yield flask.request.args['name']\n    yield '!'"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_streaming_with_context_as_decorator` test verifies that the Flask application can correctly stream a response while maintaining access to the request context using the `stream_with_context` decorator. It ensures that the response generated by the streaming function includes the expected data based on the request parameters.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the response from the endpoint correctly concatenates a greeting with a name provided in the query string. It confirms that the `generate` function can yield values that include both a static string and a dynamic value from the request arguments.\n\n**Code Being Tested and How It Works**:  \nThe code under test defines a Flask route at the root URL (\"/\"). Inside this route, a generator function `generate` is decorated with `@flask.stream_with_context`, allowing it to access the request context. The generator yields a greeting (\"Hello \"), the value of the \"name\" query parameter, and an exclamation mark. The response is constructed using `flask.Response`, which streams the output of the generator. The test then simulates a GET request to the endpoint with the query parameter `name=World` and asserts that the response data matches the expected byte string `b\"Hello World!\"`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of Flask's test client to simulate HTTP requests and responses, allowing for integration-style testing of the application. It also utilizes the `stream_with_context` decorator, which is a notable pattern in Flask for managing request contexts in streaming responses. The test asserts the correctness of the response data, ensuring that the application behaves as expected when handling streamed responses with context."
    },
    {
      "name": "test_streaming_with_context_and_custom_close",
      "module": "test_helpers",
      "class_name": "TestStreaming",
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 264,
      "end_line_number": 293,
      "source_code": "def test_streaming_with_context_and_custom_close(self, app, client):\n        called = []\n\n        class Wrapper:\n            def __init__(self, gen):\n                self._gen = gen\n\n            def __iter__(self):\n                return self\n\n            def close(self):\n                called.append(42)\n\n            def __next__(self):\n                return next(self._gen)\n\n            next = __next__\n\n        @app.route(\"/\")\n        def index():\n            def generate():\n                yield \"Hello \"\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(flask.stream_with_context(Wrapper(generate())))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\"\n        assert called == [42]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "client"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'Hello World!'",
        "assert called == [42]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "generate",
          "body": "def generate():\n    yield 'Hello '\n    yield flask.request.args['name']\n    yield '!'"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_streaming_with_context_and_custom_close` test is to verify that a Flask application can stream responses correctly while managing the context and ensuring that a custom close method is invoked when the response is finished.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the response data returned from the Flask route is as expected (\"Hello World!\") and that the custom `close` method of the `Wrapper` class is called, which appends the value `42` to the `called` list. This ensures that resource cleanup or any finalization logic defined in the `close` method is executed.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a Flask route defined in the `index` function, which uses a generator function `generate` to yield parts of a response. The `Wrapper` class is designed to wrap this generator, providing an iterable interface and a custom `close` method. The `flask.stream_with_context` function is used to ensure that the request context is preserved during the streaming of the response. The test simulates a GET request to the route with a query parameter (`name=World`) and checks the response data and the state of the `called` list.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Context Management**: It uses `flask.stream_with_context` to manage the request context during streaming, which is crucial for accessing request-specific data.\n- **Custom Wrapper Class**: The `Wrapper` class encapsulates the generator and provides a custom `close` method, demonstrating how to extend functionality while adhering to iterable protocols.\n- **Assertions**: The test includes assertions to validate both the content of the response and the side effects (the `called` list), ensuring comprehensive verification of the behavior being tested."
    },
    {
      "name": "test_stream_keeps_session",
      "module": "test_helpers",
      "class_name": "TestStreaming",
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 295,
      "end_line_number": 307,
      "source_code": "def test_stream_keeps_session(self, app, client):\n        @app.route(\"/\")\n        def index():\n            flask.session[\"test\"] = \"flask\"\n\n            @flask.stream_with_context\n            def gen():\n                yield flask.session[\"test\"]\n\n            return flask.Response(gen())\n\n        rv = client.get(\"/\")\n        assert rv.data == b\"flask\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "client"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'flask'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "gen",
          "body": "@flask.stream_with_context\ndef gen():\n    yield flask.session['test']"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_stream_keeps_session` test verifies that the Flask application correctly maintains session data when using streaming responses. It ensures that the session data set during the request is accessible and returned in the response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the value stored in the session (in this case, the string \"flask\") is correctly yielded and returned as part of the response when the endpoint is accessed. It confirms that the session context is preserved across the streaming generator function.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a Flask route defined in the `index` function, which sets a session variable `flask.session[\"test\"]` to \"flask\". It then defines a generator function `gen` decorated with `@flask.stream_with_context`, which yields the session value. The response is created using `flask.Response(gen())`, which streams the output of the generator. The test makes a GET request to the root endpoint (\"/\") and asserts that the response data matches the expected byte string `b\"flask\"`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of Flask's test client to simulate a request to the application, allowing for easy verification of the response. It also utilizes the `@flask.stream_with_context` decorator, which is crucial for maintaining the request context (including session data) during the streaming process. This pattern is particularly useful in scenarios where data needs to be sent in chunks, ensuring that the session remains accessible throughout the streaming operation."
    },
    {
      "name": "test_get_debug_flag",
      "module": "test_helpers",
      "class_name": "TestHelpers",
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 321,
      "end_line_number": 323,
      "source_code": "def test_get_debug_flag(self, monkeypatch, debug, expect):\n        monkeypatch.setenv(\"FLASK_DEBUG\", debug)\n        assert get_debug_flag() == expect",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize(('debug', 'expect'), [('', False), ('0', False), ('False', False), ('No', False), ('True', True)])"
      ],
      "arguments": [
        "self",
        "monkeypatch",
        "debug",
        "expect"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert get_debug_flag() == expect"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_make_response",
      "module": "test_helpers",
      "class_name": "TestHelpers",
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 325,
      "end_line_number": 335,
      "source_code": "def test_make_response(self):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            rv = flask.helpers.make_response()\n            assert rv.status_code == 200\n            assert rv.mimetype == \"text/html\"\n\n            rv = flask.helpers.make_response(\"Hello\")\n            assert rv.status_code == 200\n            assert rv.data == b\"Hello\"\n            assert rv.mimetype == \"text/html\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 200",
        "assert rv.mimetype == 'text/html'",
        "assert rv.status_code == 200",
        "assert rv.data == b'Hello'",
        "assert rv.mimetype == 'text/html'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_open_resource",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 339,
      "end_line_number": 343,
      "source_code": "def test_open_resource(mode):\n    app = flask.Flask(__name__)\n\n    with app.open_resource(\"static/index.html\", mode) as f:\n        assert \"<h1>Hello World!</h1>\" in str(f.read())",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('mode', ('r', 'rb', 'rt'))"
      ],
      "arguments": [
        "mode"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert '<h1>Hello World!</h1>' in str(f.read())"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "f.read",
          "body": "@app.route('/read')\ndef read():\n    return str(flask.session.get('foo', 0))"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_open_resource` function is designed to verify that the Flask application can successfully open and read a static resource file (in this case, `static/index.html`) and that the content of this file contains the expected HTML string `<h1>Hello World!</h1>`.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks the behavior of the `open_resource` method of the Flask application, ensuring that it can read files correctly in various modes (read modes such as `r`, `rb`, and `rt`). It confirms that the content read from the file matches the expected string, thereby validating the file's existence and content.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `open_resource` method of the Flask application instance. This method is used to open a resource file located in the application's static folder. The test uses a context manager (`with` statement) to open the file, read its contents, and then checks if the expected string is present in the read data. The `mode` parameter allows for testing different file access modes, which is crucial for ensuring that the method behaves correctly under various scenarios.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the parameterized testing technique using `pytest.mark.parametrize`, which allows the same test function to be executed multiple times with different input values (in this case, different file modes). This approach enhances test coverage and reduces code duplication. Additionally, the use of assertions to verify the presence of the expected string in the file content is a standard practice in unit testing, ensuring that the test fails if the content does not match expectations."
    },
    {
      "name": "test_open_resource_exceptions",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 347,
      "end_line_number": 351,
      "source_code": "def test_open_resource_exceptions(mode):\n    app = flask.Flask(__name__)\n\n    with pytest.raises(ValueError):\n        app.open_resource(\"static/index.html\", mode)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('mode', ('w', 'x', 'a', 'r+'))"
      ],
      "arguments": [
        "mode"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_open_resource_with_encoding",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 355,
      "end_line_number": 360,
      "source_code": "def test_open_resource_with_encoding(tmp_path, encoding):\n    app = flask.Flask(__name__, root_path=os.fspath(tmp_path))\n    (tmp_path / \"test\").write_text(\"test\", encoding=encoding)\n\n    with app.open_resource(\"test\", mode=\"rt\", encoding=encoding) as f:\n        assert f.read() == \"test\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('encoding', ('utf-8', 'utf-16-le'))"
      ],
      "arguments": [
        "tmp_path",
        "encoding"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert f.read() == 'test'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "f.read",
          "body": "@app.route('/read')\ndef read():\n    return str(flask.session.get('foo', 0))"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_open_resource_with_encoding` test is designed to verify that the Flask application can correctly open and read a resource file with a specified encoding. This ensures that the application handles text files properly, especially when different character encodings are involved.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a text file is created with a specific encoding and then opened using the Flask application's `open_resource` method, the content read from the file matches the expected string. This confirms that the encoding is respected during the read operation.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `open_resource` method of the Flask application, which is responsible for opening files located in the application's root path. The method allows specifying the mode (in this case, read text mode) and the encoding. The test creates a temporary file with the name \"test\" in the specified encoding, writes the string \"test\" to it, and then reads it back using the `open_resource` method. The assertion checks that the content read from the file matches the original string.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Temporary File Creation**: The use of `tmp_path` allows for the creation of a temporary directory for testing, ensuring that tests do not interfere with each other or the file system.\n- **Parameterized Testing**: The test function accepts `encoding` as an argument, which suggests that it may be part of a parameterized test suite that runs the same test with different encoding values, enhancing coverage for various scenarios.\n- **Context Management**: The use of a context manager (`with` statement) ensures that the file is properly opened and closed, which is a good practice for resource management in Python."
    },
    {
      "name": "test_send_file",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 34,
      "end_line_number": 43,
      "source_code": "def test_send_file(self, app, req_ctx):\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.direct_passthrough\n        assert rv.mimetype == \"text/html\"\n\n        with app.open_resource(\"static/index.html\") as f:\n            rv.direct_passthrough = False\n            assert rv.data == f.read()\n\n        rv.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "req_ctx"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.direct_passthrough",
        "assert rv.mimetype == 'text/html'",
        "assert rv.data == f.read()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)"
        },
        {
          "name": "f.read",
          "body": "@app.route('/read')\ndef read():\n    return str(flask.session.get('foo', 0))"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_send_file` function is designed to verify the behavior of Flask's `send_file` function when serving a static HTML file. It ensures that the file is sent correctly with the expected properties, such as MIME type and data integrity.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main aspects: \n1. It verifies that the response (`rv`) from `send_file` has the `direct_passthrough` attribute set to `True`, indicating that the file is being sent directly without buffering.\n2. It confirms that the MIME type of the response is `text/html`, which is appropriate for an HTML file. Additionally, it checks that the data returned in the response matches the content of the file being served.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `send_file` function from Flask, which is responsible for sending files to the client. It takes a file path or file-like object as input and returns a response object. The test specifically opens the file `static/index.html` using `app.open_resource`, reads its content, and compares it to the data in the response. The `rv.close()` method is called to ensure that any resources associated with the response are properly released.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The test uses a context manager (`with` statement) to safely open the file resource, ensuring that it is properly closed after reading.\n- **Assertions**: The test employs assertions to validate the expected outcomes, which is a common practice in unit testing to confirm that the code behaves as intended.\n- **Direct Interaction with Flask's Response**: The test directly manipulates and inspects the response object (`rv`), checking its attributes and data, which is a typical approach in testing web frameworks to ensure that the correct data is being sent to the client."
    },
    {
      "name": "test_static_file",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 45,
      "end_line_number": 90,
      "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "req_ctx"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.cache_control.max_age is None",
        "assert rv.cache_control.max_age is None",
        "assert rv.cache_control.max_age == 3600",
        "assert rv.cache_control.max_age == 3600",
        "assert rv.cache_control.max_age == 3600",
        "assert rv.cache_control.max_age == 10",
        "assert rv.cache_control.max_age == 10"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)"
        },
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)"
        },
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)"
        },
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)"
        },
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)"
        },
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)"
        },
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:\nThe `test_static_file` function is designed to verify the behavior of Flask's static file serving mechanism, specifically focusing on the `max_age` attribute of the `Cache-Control` header. It ensures that the caching behavior is correctly configured based on the application settings and the specific implementation of the static file handler.\n\n**Specific Functionality or Behavior Verified**:\nThe test checks that:\n1. The default `max_age` for static files is `None`.\n2. When the `SEND_FILE_MAX_AGE_DEFAULT` configuration is set to a specific value (e.g., `3600`), the `max_age` for served static files reflects this value.\n3. The `max_age` can be overridden by a custom implementation in a subclass of `Flask`.\n4. The test also verifies that the static file serving works correctly with different types of file references, including strings and `pathlib.Path` objects.\n\n**Code Being Tested and How It Works**:\nThe code under test includes the `send_static_file` method of the Flask application, which serves static files. The `max_age` attribute is part of the `Cache-Control` header in the response, which dictates how long the file can be cached by the client. The test manipulates the application configuration to set the `SEND_FILE_MAX_AGE_DEFAULT` and checks the resulting `max_age` in the response. It also tests a custom subclass of `Flask` that overrides the `get_send_file_max_age` method to return a different caching duration.\n\n**Notable Testing Patterns or Techniques Used**:\n1. **Context Management**: The test uses Flask's `test_request_context()` to simulate a request context, allowing the test to access request-specific features without needing to run a full server.\n2. **Assertions**: The test employs assertions to validate the expected behavior of the `max_age` attribute, ensuring that the caching logic is functioning as intended.\n3. **Isolation of Tests**: The test modifies the application configuration temporarily and restores it afterward, ensuring that changes do not affect other tests.\n4. **Custom Class Testing**: The test demonstrates how to extend Flask's functionality by creating a subclass (`StaticFileApp`) to customize behavior, showcasing the flexibility of the framework."
    },
    {
      "name": "test_send_from_directory",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 92,
      "end_line_number": 99,
      "source_code": "def test_send_from_directory(self, app, req_ctx):\n        app.root_path = os.path.join(\n            os.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n        )\n        rv = flask.send_from_directory(\"static\", \"hello.txt\")\n        rv.direct_passthrough = False\n        assert rv.data.strip() == b\"Hello Subdomain\"\n        rv.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "req_ctx"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data.strip() == b'Hello Subdomain'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_send_from_directory` unit test is designed to verify the functionality of the `flask.send_from_directory` method, ensuring that it correctly serves a file from a specified directory within the Flask application. This test checks that the file content returned matches the expected data.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically verifies that when a request is made to send the file `hello.txt` from the `static` directory, the response data matches the expected byte string `b\"Hello Subdomain\"`. It also sets `rv.direct_passthrough` to `False`, indicating that the response should not be passed through directly to the client, which is a common behavior when serving files.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `send_from_directory` function, which is a secure way to serve files from a specified directory. It uses `werkzeug.security.safe_join` to prevent directory traversal attacks, ensuring that the requested file is within the allowed directory. The test sets the `app.root_path` to a specific directory and then calls `flask.send_from_directory(\"static\", \"hello.txt\")`, which attempts to retrieve the file `hello.txt` from the `static` directory relative to the application's root path.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the response data, specifically checking that the stripped response data matches the expected byte string. It also utilizes the `rv.close()` method to ensure that any resources associated with the response are properly released after the test. The test is structured to run within a Flask application context, which is essential for testing Flask routes and helpers effectively."
    },
    {
      "name": "test_url_for_with_anchor",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 103,
      "end_line_number": 108,
      "source_code": "def test_url_for_with_anchor(self, app, req_ctx):\n        @app.route(\"/\")\n        def index():\n            return \"42\"\n\n        assert flask.url_for(\"index\", _anchor=\"x y\") == \"/#x%20y\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "req_ctx"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.url_for('index', _anchor='x y') == '/#x%20y'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_url_for_with_scheme",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 110,
      "end_line_number": 118,
      "source_code": "def test_url_for_with_scheme(self, app, req_ctx):\n        @app.route(\"/\")\n        def index():\n            return \"42\"\n\n        assert (\n            flask.url_for(\"index\", _external=True, _scheme=\"https\")\n            == \"https://localhost/\"\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "req_ctx"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.url_for('index', _external=True, _scheme='https') == 'https://localhost/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_url_for_with_scheme_not_external",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 120,
      "end_line_number": 129,
      "source_code": "def test_url_for_with_scheme_not_external(self, app, req_ctx):\n        app.add_url_rule(\"/\", endpoint=\"index\")\n\n        # Implicit external with scheme.\n        url = flask.url_for(\"index\", _scheme=\"https\")\n        assert url == \"https://localhost/\"\n\n        # Error when external=False with scheme\n        with pytest.raises(ValueError):\n            flask.url_for(\"index\", _scheme=\"https\", _external=False)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "req_ctx"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert url == 'https://localhost/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_url_for_with_alternating_schemes",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 131,
      "end_line_number": 141,
      "source_code": "def test_url_for_with_alternating_schemes(self, app, req_ctx):\n        @app.route(\"/\")\n        def index():\n            return \"42\"\n\n        assert flask.url_for(\"index\", _external=True) == \"http://localhost/\"\n        assert (\n            flask.url_for(\"index\", _external=True, _scheme=\"https\")\n            == \"https://localhost/\"\n        )\n        assert flask.url_for(\"index\", _external=True) == \"http://localhost/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "req_ctx"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.url_for('index', _external=True) == 'http://localhost/'",
        "assert flask.url_for('index', _external=True, _scheme='https') == 'https://localhost/'",
        "assert flask.url_for('index', _external=True) == 'http://localhost/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_url_with_method",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 143,
      "end_line_number": 162,
      "source_code": "def test_url_with_method(self, app, req_ctx):\n        from flask.views import MethodView\n\n        class MyView(MethodView):\n            def get(self, id=None):\n                if id is None:\n                    return \"List\"\n                return f\"Get {id:d}\"\n\n            def post(self):\n                return \"Create\"\n\n        myview = MyView.as_view(\"myview\")\n        app.add_url_rule(\"/myview/\", methods=[\"GET\"], view_func=myview)\n        app.add_url_rule(\"/myview/<int:id>\", methods=[\"GET\"], view_func=myview)\n        app.add_url_rule(\"/myview/create\", methods=[\"POST\"], view_func=myview)\n\n        assert flask.url_for(\"myview\", _method=\"GET\") == \"/myview/\"\n        assert flask.url_for(\"myview\", id=42, _method=\"GET\") == \"/myview/42\"\n        assert flask.url_for(\"myview\", _method=\"POST\") == \"/myview/create\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "req_ctx"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.url_for('myview', _method='GET') == '/myview/'",
        "assert flask.url_for('myview', id=42, _method='GET') == '/myview/42'",
        "assert flask.url_for('myview', _method='POST') == '/myview/create'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_url_for_with_self",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 164,
      "end_line_number": 169,
      "source_code": "def test_url_for_with_self(self, app, req_ctx):\n        @app.route(\"/<self>\")\n        def index(self):\n            return \"42\"\n\n        assert flask.url_for(\"index\", self=\"2\") == \"/2\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "req_ctx"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.url_for('index', self='2') == '/2'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_name_with_import_error",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 228,
      "end_line_number": 233,
      "source_code": "def test_name_with_import_error(self, modules_tmp_path):\n        (modules_tmp_path / \"importerror.py\").write_text(\"raise NotImplementedError()\")\n        try:\n            flask.Flask(\"importerror\")\n        except NotImplementedError:\n            AssertionError(\"Flask(import_name) is importing import_name.\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "modules_tmp_path"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_streaming_with_context",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 237,
      "end_line_number": 248,
      "source_code": "def test_streaming_with_context(self, app, client):\n        @app.route(\"/\")\n        def index():\n            def generate():\n                yield \"Hello \"\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(flask.stream_with_context(generate()))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "client"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'Hello World!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "generate",
          "body": "def generate():\n    yield 'Hello '\n    yield flask.request.args['name']\n    yield '!'"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_streaming_with_context` test is to verify that the Flask application can correctly stream responses while maintaining the request context. It ensures that the application can yield multiple parts of a response and that the context (like request arguments) is preserved throughout the streaming process.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the response generated by the `generate` function correctly concatenates the string \"Hello \", the value of the `name` query parameter from the request, and the string \"!\" into a single response. It asserts that when the client makes a GET request with the query parameter `name=World`, the complete response is `b\"Hello World!\"`.\n\n**Code Being Tested and How It Works**:  \nThe code being tested includes a Flask route defined by the `index` function, which uses a generator function `generate` to yield parts of the response. The `flask.stream_with_context` function is used to ensure that the request context is available within the generator. The test simulates a client request to the root endpoint (\"/\") with a query parameter and checks the response data.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Streaming Response**: It uses a generator to yield parts of the response, demonstrating how Flask can handle streaming data.\n- **Context Management**: The use of `flask.stream_with_context` ensures that the request context is preserved across the generator's execution, which is crucial for accessing request-specific data.\n- **Client Simulation**: The test uses the `client` fixture to simulate HTTP requests, allowing for integration-style testing of the Flask application.\n- **Assertions**: The test asserts the expected output using a byte string comparison, ensuring that the response matches the anticipated format."
    },
    {
      "name": "test_streaming_with_context_as_decorator",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 250,
      "end_line_number": 262,
      "source_code": "def test_streaming_with_context_as_decorator(self, app, client):\n        @app.route(\"/\")\n        def index():\n            @flask.stream_with_context\n            def generate(hello):\n                yield hello\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(generate(\"Hello \"))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "client"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'Hello World!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "generate",
          "body": "def generate():\n    yield 'Hello '\n    yield flask.request.args['name']\n    yield '!'"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_streaming_with_context_as_decorator` verifies that the Flask application can correctly stream a response while maintaining access to the request context using the `stream_with_context` decorator. It ensures that the response generated by the streaming function includes the expected data based on the request parameters.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a client makes a GET request to the root endpoint (\"/\") with a query parameter `name`, the response correctly concatenates the string \"Hello \", the value of the `name` parameter, and an exclamation mark (\"!\"). Specifically, it verifies that the response data matches the expected byte string `b\"Hello World!\"` when the `name` parameter is set to \"World\".\n\n**Code Being Tested and How It Works**:  \nThe code under test defines a Flask route at the root URL (\"/\") that uses a nested generator function `generate`, decorated with `@flask.stream_with_context`. This generator yields a greeting string, the value of the `name` parameter from the request, and a closing exclamation mark. The `flask.Response` object is created using this generator, allowing the response to be streamed back to the client while still having access to the request context.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of Flask's test client to simulate a GET request, allowing for easy verification of the response. It also utilizes the `stream_with_context` decorator, which is a key feature in Flask for managing request contexts in streaming responses. The test asserts the correctness of the response data using a simple equality check, which is a common pattern in unit testing to validate expected outcomes."
    },
    {
      "name": "test_streaming_with_context_and_custom_close",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 264,
      "end_line_number": 293,
      "source_code": "def test_streaming_with_context_and_custom_close(self, app, client):\n        called = []\n\n        class Wrapper:\n            def __init__(self, gen):\n                self._gen = gen\n\n            def __iter__(self):\n                return self\n\n            def close(self):\n                called.append(42)\n\n            def __next__(self):\n                return next(self._gen)\n\n            next = __next__\n\n        @app.route(\"/\")\n        def index():\n            def generate():\n                yield \"Hello \"\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(flask.stream_with_context(Wrapper(generate())))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\"\n        assert called == [42]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "client"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'Hello World!'",
        "assert called == [42]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "generate",
          "body": "def generate():\n    yield 'Hello '\n    yield flask.request.args['name']\n    yield '!'"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_streaming_with_context_and_custom_close` is designed to verify that a Flask application can stream responses correctly while managing the context and ensuring that a custom close method is invoked when the response is finished. This is particularly important for resource management and cleanup in web applications.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main behaviors: \n1. It verifies that the response data returned from the streaming generator is as expected (i.e., \"Hello World!\").\n2. It ensures that the custom `close` method of the `Wrapper` class is called, which appends the value `42` to the `called` list, confirming that the cleanup logic is executed.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a Flask route defined by the `index` function, which uses a generator function `generate` to yield parts of a response. The `Wrapper` class is used to wrap this generator, providing an iterable interface and a custom `close` method. The `flask.stream_with_context` function is employed to ensure that the request context is preserved during the streaming process. When the client makes a GET request to the route with the query parameter `name=World`, the response is constructed by streaming the output of the generator through the `Wrapper`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The use of `flask.stream_with_context` allows the test to maintain the request context during the streaming of the response, which is crucial for accessing request-specific data.\n- **Custom Wrapper Class**: The `Wrapper` class encapsulates the generator and provides a custom `close` method, demonstrating how to extend functionality while adhering to Python's iterator protocol.\n- **Assertions**: The test employs assertions to validate both the content of the response and the side effect of invoking the `close` method, ensuring comprehensive verification of the functionality."
    },
    {
      "name": "test_stream_keeps_session",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 295,
      "end_line_number": 307,
      "source_code": "def test_stream_keeps_session(self, app, client):\n        @app.route(\"/\")\n        def index():\n            flask.session[\"test\"] = \"flask\"\n\n            @flask.stream_with_context\n            def gen():\n                yield flask.session[\"test\"]\n\n            return flask.Response(gen())\n\n        rv = client.get(\"/\")\n        assert rv.data == b\"flask\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "client"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'flask'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "gen",
          "body": "@flask.stream_with_context\ndef gen():\n    yield flask.session['test']"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_stream_keeps_session` test verifies that the Flask application correctly maintains session data when using streaming responses. It ensures that the session data set during the request is accessible and returned in the response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the value stored in the session (in this case, the string \"flask\") is correctly yielded and returned as part of the streaming response. It confirms that the session context is preserved across the streaming operation.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a Flask route defined in the `index` function, which sets a session variable `flask.session[\"test\"]` to \"flask\". It then defines a generator function `gen` decorated with `@flask.stream_with_context`, which yields the session value. The response is created using `flask.Response(gen())`, which streams the output of the generator. The test makes a GET request to the root URL (\"/\") and asserts that the response data matches the expected byte string `b\"flask\"`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of Flask's test client to simulate a request to the application, allowing for easy verification of the response. It also utilizes the `@flask.stream_with_context` decorator to ensure that the session context is available within the generator function. This pattern is crucial for testing streaming responses while maintaining access to request-specific data, such as session variables."
    },
    {
      "name": "test_get_debug_flag",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 321,
      "end_line_number": 323,
      "source_code": "def test_get_debug_flag(self, monkeypatch, debug, expect):\n        monkeypatch.setenv(\"FLASK_DEBUG\", debug)\n        assert get_debug_flag() == expect",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize(('debug', 'expect'), [('', False), ('0', False), ('False', False), ('No', False), ('True', True)])"
      ],
      "arguments": [
        "self",
        "monkeypatch",
        "debug",
        "expect"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert get_debug_flag() == expect"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_make_response",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_helpers.py",
      "line_number": 325,
      "end_line_number": 335,
      "source_code": "def test_make_response(self):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            rv = flask.helpers.make_response()\n            assert rv.status_code == 200\n            assert rv.mimetype == \"text/html\"\n\n            rv = flask.helpers.make_response(\"Hello\")\n            assert rv.status_code == 200\n            assert rv.data == b\"Hello\"\n            assert rv.mimetype == \"text/html\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "io",
        "os",
        "pytest",
        "werkzeug.exceptions",
        "flask",
        "flask.helpers.get_debug_flag",
        "flask.views.MethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 200",
        "assert rv.mimetype == 'text/html'",
        "assert rv.status_code == 200",
        "assert rv.data == b'Hello'",
        "assert rv.mimetype == 'text/html'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_async_route",
      "module": "test_async",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_async.py",
      "line_number": 82,
      "end_line_number": 87,
      "source_code": "def test_async_route(path, async_app):\n    test_client = async_app.test_client()\n    response = test_client.get(path)\n    assert b\"GET\" in response.get_data()\n    response = test_client.post(path)\n    assert b\"POST\" in response.get_data()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('path', ['/', '/home', '/bp/', '/view', '/methodview'])"
      ],
      "arguments": [
        "path",
        "async_app"
      ],
      "imports": [
        "asyncio",
        "pytest",
        "flask.Blueprint",
        "flask.Flask",
        "flask.request",
        "flask.views.MethodView",
        "flask.views.View"
      ],
      "fixtures": [],
      "assertions": [
        "assert b'GET' in response.get_data()",
        "assert b'POST' in response.get_data()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "test_client.post",
          "body": "def post(self):\n    return 'Create'"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_async_route` function is designed to verify the behavior of asynchronous routes in a Flask application. It specifically tests the handling of GET and POST requests to a specified path, ensuring that the application responds correctly to both types of requests.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a GET request is made to the specified path, the response contains the string \"GET\", and when a POST request is made, the response contains the string \"POST\". This confirms that the application is correctly processing different HTTP methods and returning appropriate responses.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with two route handlers: one for GET requests and another for POST requests. The GET handler retrieves a value from the session (defaulting to 'None' if not set) and returns it, while the POST handler simply returns the string 'Create'. The test uses Flask's test client to simulate requests to these routes and checks the response data for the expected content.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Test Client Usage**: The test utilizes Flask's built-in test client to simulate HTTP requests, allowing for isolated testing of route behavior without needing to run a live server.\n- **Assertions**: The test employs assertions to validate the response data, ensuring that the application behaves as expected for both GET and POST requests.\n- **Parameterization**: The test function accepts parameters (`path` and `async_app`), which allows for flexible testing of different routes and applications, promoting reusability and scalability in the test suite."
    },
    {
      "name": "test_async_error_handler",
      "module": "test_async",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_async.py",
      "line_number": 91,
      "end_line_number": 94,
      "source_code": "def test_async_error_handler(path, async_app):\n    test_client = async_app.test_client()\n    response = test_client.get(path)\n    assert response.status_code == 412",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('path', ['/error', '/bp/error'])"
      ],
      "arguments": [
        "path",
        "async_app"
      ],
      "imports": [
        "asyncio",
        "pytest",
        "flask.Blueprint",
        "flask.Flask",
        "flask.request",
        "flask.views.MethodView",
        "flask.views.View"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 412"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_async_error_handler` function is designed to verify the behavior of an asynchronous Flask application when a specific endpoint is accessed. It checks that the application correctly returns a 412 status code, which typically indicates a precondition failure.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically verifies that when a request is made to the given `path`, the response status code is 412. This suggests that the application is expected to handle certain conditions or preconditions that are not met, leading to this specific HTTP response.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the Flask route associated with the `path` parameter. The `async_app` is a Flask application instance configured for asynchronous operations. The test client (`test_client`) is used to simulate a GET request to the specified `path`. The assertion checks if the response's status code matches the expected value of 412, indicating that the application is handling the request as intended under certain conditions.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Test Client Usage**: The test utilizes Flask's test client to simulate HTTP requests, allowing for easy verification of response behavior without needing to run a live server.\n- **Asynchronous Testing**: The test is structured to work with an asynchronous Flask application, which is important for ensuring that the application can handle concurrent requests properly.\n- **Parameterized Testing**: The test function accepts `path` and `async_app` as parameters, suggesting that it can be reused with different paths and application configurations, enhancing test coverage and flexibility."
    },
    {
      "name": "test_async_before_after_request",
      "module": "test_async",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_async.py",
      "line_number": 97,
      "end_line_number": 145,
      "source_code": "def test_async_before_after_request():\n    app_before_called = False\n    app_after_called = False\n    bp_before_called = False\n    bp_after_called = False\n\n    app = Flask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        return \"\"\n\n    @app.before_request\n    async def before():\n        nonlocal app_before_called\n        app_before_called = True\n\n    @app.after_request\n    async def after(response):\n        nonlocal app_after_called\n        app_after_called = True\n        return response\n\n    blueprint = Blueprint(\"bp\", __name__)\n\n    @blueprint.route(\"/\")\n    def bp_index():\n        return \"\"\n\n    @blueprint.before_request\n    async def bp_before():\n        nonlocal bp_before_called\n        bp_before_called = True\n\n    @blueprint.after_request\n    async def bp_after(response):\n        nonlocal bp_after_called\n        bp_after_called = True\n        return response\n\n    app.register_blueprint(blueprint, url_prefix=\"/bp\")\n\n    test_client = app.test_client()\n    test_client.get(\"/\")\n    assert app_before_called\n    assert app_after_called\n    test_client.get(\"/bp/\")\n    assert bp_before_called\n    assert bp_after_called",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "flask.Blueprint",
        "flask.Flask",
        "flask.request",
        "flask.views.MethodView",
        "flask.views.View"
      ],
      "fixtures": [],
      "assertions": [
        "assert app_before_called",
        "assert app_after_called",
        "assert bp_before_called",
        "assert bp_after_called"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "test_client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "test_client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_async_before_after_request` test is to verify that the asynchronous `before_request` and `after_request` hooks in a Flask application and its associated blueprint are correctly invoked during HTTP requests. This ensures that the application lifecycle hooks function as expected in an asynchronous context.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the flags `app_before_called`, `app_after_called`, `bp_before_called`, and `bp_after_called` are set to `True` after making GET requests to the root endpoint and the blueprint endpoint. This confirms that the respective hooks are executed before and after the request handling.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Flask application with a root route and a blueprint that also has a route. It defines asynchronous `before_request` and `after_request` functions for both the application and the blueprint. When a request is made to the root route (`/`) and the blueprint route (`/bp/`), the test checks if the corresponding flags are set, indicating that the hooks were called. The `nonlocal` keyword is used to modify the flags defined in the outer scope of the test function.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test utilizes asynchronous functions for the request hooks, demonstrating how Flask can handle async operations.\n- **Nonlocal Variables**: The use of `nonlocal` allows the test to modify variables defined in the enclosing scope, which is a useful technique for tracking state across nested functions.\n- **Blueprints**: The test showcases the use of Flask blueprints, which help organize routes and handlers, and verifies that hooks can be applied at both the application and blueprint levels.\n- **Assertions**: The test employs assertions to validate that the expected behavior occurs, ensuring that the hooks are triggered as intended during the request lifecycle."
    },
    {
      "name": "test_suppressed_exception_logging",
      "module": "test_subclassing",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_subclassing.py",
      "line_number": 6,
      "end_line_number": 21,
      "source_code": "def test_suppressed_exception_logging():\n    class SuppressedFlask(flask.Flask):\n        def log_exception(self, exc_info):\n            pass\n\n    out = StringIO()\n    app = SuppressedFlask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        raise Exception(\"test\")\n\n    rv = app.test_client().get(\"/\", errors_stream=out)\n    assert rv.status_code == 500\n    assert b\"Internal Server Error\" in rv.data\n    assert not out.getvalue()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "io.StringIO",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 500",
        "assert b'Internal Server Error' in rv.data",
        "assert not out.getvalue()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_options_work",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 28,
      "end_line_number": 35,
      "source_code": "def test_options_work(app, client):\n    @app.route(\"/\", methods=[\"GET\", \"POST\"])\n    def index():\n        return \"Hello World\"\n\n    rv = client.open(\"/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n    assert rv.data == b\"\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST']",
        "assert rv.data == b''"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_options_on_multiple_rules",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 38,
      "end_line_number": 48,
      "source_code": "def test_options_on_multiple_rules(app, client):\n    @app.route(\"/\", methods=[\"GET\", \"POST\"])\n    def index():\n        return \"Hello World\"\n\n    @app.route(\"/\", methods=[\"PUT\"])\n    def index_put():\n        return \"Aha!\"\n\n    rv = client.open(\"/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\", \"PUT\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_method_route",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 52,
      "end_line_number": 60,
      "source_code": "def test_method_route(app, client, method):\n    method_route = getattr(app, method)\n    client_method = getattr(client, method)\n\n    @method_route(\"/\")\n    def hello():\n        return \"Hello\"\n\n    assert client_method(\"/\").data == b\"Hello\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('method', ['get', 'post', 'put', 'delete', 'patch'])"
      ],
      "arguments": [
        "app",
        "client",
        "method"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert client_method('/').data == b'Hello'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_method_route_no_methods",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 63,
      "end_line_number": 65,
      "source_code": "def test_method_route_no_methods(app):\n    with pytest.raises(TypeError):\n        app.get(\"/\", methods=[\"GET\", \"POST\"])",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_method_route_no_methods` test is to verify that the Flask application raises a `TypeError` when an invalid combination of HTTP methods is specified in a route handler. Specifically, it checks the behavior of the `app.get` method when it is called with a route and a list of methods that are not supported.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the Flask framework correctly handles the situation where a route is requested with methods that are not allowed or improperly specified. In this case, it is expected that the application will raise a `TypeError`, indicating that the method signature is incorrect or that the provided methods are not valid for the route.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `app.get` method, which is part of the Flask routing system. The `app.get` method is used to define a route that responds to GET requests. In this test, the method is called with a route (\"/\") and a list of methods ([\"GET\", \"POST\"]). Since the `app.get` method is designed to only handle GET requests, passing multiple methods in this context is inappropriate, leading to a `TypeError`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that a specific exception (`TypeError`) is raised during the execution of the code block. This is a common pattern in unit testing to verify that error handling works as expected. By encapsulating the call to `app.get` within this context manager, the test effectively checks for the correct exception without needing to handle it explicitly, thus keeping the test clean and focused on the expected outcome."
    },
    {
      "name": "test_provide_automatic_options_attr",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 68,
      "end_line_number": 87,
      "source_code": "def test_provide_automatic_options_attr():\n    app = flask.Flask(__name__)\n\n    def index():\n        return \"Hello World!\"\n\n    index.provide_automatic_options = False\n    app.route(\"/\")(index)\n    rv = app.test_client().open(\"/\", method=\"OPTIONS\")\n    assert rv.status_code == 405\n\n    app = flask.Flask(__name__)\n\n    def index2():\n        return \"Hello World!\"\n\n    index2.provide_automatic_options = True\n    app.route(\"/\", methods=[\"OPTIONS\"])(index2)\n    rv = app.test_client().open(\"/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"OPTIONS\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 405",
        "assert sorted(rv.allow) == ['OPTIONS']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_provide_automatic_options_kwarg",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 90,
      "end_line_number": 124,
      "source_code": "def test_provide_automatic_options_kwarg(app, client):\n    def index():\n        return flask.request.method\n\n    def more():\n        return flask.request.method\n\n    app.add_url_rule(\"/\", view_func=index, provide_automatic_options=False)\n    app.add_url_rule(\n        \"/more\",\n        view_func=more,\n        methods=[\"GET\", \"POST\"],\n        provide_automatic_options=False,\n    )\n    assert client.get(\"/\").data == b\"GET\"\n\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\"]\n\n    rv = client.open(\"/\", method=\"OPTIONS\")\n    assert rv.status_code == 405\n\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"POST\"]\n\n    rv = client.open(\"/more\", method=\"OPTIONS\")\n    assert rv.status_code == 405",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/').data == b'GET'",
        "assert rv.status_code == 405",
        "assert sorted(rv.allow) == ['GET', 'HEAD']",
        "assert rv.status_code == 405",
        "assert rv.status_code == 200",
        "assert not rv.data",
        "assert client.post('/more').data == b'POST'",
        "assert client.get('/more').data == b'GET'",
        "assert rv.status_code == 405",
        "assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']",
        "assert rv.status_code == 405"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'"
        },
        {
          "name": "client.head",
          "body": "def head(self):\n    return flask.Response('', headers={'X-Method': 'HEAD'})"
        },
        {
          "name": "client.delete",
          "body": "def delete(self):\n    return 'DELETE'"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_provide_automatic_options_kwarg` test is to verify the behavior of Flask's routing system when the `provide_automatic_options` argument is set to `False`. This ensures that the application does not automatically provide OPTIONS responses for routes, which is crucial for controlling the HTTP methods that are allowed for specific endpoints.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. A GET request to the root endpoint (\"/\") returns the expected response.\n2. A POST request to the root endpoint results in a 405 Method Not Allowed status, confirming that POST is not permitted.\n3. OPTIONS requests to both endpoints return a 405 status, indicating that OPTIONS is not supported.\n4. A HEAD request to the root endpoint returns a 200 status with no content, verifying that HEAD requests are handled correctly.\n5. The `/more` endpoint correctly processes GET and POST requests while rejecting DELETE requests with a 405 status.\n\n**Code Being Tested and How It Works**:  \nThe test defines two view functions, `index` and `more`, which return the HTTP method of the request. The `app.add_url_rule` method is used to register these functions with specific routes and set `provide_automatic_options` to `False`. This means that Flask will not automatically generate OPTIONS responses for these routes. The test then uses the Flask test client to simulate various HTTP requests to these endpoints and asserts the expected outcomes based on the defined behavior.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertions**: The test employs assertions to validate the responses from the client, checking both the status codes and the response data.\n- **HTTP Method Testing**: It systematically tests different HTTP methods (GET, POST, HEAD, DELETE, OPTIONS) to ensure that the application behaves as expected for each method.\n- **Client Simulation**: The use of `client.get`, `client.post`, and `client.open` methods allows for simulating requests to the Flask application, which is a common pattern in testing web applications.\n- **Error Handling Verification**: The test checks for proper handling of unsupported methods by asserting the correct status codes and allowed methods in the response, ensuring that the application adheres to RESTful principles."
    },
    {
      "name": "test_request_dispatching",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 127,
      "end_line_number": 147,
      "source_code": "def test_request_dispatching(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.request.method\n\n    @app.route(\"/more\", methods=[\"GET\", \"POST\"])\n    def more():\n        return flask.request.method\n\n    assert client.get(\"/\").data == b\"GET\"\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\"]\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/').data == b'GET'",
        "assert rv.status_code == 405",
        "assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS']",
        "assert rv.status_code == 200",
        "assert not rv.data",
        "assert client.post('/more').data == b'POST'",
        "assert client.get('/more').data == b'GET'",
        "assert rv.status_code == 405",
        "assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'"
        },
        {
          "name": "client.head",
          "body": "def head(self):\n    return flask.Response('', headers={'X-Method': 'HEAD'})"
        },
        {
          "name": "client.delete",
          "body": "def delete(self):\n    return 'DELETE'"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_request_dispatching` function is designed to verify the correct handling of HTTP request methods in a Flask application. It ensures that the application responds appropriately to different types of requests (GET, POST, HEAD, DELETE) and that it enforces method restrictions on specific routes.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n- A GET request to the root endpoint (\"/\") returns \"GET\".\n- A POST request to the root endpoint returns a 405 Method Not Allowed status, with allowed methods listed.\n- A HEAD request to the root endpoint returns a 200 status with no body (data).\n- A POST request to the \"/more\" endpoint returns \"POST\".\n- A GET request to the \"/more\" endpoint returns \"GET\".\n- A DELETE request to the \"/more\" endpoint returns a 405 status, with allowed methods listed.\n\n**Code Being Tested and How It Works**:  \nThe code under test consists of two route handlers defined within the `test_request_dispatching` function:\n1. The `index` function handles requests to the root endpoint (\"/\") and returns the request method.\n2. The `more` function handles requests to the \"/more\" endpoint and supports both GET and POST methods, returning the request method accordingly.\n\nThe assertions in the test utilize the `client` fixture to simulate HTTP requests and check the responses against expected outcomes.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertion-Based Testing**: The test uses assertions to validate the expected outcomes of various HTTP requests, ensuring that the application behaves as intended.\n- **Method Testing**: It specifically tests the behavior of different HTTP methods, which is crucial for RESTful API design.\n- **Error Handling Verification**: The test checks for proper error responses (405 Method Not Allowed) when unsupported methods are used, ensuring robust error handling in the application."
    },
    {
      "name": "test_disallow_string_for_allowed_methods",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 150,
      "end_line_number": 152,
      "source_code": "def test_disallow_string_for_allowed_methods(app):\n    with pytest.raises(TypeError):\n        app.add_url_rule(\"/\", methods=\"GET POST\", endpoint=\"test\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_url_mapping",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 155,
      "end_line_number": 188,
      "source_code": "def test_url_mapping(app, client):\n    random_uuid4 = \"7eb41166-9ebf-4d26-b771-ea3f54f8b383\"\n\n    def index():\n        return flask.request.method\n\n    def more():\n        return flask.request.method\n\n    def options():\n        return random_uuid4\n\n    app.add_url_rule(\"/\", \"index\", index)\n    app.add_url_rule(\"/more\", \"more\", more, methods=[\"GET\", \"POST\"])\n\n    # Issue 1288: Test that automatic options are not added\n    #             when non-uppercase 'options' in methods\n    app.add_url_rule(\"/options\", \"options\", options, methods=[\"options\"])\n\n    assert client.get(\"/\").data == b\"GET\"\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\"]\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n    rv = client.open(\"/options\", method=\"OPTIONS\")\n    assert rv.status_code == 200\n    assert random_uuid4 in rv.data.decode(\"utf-8\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/').data == b'GET'",
        "assert rv.status_code == 405",
        "assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS']",
        "assert rv.status_code == 200",
        "assert not rv.data",
        "assert client.post('/more').data == b'POST'",
        "assert client.get('/more').data == b'GET'",
        "assert rv.status_code == 405",
        "assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST']",
        "assert rv.status_code == 200",
        "assert random_uuid4 in rv.data.decode('utf-8')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'"
        },
        {
          "name": "client.head",
          "body": "def head(self):\n    return flask.Response('', headers={'X-Method': 'HEAD'})"
        },
        {
          "name": "client.delete",
          "body": "def delete(self):\n    return 'DELETE'"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_url_mapping` function is designed to verify the correct mapping of URLs to their respective view functions in a Flask application. It ensures that the application responds appropriately to various HTTP methods for different routes, particularly focusing on the handling of OPTIONS requests and the enforcement of allowed methods.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n- The root URL (\"/\") correctly responds to GET requests with \"GET\" and rejects POST requests with a 405 status code.\n- The \"/more\" URL responds to both GET and POST requests appropriately.\n- The \"/options\" URL returns a specific UUID when accessed via OPTIONS.\n- The automatic addition of OPTIONS to the allowed methods is not triggered when the method is specified in lowercase.\n\n**Code Being Tested and How It Works**:  \nThe test sets up three routes:\n1. The root route (\"/\") returns the request method.\n2. The \"/more\" route returns the request method and allows both GET and POST methods.\n3. The \"/options\" route returns a predefined UUID when accessed via OPTIONS.\n\nThe test then uses the Flask test client to simulate requests to these routes, asserting the expected responses and status codes. It checks the response data, status codes, and allowed methods for various HTTP methods (GET, POST, HEAD, DELETE, OPTIONS).\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertions**: The test employs assertions to validate the expected outcomes of the requests, such as checking response data and status codes.\n- **Client Simulation**: It uses Flask's test client to simulate HTTP requests, allowing for comprehensive testing of the application's routing and method handling without needing to run a live server.\n- **Isolation of Tests**: The test is self-contained, setting up its routes and logic within the test function, ensuring that it does not interfere with other tests or application state."
    },
    {
      "name": "test_werkzeug_routing",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 191,
      "end_line_number": 209,
      "source_code": "def test_werkzeug_routing(app, client):\n    from werkzeug.routing import Rule\n    from werkzeug.routing import Submount\n\n    app.url_map.add(\n        Submount(\"/foo\", [Rule(\"/bar\", endpoint=\"bar\"), Rule(\"/\", endpoint=\"index\")])\n    )\n\n    def bar():\n        return \"bar\"\n\n    def index():\n        return \"index\"\n\n    app.view_functions[\"bar\"] = bar\n    app.view_functions[\"index\"] = index\n\n    assert client.get(\"/foo/\").data == b\"index\"\n    assert client.get(\"/foo/bar\").data == b\"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/foo/').data == b'index'",
        "assert client.get('/foo/bar').data == b'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_map.add",
          "body": "def add(self, app):\n    self.count += 1"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_werkzeug_routing` function is designed to verify the routing capabilities of a Flask application using Werkzeug's routing system. It ensures that the application correctly maps URLs to their respective view functions and returns the expected responses.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that requests to the `/foo/` and `/foo/bar` endpoints return the correct responses (\"index\" and \"bar\", respectively). It validates that the routing rules defined in the application are functioning as intended, allowing the correct view functions to be executed based on the incoming request paths.\n\n**Code Being Tested and How It Works**:  \nThe test adds a `Submount` to the application's URL map, which groups related routes under a common prefix (`/foo`). Two rules are defined: one for the root path (`/`) that maps to the `index` function and another for `/bar` that maps to the `bar` function. The view functions return simple string responses. The `client.get` method is then used to simulate HTTP GET requests to these endpoints, and the responses are asserted against the expected byte strings.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Submounting**: The use of `Submount` allows for organizing routes under a common prefix, which is a common pattern in Flask applications for better route management.\n- **View Function Registration**: The test dynamically registers view functions to the Flask application, demonstrating how to associate endpoints with their corresponding logic.\n- **Assertions**: The test employs assertions to validate the correctness of the responses, ensuring that the application behaves as expected under the defined routing rules.\n- **Client Simulation**: The use of `client.get` simulates real HTTP requests, allowing for end-to-end testing of the routing and response mechanisms in the Flask application."
    },
    {
      "name": "test_endpoint_decorator",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 212,
      "end_line_number": 229,
      "source_code": "def test_endpoint_decorator(app, client):\n    from werkzeug.routing import Rule\n    from werkzeug.routing import Submount\n\n    app.url_map.add(\n        Submount(\"/foo\", [Rule(\"/bar\", endpoint=\"bar\"), Rule(\"/\", endpoint=\"index\")])\n    )\n\n    @app.endpoint(\"bar\")\n    def bar():\n        return \"bar\"\n\n    @app.endpoint(\"index\")\n    def index():\n        return \"index\"\n\n    assert client.get(\"/foo/\").data == b\"index\"\n    assert client.get(\"/foo/bar\").data == b\"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/foo/').data == b'index'",
        "assert client.get('/foo/bar').data == b'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_map.add",
          "body": "def add(self, app):\n    self.count += 1"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:\nThe `test_endpoint_decorator` function is designed to verify the correct behavior of Flask's endpoint registration and routing mechanisms. It ensures that endpoints defined with specific rules can be accessed and return the expected responses.\n\n**Specific Functionality or Behavior Verified**:\nThis test checks that the Flask application correctly routes requests to the appropriate endpoint based on the URL structure defined by the `Submount` and `Rule` classes from Werkzeug. It verifies that accessing the root path (`/foo/`) returns the response from the `index` endpoint, and accessing the path (`/foo/bar`) returns the response from the `bar` endpoint.\n\n**Code Being Tested and How It Works**:\nThe test sets up a Flask application and adds a submount with two rules: one for the root path (`/`) and another for the path (`/bar`). It defines two endpoint functions, `bar` and `index`, which return simple string responses. The assertions at the end of the test use the `client` to simulate GET requests to these endpoints and check that the returned data matches the expected byte strings (`b\"index\"` and `b\"bar\"`).\n\n**Notable Testing Patterns or Techniques Used**:\nThe test employs the use of Flask's test client to simulate HTTP requests, allowing for easy verification of endpoint behavior without needing to run a live server. It also utilizes the `Submount` and `Rule` classes to create a structured routing setup, demonstrating how to organize routes in a Flask application. The use of assertions to compare the actual output with expected values is a standard practice in unit testing to ensure correctness."
    },
    {
      "name": "test_session",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 232,
      "end_line_number": 252,
      "source_code": "def test_session(app, client):\n    @app.route(\"/set\", methods=[\"POST\"])\n    def set():\n        assert not flask.session.accessed\n        assert not flask.session.modified\n        flask.session[\"value\"] = flask.request.form[\"value\"]\n        assert flask.session.accessed\n        assert flask.session.modified\n        return \"value set\"\n\n    @app.route(\"/get\")\n    def get():\n        assert not flask.session.accessed\n        assert not flask.session.modified\n        v = flask.session.get(\"value\", \"None\")\n        assert flask.session.accessed\n        assert not flask.session.modified\n        return v\n\n    assert client.post(\"/set\", data={\"value\": \"42\"}).data == b\"value set\"\n    assert client.get(\"/get\").data == b\"42\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.post('/set', data={'value': '42'}).data == b'value set'",
        "assert client.get('/get').data == b'42'",
        "assert not flask.session.accessed",
        "assert not flask.session.modified",
        "assert flask.session.accessed",
        "assert flask.session.modified",
        "assert not flask.session.accessed",
        "assert not flask.session.modified",
        "assert flask.session.accessed",
        "assert not flask.session.modified"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "flask.session.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_session` function is designed to verify the behavior of session management in a Flask application. It specifically tests the setting and retrieval of session variables, ensuring that the session state is correctly updated and accessed.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a value is set in the session via a POST request to the `/set` endpoint, the session is marked as accessed and modified. It also verifies that the value can be retrieved correctly via a GET request to the `/get` endpoint, confirming that the session state remains consistent.\n\n**Code Being Tested and How It Works**:  \nThe test defines two routes: `/set` and `/get`. The `/set` route accepts a POST request, sets a session variable (`flask.session[\"value\"]`), and asserts that the session has been accessed and modified. The `/get` route retrieves the session variable and checks that the session was accessed but not modified during the retrieval. The assertions at the end of the test ensure that the expected responses are returned from the client requests.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertions**: The test uses assertions to validate the state of the session before and after operations, ensuring that the session behaves as expected.\n- **Client Simulation**: It employs Flask's test client to simulate HTTP requests, allowing for the testing of route behavior in a controlled environment.\n- **Session State Verification**: The test checks both the accessed and modified flags of the session, which is crucial for understanding how Flask manages session state across requests."
    },
    {
      "name": "test_session_path",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 255,
      "end_line_number": 264,
      "source_code": "def test_session_path(app, client):\n    app.config.update(APPLICATION_ROOT=\"/foo\")\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    rv = client.get(\"/\", \"http://example.com:8080/foo\")\n    assert \"path=/foo\" in rv.headers[\"set-cookie\"].lower()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'path=/foo' in rv.headers['set-cookie'].lower()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_session_path` function is designed to verify that the session cookie's path attribute is correctly set based on the application's configuration, specifically the `APPLICATION_ROOT`. This ensures that the session management behaves as expected when the application is accessed through a specific root path.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a request is made to the root endpoint (\"/\") of the application, the `set-cookie` header in the response contains the correct path attribute (`path=/foo`). This confirms that the session cookie is scoped to the specified application root, which is crucial for maintaining session integrity across different parts of the application.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a Flask route defined at the root (\"/\") that sets a session variable (`flask.session[\"testing\"] = 42`). The test simulates a GET request to this route using a test client, while specifying the full URL that includes the application root (`http://example.com:8080/foo`). After the request, it checks the response headers to ensure that the session cookie's path is set to `/foo`, which is derived from the application's configuration.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of Flask's testing client to simulate HTTP requests and inspect response headers. It also utilizes assertions to validate the presence and correctness of the `set-cookie` header. This pattern of testing is common in web applications to ensure that HTTP responses conform to expected behaviors, particularly in relation to session management and cookie attributes. The use of configuration updates within the test setup is a technique that allows for dynamic testing of different application states without modifying the actual application code."
    },
    {
      "name": "test_session_using_application_root",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 267,
      "end_line_number": 286,
      "source_code": "def test_session_using_application_root(app, client):\n    class PrefixPathMiddleware:\n        def __init__(self, app, prefix):\n            self.app = app\n            self.prefix = prefix\n\n        def __call__(self, environ, start_response):\n            environ[\"SCRIPT_NAME\"] = self.prefix\n            return self.app(environ, start_response)\n\n    app.wsgi_app = PrefixPathMiddleware(app.wsgi_app, \"/bar\")\n    app.config.update(APPLICATION_ROOT=\"/bar\")\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    rv = client.get(\"/\", \"http://example.com:8080/\")\n    assert \"path=/bar\" in rv.headers[\"set-cookie\"].lower()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'path=/bar' in rv.headers['set-cookie'].lower()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "self.app",
          "body": "@pytest.fixture()\ndef app(self, app):\n\n    @app.route('/custom')\n    def do_custom():\n        raise self.Custom()\n\n    @app.route('/error')\n    def do_error():\n        raise KeyError()\n\n    @app.route('/abort')\n    def do_abort():\n        flask.abort(500)\n\n    @app.route('/raise')\n    def do_raise():\n        raise InternalServerError()\n    app.config['PROPAGATE_EXCEPTIONS'] = False\n    return app"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:\nThe primary purpose of the `test_session_using_application_root` test is to verify that the Flask application correctly handles session cookies when a prefix path is applied to the application root. This ensures that the session data is properly scoped to the specified application root.\n\n**Specific Functionality or Behavior Verified**:\nThe test specifically checks that when a session variable is set (in this case, `flask.session[\"testing\"] = 42`), the resulting cookie sent in the HTTP response includes the correct path attribute (`path=/bar`). This confirms that the session cookie is associated with the correct application root, which is crucial for maintaining session integrity in applications that may be served under different prefixes.\n\n**Code Being Tested and How It Works**:\nThe code under test involves a Flask application that uses a middleware class (`PrefixPathMiddleware`) to modify the `SCRIPT_NAME` in the WSGI environment, effectively simulating a prefix path for the application. The application defines a route (`/`) that sets a session variable and returns a simple response. The test client then makes a GET request to this route, and the response headers are checked to ensure that the session cookie's path is set to `/bar`, as defined in the middleware and application configuration.\n\n**Notable Testing Patterns or Techniques Used**:\nThe test employs several notable patterns:\n1. **Middleware Simulation**: The use of a custom middleware class to manipulate the WSGI environment demonstrates how to test applications with specific routing or path requirements.\n2. **Client Interaction**: The test utilizes Flask's test client to simulate HTTP requests and responses, allowing for verification of the application's behavior in a controlled environment.\n3. **Assertion on Response Headers**: The test asserts the presence and correctness of a specific header in the response, which is a common practice in testing web applications to ensure that the server's response meets expected criteria."
    },
    {
      "name": "test_session_using_session_settings",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 289,
      "end_line_number": 326,
      "source_code": "def test_session_using_session_settings(app, client):\n    app.config.update(\n        SERVER_NAME=\"www.example.com:8080\",\n        APPLICATION_ROOT=\"/test\",\n        SESSION_COOKIE_DOMAIN=\".example.com\",\n        SESSION_COOKIE_HTTPONLY=False,\n        SESSION_COOKIE_SECURE=True,\n        SESSION_COOKIE_SAMESITE=\"Lax\",\n        SESSION_COOKIE_PATH=\"/\",\n    )\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    @app.route(\"/clear\")\n    def clear():\n        flask.session.pop(\"testing\", None)\n        return \"Goodbye World\"\n\n    rv = client.get(\"/\", \"http://www.example.com:8080/test/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    # or condition for Werkzeug < 2.3\n    assert \"domain=example.com\" in cookie or \"domain=.example.com\" in cookie\n    assert \"path=/\" in cookie\n    assert \"secure\" in cookie\n    assert \"httponly\" not in cookie\n    assert \"samesite\" in cookie\n\n    rv = client.get(\"/clear\", \"http://www.example.com:8080/test/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"session=;\" in cookie\n    # or condition for Werkzeug < 2.3\n    assert \"domain=example.com\" in cookie or \"domain=.example.com\" in cookie\n    assert \"path=/\" in cookie\n    assert \"secure\" in cookie\n    assert \"samesite\" in cookie",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'domain=example.com' in cookie or 'domain=.example.com' in cookie",
        "assert 'path=/' in cookie",
        "assert 'secure' in cookie",
        "assert 'httponly' not in cookie",
        "assert 'samesite' in cookie",
        "assert 'session=;' in cookie",
        "assert 'domain=example.com' in cookie or 'domain=.example.com' in cookie",
        "assert 'path=/' in cookie",
        "assert 'secure' in cookie",
        "assert 'samesite' in cookie"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_session_using_session_settings` function is designed to verify that the session cookie settings in a Flask application are correctly configured and that the expected attributes are present in the session cookies when a user interacts with the application.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks the behavior of session cookies in terms of their domain, path, security attributes (HTTPOnly, Secure), SameSite attribute, and partitioning. It ensures that the session cookie is set correctly when a session is created and that it is cleared appropriately when the session is terminated.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Flask application with specific session cookie configurations. It defines two routes: the root route (`/`) which initializes a session variable, and a `/clear` route which removes that session variable. The test then simulates HTTP GET requests to these routes using a test client, capturing the response headers to inspect the `set-cookie` header. Assertions are made to confirm that the cookie attributes match the expected values based on the configuration.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Configuration Testing**: The test modifies the Flask app's configuration to set various session cookie parameters, allowing for dynamic testing of different settings.\n- **Assertions on Response Headers**: The test checks the `set-cookie` header in the response to validate that the session cookie is set with the correct attributes.\n- **Use of Flask's Test Client**: The test leverages Flask's built-in test client to simulate requests and inspect responses, which is a common pattern in testing web applications.\n- **Handling of Different Werkzeug Versions**: The test includes conditions to accommodate differences in behavior between Werkzeug versions, ensuring compatibility across versions."
    },
    {
      "name": "test_session_using_samesite_attribute",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 329,
      "end_line_number": 353,
      "source_code": "def test_session_using_samesite_attribute(app, client):\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"invalid\")\n\n    with pytest.raises(ValueError):\n        client.get(\"/\")\n\n    app.config.update(SESSION_COOKIE_SAMESITE=None)\n    rv = client.get(\"/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite\" not in cookie\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"Strict\")\n    rv = client.get(\"/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite=strict\" in cookie\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"Lax\")\n    rv = client.get(\"/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite=lax\" in cookie",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'samesite' not in cookie",
        "assert 'samesite=strict' in cookie",
        "assert 'samesite=lax' in cookie"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_session_using_samesite_attribute` test is to verify the behavior of Flask's session cookie settings, specifically the `SESSION_COOKIE_SAMESITE` attribute. It ensures that the application correctly handles various configurations of the SameSite attribute, including invalid values, and checks that the appropriate cookies are set in the response headers.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks three main behaviors:\n1. It verifies that an invalid SameSite value raises a `ValueError`.\n2. It confirms that when `SESSION_COOKIE_SAMESITE` is set to `None`, the `set-cookie` header does not include the SameSite attribute.\n3. It ensures that when `SESSION_COOKIE_SAMESITE` is set to valid values (\"Strict\" and \"Lax\"), the corresponding SameSite attribute is present in the `set-cookie` header.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves a Flask application with a single route (`/`) that sets a session variable. The test modifies the application's configuration to change the `SESSION_COOKIE_SAMESITE` setting and then makes requests to the `/` route using the test client. The response headers are inspected to verify the presence or absence of the SameSite attribute based on the configuration. The relevant code for session handling is part of Flask's session management, which utilizes the `SecureCookieSessionInterface` to manage session cookies.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Context Management**: It uses Flask's test request context to simulate requests and manage session state.\n- **Exception Testing**: The test checks for expected exceptions using `pytest.raises`, ensuring that invalid configurations are handled correctly.\n- **Assertions on Response Headers**: It asserts conditions on the response headers to validate the correct behavior of the session cookie settings, demonstrating a focus on integration testing by verifying the interaction between the application and the HTTP response."
    },
    {
      "name": "test_missing_session",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 356,
      "end_line_number": 366,
      "source_code": "def test_missing_session(app):\n    app.secret_key = None\n\n    def expect_exception(f, *args, **kwargs):\n        e = pytest.raises(RuntimeError, f, *args, **kwargs)\n        assert e.value.args and \"session is unavailable\" in e.value.args[0]\n\n    with app.test_request_context():\n        assert flask.session.get(\"missing_key\") is None\n        expect_exception(flask.session.__setitem__, \"foo\", 42)\n        expect_exception(flask.session.pop, \"foo\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert e.value.args and 'session is unavailable' in e.value.args[0]",
        "assert flask.session.get('missing_key') is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "expect_exception",
          "body": "def expect_exception(f, *args, **kwargs):\n    e = pytest.raises(RuntimeError, f, *args, **kwargs)\n    assert e.value.args and 'session is unavailable' in e.value.args[0]"
        },
        {
          "name": "expect_exception",
          "body": "def expect_exception(f, *args, **kwargs):\n    e = pytest.raises(RuntimeError, f, *args, **kwargs)\n    assert e.value.args and 'session is unavailable' in e.value.args[0]"
        },
        {
          "name": "flask.session.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_missing_session` function is designed to verify the behavior of Flask's session management when the session is unavailable. Specifically, it tests that appropriate exceptions are raised when attempting to access or modify the session without a valid secret key.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. Accessing a non-existent key in the session returns `None`.\n2. Attempting to set a value in the session raises a `RuntimeError` with the message \"session is unavailable\".\n3. Attempting to pop a value from the session also raises a `RuntimeError` with the same message.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the Flask session object, specifically the `flask.session.get`, `flask.session.__setitem__`, and `flask.session.pop` methods. The test sets the `app.secret_key` to `None`, which simulates a scenario where the session cannot be used. The `with app.test_request_context()` block creates a request context for the test, allowing the session to be accessed. The `expect_exception` helper function is used to assert that the expected exceptions are raised when trying to modify the session.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The use of `app.test_request_context()` allows the test to simulate a request context, which is necessary for session operations.\n- **Custom Assertion Function**: The `expect_exception` function encapsulates the logic for asserting that a specific exception is raised, improving code readability and reusability.\n- **Direct Exception Testing**: The test directly checks for exceptions raised by specific operations, ensuring that the application behaves correctly under error conditions."
    },
    {
      "name": "test_session_expiration",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 369,
      "end_line_number": 398,
      "source_code": "def test_session_expiration(app, client):\n    permanent = True\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"test\"] = 42\n        flask.session.permanent = permanent\n        return \"\"\n\n    @app.route(\"/test\")\n    def test():\n        return str(flask.session.permanent)\n\n    rv = client.get(\"/\")\n    assert \"set-cookie\" in rv.headers\n    match = re.search(r\"(?i)\\bexpires=([^;]+)\", rv.headers[\"set-cookie\"])\n    expires = parse_date(match.group())\n    expected = datetime.now(timezone.utc) + app.permanent_session_lifetime\n    assert expires.year == expected.year\n    assert expires.month == expected.month\n    assert expires.day == expected.day\n\n    rv = client.get(\"/test\")\n    assert rv.data == b\"True\"\n\n    permanent = False\n    rv = client.get(\"/\")\n    assert \"set-cookie\" in rv.headers\n    match = re.search(r\"\\bexpires=([^;]+)\", rv.headers[\"set-cookie\"])\n    assert match is None",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'set-cookie' in rv.headers",
        "assert expires.year == expected.year",
        "assert expires.month == expected.month",
        "assert expires.day == expected.day",
        "assert rv.data == b'True'",
        "assert 'set-cookie' in rv.headers",
        "assert match is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_session_expiration` function is designed to verify the behavior of session expiration in a Flask application. It specifically tests whether the session cookie is set correctly based on the `permanent` attribute of the session and whether the expiration date of the cookie aligns with the expected lifetime defined in the application configuration.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main behaviors: \n1. When the session is marked as permanent, it verifies that a \"Set-Cookie\" header is present and that the expiration date of the cookie is correctly calculated based on the `permanent_session_lifetime`.\n2. When the session is not permanent, it ensures that no expiration date is set in the cookie, confirming that the session is treated as a browser session.\n\n**Code Being Tested and How It Works**:  \nThe test sets up two routes in the Flask application:\n- The `index` route initializes a session variable and sets the session to be permanent.\n- The `test` route returns the value of the session's `permanent` attribute.\n\nThe test then simulates a request to the `index` route, checks for the presence of the \"Set-Cookie\" header, extracts the expiration date from the cookie, and compares it to the expected expiration date. It subsequently checks the `test` route to confirm that the session is indeed permanent. Finally, it modifies the `permanent` attribute to `False`, makes another request to the `index` route, and verifies that no expiration date is set in the cookie.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertions**: The test employs assertions to validate the presence of headers and the correctness of the expiration date, ensuring that the expected outcomes are met.\n- **Regular Expressions**: It uses regex to extract the expiration date from the \"Set-Cookie\" header, demonstrating a technique for parsing HTTP headers.\n- **Context Management**: The test leverages Flask's test client to simulate requests, allowing for isolated testing of the application\u2019s behavior without needing to run a live server.\n- **State Management**: The test manipulates the session state (permanent vs. non-permanent) to verify different behaviors, showcasing the importance of state in web applications."
    },
    {
      "name": "test_session_stored_last",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 401,
      "end_line_number": 412,
      "source_code": "def test_session_stored_last(app, client):\n    @app.after_request\n    def modify_session(response):\n        flask.session[\"foo\"] = 42\n        return response\n\n    @app.route(\"/\")\n    def dump_session_contents():\n        return repr(flask.session.get(\"foo\"))\n\n    assert client.get(\"/\").data == b\"None\"\n    assert client.get(\"/\").data == b\"42\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/').data == b'None'",
        "assert client.get('/').data == b'42'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "flask.session.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_session_stored_last` function is designed to verify the behavior of Flask's session management, specifically ensuring that session data is correctly stored and retrieved across multiple requests.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the session variable `foo` is initially `None` and then correctly updated to `42` after a request is processed. It ensures that the session modification occurs as expected when the `after_request` decorator is used.\n\n**Code Being Tested and How It Works**:  \nThe test defines an `after_request` function that modifies the session by setting `flask.session[\"foo\"]` to `42`. The test then makes two GET requests to the root route (`\"/\"`), which returns the current value of `foo` from the session. The first request should return `b\"None\"` (indicating that the session has not yet been modified), while the second request should return `b\"42\"` (indicating that the session has been updated).\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Flask Testing Client**: The test utilizes Flask's test client to simulate HTTP requests and responses, allowing for the verification of session behavior in a controlled environment.\n- **After Request Hook**: The use of the `@app.after_request` decorator demonstrates how to modify the response after a request has been processed, showcasing Flask's middleware capabilities.\n- **Assertions**: The test employs assertions to validate the expected outcomes of the session state before and after the modification, ensuring that the session management logic works as intended."
    },
    {
      "name": "test_session_special_types",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 415,
      "end_line_number": 443,
      "source_code": "def test_session_special_types(app, client):\n    now = datetime.now(timezone.utc).replace(microsecond=0)\n    the_uuid = uuid.uuid4()\n\n    @app.route(\"/\")\n    def dump_session_contents():\n        flask.session[\"t\"] = (1, 2, 3)\n        flask.session[\"b\"] = b\"\\xff\"\n        flask.session[\"m\"] = Markup(\"<html>\")\n        flask.session[\"u\"] = the_uuid\n        flask.session[\"d\"] = now\n        flask.session[\"t_tag\"] = {\" t\": \"not-a-tuple\"}\n        flask.session[\"di_t_tag\"] = {\" t__\": \"not-a-tuple\"}\n        flask.session[\"di_tag\"] = {\" di\": \"not-a-dict\"}\n        return \"\", 204\n\n    with client:\n        client.get(\"/\")\n        s = flask.session\n        assert s[\"t\"] == (1, 2, 3)\n        assert type(s[\"b\"]) is bytes  # noqa: E721\n        assert s[\"b\"] == b\"\\xff\"\n        assert type(s[\"m\"]) is Markup  # noqa: E721\n        assert s[\"m\"] == Markup(\"<html>\")\n        assert s[\"u\"] == the_uuid\n        assert s[\"d\"] == now\n        assert s[\"t_tag\"] == {\" t\": \"not-a-tuple\"}\n        assert s[\"di_t_tag\"] == {\" t__\": \"not-a-tuple\"}\n        assert s[\"di_tag\"] == {\" di\": \"not-a-dict\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert s['t'] == (1, 2, 3)",
        "assert type(s['b']) is bytes",
        "assert s['b'] == b'\\xff'",
        "assert type(s['m']) is Markup",
        "assert s['m'] == Markup('<html>')",
        "assert s['u'] == the_uuid",
        "assert s['d'] == now",
        "assert s['t_tag'] == {' t': 'not-a-tuple'}",
        "assert s['di_t_tag'] == {' t__': 'not-a-tuple'}",
        "assert s['di_tag'] == {' di': 'not-a-dict'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_session_special_types` test is to verify that various special data types can be correctly stored and retrieved from the Flask session. This includes tuples, bytes, Markup objects, UUIDs, datetime objects, and dictionaries.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the session can handle and accurately return different types of data. It ensures that the values stored in the session match the expected values and types after a request is made to the application. This is crucial for maintaining data integrity and ensuring that the session behaves as expected when dealing with complex data types.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route (`/`) that populates the Flask session with various types of data when accessed. The `client.get(\"/\")` call simulates a request to this route, triggering the session population. After the request, the test asserts that the session contains the expected values and types, confirming that the session handling mechanism in Flask works correctly for these special types.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The test uses Flask's test client within a context manager (`with client:`) to ensure that the request context is properly managed during the test execution.\n- **Assertions**: The test employs assertions to validate that the session data matches expected values and types, which is a common practice in unit testing to ensure correctness.\n- **Anonymous Function for Route**: The route is defined as an inner function (`dump_session_contents`) to encapsulate the session population logic, which is a technique to keep the test organized and focused on the specific behavior being tested."
    },
    {
      "name": "test_session_cookie_setting",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 446,
      "end_line_number": 484,
      "source_code": "def test_session_cookie_setting(app):\n    is_permanent = True\n\n    @app.route(\"/bump\")\n    def bump():\n        rv = flask.session[\"foo\"] = flask.session.get(\"foo\", 0) + 1\n        flask.session.permanent = is_permanent\n        return str(rv)\n\n    @app.route(\"/read\")\n    def read():\n        return str(flask.session.get(\"foo\", 0))\n\n    def run_test(expect_header):\n        with app.test_client() as c:\n            assert c.get(\"/bump\").data == b\"1\"\n            assert c.get(\"/bump\").data == b\"2\"\n            assert c.get(\"/bump\").data == b\"3\"\n\n            rv = c.get(\"/read\")\n            set_cookie = rv.headers.get(\"set-cookie\")\n            assert (set_cookie is not None) == expect_header\n            assert rv.data == b\"3\"\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=True)\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert c.get('/bump').data == b'1'",
        "assert c.get('/bump').data == b'2'",
        "assert c.get('/bump').data == b'3'",
        "assert (set_cookie is not None) == expect_header",
        "assert rv.data == b'3'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "run_test",
          "body": "def run_test(expect_header):\n    with app.test_client() as c:\n        assert c.get('/bump').data == b'1'\n        assert c.get('/bump').data == b'2'\n        assert c.get('/bump').data == b'3'\n        rv = c.get('/read')\n        set_cookie = rv.headers.get('set-cookie')\n        assert (set_cookie is not None) == expect_header\n        assert rv.data == b'3'"
        },
        {
          "name": "run_test",
          "body": "def run_test(expect_header):\n    with app.test_client() as c:\n        assert c.get('/bump').data == b'1'\n        assert c.get('/bump').data == b'2'\n        assert c.get('/bump').data == b'3'\n        rv = c.get('/read')\n        set_cookie = rv.headers.get('set-cookie')\n        assert (set_cookie is not None) == expect_header\n        assert rv.data == b'3'"
        },
        {
          "name": "run_test",
          "body": "def run_test(expect_header):\n    with app.test_client() as c:\n        assert c.get('/bump').data == b'1'\n        assert c.get('/bump').data == b'2'\n        assert c.get('/bump').data == b'3'\n        rv = c.get('/read')\n        set_cookie = rv.headers.get('set-cookie')\n        assert (set_cookie is not None) == expect_header\n        assert rv.data == b'3'"
        },
        {
          "name": "run_test",
          "body": "def run_test(expect_header):\n    with app.test_client() as c:\n        assert c.get('/bump').data == b'1'\n        assert c.get('/bump').data == b'2'\n        assert c.get('/bump').data == b'3'\n        rv = c.get('/read')\n        set_cookie = rv.headers.get('set-cookie')\n        assert (set_cookie is not None) == expect_header\n        assert rv.data == b'3'"
        },
        {
          "name": "flask.session.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "flask.session.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "rv.headers.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_session_cookie_setting` test is to verify the behavior of session cookies in a Flask application, specifically how the session's permanence and the configuration of `SESSION_REFRESH_EACH_REQUEST` affect the setting of session cookies.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks whether the session cookie is set correctly based on the `is_permanent` flag and the `SESSION_REFRESH_EACH_REQUEST` configuration. It verifies that the session value increments correctly with each request to the `/bump` endpoint and that the appropriate cookie header is returned when accessing the `/read` endpoint.\n\n**Code Being Tested and How It Works**:  \nThe test defines two routes: `/bump`, which increments a session variable `foo` and sets the session's permanence, and `/read`, which retrieves the current value of `foo`. The `run_test` function is called multiple times with different configurations to assert the expected behavior of the session cookie. The assertions check the response data from the `/bump` endpoint and the presence or absence of the `set-cookie` header in the response from the `/read` endpoint.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterized Testing**: The test runs multiple scenarios by changing the values of `is_permanent` and `SESSION_REFRESH_EACH_REQUEST`, allowing for comprehensive coverage of different configurations.\n- **Assertions**: The use of assertions to validate both the response data and the presence of the `set-cookie` header ensures that the test checks both the functional and state aspects of the session management.\n- **Test Client**: The use of `app.test_client()` allows for simulating requests to the Flask application, making it possible to test the application\u2019s behavior in a controlled environment."
    },
    {
      "name": "test_session_vary_cookie",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 487,
      "end_line_number": 545,
      "source_code": "def test_session_vary_cookie(app, client):\n    @app.route(\"/set\")\n    def set_session():\n        flask.session[\"test\"] = \"test\"\n        return \"\"\n\n    @app.route(\"/get\")\n    def get():\n        return flask.session.get(\"test\")\n\n    @app.route(\"/getitem\")\n    def getitem():\n        return flask.session[\"test\"]\n\n    @app.route(\"/setdefault\")\n    def setdefault():\n        return flask.session.setdefault(\"test\", \"default\")\n\n    @app.route(\"/clear\")\n    def clear():\n        flask.session.clear()\n        return \"\"\n\n    @app.route(\"/vary-cookie-header-set\")\n    def vary_cookie_header_set():\n        response = flask.Response()\n        response.vary.add(\"Cookie\")\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/vary-header-set\")\n    def vary_header_set():\n        response = flask.Response()\n        response.vary.update((\"Accept-Encoding\", \"Accept-Language\"))\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/no-vary-header\")\n    def no_vary_header():\n        return \"\"\n\n    def expect(path, header_value=\"Cookie\"):\n        rv = client.get(path)\n\n        if header_value:\n            # The 'Vary' key should exist in the headers only once.\n            assert len(rv.headers.get_all(\"Vary\")) == 1\n            assert rv.headers[\"Vary\"] == header_value\n        else:\n            assert \"Vary\" not in rv.headers\n\n    expect(\"/set\")\n    expect(\"/get\")\n    expect(\"/getitem\")\n    expect(\"/setdefault\")\n    expect(\"/clear\")\n    expect(\"/vary-cookie-header-set\")\n    expect(\"/vary-header-set\", \"Accept-Encoding, Accept-Language, Cookie\")\n    expect(\"/no-vary-header\", None)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(rv.headers.get_all('Vary')) == 1",
        "assert rv.headers['Vary'] == header_value",
        "assert 'Vary' not in rv.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "expect",
          "body": "def expect(path, header_value='Cookie'):\n    rv = client.get(path)\n    if header_value:\n        assert len(rv.headers.get_all('Vary')) == 1\n        assert rv.headers['Vary'] == header_value\n    else:\n        assert 'Vary' not in rv.headers"
        },
        {
          "name": "expect",
          "body": "def expect(path, header_value='Cookie'):\n    rv = client.get(path)\n    if header_value:\n        assert len(rv.headers.get_all('Vary')) == 1\n        assert rv.headers['Vary'] == header_value\n    else:\n        assert 'Vary' not in rv.headers"
        },
        {
          "name": "expect",
          "body": "def expect(path, header_value='Cookie'):\n    rv = client.get(path)\n    if header_value:\n        assert len(rv.headers.get_all('Vary')) == 1\n        assert rv.headers['Vary'] == header_value\n    else:\n        assert 'Vary' not in rv.headers"
        },
        {
          "name": "expect",
          "body": "def expect(path, header_value='Cookie'):\n    rv = client.get(path)\n    if header_value:\n        assert len(rv.headers.get_all('Vary')) == 1\n        assert rv.headers['Vary'] == header_value\n    else:\n        assert 'Vary' not in rv.headers"
        },
        {
          "name": "expect",
          "body": "def expect(path, header_value='Cookie'):\n    rv = client.get(path)\n    if header_value:\n        assert len(rv.headers.get_all('Vary')) == 1\n        assert rv.headers['Vary'] == header_value\n    else:\n        assert 'Vary' not in rv.headers"
        },
        {
          "name": "expect",
          "body": "def expect(path, header_value='Cookie'):\n    rv = client.get(path)\n    if header_value:\n        assert len(rv.headers.get_all('Vary')) == 1\n        assert rv.headers['Vary'] == header_value\n    else:\n        assert 'Vary' not in rv.headers"
        },
        {
          "name": "expect",
          "body": "def expect(path, header_value='Cookie'):\n    rv = client.get(path)\n    if header_value:\n        assert len(rv.headers.get_all('Vary')) == 1\n        assert rv.headers['Vary'] == header_value\n    else:\n        assert 'Vary' not in rv.headers"
        },
        {
          "name": "expect",
          "body": "def expect(path, header_value='Cookie'):\n    rv = client.get(path)\n    if header_value:\n        assert len(rv.headers.get_all('Vary')) == 1\n        assert rv.headers['Vary'] == header_value\n    else:\n        assert 'Vary' not in rv.headers"
        },
        {
          "name": "flask.session.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "flask.session.setdefault",
          "body": "@app.route('/setdefault')\ndef setdefault():\n    return flask.session.setdefault('test', 'default')"
        },
        {
          "name": "flask.session.clear",
          "body": "@app.route('/clear')\ndef clear():\n    flask.session.pop('testing', None)\n    return 'Goodbye World'"
        },
        {
          "name": "response.vary.add",
          "body": "def add(self, app):\n    self.count += 1"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_session_vary_cookie` function is to verify the behavior of Flask session management in relation to the `Vary` HTTP header. Specifically, it checks whether the `Vary` header is set correctly based on the presence of session data and the type of response generated by various routes.\n\n**Specific Functionality or Behavior Verified**:  \nThe test ensures that the `Vary` header is included in the response when certain routes are accessed, particularly when session data is modified. It checks that the header is set to \"Cookie\" for routes that directly interact with the session and verifies that it reflects the correct values when multiple headers are involved. Additionally, it confirms that routes that do not modify the session do not include the `Vary` header.\n\n**Code Being Tested and How It Works**:  \nThe test defines several Flask routes that manipulate session data and return responses. The routes include `/set`, `/get`, `/getitem`, `/setdefault`, `/clear`, `/vary-cookie-header-set`, `/vary-header-set`, and `/no-vary-header`. Each route performs specific actions on the session and returns a response. The `expect` function is called for each route to assert the presence and correctness of the `Vary` header in the response. The test checks that the header is present and correctly set when expected, and absent when it should not be.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a parameterized approach through the `expect` function, which encapsulates the logic for making requests and asserting header values. This reduces code duplication and enhances readability. The use of assertions to validate the presence and content of the `Vary` header is a common pattern in unit testing, ensuring that the application behaves as intended under various conditions. Additionally, the test leverages Flask's test client to simulate requests and inspect responses, which is a standard technique for testing web applications."
    },
    {
      "name": "test_session_refresh_vary",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 548,
      "end_line_number": 562,
      "source_code": "def test_session_refresh_vary(app, client):\n    @app.get(\"/login\")\n    def login():\n        flask.session[\"user_id\"] = 1\n        flask.session.permanent = True\n        return \"\"\n\n    @app.get(\"/ignored\")\n    def ignored():\n        return \"\"\n\n    rv = client.get(\"/login\")\n    assert rv.headers[\"Vary\"] == \"Cookie\"\n    rv = client.get(\"/ignored\")\n    assert rv.headers[\"Vary\"] == \"Cookie\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.headers['Vary'] == 'Cookie'",
        "assert rv.headers['Vary'] == 'Cookie'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "app.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_session_refresh_vary` function is designed to verify that the HTTP response headers correctly include the \"Vary: Cookie\" directive when a session is established or accessed. This is crucial for ensuring that caching mechanisms behave correctly based on the presence of session cookies.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a user logs in (which sets a session) and accesses a specific endpoint, the response header \"Vary\" is set to \"Cookie\". It also verifies that this behavior is consistent across different endpoints, specifically the `/ignored` endpoint, which does not modify the session.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes two Flask routes: `/login` and `/ignored`. The `/login` route sets a session variable (`user_id`) and marks the session as permanent. The test then makes GET requests to both routes using the Flask test client. The relevant code that influences the response headers is found in the `save_session` function, which adds the \"Vary: Cookie\" header if the session was accessed. This is determined by checking the `session.accessed` attribute.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of Flask's test client to simulate HTTP requests and assert the expected behavior of the application. It uses assertions to validate the presence of the \"Vary\" header in the response, demonstrating a straightforward approach to unit testing by focusing on the output of the application in response to specific inputs. The test also encapsulates the setup of routes within the test function, which is a common pattern in Flask testing to isolate the test environment."
    },
    {
      "name": "test_flashes",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 565,
      "end_line_number": 571,
      "source_code": "def test_flashes(app, req_ctx):\n    assert not flask.session.modified\n    flask.flash(\"Zap\")\n    flask.session.modified = False\n    flask.flash(\"Zip\")\n    assert flask.session.modified\n    assert list(flask.get_flashed_messages()) == [\"Zap\", \"Zip\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "req_ctx"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert not flask.session.modified",
        "assert flask.session.modified",
        "assert list(flask.get_flashed_messages()) == ['Zap', 'Zip']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_extended_flashing",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 574,
      "end_line_number": 652,
      "source_code": "def test_extended_flashing(app):\n    # Be sure app.testing=True below, else tests can fail silently.\n    #\n    # Specifically, if app.testing is not set to True, the AssertionErrors\n    # in the view functions will cause a 500 response to the test client\n    # instead of propagating exceptions.\n\n    @app.route(\"/\")\n    def index():\n        flask.flash(\"Hello World\")\n        flask.flash(\"Hello World\", \"error\")\n        flask.flash(Markup(\"<em>Testing</em>\"), \"warning\")\n        return \"\"\n\n    @app.route(\"/test/\")\n    def test():\n        messages = flask.get_flashed_messages()\n        assert list(messages) == [\n            \"Hello World\",\n            \"Hello World\",\n            Markup(\"<em>Testing</em>\"),\n        ]\n        return \"\"\n\n    @app.route(\"/test_with_categories/\")\n    def test_with_categories():\n        messages = flask.get_flashed_messages(with_categories=True)\n        assert len(messages) == 3\n        assert list(messages) == [\n            (\"message\", \"Hello World\"),\n            (\"error\", \"Hello World\"),\n            (\"warning\", Markup(\"<em>Testing</em>\")),\n        ]\n        return \"\"\n\n    @app.route(\"/test_filter/\")\n    def test_filter():\n        messages = flask.get_flashed_messages(\n            category_filter=[\"message\"], with_categories=True\n        )\n        assert list(messages) == [(\"message\", \"Hello World\")]\n        return \"\"\n\n    @app.route(\"/test_filters/\")\n    def test_filters():\n        messages = flask.get_flashed_messages(\n            category_filter=[\"message\", \"warning\"], with_categories=True\n        )\n        assert list(messages) == [\n            (\"message\", \"Hello World\"),\n            (\"warning\", Markup(\"<em>Testing</em>\")),\n        ]\n        return \"\"\n\n    @app.route(\"/test_filters_without_returning_categories/\")\n    def test_filters2():\n        messages = flask.get_flashed_messages(category_filter=[\"message\", \"warning\"])\n        assert len(messages) == 2\n        assert messages[0] == \"Hello World\"\n        assert messages[1] == Markup(\"<em>Testing</em>\")\n        return \"\"\n\n    # Create new test client on each test to clean flashed messages.\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_with_categories/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filter/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filters/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filters_without_returning_categories/\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert list(messages) == ['Hello World', 'Hello World', Markup('<em>Testing</em>')]",
        "assert len(messages) == 3",
        "assert list(messages) == [('message', 'Hello World'), ('error', 'Hello World'), ('warning', Markup('<em>Testing</em>'))]",
        "assert list(messages) == [('message', 'Hello World')]",
        "assert list(messages) == [('message', 'Hello World'), ('warning', Markup('<em>Testing</em>'))]",
        "assert len(messages) == 2",
        "assert messages[0] == 'Hello World'",
        "assert messages[1] == Markup('<em>Testing</em>')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_extended_flashing` function is to verify the behavior of Flask's message flashing system, ensuring that messages can be correctly flashed, retrieved, and filtered based on categories. This is crucial for applications that need to provide user feedback through temporary messages.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks several aspects of the flashing mechanism:\n1. Basic flashing of messages without categories.\n2. Flashing messages with specific categories and verifying their retrieval.\n3. Filtering flashed messages by category to ensure only the relevant messages are returned.\n4. Ensuring that the messages are correctly formatted and returned in the expected structure.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes several Flask route handlers that utilize `flask.flash` to store messages in the session. The `flask.get_flashed_messages` function retrieves these messages. The test routes include:\n- `index`: Flashes multiple messages with and without categories.\n- `test`: Retrieves and asserts the messages flashed without categories.\n- `test_with_categories`: Retrieves and asserts the messages flashed with categories.\n- `test_filter` and `test_filters`: Test the filtering of messages based on specified categories.\n\nThe test client simulates requests to these routes, allowing the assertions to verify the correctness of the flashed messages.\n\n**Notable Testing Patterns or Techniques Used**:  \n1. **Setup and Teardown**: The test client is created anew for each test to ensure a clean state, preventing messages from previous tests from affecting the results.\n2. **Assertions**: The use of assertions to validate the expected output against the actual output is a fundamental aspect of unit testing, ensuring that the functionality behaves as intended.\n3. **Route Testing**: The test leverages Flask's routing capabilities to directly test the application\u2019s behavior in response to HTTP requests, which is a common practice in testing web applications.\n4. **Category Filtering**: The tests demonstrate the ability to filter messages by category, showcasing the flexibility of the flashing system and ensuring that it meets the application's needs for user feedback."
    },
    {
      "name": "test_request_processing",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 655,
      "end_line_number": 677,
      "source_code": "def test_request_processing(app, client):\n    evts = []\n\n    @app.before_request\n    def before_request():\n        evts.append(\"before\")\n\n    @app.after_request\n    def after_request(response):\n        response.data += b\"|after\"\n        evts.append(\"after\")\n        return response\n\n    @app.route(\"/\")\n    def index():\n        assert \"before\" in evts\n        assert \"after\" not in evts\n        return \"request\"\n\n    assert \"after\" not in evts\n    rv = client.get(\"/\").data\n    assert \"after\" in evts\n    assert rv == b\"request|after\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'after' not in evts",
        "assert 'after' in evts",
        "assert rv == b'request|after'",
        "assert 'before' in evts",
        "assert 'after' not in evts"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_request_processing` function is to verify the correct execution order of Flask's request lifecycle hooks, specifically the `before_request` and `after_request` decorators. It ensures that the expected events are triggered at the appropriate times during the handling of a request.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the `before_request` hook is executed before the request handler (`index` function) and that the `after_request` hook is executed after the request handler. It asserts that the `evts` list correctly reflects this order, confirming that the `before` event is recorded before the request is processed and the `after` event is recorded afterward.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the Flask application setup with a route defined at `/`, which asserts the presence of the `before` event and the absence of the `after` event before the request is processed. The `client.get(\"/\")` call simulates a GET request to the root URL, triggering the request lifecycle. The assertions after the request confirm that the `after` event is now present and that the response data includes the expected string \"request|after\".\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Lifecycle Hook Testing**: It utilizes Flask's lifecycle hooks (`before_request` and `after_request`) to validate the order of execution.\n- **Assertions on Side Effects**: The test checks the state of the `evts` list before and after the request to confirm the correct sequence of events.\n- **Client Simulation**: It uses Flask's test client to simulate HTTP requests, allowing for the testing of request handling in a controlled environment.\n- **Inline Function Definitions**: The use of inline functions for hooks and route handlers keeps the test self-contained and focused on the specific behavior being tested."
    },
    {
      "name": "test_request_preprocessing_early_return",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 680,
      "end_line_number": 704,
      "source_code": "def test_request_preprocessing_early_return(app, client):\n    evts = []\n\n    @app.before_request\n    def before_request1():\n        evts.append(1)\n\n    @app.before_request\n    def before_request2():\n        evts.append(2)\n        return \"hello\"\n\n    @app.before_request\n    def before_request3():\n        evts.append(3)\n        return \"bye\"\n\n    @app.route(\"/\")\n    def index():\n        evts.append(\"index\")\n        return \"damnit\"\n\n    rv = client.get(\"/\").data.strip()\n    assert rv == b\"hello\"\n    assert evts == [1, 2]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv == b'hello'",
        "assert evts == [1, 2]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_request_preprocessing_early_return` test is designed to verify the behavior of Flask's request preprocessing mechanism, specifically how early returns from `before_request` handlers affect the request lifecycle and the response returned to the client.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when multiple `before_request` handlers are defined, the first handler can execute successfully, but if a subsequent handler returns a value (in this case, \"hello\"), it short-circuits the request processing, preventing any further handlers from executing. The test also verifies that the response returned to the client matches the expected output.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes three `before_request` handlers and a route handler for the root URL (\"/\"). The first handler appends `1` to the `evts` list, the second appends `2` and returns \"hello\", and the third appends `3` but is never executed due to the early return from the second handler. The route handler appends \"index\" to the `evts` list and returns \"damnit\", but it is also not executed because of the early return. The test then makes a GET request to the root URL and asserts that the response data is `b\"hello\"` and that the `evts` list contains `[1, 2]`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Setup of Handlers**: The test dynamically registers multiple `before_request` handlers to simulate different scenarios within the same test context.\n- **Assertions**: It uses assertions to validate both the response content and the order of events recorded in the `evts` list, ensuring that the expected behavior of early returns is correctly implemented.\n- **Isolation of Side Effects**: By using a list to track events, the test isolates the side effects of the request processing, allowing for clear verification of the order and occurrence of events."
    },
    {
      "name": "test_after_request_processing",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 707,
      "end_line_number": 719,
      "source_code": "def test_after_request_processing(app, client):\n    @app.route(\"/\")\n    def index():\n        @flask.after_this_request\n        def foo(response):\n            response.headers[\"X-Foo\"] = \"a header\"\n            return response\n\n        return \"Test\"\n\n    resp = client.get(\"/\")\n    assert resp.status_code == 200\n    assert resp.headers[\"X-Foo\"] == \"a header\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.status_code == 200",
        "assert resp.headers['X-Foo'] == 'a header'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_after_request_processing` test is to verify that the `after_this_request` decorator correctly modifies the response object by adding a custom header to it after the request has been processed.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a request is made to the root endpoint (\"/\"), the response includes a header \"X-Foo\" with the value \"a header\". It ensures that the after-request processing is functioning as intended.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the Flask route defined within the `test_after_request_processing` function. The `index` function registers an `after_this_request` function named `foo`, which modifies the response by adding a header. When the test client makes a GET request to the root endpoint, the `index` function is executed, and the `foo` function is called afterward, allowing it to modify the response before it is sent back to the client.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of Flask's testing client to simulate a request to the application. It also utilizes the `after_this_request` decorator, which is a common pattern in Flask for modifying responses after the view function has executed. The assertions at the end of the test confirm that the expected status code and header are present in the response, demonstrating effective use of assertions to validate the behavior of the application."
    },
    {
      "name": "test_teardown_request_handler",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 722,
      "end_line_number": 737,
      "source_code": "def test_teardown_request_handler(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_request(exc):\n        called.append(True)\n        return \"Ignored\"\n\n    @app.route(\"/\")\n    def root():\n        return \"Response\"\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 200\n    assert b\"Response\" in rv.data\n    assert len(called) == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 200",
        "assert b'Response' in rv.data",
        "assert len(called) == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_teardown_request_handler` is to verify that the `teardown_request` handler in a Flask application is executed after a request is processed, regardless of whether the request was successful or resulted in an error. It ensures that the teardown logic is invoked and that it behaves as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `teardown_request` function is called exactly once after a successful request to the root endpoint (\"/\"). It also verifies that the response from the route is correct and that the teardown function is properly registered and executed.\n\n**Code Being Tested and How It Works**:  \nThe test defines a Flask application with a route that returns a simple string (\"Response\"). It registers a `teardown_request` function that appends a value to a list (`called`) when invoked. The test then makes a GET request to the root endpoint using the `client` fixture. After the request, it asserts that the response status code is 200, the response data contains \"Response\", and that the `called` list has one entry, indicating that the teardown function was executed.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The test utilizes Flask's testing client and application context to simulate requests and manage application state.\n- **Teardown Function Registration**: It demonstrates how to register a teardown function that executes after a request, showcasing Flask's lifecycle management.\n- **Assertions**: The test employs assertions to validate the expected outcomes, ensuring that both the response and the execution of the teardown function meet the specified criteria."
    },
    {
      "name": "test_teardown_request_handler_debug_mode",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 740,
      "end_line_number": 755,
      "source_code": "def test_teardown_request_handler_debug_mode(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_request(exc):\n        called.append(True)\n        return \"Ignored\"\n\n    @app.route(\"/\")\n    def root():\n        return \"Response\"\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 200\n    assert b\"Response\" in rv.data\n    assert len(called) == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 200",
        "assert b'Response' in rv.data",
        "assert len(called) == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_teardown_request_handler_debug_mode` test is to verify that the `teardown_request` handler is correctly invoked after a request is processed in a Flask application when the application is in debug mode. It ensures that the teardown function is executed and that it can modify the state (in this case, appending to a list) without affecting the response returned to the client.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `teardown_request` function is called exactly once after handling a request to the root route (\"/\"). It also verifies that the response from the route is correct (HTTP status 200 and the expected response body).\n\n**Code Being Tested and How It Works**:  \nThe code being tested includes a Flask application with a route defined for the root URL (\"/\") that returns a simple string \"Response\". The `teardown_request` function is registered to be called after each request, and it appends `True` to the `called` list. The test sends a GET request to the root route using the `client` and checks the response status and content, as well as the length of the `called` list to confirm that the teardown function was executed.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of Flask's testing client to simulate HTTP requests and responses, allowing for integration-style testing of the application. It also utilizes a list (`called`) to track whether the teardown function was invoked, demonstrating a common pattern in unit tests where state is monitored to verify behavior. The test is structured to assert multiple conditions, ensuring that both the response and the side effects of the request handling are validated."
    },
    {
      "name": "test_teardown_request_handler_error",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 758,
      "end_line_number": 793,
      "source_code": "def test_teardown_request_handler_error(app, client):\n    called = []\n    app.testing = False\n\n    @app.teardown_request\n    def teardown_request1(exc):\n        assert type(exc) is ZeroDivisionError\n        called.append(True)\n        # This raises a new error and blows away sys.exc_info(), so we can\n        # test that all teardown_requests get passed the same original\n        # exception.\n        try:\n            raise TypeError()\n        except Exception:\n            pass\n\n    @app.teardown_request\n    def teardown_request2(exc):\n        assert type(exc) is ZeroDivisionError\n        called.append(True)\n        # This raises a new error and blows away sys.exc_info(), so we can\n        # test that all teardown_requests get passed the same original\n        # exception.\n        try:\n            raise TypeError()\n        except Exception:\n            pass\n\n    @app.route(\"/\")\n    def fails():\n        raise ZeroDivisionError\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 500\n    assert b\"Internal Server Error\" in rv.data\n    assert len(called) == 2",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 500",
        "assert b'Internal Server Error' in rv.data",
        "assert len(called) == 2",
        "assert type(exc) is ZeroDivisionError",
        "assert type(exc) is ZeroDivisionError"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_teardown_request_handler_error` test is to verify that the Flask application's teardown request handlers are invoked correctly when an unhandled exception occurs during a request. Specifically, it checks that the original exception (in this case, `ZeroDivisionError`) is passed to all registered teardown handlers, even if those handlers raise new exceptions.\n\n**Specific Functionality or Behavior Verified**:  \nThis test verifies that:\n1. The correct exception type (`ZeroDivisionError`) is received by the teardown request handlers.\n2. Both teardown handlers are called when the route raises an exception.\n3. The response from the client indicates a server error (HTTP status code 500) when the route fails.\n\n**Code Being Tested and How It Works**:  \nThe code being tested includes:\n- A Flask route (`fails`) that intentionally raises a `ZeroDivisionError`.\n- Two teardown request handlers (`teardown_request1` and `teardown_request2`) that assert the type of the exception passed to them and append a value to a list (`called`) to track their invocation. Each handler also raises a new `TypeError`, which is intended to test that the original exception is preserved for subsequent handlers.\n- The test simulates a request to the route using `client.get(\"/\")`, which triggers the error and subsequently the teardown handlers.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Exception Handling**: The test uses exception handling to simulate and verify the behavior of the application when an error occurs.\n- **Teardown Handlers**: It demonstrates the use of Flask's teardown request mechanism to clean up or handle errors after a request is processed.\n- **Assertions**: The test employs assertions to validate the expected outcomes, such as checking the response status code and the content of the response, as well as ensuring that both teardown handlers were called.\n- **State Tracking**: The use of a list (`called`) to track whether the teardown handlers were invoked is a common pattern in testing to verify side effects of function calls."
    },
    {
      "name": "test_before_after_request_order",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 796,
      "end_line_number": 831,
      "source_code": "def test_before_after_request_order(app, client):\n    called = []\n\n    @app.before_request\n    def before1():\n        called.append(1)\n\n    @app.before_request\n    def before2():\n        called.append(2)\n\n    @app.after_request\n    def after1(response):\n        called.append(4)\n        return response\n\n    @app.after_request\n    def after2(response):\n        called.append(3)\n        return response\n\n    @app.teardown_request\n    def finish1(exc):\n        called.append(6)\n\n    @app.teardown_request\n    def finish2(exc):\n        called.append(5)\n\n    @app.route(\"/\")\n    def index():\n        return \"42\"\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"42\"\n    assert called == [1, 2, 3, 4, 5, 6]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'42'",
        "assert called == [1, 2, 3, 4, 5, 6]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_before_after_request_order` test is to verify the execution order of Flask's request lifecycle hooks, specifically the `before_request`, `after_request`, and `teardown_request` functions. It ensures that these hooks are called in the expected sequence when a request is processed.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the `before_request` functions are executed in the order they are registered, followed by the `after_request` functions in reverse order of registration, and finally the `teardown_request` functions in the order they were registered. The expected order of calls is validated by asserting the contents of the `called` list.\n\n**Code Being Tested and How It Works**:  \nThe test defines several request lifecycle hooks:\n- Two `before_request` functions (`before1` and `before2`) that append values `1` and `2` to the `called` list.\n- Two `after_request` functions (`after1` and `after2`) that append values `4` and `3` to the `called` list, respectively, and return the response.\n- Two `teardown_request` functions (`finish1` and `finish2`) that append values `6` and `5` to the `called` list.\n\nThe test then defines a simple route (`index`) that returns the string \"42\". When a GET request is made to this route using the `client`, the test checks that the response data is as expected and that the `called` list reflects the correct order of execution: `[1, 2, 3, 4, 5, 6]`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Lifecycle Hook Registration**: The test demonstrates the use of Flask's lifecycle hooks (`before_request`, `after_request`, and `teardown_request`) to manage request processing and cleanup.\n- **Order Verification**: The test employs a list to track the order of function calls, allowing for straightforward verification of the expected sequence.\n- **Assertions**: It uses assertions to validate both the response data and the order of execution, which is a common practice in unit testing to ensure correctness.\n- **Flask Testing Client**: The test utilizes Flask's testing client to simulate HTTP requests, which is a standard technique for testing web applications."
    },
    {
      "name": "test_error_handling",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 834,
      "end_line_number": 869,
      "source_code": "def test_error_handling(app, client):\n    app.testing = False\n\n    @app.errorhandler(404)\n    def not_found(e):\n        return \"not found\", 404\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"internal server error\", 500\n\n    @app.errorhandler(Forbidden)\n    def forbidden(e):\n        return \"forbidden\", 403\n\n    @app.route(\"/\")\n    def index():\n        flask.abort(404)\n\n    @app.route(\"/error\")\n    def error():\n        raise ZeroDivisionError\n\n    @app.route(\"/forbidden\")\n    def error2():\n        flask.abort(403)\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 404\n    assert rv.data == b\"not found\"\n    rv = client.get(\"/error\")\n    assert rv.status_code == 500\n    assert b\"internal server error\" == rv.data\n    rv = client.get(\"/forbidden\")\n    assert rv.status_code == 403\n    assert b\"forbidden\" == rv.data",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 404",
        "assert rv.data == b'not found'",
        "assert rv.status_code == 500",
        "assert b'internal server error' == rv.data",
        "assert rv.status_code == 403",
        "assert b'forbidden' == rv.data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_error_handling` function is designed to verify that the Flask application correctly handles various HTTP errors, specifically 404 (Not Found), 500 (Internal Server Error), and 403 (Forbidden). It ensures that the appropriate error messages and status codes are returned when these errors occur.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n- A request to a non-existent route returns a 404 status with the message \"not found\".\n- A request that raises an unhandled exception (in this case, a `ZeroDivisionError`) returns a 500 status with the message \"internal server error\".\n- A request to a route that explicitly aborts with a 403 status returns the message \"forbidden\".\n\n**Code Being Tested and How It Works**:  \nThe code under test includes several Flask routes and error handlers:\n- The `index` route triggers a 404 error by calling `flask.abort(404)`.\n- The `error` route raises a `ZeroDivisionError`, which is caught by the 500 error handler.\n- The `error2` route triggers a 403 error using `flask.abort(403)`.\nThe error handlers are defined to return specific messages and status codes when these errors occur, allowing the test to assert that the correct responses are returned.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Error Handling Testing**: The test utilizes Flask's error handling mechanism to simulate and verify responses to various error conditions.\n- **Assertions**: The test employs assertions to validate the status codes and response data returned by the client for each route, ensuring that the application behaves as expected under error conditions.\n- **Client Simulation**: The use of `client.get()` simulates HTTP requests to the application, allowing for comprehensive testing of the application's response to different error scenarios."
    },
    {
      "name": "test_error_handling_processing",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 872,
      "end_line_number": 890,
      "source_code": "def test_error_handling_processing(app, client):\n    app.testing = False\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"internal server error\", 500\n\n    @app.route(\"/\")\n    def broken_func():\n        raise ZeroDivisionError\n\n    @app.after_request\n    def after_request(resp):\n        resp.mimetype = \"text/x-special\"\n        return resp\n\n    resp = client.get(\"/\")\n    assert resp.mimetype == \"text/x-special\"\n    assert resp.data == b\"internal server error\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.mimetype == 'text/x-special'",
        "assert resp.data == b'internal server error'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_error_handling_processing` test is to verify that the Flask application correctly handles internal server errors (HTTP 500) by returning a specific error message and setting the response's MIME type appropriately.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a route raises an unhandled exception (in this case, a `ZeroDivisionError`), the application responds with a 500 status code, a specific error message (\"internal server error\"), and a custom MIME type (\"text/x-special\"). It ensures that the error handling mechanism is functioning as intended.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a route (`broken_func`) that intentionally raises a `ZeroDivisionError`. The test sets up an error handler for 500 errors that returns a predefined message and status code. Additionally, an `after_request` function modifies the response's MIME type. When the test client makes a GET request to the root URL (\"/\"), it triggers the error, allowing the error handler to process it and return the expected response.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Error Handling Testing**: The test specifically checks how the application responds to exceptions, which is crucial for robust applications.\n- **Custom Error Handlers**: It demonstrates the use of Flask's error handling capabilities by defining a custom error handler for 500 errors.\n- **Response Modification**: The use of an `after_request` function to modify the response's MIME type showcases how to manipulate responses in Flask tests.\n- **Assertions**: The test employs assertions to validate the response's properties, ensuring that both the status code and the content are as expected."
    },
    {
      "name": "test_baseexception_error_handling",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 893,
      "end_line_number": 901,
      "source_code": "def test_baseexception_error_handling(app, client):\n    app.testing = False\n\n    @app.route(\"/\")\n    def broken_func():\n        raise KeyboardInterrupt()\n\n    with pytest.raises(KeyboardInterrupt):\n        client.get(\"/\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_baseexception_error_handling` test is to verify that the Flask application correctly propagates exceptions raised during request handling when the application is not in testing mode. Specifically, it checks that a `KeyboardInterrupt` exception raised by a route handler is not caught by the Flask error handling mechanism, allowing the test to assert that the exception is raised as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThis test verifies that when a `KeyboardInterrupt` is raised in a route handler, it is propagated to the test client, allowing the test to catch it using `pytest.raises`. This behavior is crucial for ensuring that critical exceptions are not silently handled by the application, which could lead to unexpected behavior in production.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the route defined by `@app.route(\"/\")`, which calls the `broken_func` function that raises a `KeyboardInterrupt`. The test uses the `client.get(\"/\")` method to simulate a request to this route. Since `app.testing` is set to `False`, the exception is expected to propagate rather than being caught by Flask's error handling. The test asserts that the `KeyboardInterrupt` is raised when the route is accessed.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that a specific exception is raised during the execution of the request. This is a common pattern in unit testing for verifying that error conditions are handled as expected. Additionally, the test demonstrates the importance of the `app.testing` configuration, highlighting that setting it to `False` allows exceptions to propagate, which is a critical aspect of testing error handling in Flask applications."
    },
    {
      "name": "test_before_request_and_routing_errors",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 904,
      "end_line_number": 915,
      "source_code": "def test_before_request_and_routing_errors(app, client):\n    @app.before_request\n    def attach_something():\n        flask.g.something = \"value\"\n\n    @app.errorhandler(404)\n    def return_something(error):\n        return flask.g.something, 404\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 404\n    assert rv.data == b\"value\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 404",
        "assert rv.data == b'value'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_before_request_and_routing_errors` test is to verify the behavior of Flask's error handling mechanism, specifically how the application responds to a 404 Not Found error when a route is not defined. It also checks that a value set in the `before_request` function is accessible in the error handler.\n\n**Specific Functionality or Behavior Verified**:  \nThis test verifies that when a request is made to a non-existent route (\"/\"), the application correctly triggers the 404 error handler. It ensures that the error handler returns the expected data (the value set in the `before_request` function) along with the correct HTTP status code (404).\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Flask application with a `before_request` function that assigns a value (\"value\") to `flask.g.something`. It also defines an error handler for 404 errors that returns the value stored in `flask.g.something`. When the test makes a GET request to the root URL (\"/\"), which does not exist, it expects the response to have a status code of 404 and the response data to be the byte string `b\"value\"`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of Flask's `before_request` and `errorhandler` decorators to set up pre-request processing and custom error handling. It also utilizes assertions to validate the response's status code and data, which is a common pattern in unit testing to ensure that the application behaves as expected under specific conditions. The use of `flask.g` for storing temporary data during a request lifecycle is also noteworthy, as it allows for sharing data between different parts of the request handling process."
    },
    {
      "name": "test_user_error_handling",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 918,
      "end_line_number": 931,
      "source_code": "def test_user_error_handling(app, client):\n    class MyException(Exception):\n        pass\n\n    @app.errorhandler(MyException)\n    def handle_my_exception(e):\n        assert isinstance(e, MyException)\n        return \"42\"\n\n    @app.route(\"/\")\n    def index():\n        raise MyException()\n\n    assert client.get(\"/\").data == b\"42\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/').data == b'42'",
        "assert isinstance(e, MyException)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_user_error_handling` function is designed to verify the custom error handling mechanism in a Flask application. Specifically, it tests how the application responds when a user-defined exception (`MyException`) is raised.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when `MyException` is raised within a route, the application correctly invokes the associated error handler, returning a specific response (\"42\"). It ensures that the error handling logic is functioning as intended and that the correct response is sent back to the client.\n\n**Code Being Tested and How It Works**:  \nThe test defines a custom exception class `MyException` and registers an error handler for it using the `@app.errorhandler` decorator. The `index` route is set up to raise `MyException`. When the test client makes a GET request to the root URL (\"/\"), the application raises `MyException`, which triggers the error handler. The handler asserts that the exception is indeed of type `MyException` and returns the string \"42\". The test then asserts that the response data from the client matches the expected output (`b\"42\"`).\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Custom Exception Handling**: The test demonstrates how to create and handle custom exceptions in Flask applications, showcasing the flexibility of Flask's error handling system.\n- **Assertions**: The test uses assertions to validate both the type of the exception and the response data, ensuring that the error handling behaves as expected.\n- **Integration Testing**: By using the Flask test client to simulate a request, the test effectively integrates the route and error handling logic, verifying that they work together correctly in a real-world scenario."
    },
    {
      "name": "test_http_error_subclass_handling",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 934,
      "end_line_number": 963,
      "source_code": "def test_http_error_subclass_handling(app, client):\n    class ForbiddenSubclass(Forbidden):\n        pass\n\n    @app.errorhandler(ForbiddenSubclass)\n    def handle_forbidden_subclass(e):\n        assert isinstance(e, ForbiddenSubclass)\n        return \"banana\"\n\n    @app.errorhandler(403)\n    def handle_403(e):\n        assert not isinstance(e, ForbiddenSubclass)\n        assert isinstance(e, Forbidden)\n        return \"apple\"\n\n    @app.route(\"/1\")\n    def index1():\n        raise ForbiddenSubclass()\n\n    @app.route(\"/2\")\n    def index2():\n        flask.abort(403)\n\n    @app.route(\"/3\")\n    def index3():\n        raise Forbidden()\n\n    assert client.get(\"/1\").data == b\"banana\"\n    assert client.get(\"/2\").data == b\"apple\"\n    assert client.get(\"/3\").data == b\"apple\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/1').data == b'banana'",
        "assert client.get('/2').data == b'apple'",
        "assert client.get('/3').data == b'apple'",
        "assert isinstance(e, ForbiddenSubclass)",
        "assert not isinstance(e, ForbiddenSubclass)",
        "assert isinstance(e, Forbidden)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_http_error_subclass_handling` test is to verify the correct handling of custom error subclasses in a Flask application. It ensures that specific error handlers are invoked for different types of errors, particularly distinguishing between a custom subclass of `Forbidden` and the standard `Forbidden` error.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a `ForbiddenSubclass` exception is raised, the corresponding error handler returns the expected response (\"banana\"). It also verifies that when a standard `403 Forbidden` error is triggered, the appropriate handler returns a different response (\"apple\"). This ensures that the application correctly differentiates between the two error types and handles them accordingly.\n\n**Code Being Tested and How It Works**:  \nThe test defines a custom error subclass `ForbiddenSubclass` that inherits from Flask's `Forbidden` exception. It sets up two error handlers: one for `ForbiddenSubclass` that asserts the exception type and returns \"banana\", and another for the standard `403` error that asserts the exception is of type `Forbidden` and returns \"apple\". The test then defines three routes: `/1` raises `ForbiddenSubclass`, `/2` triggers a `403` error using `flask.abort`, and `/3` raises a standard `Forbidden` error. The assertions at the end of the test confirm that the responses from these routes match the expected outputs.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Error Handling**: It demonstrates how to register custom error handlers in Flask for specific exceptions, showcasing Flask's flexibility in managing errors.\n- **Assertions**: The use of assertions within the error handlers to validate the type of exception being handled is a unique approach that ensures the correct logic is executed.\n- **Route Testing**: The test utilizes Flask's test client to simulate requests to the defined routes, allowing for straightforward verification of the application's behavior in response to different error conditions. This is a common practice in unit testing Flask applications to ensure that routes behave as expected under various scenarios."
    },
    {
      "name": "test_errorhandler_precedence",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 966,
      "end_line_number": 996,
      "source_code": "def test_errorhandler_precedence(app, client):\n    class E1(Exception):\n        pass\n\n    class E2(Exception):\n        pass\n\n    class E3(E1, E2):\n        pass\n\n    @app.errorhandler(E2)\n    def handle_e2(e):\n        return \"E2\"\n\n    @app.errorhandler(Exception)\n    def handle_exception(e):\n        return \"Exception\"\n\n    @app.route(\"/E1\")\n    def raise_e1():\n        raise E1\n\n    @app.route(\"/E3\")\n    def raise_e3():\n        raise E3\n\n    rv = client.get(\"/E1\")\n    assert rv.data == b\"Exception\"\n\n    rv = client.get(\"/E3\")\n    assert rv.data == b\"E2\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'Exception'",
        "assert rv.data == b'E2'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_errorhandler_precedence` test is to verify the error handling mechanism in a Flask application, specifically how the application prioritizes error handlers when multiple exceptions are raised. It ensures that the correct error handler is invoked based on the type of exception raised.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when an instance of `E1` is raised, the generic `Exception` handler is triggered, returning \"Exception\". Conversely, when an instance of `E3` (which inherits from both `E1` and `E2`) is raised, the more specific handler for `E2` is invoked, returning \"E2\". This demonstrates the precedence of error handlers based on specificity.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes two custom exception classes (`E1` and `E2`), and a third class (`E3`) that inherits from both. The Flask application defines two error handlers: one for `E2` and a more generic one for `Exception`. The routes `/E1` and `/E3` are set up to raise `E1` and `E3`, respectively. The test uses a Flask test client to simulate GET requests to these routes and asserts that the responses match the expected outputs based on the defined error handlers.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of Flask's error handling mechanism, showcasing how specific error handlers can override more generic ones. It also utilizes assertions to validate the response data from the client requests, ensuring that the correct error handling logic is executed. The test structure is straightforward, focusing on clear and isolated unit tests for specific behaviors, which is a common practice in unit testing."
    },
    {
      "name": "test_trap_bad_request_key_error",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1003,
      "end_line_number": 1031,
      "source_code": "def test_trap_bad_request_key_error(app, client, debug, trap, expect_key, expect_abort):\n    app.config[\"DEBUG\"] = debug\n    app.config[\"TRAP_BAD_REQUEST_ERRORS\"] = trap\n\n    @app.route(\"/key\")\n    def fail():\n        flask.request.form[\"missing_key\"]\n\n    @app.route(\"/abort\")\n    def allow_abort():\n        flask.abort(400)\n\n    if expect_key:\n        rv = client.get(\"/key\")\n        assert rv.status_code == 400\n        assert b\"missing_key\" not in rv.data\n    else:\n        with pytest.raises(KeyError) as exc_info:\n            client.get(\"/key\")\n\n        assert exc_info.errisinstance(BadRequest)\n        assert \"missing_key\" in exc_info.value.get_description()\n\n    if expect_abort:\n        rv = client.get(\"/abort\")\n        assert rv.status_code == 400\n    else:\n        with pytest.raises(BadRequest):\n            client.get(\"/abort\")",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize(('debug', 'trap', 'expect_key', 'expect_abort'), [(False, None, True, True), (True, None, False, True), (False, True, False, False)])"
      ],
      "arguments": [
        "app",
        "client",
        "debug",
        "trap",
        "expect_key",
        "expect_abort"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 400",
        "assert b'missing_key' not in rv.data",
        "assert exc_info.errisinstance(BadRequest)",
        "assert 'missing_key' in exc_info.value.get_description()",
        "assert rv.status_code == 400"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_trap_bad_request_key_error` function is designed to verify the behavior of a Flask application when a request is made to a route that attempts to access a missing key in the request form data. It tests how the application handles bad requests, specifically focusing on whether it raises a `KeyError` or returns a `BadRequest` response based on the configuration settings.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main scenarios based on the `expect_key` and `expect_abort` parameters:\n1. If `expect_key` is `True`, it verifies that a request to the `/key` route results in a `400 Bad Request` response without including the string \"missing_key\" in the response data.\n2. If `expect_key` is `False`, it ensures that a `KeyError` is raised when accessing the missing key, and that this error is correctly transformed into a `BadRequest` exception, which includes the description of the missing key.\n\nAdditionally, it tests the `/abort` route to confirm that it either returns a `400 Bad Request` response or raises a `BadRequest` exception based on the `expect_abort` parameter.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes two Flask routes:\n- The `/key` route attempts to access `flask.request.form[\"missing_key\"]`, which will raise a `KeyError` if the key is not present in the form data.\n- The `/abort` route explicitly calls `flask.abort(400)`, which raises a `BadRequest` exception.\n\nThe test modifies the Flask app's configuration to control the behavior of error trapping (`TRAP_BAD_REQUEST_ERRORS`) and checks the response or exception raised based on the test parameters.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses parameters (`debug`, `trap`, `expect_key`, `expect_abort`) to control the behavior of the test dynamically, allowing for multiple scenarios to be tested with different configurations.\n- **Assertions**: The test employs assertions to validate the expected outcomes, such as checking the status code of the response and the presence or absence of specific content in the response data.\n- **Exception Handling**: The use of `pytest.raises` to assert that specific exceptions are raised under certain conditions is a key technique in this test, ensuring that the application behaves correctly in error scenarios.\n- **Route Testing**: The test leverages Flask's test client to simulate HTTP requests to the defined routes, allowing for comprehensive testing of the application's behavior in response to various inputs."
    },
    {
      "name": "test_trapping_of_all_http_exceptions",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1034,
      "end_line_number": 1042,
      "source_code": "def test_trapping_of_all_http_exceptions(app, client):\n    app.config[\"TRAP_HTTP_EXCEPTIONS\"] = True\n\n    @app.route(\"/fail\")\n    def fail():\n        flask.abort(404)\n\n    with pytest.raises(NotFound):\n        client.get(\"/fail\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_trapping_of_all_http_exceptions` test is to verify that the Flask application correctly handles HTTP exceptions when the `TRAP_HTTP_EXCEPTIONS` configuration is enabled. Specifically, it checks that a 404 error (Not Found) is properly raised and caught as a `NotFound` exception.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a route is accessed that triggers a 404 error (via `flask.abort(404)`), the application does not crash or return an unhandled error. Instead, it confirms that the exception is raised as expected, allowing for proper error handling in the application.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the route defined by `@app.route(\"/fail\")`, which intentionally raises a 404 error using `flask.abort(404)`. The test uses the Flask test client to make a GET request to this route. The `with pytest.raises(NotFound)` context manager is used to assert that the expected `NotFound` exception is raised when the route is accessed.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of context managers (`with pytest.raises(...)`) to assert that specific exceptions are raised during the execution of code blocks. This is a common pattern in unit testing to ensure that error handling behaves as expected. Additionally, the test leverages Flask's built-in testing capabilities, such as the test client, to simulate HTTP requests and responses, allowing for comprehensive testing of the application's behavior in response to various conditions."
    },
    {
      "name": "test_error_handler_after_processor_error",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1045,
      "end_line_number": 1071,
      "source_code": "def test_error_handler_after_processor_error(app, client):\n    app.testing = False\n\n    @app.before_request\n    def before_request():\n        if _trigger == \"before\":\n            raise ZeroDivisionError\n\n    @app.after_request\n    def after_request(response):\n        if _trigger == \"after\":\n            raise ZeroDivisionError\n\n        return response\n\n    @app.route(\"/\")\n    def index():\n        return \"Foo\"\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"Hello Server Error\", 500\n\n    for _trigger in \"before\", \"after\":\n        rv = client.get(\"/\")\n        assert rv.status_code == 500\n        assert rv.data == b\"Hello Server Error\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 500",
        "assert rv.data == b'Hello Server Error'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_error_handler_after_processor_error` is designed to verify that the Flask application correctly handles errors that occur during the request processing phase, specifically when a `ZeroDivisionError` is raised either in the `before_request` or `after_request` hooks. It ensures that the application responds with a 500 Internal Server Error and returns the appropriate error message.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a `ZeroDivisionError` is raised, the application responds with a status code of 500 and the body of the response contains the string \"Hello Server Error\". This behavior is validated for both scenarios: when the error is triggered in the `before_request` hook and when it is triggered in the `after_request` hook.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a Flask application with a simple route (`index`) and an error handler for 500 errors. The `before_request` and `after_request` hooks are defined to raise a `ZeroDivisionError` based on the value of the `_trigger` variable. The test iterates over two values of `_trigger` (\"before\" and \"after\"), simulating requests to the root route (\"/\") and checking the response for each case. The error handler is expected to catch the error and return a predefined response.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterized Testing**: The test uses a loop to iterate over different scenarios (before and after request processing), allowing for concise and clear testing of multiple conditions without duplicating code.\n- **Error Handling Verification**: The test specifically checks the application's behavior in response to exceptions, ensuring that the error handling mechanism is functioning as intended.\n- **Assertions**: The use of assertions (`assert rv.status_code == 500` and `assert rv.data == b\"Hello Server Error\"`) is crucial for validating the expected outcomes of the test, providing a clear pass/fail indication based on the application's response."
    },
    {
      "name": "test_enctype_debug_helper",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1074,
      "end_line_number": 1086,
      "source_code": "def test_enctype_debug_helper(app, client):\n    from flask.debughelpers import DebugFilesKeyError\n\n    app.debug = True\n\n    @app.route(\"/fail\", methods=[\"POST\"])\n    def index():\n        return flask.request.files[\"foo\"].filename\n\n    with pytest.raises(DebugFilesKeyError) as e:\n        client.post(\"/fail\", data={\"foo\": \"index.txt\"})\n    assert \"no file contents were transmitted\" in str(e.value)\n    assert \"This was submitted: 'index.txt'\" in str(e.value)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'no file contents were transmitted' in str(e.value)",
        "assert \"This was submitted: 'index.txt'\" in str(e.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_enctype_debug_helper` test is to verify the behavior of a Flask route when a file upload is attempted without actually providing file contents. It specifically checks that the appropriate exception (`DebugFilesKeyError`) is raised and that the error message contains the expected details about the missing file contents.\n\n**Specific Functionality or Behavior Verified**:  \nThis test verifies that when a POST request is made to the `/fail` route with form data that includes a filename but no actual file content, the application raises a `DebugFilesKeyError`. It also checks that the error message correctly indicates that no file contents were transmitted and includes the name of the submitted file.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the Flask route defined within the test, which attempts to access the uploaded file's filename using `flask.request.files[\"foo\"].filename`. Since the request is made with `data={\"foo\": \"index.txt\"}` (which does not include file content), the Flask application raises a `DebugFilesKeyError`. The test captures this exception and asserts that the error message contains specific strings that confirm the expected behavior.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that a specific exception is raised during the execution of the code block. This is a common pattern in unit testing to ensure that error handling works as intended. Additionally, the use of assertions to check the content of the exception message demonstrates a focus on validating not just the occurrence of the error, but also the correctness of the error message, which is crucial for debugging and user feedback."
    },
    {
      "name": "test_response_types",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1089,
      "end_line_number": 1180,
      "source_code": "def test_response_types(app, client):\n    @app.route(\"/text\")\n    def from_text():\n        return \"H\u00e4llo W\u00f6rld\"\n\n    @app.route(\"/bytes\")\n    def from_bytes():\n        return \"H\u00e4llo W\u00f6rld\".encode()\n\n    @app.route(\"/full_tuple\")\n    def from_full_tuple():\n        return (\n            \"Meh\",\n            400,\n            {\"X-Foo\": \"Testing\", \"Content-Type\": \"text/plain; charset=utf-8\"},\n        )\n\n    @app.route(\"/text_headers\")\n    def from_text_headers():\n        return \"Hello\", {\"X-Foo\": \"Test\", \"Content-Type\": \"text/plain; charset=utf-8\"}\n\n    @app.route(\"/text_status\")\n    def from_text_status():\n        return \"Hi, status!\", 400\n\n    @app.route(\"/response_headers\")\n    def from_response_headers():\n        return (\n            flask.Response(\n                \"Hello world\", 404, {\"Content-Type\": \"text/html\", \"X-Foo\": \"Baz\"}\n            ),\n            {\"Content-Type\": \"text/plain\", \"X-Foo\": \"Bar\", \"X-Bar\": \"Foo\"},\n        )\n\n    @app.route(\"/response_status\")\n    def from_response_status():\n        return app.response_class(\"Hello world\", 400), 500\n\n    @app.route(\"/wsgi\")\n    def from_wsgi():\n        return NotFound()\n\n    @app.route(\"/dict\")\n    def from_dict():\n        return {\"foo\": \"bar\"}, 201\n\n    @app.route(\"/list\")\n    def from_list():\n        return [\"foo\", \"bar\"], 201\n\n    assert client.get(\"/text\").data == \"H\u00e4llo W\u00f6rld\".encode()\n    assert client.get(\"/bytes\").data == \"H\u00e4llo W\u00f6rld\".encode()\n\n    rv = client.get(\"/full_tuple\")\n    assert rv.data == b\"Meh\"\n    assert rv.headers[\"X-Foo\"] == \"Testing\"\n    assert rv.status_code == 400\n    assert rv.mimetype == \"text/plain\"\n\n    rv = client.get(\"/text_headers\")\n    assert rv.data == b\"Hello\"\n    assert rv.headers[\"X-Foo\"] == \"Test\"\n    assert rv.status_code == 200\n    assert rv.mimetype == \"text/plain\"\n\n    rv = client.get(\"/text_status\")\n    assert rv.data == b\"Hi, status!\"\n    assert rv.status_code == 400\n    assert rv.mimetype == \"text/html\"\n\n    rv = client.get(\"/response_headers\")\n    assert rv.data == b\"Hello world\"\n    assert rv.content_type == \"text/plain\"\n    assert rv.headers.getlist(\"X-Foo\") == [\"Bar\"]\n    assert rv.headers[\"X-Bar\"] == \"Foo\"\n    assert rv.status_code == 404\n\n    rv = client.get(\"/response_status\")\n    assert rv.data == b\"Hello world\"\n    assert rv.status_code == 500\n\n    rv = client.get(\"/wsgi\")\n    assert b\"Not Found\" in rv.data\n    assert rv.status_code == 404\n\n    rv = client.get(\"/dict\")\n    assert rv.json == {\"foo\": \"bar\"}\n    assert rv.status_code == 201\n\n    rv = client.get(\"/list\")\n    assert rv.json == [\"foo\", \"bar\"]\n    assert rv.status_code == 201",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/text').data == 'H\u00e4llo W\u00f6rld'.encode()",
        "assert client.get('/bytes').data == 'H\u00e4llo W\u00f6rld'.encode()",
        "assert rv.data == b'Meh'",
        "assert rv.headers['X-Foo'] == 'Testing'",
        "assert rv.status_code == 400",
        "assert rv.mimetype == 'text/plain'",
        "assert rv.data == b'Hello'",
        "assert rv.headers['X-Foo'] == 'Test'",
        "assert rv.status_code == 200",
        "assert rv.mimetype == 'text/plain'",
        "assert rv.data == b'Hi, status!'",
        "assert rv.status_code == 400",
        "assert rv.mimetype == 'text/html'",
        "assert rv.data == b'Hello world'",
        "assert rv.content_type == 'text/plain'",
        "assert rv.headers.getlist('X-Foo') == ['Bar']",
        "assert rv.headers['X-Bar'] == 'Foo'",
        "assert rv.status_code == 404",
        "assert rv.data == b'Hello world'",
        "assert rv.status_code == 500",
        "assert b'Not Found' in rv.data",
        "assert rv.status_code == 404",
        "assert rv.json == {'foo': 'bar'}",
        "assert rv.status_code == 201",
        "assert rv.json == ['foo', 'bar']",
        "assert rv.status_code == 201"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_response_types` function is designed to verify the behavior of various Flask route handlers and their response types. It ensures that the application correctly handles different response formats, including strings, bytes, tuples, dictionaries, and lists, while also validating the associated HTTP status codes and headers.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that each route returns the expected data type and content, including:\n- Plain text and byte responses.\n- Responses in tuple format, which can include data, status codes, and headers.\n- Proper handling of response headers and status codes.\n- JSON responses for dictionary and list types.\n- Correct error handling for routes that return invalid types.\n\n**Code Being Tested and How It Works**:  \nThe test defines several routes within a Flask application:\n- `/text` and `/bytes` return string and byte responses, respectively.\n- `/full_tuple`, `/text_headers`, and `/response_headers` return tuples that include data, status codes, and headers.\n- `/dict` and `/list` return JSON responses.\n- Each route is accessed using the `client.get()` method, and assertions are made to verify that the returned data matches the expected output, including checking the response status codes and headers.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertions**: The test uses assertions to validate the response data, status codes, and headers, ensuring that the application behaves as expected.\n- **Client Simulation**: The `client` object simulates HTTP requests to the Flask application, allowing for comprehensive testing of route responses without needing to run a live server.\n- **Route Definition within Test**: Routes are defined within the test function, which allows for isolated testing of specific behaviors without affecting the global application state.\n- **Error Handling**: The test indirectly verifies that the application raises appropriate errors when routes return invalid types, as seen in the `test_response_type_errors` function, which complements the main test by checking for TypeErrors."
    },
    {
      "name": "test_response_type_errors",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1183,
      "end_line_number": 1229,
      "source_code": "def test_response_type_errors():\n    app = flask.Flask(__name__)\n    app.testing = True\n\n    @app.route(\"/none\")\n    def from_none():\n        pass\n\n    @app.route(\"/small_tuple\")\n    def from_small_tuple():\n        return (\"Hello\",)\n\n    @app.route(\"/large_tuple\")\n    def from_large_tuple():\n        return \"Hello\", 234, {\"X-Foo\": \"Bar\"}, \"???\"\n\n    @app.route(\"/bad_type\")\n    def from_bad_type():\n        return True\n\n    @app.route(\"/bad_wsgi\")\n    def from_bad_wsgi():\n        return lambda: None\n\n    c = app.test_client()\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"/none\")\n\n    assert \"returned None\" in str(e.value)\n    assert \"from_none\" in str(e.value)\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"/small_tuple\")\n\n    assert \"tuple must have the form\" in str(e.value)\n\n    with pytest.raises(TypeError):\n        c.get(\"/large_tuple\")\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"/bad_type\")\n\n    assert \"it was a bool\" in str(e.value)\n\n    with pytest.raises(TypeError):\n        c.get(\"/bad_wsgi\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'returned None' in str(e.value)",
        "assert 'from_none' in str(e.value)",
        "assert 'tuple must have the form' in str(e.value)",
        "assert 'it was a bool' in str(e.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_response_type_errors` function is to verify that the Flask application correctly raises `TypeError` exceptions when routes return invalid response types. This ensures that the application adheres to Flask's expected response formats and handles errors appropriately.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks various routes to confirm that they return the correct error messages when the response types are not valid. Specifically, it verifies that:\n- A route returning `None` raises a `TypeError` indicating that `None` cannot be returned.\n- A route returning a single-element tuple raises a `TypeError` indicating that the tuple must have a specific form.\n- A route returning a multi-element tuple raises a `TypeError`.\n- A route returning a boolean raises a `TypeError` indicating that a boolean is not a valid response type.\n- A route returning a lambda function raises a `TypeError` since it does not conform to the expected response types.\n\n**Code Being Tested and How It Works**:  \nThe code under test consists of several Flask route handlers defined within the `test_response_type_errors` function. Each route is designed to return a different type of response:\n- `/none`: Returns `None`.\n- `/small_tuple`: Returns a single-element tuple.\n- `/large_tuple`: Returns a multi-element tuple.\n- `/bad_type`: Returns a boolean.\n- `/bad_wsgi`: Returns a lambda function.\n\nThe test client (`c`) is used to simulate GET requests to these routes, and the responses are checked to ensure that the appropriate `TypeError` exceptions are raised, along with the expected error messages.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the following notable patterns and techniques:\n- **Context Management**: The use of `with pytest.raises(TypeError) as e:` allows for clean and readable exception handling, capturing the exception for further assertions.\n- **Assertions on Exception Messages**: The test checks the content of the exception messages to ensure that they provide meaningful feedback about the nature of the error, which is crucial for debugging.\n- **Route Definition within Tests**: The routes are defined within the test function, allowing for isolated testing of specific behaviors without affecting the global application state. This encapsulation is a common practice in unit testing to ensure that tests are self-contained and do not interfere with one another."
    },
    {
      "name": "test_make_response",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1232,
      "end_line_number": 1251,
      "source_code": "def test_make_response(app, req_ctx):\n    rv = flask.make_response()\n    assert rv.status_code == 200\n    assert rv.data == b\"\"\n    assert rv.mimetype == \"text/html\"\n\n    rv = flask.make_response(\"Awesome\")\n    assert rv.status_code == 200\n    assert rv.data == b\"Awesome\"\n    assert rv.mimetype == \"text/html\"\n\n    rv = flask.make_response(\"W00t\", 404)\n    assert rv.status_code == 404\n    assert rv.data == b\"W00t\"\n    assert rv.mimetype == \"text/html\"\n\n    rv = flask.make_response(c for c in \"Hello\")\n    assert rv.status_code == 200\n    assert rv.data == b\"Hello\"\n    assert rv.mimetype == \"text/html\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "req_ctx"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 200",
        "assert rv.data == b''",
        "assert rv.mimetype == 'text/html'",
        "assert rv.status_code == 200",
        "assert rv.data == b'Awesome'",
        "assert rv.mimetype == 'text/html'",
        "assert rv.status_code == 404",
        "assert rv.data == b'W00t'",
        "assert rv.mimetype == 'text/html'",
        "assert rv.status_code == 200",
        "assert rv.data == b'Hello'",
        "assert rv.mimetype == 'text/html'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_make_response_with_response_instance",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1254,
      "end_line_number": 1272,
      "source_code": "def test_make_response_with_response_instance(app, req_ctx):\n    rv = flask.make_response(flask.jsonify({\"msg\": \"W00t\"}), 400)\n    assert rv.status_code == 400\n    assert rv.data == b'{\"msg\":\"W00t\"}\\n'\n    assert rv.mimetype == \"application/json\"\n\n    rv = flask.make_response(flask.Response(\"\"), 400)\n    assert rv.status_code == 400\n    assert rv.data == b\"\"\n    assert rv.mimetype == \"text/html\"\n\n    rv = flask.make_response(\n        flask.Response(\"\", headers={\"Content-Type\": \"text/html\"}),\n        400,\n        [(\"X-Foo\", \"bar\")],\n    )\n    assert rv.status_code == 400\n    assert rv.headers[\"Content-Type\"] == \"text/html\"\n    assert rv.headers[\"X-Foo\"] == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "req_ctx"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 400",
        "assert rv.data == b'{\"msg\":\"W00t\"}\\n'",
        "assert rv.mimetype == 'application/json'",
        "assert rv.status_code == 400",
        "assert rv.data == b''",
        "assert rv.mimetype == 'text/html'",
        "assert rv.status_code == 400",
        "assert rv.headers['Content-Type'] == 'text/html'",
        "assert rv.headers['X-Foo'] == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_jsonify_no_prettyprint",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1276,
      "end_line_number": 1281,
      "source_code": "def test_jsonify_no_prettyprint(app, compact):\n    app.json.compact = compact\n    rv = app.json.response({\"msg\": {\"submsg\": \"W00t\"}, \"msg2\": \"foobar\"})\n    data = rv.data.strip()\n    assert (b\" \" not in data) is compact\n    assert (b\"\\n\" not in data) is compact",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('compact', [True, False])"
      ],
      "arguments": [
        "app",
        "compact"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert (b' ' not in data) is compact",
        "assert (b'\\n' not in data) is compact"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_jsonify_mimetype",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1284,
      "end_line_number": 1288,
      "source_code": "def test_jsonify_mimetype(app, req_ctx):\n    app.json.mimetype = \"application/vnd.api+json\"\n    msg = {\"msg\": {\"submsg\": \"W00t\"}}\n    rv = flask.make_response(flask.jsonify(msg), 200)\n    assert rv.mimetype == \"application/vnd.api+json\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "req_ctx"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.mimetype == 'application/vnd.api+json'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_json_dump_dataclass",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1291,
      "end_line_number": 1297,
      "source_code": "def test_json_dump_dataclass(app, req_ctx):\n    from dataclasses import make_dataclass\n\n    Data = make_dataclass(\"Data\", [(\"name\", str)])\n    value = app.json.dumps(Data(\"Flask\"))\n    value = app.json.loads(value)\n    assert value == {\"name\": \"Flask\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "req_ctx"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert value == {'name': 'Flask'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.json.loads",
          "body": "def loads(self, s, **kwargs):\n    kwargs.setdefault('object_hook', self.object_hook)\n    return super().loads(s, **kwargs)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_json_dump_dataclass` unit test is designed to verify the serialization and deserialization of a dataclass instance to and from JSON format using Flask's JSON handling capabilities. It ensures that the `app.json.dumps` and `app.json.loads` methods correctly handle a simple dataclass.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that a dataclass instance, when serialized to JSON and then deserialized back, retains its original structure and data. In this case, it verifies that the deserialized output matches the expected dictionary format.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `app.json.dumps` method, which serializes a dataclass instance into a JSON string, and the `app.json.loads` method, which deserializes that JSON string back into a Python object. The test creates a dataclass named `Data` with a single field `name`, initializes it with the value \"Flask\", and then checks that the deserialized result is a dictionary with the key-value pair `{\"name\": \"Flask\"}`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern to validate the output of the serialization and deserialization process. It uses the `assert` statement to compare the actual output against the expected output, which is a common practice in unit testing to ensure correctness. Additionally, the use of a dataclass demonstrates the test's focus on modern Python features, promoting clarity and type safety in the data structure being tested."
    },
    {
      "name": "test_jsonify_args_and_kwargs_check",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1300,
      "end_line_number": 1303,
      "source_code": "def test_jsonify_args_and_kwargs_check(app, req_ctx):\n    with pytest.raises(TypeError) as e:\n        flask.jsonify(\"fake args\", kwargs=\"fake\")\n    assert \"args or kwargs\" in str(e.value)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "req_ctx"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'args or kwargs' in str(e.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_url_generation",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1306,
      "end_line_number": 1315,
      "source_code": "def test_url_generation(app, req_ctx):\n    @app.route(\"/hello/<name>\", methods=[\"POST\"])\n    def hello():\n        pass\n\n    assert flask.url_for(\"hello\", name=\"test x\") == \"/hello/test%20x\"\n    assert (\n        flask.url_for(\"hello\", name=\"test x\", _external=True)\n        == \"http://localhost/hello/test%20x\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "req_ctx"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.url_for('hello', name='test x') == '/hello/test%20x'",
        "assert flask.url_for('hello', name='test x', _external=True) == 'http://localhost/hello/test%20x'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_build_error_handler",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1318,
      "end_line_number": 1341,
      "source_code": "def test_build_error_handler(app):\n    # Test base case, a URL which results in a BuildError.\n    with app.test_request_context():\n        pytest.raises(BuildError, flask.url_for, \"spam\")\n\n    # Verify the error is re-raised if not the current exception.\n    try:\n        with app.test_request_context():\n            flask.url_for(\"spam\")\n    except BuildError as err:\n        error = err\n    try:\n        raise RuntimeError(\"Test case where BuildError is not current.\")\n    except RuntimeError:\n        pytest.raises(BuildError, app.handle_url_build_error, error, \"spam\", {})\n\n    # Test a custom handler.\n    def handler(error, endpoint, values):\n        # Just a test.\n        return \"/test_handler/\"\n\n    app.url_build_error_handlers.append(handler)\n    with app.test_request_context():\n        assert flask.url_for(\"spam\") == \"/test_handler/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.url_for('spam') == '/test_handler/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_build_error_handler_reraise",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1344,
      "end_line_number": 1352,
      "source_code": "def test_build_error_handler_reraise(app):\n    # Test a custom handler which reraises the BuildError\n    def handler_raises_build_error(error, endpoint, values):\n        raise error\n\n    app.url_build_error_handlers.append(handler_raises_build_error)\n\n    with app.test_request_context():\n        pytest.raises(BuildError, flask.url_for, \"not.existing\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_url_for_passes_special_values_to_build_error_handler",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1355,
      "end_line_number": 1367,
      "source_code": "def test_url_for_passes_special_values_to_build_error_handler(app):\n    @app.url_build_error_handlers.append\n    def handler(error, endpoint, values):\n        assert values == {\n            \"_external\": False,\n            \"_anchor\": None,\n            \"_method\": None,\n            \"_scheme\": None,\n        }\n        return \"handled\"\n\n    with app.test_request_context():\n        flask.url_for(\"/\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert values == {'_external': False, '_anchor': None, '_method': None, '_scheme': None}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_static_files",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1370,
      "end_line_number": 1376,
      "source_code": "def test_static_files(app, client):\n    rv = client.get(\"/static/index.html\")\n    assert rv.status_code == 200\n    assert rv.data.strip() == b\"<h1>Hello World!</h1>\"\n    with app.test_request_context():\n        assert flask.url_for(\"static\", filename=\"index.html\") == \"/static/index.html\"\n    rv.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 200",
        "assert rv.data.strip() == b'<h1>Hello World!</h1>'",
        "assert flask.url_for('static', filename='index.html') == '/static/index.html'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_static_files` function is designed to verify that the Flask application correctly serves static files, specifically checking that the static file `index.html` returns a successful HTTP status code (200) and contains the expected content.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks two main behaviors: \n1. It ensures that a GET request to the static file URL (`/static/index.html`) returns a status code of 200, indicating that the file is accessible.\n2. It verifies that the content of the file matches the expected byte string (`b\"<h1>Hello World!</h1>\"`), confirming that the correct file is being served.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the Flask application through the `client` object, which is an instance of `FlaskClient`. The `client.get` method is used to simulate a GET request to the static file URL. The `rv` variable holds the response object returned by this request, which contains the status code and the data of the response. The `flask.url_for` function is also tested within a request context to ensure that the URL for the static file is generated correctly.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The test uses `app.test_request_context()` to create a request context for testing URL generation, which is a common pattern in Flask tests to ensure that the application context is available.\n- **Assertions**: The test employs assertions to validate the response's status code and content, which is a standard practice in unit testing to confirm that the code behaves as expected.\n- **Resource Management**: The `rv.close()` method is called to clean up the response object, which is a good practice to prevent resource leaks in tests."
    },
    {
      "name": "test_static_url_path",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1379,
      "end_line_number": 1387,
      "source_code": "def test_static_url_path():\n    app = flask.Flask(__name__, static_url_path=\"/foo\")\n    app.testing = True\n    rv = app.test_client().get(\"/foo/index.html\")\n    assert rv.status_code == 200\n    rv.close()\n\n    with app.test_request_context():\n        assert flask.url_for(\"static\", filename=\"index.html\") == \"/foo/index.html\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 200",
        "assert flask.url_for('static', filename='index.html') == '/foo/index.html'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_static_url_path` function is designed to verify that a Flask application correctly serves static files from a specified URL path. It ensures that the application can handle requests for static files and that the URL generation for static resources is accurate.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main behaviors: \n1. It verifies that a GET request to the static file URL (`/foo/index.html`) returns a successful HTTP status code (200), indicating that the file is accessible.\n2. It confirms that the URL generated for the static file using `flask.url_for` matches the expected path (`/foo/index.html`), ensuring that the URL routing for static files is functioning correctly.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves creating a Flask application instance with a custom `static_url_path` set to `/foo`. The test client is then used to simulate a GET request to the static file's URL. The `app.test_request_context()` is utilized to create a request context for testing the URL generation. The assertions check the response status and the correctness of the URL generated for the static file.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Test Client Usage**: The test employs Flask's test client to simulate HTTP requests, allowing for the verification of response codes and content without needing to run a live server.\n- **Request Context Management**: The use of `app.test_request_context()` allows the test to create a context for URL generation, ensuring that the application behaves as it would during a real request.\n- **Assertions**: The test uses assertions to validate expected outcomes, which is a fundamental practice in unit testing to ensure that the code behaves as intended."
    },
    {
      "name": "test_static_url_path_with_ending_slash",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1390,
      "end_line_number": 1398,
      "source_code": "def test_static_url_path_with_ending_slash():\n    app = flask.Flask(__name__, static_url_path=\"/foo/\")\n    app.testing = True\n    rv = app.test_client().get(\"/foo/index.html\")\n    assert rv.status_code == 200\n    rv.close()\n\n    with app.test_request_context():\n        assert flask.url_for(\"static\", filename=\"index.html\") == \"/foo/index.html\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 200",
        "assert flask.url_for('static', filename='index.html') == '/foo/index.html'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_static_url_path_with_ending_slash` unit test is designed to verify that a Flask application correctly serves static files when the static URL path is defined with a trailing slash. It ensures that the application can handle requests to static files and that the URL generation for static files is accurate.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks two main behaviors: \n1. It verifies that a GET request to the static file `/foo/index.html` returns a successful HTTP status code (200), indicating that the file is accessible.\n2. It confirms that the URL generated for the static file using `flask.url_for` matches the expected path, ensuring that the URL routing is functioning correctly with the specified static URL path.\n\n**Code Being Tested and How It Works**:  \nThe test creates a Flask application instance with a static URL path set to `/foo/`. It then uses the test client to send a GET request to `/foo/index.html`. The response is checked for a status code of 200, which indicates that the file was found and served correctly. Additionally, within a request context, it uses `flask.url_for` to generate the URL for the static file and asserts that it matches the expected path `/foo/index.html`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Test Client**: The test utilizes Flask's built-in test client to simulate HTTP requests to the application, allowing for easy verification of response behavior.\n- **Request Context**: The test employs `app.test_request_context()` to create a context for URL generation, ensuring that the `url_for` function can access the application context.\n- **Assertions**: The test uses assertions to validate the expected outcomes, specifically checking the response status code and the correctness of the generated URL, which is a common practice in unit testing to ensure that the code behaves as intended."
    },
    {
      "name": "test_static_url_empty_path",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1401,
      "end_line_number": 1405,
      "source_code": "def test_static_url_empty_path(app):\n    app = flask.Flask(__name__, static_folder=\"\", static_url_path=\"\")\n    rv = app.test_client().open(\"/static/index.html\", method=\"GET\")\n    assert rv.status_code == 200\n    rv.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_static_url_empty_path` unit test is designed to verify that a Flask application can successfully serve static files when both the `static_folder` and `static_url_path` are set to empty strings. This ensures that the application can handle edge cases in static file serving configurations.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that a GET request to the path `/static/index.html` returns a status code of 200, indicating that the request was successful and the static file was found and served correctly, despite the unconventional configuration of empty paths.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the Flask application instance created with `flask.Flask(__name__, static_folder=\"\", static_url_path=\"\")`. The `test_client().open(\"/static/index.html\", method=\"GET\")` method simulates a client making a GET request to the specified URL. The assertion `assert rv.status_code == 200` confirms that the response status code is as expected, indicating successful file retrieval.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of Flask's test client to simulate HTTP requests, which is a common pattern in testing web applications. It also utilizes assertions to validate the expected outcomes, ensuring that the application behaves correctly under the specified conditions. The test structure follows a clear and concise format, making it easy to understand the intent and expected behavior. Additionally, the use of `rv.close()` is a good practice to clean up resources after the test execution."
    },
    {
      "name": "test_static_url_empty_path_default",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1408,
      "end_line_number": 1412,
      "source_code": "def test_static_url_empty_path_default(app):\n    app = flask.Flask(__name__, static_folder=\"\")\n    rv = app.test_client().open(\"/static/index.html\", method=\"GET\")\n    assert rv.status_code == 200\n    rv.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_static_url_empty_path_default` test is designed to verify that a Flask application can serve static files correctly when the `static_folder` is set to an empty string. It specifically checks if the application can successfully respond to a request for a static file located at `/static/index.html`.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the application returns a successful HTTP status code (200) when attempting to access the static file. It confirms that the routing and serving of static files work as expected, even when the static folder is configured to be empty.\n\n**Code Being Tested and How It Works**:  \nThe test creates a Flask application instance with `static_folder` set to an empty string. It then uses the test client to send a GET request to `/static/index.html`. The expected behavior is that the application should still be able to serve the static file, and the test checks that the response status code is 200, indicating success. The `rv.close()` method is called to clean up the response object.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Test Client Usage**: The test utilizes Flask's built-in test client to simulate HTTP requests, allowing for easy testing of routes and responses.\n- **Assertion**: The test employs an assertion to verify the expected outcome (status code 200), which is a common practice in unit testing to validate functionality.\n- **Isolation**: The test is isolated from other tests by creating a new Flask application instance, ensuring that it does not interfere with or depend on the state of other tests."
    },
    {
      "name": "test_static_folder_with_pathlib_path",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1415,
      "end_line_number": 1421,
      "source_code": "def test_static_folder_with_pathlib_path(app):\n    from pathlib import Path\n\n    app = flask.Flask(__name__, static_folder=Path(\"static\"))\n    rv = app.test_client().open(\"/static/index.html\", method=\"GET\")\n    assert rv.status_code == 200\n    rv.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_static_folder_with_pathlib_path` test is to verify that a Flask application can correctly serve static files when the `static_folder` is specified using a `Path` object from the `pathlib` module. This ensures compatibility with modern Python file handling practices.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that a GET request to the static file located at `/static/index.html` returns a successful HTTP status code of 200. This indicates that the file is accessible and being served correctly by the Flask application.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the instantiation of a Flask application with a static folder defined as `Path(\"static\")`. The test client then attempts to open the URL `/static/index.html` using the `open` method. The `assert` statement checks that the response status code is 200, confirming that the file is served correctly. The `rv.close()` method is called to clean up the response object, ensuring that resources are released properly.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of Flask's test client to simulate HTTP requests, which is a common pattern in testing web applications. It also utilizes assertions to validate the expected outcomes, ensuring that the application behaves as intended. The use of `Path` from the `pathlib` module demonstrates a modern approach to file path handling, promoting better readability and cross-platform compatibility. Additionally, the test is structured to be independent, relying solely on the Flask framework's capabilities without external dependencies."
    },
    {
      "name": "test_static_folder_with_ending_slash",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1424,
      "end_line_number": 1432,
      "source_code": "def test_static_folder_with_ending_slash():\n    app = flask.Flask(__name__, static_folder=\"static/\")\n\n    @app.route(\"/<path:path>\")\n    def catch_all(path):\n        return path\n\n    rv = app.test_client().get(\"/catch/all\")\n    assert rv.data == b\"catch/all\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'catch/all'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_static_route_with_host_matching",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1435,
      "end_line_number": 1453,
      "source_code": "def test_static_route_with_host_matching():\n    app = flask.Flask(__name__, host_matching=True, static_host=\"example.com\")\n    c = app.test_client()\n    rv = c.get(\"http://example.com/static/index.html\")\n    assert rv.status_code == 200\n    rv.close()\n    with app.test_request_context():\n        rv = flask.url_for(\"static\", filename=\"index.html\", _external=True)\n        assert rv == \"http://example.com/static/index.html\"\n    # Providing static_host without host_matching=True should error.\n    with pytest.raises(AssertionError):\n        flask.Flask(__name__, static_host=\"example.com\")\n    # Providing host_matching=True with static_folder\n    # but without static_host should error.\n    with pytest.raises(AssertionError):\n        flask.Flask(__name__, host_matching=True)\n    # Providing host_matching=True without static_host\n    # but with static_folder=None should not error.\n    flask.Flask(__name__, host_matching=True, static_folder=None)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 200",
        "assert rv == 'http://example.com/static/index.html'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_static_route_with_host_matching` test is to verify the behavior of Flask's static file serving when specific configurations for host matching and static hosting are applied. It ensures that the application correctly serves static files and raises appropriate errors when configurations are misused.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. A static file can be successfully retrieved when the application is configured with `host_matching=True` and a specific `static_host`.\n2. The URL generated for the static file matches the expected external URL.\n3. Errors are raised when the `static_host` is provided without `host_matching=True`, and when `host_matching=True` is set without a `static_host`.\n\n**Code Being Tested and How It Works**:  \nThe code being tested includes the Flask application setup and the retrieval of static files. The test creates a Flask app instance with `host_matching` and `static_host` parameters, then uses the test client to make a GET request to a static file. It checks the response status code to ensure the file is served correctly. Additionally, it uses `flask.url_for` to verify that the generated URL for the static file is correct. The test also checks for assertion errors when invalid configurations are provided.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Test Client**: The use of `app.test_client()` allows for simulating requests to the Flask application without needing to run a server.\n- **Context Management**: The test utilizes `app.test_request_context()` to create a request context for generating URLs, ensuring that the URL generation behaves as expected within the application context.\n- **Error Handling**: The test employs `pytest.raises` to assert that specific configurations raise the expected errors, demonstrating the test's focus on validating both successful and erroneous behaviors."
    },
    {
      "name": "test_request_locals",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1456,
      "end_line_number": 1458,
      "source_code": "def test_request_locals():\n    assert repr(flask.g) == \"<LocalProxy unbound>\"\n    assert not flask.g",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(flask.g) == '<LocalProxy unbound>'",
        "assert not flask.g"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_server_name_subdomain",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1461,
      "end_line_number": 1503,
      "source_code": "def test_server_name_subdomain():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    client = app.test_client()\n\n    @app.route(\"/\")\n    def index():\n        return \"default\"\n\n    @app.route(\"/\", subdomain=\"foo\")\n    def subdomain():\n        return \"subdomain\"\n\n    app.config[\"SERVER_NAME\"] = \"dev.local:5000\"\n    rv = client.get(\"/\")\n    assert rv.data == b\"default\"\n\n    rv = client.get(\"/\", \"http://dev.local:5000\")\n    assert rv.data == b\"default\"\n\n    rv = client.get(\"/\", \"https://dev.local:5000\")\n    assert rv.data == b\"default\"\n\n    app.config[\"SERVER_NAME\"] = \"dev.local:443\"\n    rv = client.get(\"/\", \"https://dev.local\")\n\n    # Werkzeug 1.0 fixes matching https scheme with 443 port\n    if rv.status_code != 404:\n        assert rv.data == b\"default\"\n\n    app.config[\"SERVER_NAME\"] = \"dev.local\"\n    rv = client.get(\"/\", \"https://dev.local\")\n    assert rv.data == b\"default\"\n\n    # suppress Werkzeug 0.15 warning about name mismatch\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\n            \"ignore\", \"Current server name\", UserWarning, \"flask.app\"\n        )\n        rv = client.get(\"/\", \"http://foo.localhost\")\n        assert rv.status_code == 404\n\n    rv = client.get(\"/\", \"http://foo.dev.local\")\n    assert rv.data == b\"subdomain\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'default'",
        "assert rv.data == b'default'",
        "assert rv.data == b'default'",
        "assert rv.data == b'default'",
        "assert rv.data == b'subdomain'",
        "assert rv.data == b'default'",
        "assert rv.status_code == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_server_name_subdomain` function is designed to verify the behavior of Flask's routing system when handling requests to different subdomains. It ensures that the application correctly serves content based on the specified subdomain and the server name configuration.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the correct response is returned for requests made to the root path (\"/\") under various configurations of the `SERVER_NAME` and subdomain settings. It verifies that requests to the default subdomain return the \"default\" response, while requests to the \"foo\" subdomain return the \"subdomain\" response. Additionally, it checks the handling of HTTPS requests and the appropriate status codes for mismatched subdomains.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes two route handlers defined in the Flask application: one for the default subdomain (returning \"default\") and another for the \"foo\" subdomain (returning \"subdomain\"). The test modifies the `SERVER_NAME` configuration to simulate different environments and uses the Flask test client to make requests to the application. The responses are then asserted against expected values to confirm correct behavior.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Flask Test Client**: The test utilizes Flask's built-in test client to simulate HTTP requests, allowing for isolated testing of the application without needing to run a live server.\n- **Assertions**: The test employs assertions to validate the response data and status codes, ensuring that the application behaves as expected under various configurations.\n- **Warning Suppression**: The test includes a context manager to suppress specific warnings related to server name mismatches, demonstrating an awareness of potential issues in the testing environment.\n- **Conditional Logic**: The test includes conditional assertions based on the Werkzeug version, indicating a consideration for compatibility across different library versions."
    },
    {
      "name": "test_exception_propagation",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1507,
      "end_line_number": 1520,
      "source_code": "def test_exception_propagation(app, client, key):\n    app.testing = False\n\n    @app.route(\"/\")\n    def index():\n        raise ZeroDivisionError\n\n    if key is not None:\n        app.config[key] = True\n\n        with pytest.raises(ZeroDivisionError):\n            client.get(\"/\")\n    else:\n        assert client.get(\"/\").status_code == 500",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('key', ['TESTING', 'PROPAGATE_EXCEPTIONS', 'DEBUG', None])"
      ],
      "arguments": [
        "app",
        "client",
        "key"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/').status_code == 500"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_exception_propagation` test is designed to verify how the Flask application handles exceptions raised during request processing, specifically focusing on the propagation of a `ZeroDivisionError`. It checks whether the application correctly raises the exception when the `app.testing` mode is enabled and whether it returns a 500 status code when it is not.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies two scenarios based on the value of the `key` parameter. If `key` is not `None`, it expects the `ZeroDivisionError` to propagate, and the test should raise this exception when the client makes a GET request to the root endpoint. If `key` is `None`, it checks that the response status code is 500, indicating an internal server error due to the unhandled exception.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a Flask route defined at the root (\"/\") that intentionally raises a `ZeroDivisionError`. The test uses the Flask test client to simulate a GET request to this route. The behavior of the application is influenced by the `app.testing` attribute, which determines whether exceptions are propagated to the test client or handled internally by Flask.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that a specific exception is raised during the execution of the client request when `key` is provided. This is a common pattern in unit testing to verify that error conditions are handled as expected. Additionally, the test uses conditional logic to differentiate between the two scenarios based on the `key` parameter, showcasing a flexible approach to testing different configurations of the application."
    },
    {
      "name": "test_werkzeug_passthrough_errors",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1527,
      "end_line_number": 1538,
      "source_code": "def test_werkzeug_passthrough_errors(\n    monkeypatch, debug, use_debugger, use_reloader, propagate_exceptions, app\n):\n    rv = {}\n\n    # Mocks werkzeug.serving.run_simple method\n    def run_simple_mock(*args, **kwargs):\n        rv[\"passthrough_errors\"] = kwargs.get(\"passthrough_errors\")\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n    app.config[\"PROPAGATE_EXCEPTIONS\"] = propagate_exceptions\n    app.run(debug=debug, use_debugger=use_debugger, use_reloader=use_reloader)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('debug', [True, False])",
        "pytest.mark.parametrize('use_debugger', [True, False])",
        "pytest.mark.parametrize('use_reloader', [True, False])",
        "pytest.mark.parametrize('propagate_exceptions', [None, True, False])"
      ],
      "arguments": [
        "monkeypatch",
        "debug",
        "use_debugger",
        "use_reloader",
        "propagate_exceptions",
        "app"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "kwargs.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_werkzeug_passthrough_errors` function is designed to verify the behavior of the Flask application when handling exceptions, specifically focusing on the `passthrough_errors` configuration in the `werkzeug.serving.run_simple` method. It checks whether the application correctly propagates or suppresses exceptions based on the configuration settings.\n\n**Specific Functionality or Behavior Verified**:  \nThis test assesses how the application responds to different configurations of the `debug`, `use_debugger`, `use_reloader`, and `propagate_exceptions` parameters. It ensures that the `passthrough_errors` flag is set correctly when the application is run, which influences whether exceptions are raised or handled internally.\n\n**Code Being Tested and How It Works**:  \nThe test mocks the `run_simple` method from the `werkzeug.serving` module using `monkeypatch`, allowing it to capture the `passthrough_errors` argument passed during the application run. The application is then executed with the specified configurations, and the test checks if the `passthrough_errors` value is correctly stored in the `rv` dictionary. This indirectly tests the application's configuration handling and error propagation behavior.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses `pytest.mark.parametrize` to run multiple scenarios with different combinations of the `debug`, `use_debugger`, `use_reloader`, and `propagate_exceptions` parameters, ensuring comprehensive coverage of the configurations.\n- **Monkeypatching**: The use of `monkeypatch` allows for the replacement of the `run_simple` method, enabling the test to focus on the application's behavior without executing the actual server code.\n- **State Verification**: The test verifies the state of the `rv` dictionary to confirm that the application behaves as expected under various configurations, which is a common practice in unit testing to validate side effects."
    },
    {
      "name": "test_max_content_length",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1541,
      "end_line_number": 1559,
      "source_code": "def test_max_content_length(app, client):\n    app.config[\"MAX_CONTENT_LENGTH\"] = 64\n\n    @app.before_request\n    def always_first():\n        flask.request.form[\"myfile\"]\n        AssertionError()\n\n    @app.route(\"/accept\", methods=[\"POST\"])\n    def accept_file():\n        flask.request.form[\"myfile\"]\n        AssertionError()\n\n    @app.errorhandler(413)\n    def catcher(error):\n        return \"42\"\n\n    rv = client.post(\"/accept\", data={\"myfile\": \"foo\" * 100})\n    assert rv.data == b\"42\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'42'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_max_content_length` function is to verify that the Flask application correctly enforces the maximum content length for incoming requests. Specifically, it checks that when a request exceeds the defined limit, the application responds with a 413 (Payload Too Large) error, and that the custom error handler returns the expected response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a POST request is made with data exceeding the `MAX_CONTENT_LENGTH` configuration (set to 50 bytes in this case), the application raises a 413 error. The test also verifies that the error handler for this status code returns the string \"42\" as the response body.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the Flask route `/accept`, which attempts to access the `myfile` field from the request's form data. If the request exceeds the maximum content length, Flask raises a `RequestEntityTooLarge` exception, which is caught by the custom error handler defined in the test. The error handler returns a simple string response (\"42\"). The test simulates a POST request with data that exceeds the limit (`\"foo\" * 100`), and asserts that the response data matches the expected output (`b\"42\"`).\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Error Handling Testing**: The test effectively checks the behavior of the application when it encounters an error condition (413 status code) by using a custom error handler.\n- **Client Simulation**: It utilizes Flask's test client to simulate HTTP requests, allowing for easy testing of routes and their responses.\n- **Configuration Testing**: The test modifies the application configuration (`MAX_CONTENT_LENGTH`) to validate that the application respects this setting during request processing.\n- **Assertion**: The test uses assertions to verify that the actual response matches the expected outcome, ensuring that the application behaves as intended under specific conditions."
    },
    {
      "name": "test_url_processors",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1562,
      "end_line_number": 1588,
      "source_code": "def test_url_processors(app, client):\n    @app.url_defaults\n    def add_language_code(endpoint, values):\n        if flask.g.lang_code is not None and app.url_map.is_endpoint_expecting(\n            endpoint, \"lang_code\"\n        ):\n            values.setdefault(\"lang_code\", flask.g.lang_code)\n\n    @app.url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop(\"lang_code\", None)\n\n    @app.route(\"/<lang_code>/\")\n    def index():\n        return flask.url_for(\"about\")\n\n    @app.route(\"/<lang_code>/about\")\n    def about():\n        return flask.url_for(\"something_else\")\n\n    @app.route(\"/foo\")\n    def something_else():\n        return flask.url_for(\"about\", lang_code=\"en\")\n\n    assert client.get(\"/de/\").data == b\"/de/about\"\n    assert client.get(\"/de/about\").data == b\"/foo\"\n    assert client.get(\"/foo\").data == b\"/en/about\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/de/').data == b'/de/about'",
        "assert client.get('/de/about').data == b'/foo'",
        "assert client.get('/foo').data == b'/en/about'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "values.setdefault",
          "body": "@app.route('/setdefault')\ndef setdefault():\n    return flask.session.setdefault('test', 'default')"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:\nThe primary purpose of the `test_url_processors` test is to verify the correct functioning of URL processing in a Flask application, specifically the handling of language codes in URL routes. It ensures that the application correctly appends language codes to URLs and processes them as expected.\n\n**Specific Functionality or Behavior Verified**:\nThis test checks that the application can correctly handle requests with language codes in the URL. It verifies that:\n1. The language code is correctly added to the URL when accessing the index route.\n2. The application can retrieve the correct URL for the \"about\" route based on the provided language code.\n3. The application can redirect to the appropriate URL when accessing the \"something_else\" route.\n\n**Code Being Tested and How It Works**:\nThe test defines several URL routes that utilize language codes:\n- The `index` route responds to requests with a language code and returns the URL for the \"about\" route.\n- The `about` route returns the URL for the \"index\" route.\n- The `something_else` route returns the URL for the \"about\" route with a default language code of \"en\".\n\nThe test uses Flask's `url_defaults` and `url_value_preprocessor` decorators to manage the language code in the request context. The assertions at the end of the test check the responses from the client for specific URLs, ensuring that the expected URLs are returned.\n\n**Notable Testing Patterns or Techniques Used**:\n1. **Client Simulation**: The test uses Flask's test client to simulate HTTP requests, allowing for easy verification of responses without needing a live server.\n2. **Assertions**: The test employs assertions to validate that the actual output matches the expected output, ensuring that the URL processing logic behaves correctly.\n3. **Decorator Usage**: The test demonstrates the use of Flask decorators (`url_defaults` and `url_value_preprocessor`) to manage URL parameters, showcasing how to extend Flask's routing capabilities.\n4. **Blueprints**: The test registers a blueprint, which is a common pattern in Flask applications for organizing routes and handlers, although in this specific test, the blueprint is not utilized for routing but demonstrates the capability of Flask's architecture."
    },
    {
      "name": "test_inject_blueprint_url_defaults",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1591,
      "end_line_number": 1612,
      "source_code": "def test_inject_blueprint_url_defaults(app):\n    bp = flask.Blueprint(\"foo\", __name__, template_folder=\"template\")\n\n    @bp.url_defaults\n    def bp_defaults(endpoint, values):\n        values[\"page\"] = \"login\"\n\n    @bp.route(\"/<page>\")\n    def view(page):\n        pass\n\n    app.register_blueprint(bp)\n\n    values = dict()\n    app.inject_url_defaults(\"foo.view\", values)\n    expected = dict(page=\"login\")\n    assert values == expected\n\n    with app.test_request_context(\"/somepage\"):\n        url = flask.url_for(\"foo.view\")\n    expected = \"/login\"\n    assert url == expected",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert values == expected",
        "assert url == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_nonascii_pathinfo",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1615,
      "end_line_number": 1621,
      "source_code": "def test_nonascii_pathinfo(app, client):\n    @app.route(\"/\u043a\u0438\u0440\u0442\u0435\u0441\u0442\")\n    def index():\n        return \"Hello World!\"\n\n    rv = client.get(\"/\u043a\u0438\u0440\u0442\u0435\u0441\u0442\")\n    assert rv.data == b\"Hello World!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'Hello World!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_nonascii_pathinfo` test is designed to verify that the Flask application can correctly handle and respond to requests with non-ASCII characters in the URL path. This is important for ensuring that the application can support internationalization and various character sets.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that when a GET request is made to the route `/\u043a\u0438\u0440\u0442\u0435\u0441\u0442`, the application returns the expected response \"Hello World!\" in byte format. This confirms that the application can process non-ASCII path information without errors and return the correct content.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a Flask route defined with the decorator `@app.route(\"/\u043a\u0438\u0440\u0442\u0435\u0441\u0442\")`, which maps the URL path containing non-ASCII characters to the `index` function. This function simply returns the string \"Hello World!\". The test uses the Flask test client to simulate a GET request to this route and asserts that the response data matches the expected byte string.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of Flask's test client to simulate HTTP requests, which is a common pattern in testing web applications. It also utilizes assertions to verify that the response data matches the expected output. The test is structured to be concise, focusing on a single aspect of functionality, which is a good practice in unit testing to ensure clarity and maintainability."
    },
    {
      "name": "test_no_setup_after_first_request",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1624,
      "end_line_number": 1636,
      "source_code": "def test_no_setup_after_first_request(app, client):\n    app.debug = True\n\n    @app.route(\"/\")\n    def index():\n        return \"Awesome\"\n\n    assert client.get(\"/\").data == b\"Awesome\"\n\n    with pytest.raises(AssertionError) as exc_info:\n        app.add_url_rule(\"/foo\", endpoint=\"late\")\n\n    assert \"setup method 'add_url_rule'\" in str(exc_info.value)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/').data == b'Awesome'",
        "assert \"setup method 'add_url_rule'\" in str(exc_info.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_no_setup_after_first_request` is designed to verify that after the first request to a Flask application, no further setup methods (like adding new URL rules) can be executed. This is important for ensuring the integrity of the application\u2019s routing and request handling after it has started processing requests.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that an `AssertionError` is raised when attempting to add a new URL rule (`/foo`) after the first request has been processed. It also verifies that the error message correctly indicates that the setup method `add_url_rule` cannot be called after the first request.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the Flask application setup and the route definition for the root endpoint (`/`). The test first sets up a simple route that returns \"Awesome\" and makes a GET request to this route using the test client. After confirming that the response is as expected, it attempts to add a new route (`/foo`) and expects an `AssertionError` to be raised, indicating that the application has already processed a request and cannot accept further setup.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The test uses the Flask test client to simulate requests to the application, allowing for easy verification of responses.\n- **Exception Testing**: The test employs `pytest.raises` to assert that a specific exception is raised when an invalid operation is attempted, which is a common pattern in unit testing to ensure that error handling is functioning as expected.\n- **Assertions**: The test includes assertions to validate both the response data from the initial request and the content of the exception message, ensuring comprehensive coverage of the expected behavior."
    },
    {
      "name": "test_routing_redirect_debugging",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1639,
      "end_line_number": 1656,
      "source_code": "def test_routing_redirect_debugging(monkeypatch, app, client):\n    app.config[\"DEBUG\"] = True\n\n    @app.route(\"/user/\", methods=[\"GET\", \"POST\"])\n    def user():\n        return flask.request.form[\"status\"]\n\n    # default redirect code preserves form data\n    rv = client.post(\"/user\", data={\"status\": \"success\"}, follow_redirects=True)\n    assert rv.data == b\"success\"\n\n    # 301 and 302 raise error\n    monkeypatch.setattr(RequestRedirect, \"code\", 301)\n\n    with client, pytest.raises(AssertionError) as exc_info:\n        client.post(\"/user\", data={\"status\": \"error\"}, follow_redirects=True)\n\n    assert \"canonical URL 'http://localhost/user/'\" in str(exc_info.value)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch",
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'success'",
        "assert \"canonical URL 'http://localhost/user/'\" in str(exc_info.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'"
        },
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_routing_redirect_debugging` function is designed to verify the behavior of Flask's routing and redirect mechanisms, particularly in debug mode. It ensures that form data is preserved during redirects and that appropriate exceptions are raised when redirects do not conform to specific HTTP status codes.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main scenarios: \n1. When a POST request is made to the `/user/` route with form data, it verifies that the data is correctly returned after following the redirect.\n2. It tests that when a redirect with a status code of 301 is simulated, an `AssertionError` is raised, indicating that the redirect would cause the loss of form data, which is not allowed in debug mode.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a Flask route defined at `/user/` that returns the value of the \"status\" field from the form data. The test first sends a POST request with the status \"success\" and checks that the response data matches this value after following the redirect. Then, it uses `monkeypatch` to change the redirect status code to 301, simulating a scenario where form data would be lost. The test expects an `AssertionError` to be raised, confirming that the application correctly identifies this issue in debug mode.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `monkeypatch` fixture from `pytest` to modify the behavior of the `RequestRedirect` class dynamically. It also uses `pytest.raises` to assert that an exception is raised under specific conditions, which is a common pattern for testing error handling in unit tests. Additionally, the use of `follow_redirects=True` in the client request allows the test to verify the behavior of the application when handling redirects, ensuring that the test covers both successful and erroneous redirect scenarios."
    },
    {
      "name": "test_route_decorator_custom_endpoint",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1659,
      "end_line_number": 1681,
      "source_code": "def test_route_decorator_custom_endpoint(app, client):\n    app.debug = True\n\n    @app.route(\"/foo/\")\n    def foo():\n        return flask.request.endpoint\n\n    @app.route(\"/bar/\", endpoint=\"bar\")\n    def for_bar():\n        return flask.request.endpoint\n\n    @app.route(\"/bar/123\", endpoint=\"123\")\n    def for_bar_foo():\n        return flask.request.endpoint\n\n    with app.test_request_context():\n        assert flask.url_for(\"foo\") == \"/foo/\"\n        assert flask.url_for(\"bar\") == \"/bar/\"\n        assert flask.url_for(\"123\") == \"/bar/123\"\n\n    assert client.get(\"/foo/\").data == b\"foo\"\n    assert client.get(\"/bar/\").data == b\"bar\"\n    assert client.get(\"/bar/123\").data == b\"123\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/foo/').data == b'foo'",
        "assert client.get('/bar/').data == b'bar'",
        "assert client.get('/bar/123').data == b'123'",
        "assert flask.url_for('foo') == '/foo/'",
        "assert flask.url_for('bar') == '/bar/'",
        "assert flask.url_for('123') == '/bar/123'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_route_decorator_custom_endpoint` test is to verify that Flask's routing system correctly handles custom endpoints and that the application can return the expected endpoint names when accessed via HTTP requests.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the Flask application can correctly resolve and return the endpoint names for defined routes. It ensures that the `url_for` function generates the correct URLs for the specified endpoints and that the HTTP GET requests to those routes return the expected endpoint names as responses.\n\n**Code Being Tested and How It Works**:  \nThe test defines three routes (`/foo/`, `/bar/`, and `/bar/123`) with custom endpoint names. The `foo` function returns the endpoint name of the request, which is accessed via `flask.request.endpoint`. The test then uses the Flask test client to make GET requests to these routes and asserts that the returned data matches the expected endpoint names. Additionally, it checks that the `url_for` function generates the correct URLs for each endpoint.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Test Request Context**: The test uses `app.test_request_context()` to simulate a request context, allowing the use of `flask.request` and `flask.url_for` without an actual HTTP request.\n- **Assertions**: The test employs assertions to validate that the expected output matches the actual output, ensuring that the routing and endpoint resolution work as intended.\n- **Client Simulation**: The use of `client.get()` simulates HTTP requests to the application, allowing for the verification of route behavior in a controlled test environment."
    },
    {
      "name": "test_get_method_on_g",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1684,
      "end_line_number": 1689,
      "source_code": "def test_get_method_on_g(app_ctx):\n    assert flask.g.get(\"x\") is None\n    assert flask.g.get(\"x\", 11) == 11\n    flask.g.x = 42\n    assert flask.g.get(\"x\") == 42\n    assert flask.g.x == 42",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app_ctx"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.g.get('x') is None",
        "assert flask.g.get('x', 11) == 11",
        "assert flask.g.get('x') == 42",
        "assert flask.g.x == 42"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "flask.g.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "flask.g.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "flask.g.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_get_method_on_g` function is designed to verify the behavior of the `flask.g` object, which is a context-local object used to store data during a request. This test checks the retrieval and assignment of values in `flask.g`, ensuring that it behaves as expected when accessed.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies that:\n1. The default value for a key that does not exist in `flask.g` is `None`.\n2. A default value can be provided when attempting to retrieve a non-existent key.\n3. Values can be assigned to keys in `flask.g` and subsequently retrieved correctly.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `flask.g` object, specifically its `get` method and direct attribute access. The test performs the following actions:\n- It checks that `flask.g.get(\"x\")` returns `None` when \"x\" has not been set.\n- It checks that `flask.g.get(\"x\", 11)` returns `11` when \"x\" is not set, demonstrating the use of a default value.\n- It assigns the value `42` to `flask.g.x` and verifies that both `flask.g.get(\"x\")` and `flask.g.x` return `42`, confirming that the assignment was successful.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs direct assertions to validate the expected outcomes, which is a common pattern in unit testing. It uses the `assert` statement to check conditions, ensuring that the test fails if any of the conditions are not met. This straightforward approach allows for clear and immediate feedback on the correctness of the code being tested. Additionally, the test operates within the context of a Flask application, leveraging Flask's context management to ensure that `flask.g` behaves correctly during a request lifecycle."
    },
    {
      "name": "test_g_iteration_protocol",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1692,
      "end_line_number": 1697,
      "source_code": "def test_g_iteration_protocol(app_ctx):\n    flask.g.foo = 23\n    flask.g.bar = 42\n    assert \"foo\" in flask.g\n    assert \"foos\" not in flask.g\n    assert sorted(flask.g) == [\"bar\", \"foo\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app_ctx"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'foo' in flask.g",
        "assert 'foos' not in flask.g",
        "assert sorted(flask.g) == ['bar', 'foo']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_subdomain_basic_support",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1700,
      "end_line_number": 1717,
      "source_code": "def test_subdomain_basic_support():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain\"\n    client = app.test_client()\n\n    @app.route(\"/\")\n    def normal_index():\n        return \"normal index\"\n\n    @app.route(\"/\", subdomain=\"test\")\n    def test_index():\n        return \"test index\"\n\n    rv = client.get(\"/\", \"http://localhost.localdomain/\")\n    assert rv.data == b\"normal index\"\n\n    rv = client.get(\"/\", \"http://test.localhost.localdomain/\")\n    assert rv.data == b\"test index\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'normal index'",
        "assert rv.data == b'test index'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_subdomain_basic_support` function is designed to verify that a Flask application correctly handles requests to different subdomains, returning the appropriate responses based on the subdomain specified in the request.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a request is made to the root URL (\"/\") of the main domain, it returns the response from the `normal_index` function. Conversely, when a request is made to the same root URL but under a specific subdomain (\"test\"), it verifies that the response comes from the `test_index` function. This ensures that the application correctly distinguishes between requests to different subdomains.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes two route handlers defined in a Flask application:\n1. `normal_index`: Responds with \"normal index\" when accessed via the main domain.\n2. `test_index`: Responds with \"test index\" when accessed via the \"test\" subdomain.\n\nThe test uses Flask's test client to simulate HTTP GET requests to both the main domain and the subdomain, checking the response data to ensure it matches the expected output.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Test Client**: The use of `app.test_client()` allows for simulating requests to the Flask application without needing to run a server.\n- **Assertions**: The test employs assertions (`assert rv.data == b\"normal index\"` and `assert rv.data == b\"test index\"`) to validate that the responses are as expected, which is a common practice in unit testing to ensure correctness.\n- **Subdomain Handling**: The test specifically sets the `SERVER_NAME` configuration to enable subdomain matching, demonstrating how to test Flask's routing capabilities based on subdomains."
    },
    {
      "name": "test_subdomain_matching",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1720,
      "end_line_number": 1730,
      "source_code": "def test_subdomain_matching():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    client = app.test_client()\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain\"\n\n    @app.route(\"/\", subdomain=\"<user>\")\n    def index(user):\n        return f\"index for {user}\"\n\n    rv = client.get(\"/\", \"http://mitsuhiko.localhost.localdomain/\")\n    assert rv.data == b\"index for mitsuhiko\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'index for mitsuhiko'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_subdomain_matching` function is designed to verify that Flask's routing system correctly matches subdomains to specific routes when subdomain matching is enabled. It ensures that requests to a specific subdomain are routed to the appropriate view function.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a request is made to the subdomain `mitsuhiko.localhost.localdomain`, the application correctly identifies the subdomain and routes the request to the `index` function, which is expected to return a string formatted as \"index for mitsuhiko\". The test asserts that the response data matches this expected output.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a Flask application instance created with `subdomain_matching=True` and a route defined with a subdomain parameter (`@app.route(\"/\", subdomain=\"<user>\")`). The `client.get` method simulates an HTTP GET request to the specified subdomain. The application is configured with `SERVER_NAME` set to \"localhost.localdomain\", allowing it to recognize the subdomain in the request URL. The `index` function takes the subdomain part as a parameter and returns a formatted string.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Test Client**: The test utilizes Flask's built-in test client to simulate requests to the application, allowing for isolated testing of the routing behavior without needing a live server.\n- **Assertion**: The test employs an assertion (`assert rv.data == b\"index for mitsuhiko\"`) to verify that the response data matches the expected output, ensuring that the routing logic works as intended.\n- **Subdomain Handling**: The test specifically focuses on subdomain handling, which is a critical feature in web applications that require different behavior based on the subdomain of the request."
    },
    {
      "name": "test_subdomain_matching_with_ports",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1733,
      "end_line_number": 1743,
      "source_code": "def test_subdomain_matching_with_ports():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain:3000\"\n    client = app.test_client()\n\n    @app.route(\"/\", subdomain=\"<user>\")\n    def index(user):\n        return f\"index for {user}\"\n\n    rv = client.get(\"/\", \"http://mitsuhiko.localhost.localdomain:3000/\")\n    assert rv.data == b\"index for mitsuhiko\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'index for mitsuhiko'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_subdomain_matching_with_ports` test is to verify that the Flask application correctly matches subdomains when the server name includes a port. It ensures that the routing mechanism can handle subdomains properly and return the expected response based on the subdomain provided in the request.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a request is made to the root URL (\"/\") with a subdomain (in this case, \"mitsuhiko\"), the application correctly routes the request to the `index` function and returns the expected response string \"index for mitsuhiko\". It confirms that the subdomain matching feature works as intended when the server name includes a port.\n\n**Code Being Tested and How It Works**:  \nThe code being tested includes the Flask application setup with subdomain matching enabled. The `index` route is defined to accept a subdomain parameter (`<user>`). The test client makes a GET request to the root URL with a specific subdomain and port. The assertion checks that the response data matches the expected byte string. The relevant code is as follows:\n\n```python\n@app.route(\"/\", subdomain=\"<user>\")\ndef index(user):\n    return f\"index for {user}\"\n```\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of Flask's built-in testing capabilities, specifically the `test_client()` method, which allows for simulating requests to the application. It also utilizes assertions to validate the response data against expected values. The test is structured to isolate the functionality being tested, ensuring that the focus remains on the subdomain matching behavior without interference from other application components."
    },
    {
      "name": "test_subdomain_matching_other_name",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1747,
      "end_line_number": 1767,
      "source_code": "def test_subdomain_matching_other_name(matching):\n    app = flask.Flask(__name__, subdomain_matching=matching)\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain:3000\"\n    client = app.test_client()\n\n    @app.route(\"/\")\n    def index():\n        return \"\", 204\n\n    # suppress Werkzeug 0.15 warning about name mismatch\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\n            \"ignore\", \"Current server name\", UserWarning, \"flask.app\"\n        )\n        # ip address can't match name\n        rv = client.get(\"/\", \"http://127.0.0.1:3000/\")\n        assert rv.status_code == 404 if matching else 204\n\n    # allow all subdomains if matching is disabled\n    rv = client.get(\"/\", \"http://www.localhost.localdomain:3000/\")\n    assert rv.status_code == 404 if matching else 204",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('matching', (False, True))"
      ],
      "arguments": [
        "matching"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 404 if matching else 204",
        "assert rv.status_code == 404 if matching else 204"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_subdomain_matching_other_name` test is designed to verify the behavior of a Flask application when handling requests with different subdomain configurations. Specifically, it checks how the application responds to requests made to an IP address and a different subdomain when subdomain matching is enabled or disabled.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies that when subdomain matching is enabled (`matching=True`), requests to an IP address (e.g., `http://127.0.0.1:3000/`) should return a 404 status code, indicating that the request does not match any valid subdomain. Conversely, when subdomain matching is disabled (`matching=False`), the same request should return a 204 status code, indicating a successful request with no content. Additionally, it checks that requests to a different subdomain (e.g., `http://www.localhost.localdomain:3000/`) behave similarly based on the matching configuration.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Flask application with a specified `SERVER_NAME` and a route that returns a 204 status code. It uses Flask's test client to simulate HTTP requests. The `client.get` method is called with different host headers to test the application's response. The `subdomain_matching` configuration determines whether the application should enforce subdomain matching rules, affecting the expected status codes returned by the requests.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterized Testing**: The test uses `@pytest.mark.parametrize` to run the same test logic with different values for the `matching` parameter, allowing for efficient testing of multiple scenarios without duplicating code.\n- **Warning Suppression**: The test suppresses specific warnings from Werkzeug related to name mismatches, ensuring that the test output remains clean and focused on the assertions.\n- **Assertions**: The test employs assertions to validate the expected outcomes based on the configuration, ensuring that the application behaves correctly under different conditions."
    },
    {
      "name": "test_multi_route_rules",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1770,
      "end_line_number": 1779,
      "source_code": "def test_multi_route_rules(app, client):\n    @app.route(\"/\")\n    @app.route(\"/<test>/\")\n    def index(test=\"a\"):\n        return test\n\n    rv = client.open(\"/\")\n    assert rv.data == b\"a\"\n    rv = client.open(\"/b/\")\n    assert rv.data == b\"b\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'a'",
        "assert rv.data == b'b'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_multi_route_class_views",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1782,
      "end_line_number": 1795,
      "source_code": "def test_multi_route_class_views(app, client):\n    class View:\n        def __init__(self, app):\n            app.add_url_rule(\"/\", \"index\", self.index)\n            app.add_url_rule(\"/<test>/\", \"index\", self.index)\n\n        def index(self, test=\"a\"):\n            return test\n\n    _ = View(app)\n    rv = client.open(\"/\")\n    assert rv.data == b\"a\"\n    rv = client.open(\"/b/\")\n    assert rv.data == b\"b\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'a'",
        "assert rv.data == b'b'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_run_defaults",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1798,
      "end_line_number": 1807,
      "source_code": "def test_run_defaults(monkeypatch, app):\n    rv = {}\n\n    # Mocks werkzeug.serving.run_simple method\n    def run_simple_mock(*args, **kwargs):\n        rv[\"result\"] = \"running...\"\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n    app.run()\n    assert rv[\"result\"] == \"running...\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch",
        "app"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv['result'] == 'running...'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_run_server_port",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1810,
      "end_line_number": 1820,
      "source_code": "def test_run_server_port(monkeypatch, app):\n    rv = {}\n\n    # Mocks werkzeug.serving.run_simple method\n    def run_simple_mock(hostname, port, application, *args, **kwargs):\n        rv[\"result\"] = f\"running on {hostname}:{port} ...\"\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n    hostname, port = \"localhost\", 8000\n    app.run(hostname, port, debug=True)\n    assert rv[\"result\"] == f\"running on {hostname}:{port} ...\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch",
        "app"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv['result'] == f'running on {hostname}:{port} ...'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_run_from_config",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1835,
      "end_line_number": 1844,
      "source_code": "def test_run_from_config(\n    monkeypatch, host, port, server_name, expect_host, expect_port, app\n):\n    def run_simple_mock(hostname, port, *args, **kwargs):\n        assert hostname == expect_host\n        assert port == expect_port\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n    app.config[\"SERVER_NAME\"] = server_name\n    app.run(host, port)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('host,port,server_name,expect_host,expect_port', ((None, None, 'pocoo.org:8080', 'pocoo.org', 8080), ('localhost', None, 'pocoo.org:8080', 'localhost', 8080), (None, 80, 'pocoo.org:8080', 'pocoo.org', 80), ('localhost', 80, 'pocoo.org:8080', 'localhost', 80), ('localhost', 0, 'localhost:8080', 'localhost', 0), (None, None, 'localhost:8080', 'localhost', 8080), (None, None, 'localhost:0', 'localhost', 0)))"
      ],
      "arguments": [
        "monkeypatch",
        "host",
        "port",
        "server_name",
        "expect_host",
        "expect_port",
        "app"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert hostname == expect_host",
        "assert port == expect_port"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_max_cookie_size",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1847,
      "end_line_number": 1874,
      "source_code": "def test_max_cookie_size(app, client, recwarn):\n    app.config[\"MAX_COOKIE_SIZE\"] = 100\n\n    # outside app context, default to Werkzeug static value,\n    # which is also the default config\n    response = flask.Response()\n    default = flask.Flask.default_config[\"MAX_COOKIE_SIZE\"]\n    assert response.max_cookie_size == default\n\n    # inside app context, use app config\n    with app.app_context():\n        assert flask.Response().max_cookie_size == 100\n\n    @app.route(\"/\")\n    def index():\n        r = flask.Response(\"\", status=204)\n        r.set_cookie(\"foo\", \"bar\" * 100)\n        return r\n\n    client.get(\"/\")\n    assert len(recwarn) == 1\n    w = recwarn.pop()\n    assert \"cookie is too large\" in str(w.message)\n\n    app.config[\"MAX_COOKIE_SIZE\"] = 0\n\n    client.get(\"/\")\n    assert len(recwarn) == 0",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client",
        "recwarn"
      ],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.max_cookie_size == default",
        "assert len(recwarn) == 1",
        "assert 'cookie is too large' in str(w.message)",
        "assert len(recwarn) == 0",
        "assert flask.Response().max_cookie_size == 100"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_max_cookie_size` function is designed to verify the behavior of Flask's response object regarding the maximum size of cookies that can be set. It ensures that the application configuration for `MAX_COOKIE_SIZE` is respected and that appropriate warnings are raised when cookies exceed this limit.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main behaviors: \n1. It verifies that the default maximum cookie size is used when outside the application context and that the configured maximum cookie size is used when inside the application context.\n2. It confirms that a warning is raised when a cookie exceeds the maximum size limit, and that no warning is raised when the limit is set to zero.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `flask.Response` class, specifically its `max_cookie_size` property, which retrieves the maximum cookie size from the application's configuration. The test sets the `MAX_COOKIE_SIZE` to 100 and checks the response's `max_cookie_size` both inside and outside the application context. It also defines a route that attempts to set a cookie larger than the maximum size, triggering a warning that is captured and asserted.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The use of `with app.app_context()` allows the test to switch between application contexts, enabling the verification of configuration-dependent behavior.\n- **Warning Capture**: The `recwarn` fixture is utilized to capture warnings raised during the test, allowing for assertions on the presence and content of those warnings.\n- **Assertions**: The test employs assertions to validate expected outcomes, such as checking the length of warnings and the content of the response's `max_cookie_size`."
    },
    {
      "name": "test_app_freed_on_zero_refcount",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1878,
      "end_line_number": 1890,
      "source_code": "def test_app_freed_on_zero_refcount():\n    # A Flask instance should not create a reference cycle that prevents CPython\n    # from freeing it when all external references to it are released (see #3761).\n    gc.disable()\n    try:\n        app = flask.Flask(__name__)\n        assert app.view_functions[\"static\"]\n        weak = weakref.ref(app)\n        assert weak() is not None\n        del app\n        assert weak() is None\n    finally:\n        gc.enable()",
      "docstring": null,
      "decorators": [
        "require_cpython_gc"
      ],
      "arguments": [],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.view_functions['static']",
        "assert weak() is not None",
        "assert weak() is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_with_categories",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 599,
      "end_line_number": 607,
      "source_code": "def test_with_categories():\n        messages = flask.get_flashed_messages(with_categories=True)\n        assert len(messages) == 3\n        assert list(messages) == [\n            (\"message\", \"Hello World\"),\n            (\"error\", \"Hello World\"),\n            (\"warning\", Markup(\"<em>Testing</em>\")),\n        ]\n        return \"\"",
      "docstring": null,
      "decorators": [
        "app.route('/test_with_categories/')"
      ],
      "arguments": [],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(messages) == 3",
        "assert list(messages) == [('message', 'Hello World'), ('error', 'Hello World'), ('warning', Markup('<em>Testing</em>'))]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_filter",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 610,
      "end_line_number": 615,
      "source_code": "def test_filter():\n        messages = flask.get_flashed_messages(\n            category_filter=[\"message\"], with_categories=True\n        )\n        assert list(messages) == [(\"message\", \"Hello World\")]\n        return \"\"",
      "docstring": null,
      "decorators": [
        "app.route('/test_filter/')"
      ],
      "arguments": [],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert list(messages) == [('message', 'Hello World')]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_filters",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 618,
      "end_line_number": 626,
      "source_code": "def test_filters():\n        messages = flask.get_flashed_messages(\n            category_filter=[\"message\", \"warning\"], with_categories=True\n        )\n        assert list(messages) == [\n            (\"message\", \"Hello World\"),\n            (\"warning\", Markup(\"<em>Testing</em>\")),\n        ]\n        return \"\"",
      "docstring": null,
      "decorators": [
        "app.route('/test_filters/')"
      ],
      "arguments": [],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert list(messages) == [('message', 'Hello World'), ('warning', Markup('<em>Testing</em>'))]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_filters2",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 629,
      "end_line_number": 634,
      "source_code": "def test_filters2():\n        messages = flask.get_flashed_messages(category_filter=[\"message\", \"warning\"])\n        assert len(messages) == 2\n        assert messages[0] == \"Hello World\"\n        assert messages[1] == Markup(\"<em>Testing</em>\")\n        return \"\"",
      "docstring": null,
      "decorators": [
        "app.route('/test_filters_without_returning_categories/')"
      ],
      "arguments": [],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(messages) == 2",
        "assert messages[0] == 'Hello World'",
        "assert messages[1] == Markup('<em>Testing</em>')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_index",
      "module": "test_basic",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_basic.py",
      "line_number": 1710,
      "end_line_number": 1711,
      "source_code": "def test_index():\n        return \"test index\"",
      "docstring": null,
      "decorators": [
        "app.route('/', subdomain='test')"
      ],
      "arguments": [],
      "imports": [
        "gc",
        "re",
        "uuid",
        "warnings",
        "weakref",
        "datetime.datetime",
        "datetime.timezone",
        "platform.python_implementation",
        "pytest",
        "werkzeug.serving",
        "markupsafe.Markup",
        "werkzeug.exceptions.BadRequest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.NotFound",
        "werkzeug.http.parse_date",
        "werkzeug.routing.BuildError",
        "werkzeug.routing.RequestRedirect",
        "flask",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "werkzeug.routing.Rule",
        "werkzeug.routing.Submount",
        "flask.debughelpers.DebugFilesKeyError",
        "dataclasses.make_dataclass",
        "pathlib.Path"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_blueprint_specific_error_handling",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 8,
      "end_line_number": 43,
      "source_code": "def test_blueprint_specific_error_handling(app, client):\n    frontend = flask.Blueprint(\"frontend\", __name__)\n    backend = flask.Blueprint(\"backend\", __name__)\n    sideend = flask.Blueprint(\"sideend\", __name__)\n\n    @frontend.errorhandler(403)\n    def frontend_forbidden(e):\n        return \"frontend says no\", 403\n\n    @frontend.route(\"/frontend-no\")\n    def frontend_no():\n        flask.abort(403)\n\n    @backend.errorhandler(403)\n    def backend_forbidden(e):\n        return \"backend says no\", 403\n\n    @backend.route(\"/backend-no\")\n    def backend_no():\n        flask.abort(403)\n\n    @sideend.route(\"/what-is-a-sideend\")\n    def sideend_no():\n        flask.abort(403)\n\n    app.register_blueprint(frontend)\n    app.register_blueprint(backend)\n    app.register_blueprint(sideend)\n\n    @app.errorhandler(403)\n    def app_forbidden(e):\n        return \"application itself says no\", 403\n\n    assert client.get(\"/frontend-no\").data == b\"frontend says no\"\n    assert client.get(\"/backend-no\").data == b\"backend says no\"\n    assert client.get(\"/what-is-a-sideend\").data == b\"application itself says no\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/frontend-no').data == b'frontend says no'",
        "assert client.get('/backend-no').data == b'backend says no'",
        "assert client.get('/what-is-a-sideend').data == b'application itself says no'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_blueprint_specific_error_handling` test is to verify that specific error handling mechanisms for different Flask blueprints are functioning correctly. It ensures that when a 403 Forbidden error is triggered within the routes of the blueprints, the appropriate error handler returns the expected response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a client makes GET requests to certain routes that intentionally trigger a 403 error, the responses returned are consistent with the defined error handlers for each blueprint. Specifically, it verifies that the `frontend` blueprint returns \"frontend says no\", the `backend` blueprint returns \"backend says no\", and the `sideend` blueprint falls back to the application-level error handler, returning \"application itself says no\".\n\n**Code Being Tested and How It Works**:  \nThe test sets up three Flask blueprints: `frontend`, `backend`, and `sideend`. Each blueprint has a route that raises a 403 error using `flask.abort(403)`. The `frontend` and `backend` blueprints have their own error handlers for 403 errors, while the `sideend` blueprint does not, thus relying on the application-level error handler. The test then registers these blueprints with the main Flask application and makes GET requests to the defined routes, asserting that the responses match the expected output.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of Flask's blueprint feature to modularize the application and its error handling. It also utilizes assertions to validate the responses from the client, ensuring that the correct error handling logic is executed. The test is structured to be clear and straightforward, focusing on specific routes and their expected behaviors, which is a common pattern in unit testing to isolate and verify functionality."
    },
    {
      "name": "test_blueprint_specific_user_error_handling",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 46,
      "end_line_number": 77,
      "source_code": "def test_blueprint_specific_user_error_handling(app, client):\n    class MyDecoratorException(Exception):\n        pass\n\n    class MyFunctionException(Exception):\n        pass\n\n    blue = flask.Blueprint(\"blue\", __name__)\n\n    @blue.errorhandler(MyDecoratorException)\n    def my_decorator_exception_handler(e):\n        assert isinstance(e, MyDecoratorException)\n        return \"boom\"\n\n    def my_function_exception_handler(e):\n        assert isinstance(e, MyFunctionException)\n        return \"bam\"\n\n    blue.register_error_handler(MyFunctionException, my_function_exception_handler)\n\n    @blue.route(\"/decorator\")\n    def blue_deco_test():\n        raise MyDecoratorException()\n\n    @blue.route(\"/function\")\n    def blue_func_test():\n        raise MyFunctionException()\n\n    app.register_blueprint(blue)\n\n    assert client.get(\"/decorator\").data == b\"boom\"\n    assert client.get(\"/function\").data == b\"bam\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/decorator').data == b'boom'",
        "assert client.get('/function').data == b'bam'",
        "assert isinstance(e, MyDecoratorException)",
        "assert isinstance(e, MyFunctionException)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_blueprint_specific_user_error_handling` test is to verify that custom error handling mechanisms in a Flask blueprint correctly respond to specific exceptions raised during request processing. It ensures that the application can gracefully handle errors and return appropriate responses.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a `MyDecoratorException` is raised in the `/decorator` route, the corresponding error handler returns the string \"boom\". Similarly, it verifies that when a `MyFunctionException` is raised in the `/function` route, the error handler returns \"bam\". This confirms that the error handling logic is functioning as intended for both types of exceptions.\n\n**Code Being Tested and How It Works**:  \nThe test defines two custom exception classes, `MyDecoratorException` and `MyFunctionException`. It creates a Flask blueprint named `blue` and registers error handlers for these exceptions. The `my_decorator_exception_handler` is specifically tied to `MyDecoratorException`, while `my_function_exception_handler` is registered for `MyFunctionException`. The test then defines two routes: `/decorator`, which raises `MyDecoratorException`, and `/function`, which raises `MyFunctionException`. The test uses a Flask test client to simulate GET requests to these routes and asserts that the responses match the expected outputs.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n1. **Custom Exception Handling**: It demonstrates how to create and handle custom exceptions within a Flask application, showcasing the flexibility of Flask's error handling.\n2. **Blueprints**: The use of Flask blueprints allows for modular organization of routes and error handlers, which is a common practice in larger applications.\n3. **Assertions**: The test uses assertions to validate the output of the error handlers, ensuring that the application behaves correctly under error conditions.\n4. **Test Client**: The Flask test client is utilized to simulate HTTP requests, allowing for integration-style testing of the application's routes and error handling without needing to run a live server."
    },
    {
      "name": "test_blueprint_app_error_handling",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 80,
      "end_line_number": 101,
      "source_code": "def test_blueprint_app_error_handling(app, client):\n    errors = flask.Blueprint(\"errors\", __name__)\n\n    @errors.app_errorhandler(403)\n    def forbidden_handler(e):\n        return \"you shall not pass\", 403\n\n    @app.route(\"/forbidden\")\n    def app_forbidden():\n        flask.abort(403)\n\n    forbidden_bp = flask.Blueprint(\"forbidden_bp\", __name__)\n\n    @forbidden_bp.route(\"/nope\")\n    def bp_forbidden():\n        flask.abort(403)\n\n    app.register_blueprint(errors)\n    app.register_blueprint(forbidden_bp)\n\n    assert client.get(\"/forbidden\").data == b\"you shall not pass\"\n    assert client.get(\"/nope\").data == b\"you shall not pass\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/forbidden').data == b'you shall not pass'",
        "assert client.get('/nope').data == b'you shall not pass'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_blueprint_app_error_handling` test is to verify that the Flask application correctly handles HTTP 403 Forbidden errors when they are raised from both the application routes and the routes defined within registered blueprints.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a 403 error is triggered, the appropriate error handler returns the expected response message (\"you shall not pass\") for both the application route (`/forbidden`) and the blueprint route (`/nope`). It ensures that the error handling mechanism is functioning as intended across different contexts within the Flask application.\n\n**Code Being Tested and How It Works**:  \nThe code being tested includes:\n1. A Flask blueprint named `errors` that defines an error handler for 403 errors, returning a specific message.\n2. An application route (`/forbidden`) that triggers a 403 error using `flask.abort(403)`.\n3. A second blueprint (`forbidden_bp`) with a route (`/nope`) that also triggers a 403 error.\n\nThe test registers both blueprints with the main application and then makes GET requests to the defined routes to assert that the responses match the expected output.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprints**: The test utilizes Flask's blueprint feature to modularize error handling, demonstrating how different parts of an application can have their own error handlers.\n- **Error Handling**: It tests the application\u2019s ability to handle specific HTTP exceptions, ensuring that the correct response is returned based on the context of the request.\n- **Assertions**: The test employs assertions to validate the response data from the client requests, ensuring that the application behaves as expected when encountering errors."
    },
    {
      "name": "test_blueprint_prefix_slash",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 120,
      "end_line_number": 128,
      "source_code": "def test_blueprint_prefix_slash(app, client, prefix, rule, url):\n    bp = flask.Blueprint(\"test\", __name__, url_prefix=prefix)\n\n    @bp.route(rule)\n    def index():\n        return \"\", 204\n\n    app.register_blueprint(bp)\n    assert client.get(url).status_code == 204",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize(('prefix', 'rule', 'url'), (('', '/', '/'), ('/', '', '/'), ('/', '/', '/'), ('/foo', '', '/foo'), ('/foo/', '', '/foo/'), ('', '/bar', '/bar'), ('/foo/', '/bar', '/foo/bar'), ('/foo/', 'bar', '/foo/bar'), ('/foo', '/bar', '/foo/bar'), ('/foo/', '//bar', '/foo/bar'), ('/foo//', '/bar', '/foo/bar')))"
      ],
      "arguments": [
        "app",
        "client",
        "prefix",
        "rule",
        "url"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get(url).status_code == 204"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_blueprint_prefix_slash` function is designed to verify that a Flask blueprint correctly handles URL routing with a specified prefix. It ensures that when a client makes a GET request to a URL defined by the blueprint, the expected HTTP status code is returned.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the route defined in the blueprint responds with a 204 No Content status code when accessed via the constructed URL. It validates that the URL prefix and route are correctly applied and that the application behaves as expected when the route is hit.\n\n**Code Being Tested and How It Works**:  \nThe test creates a Flask blueprint with a specified URL prefix and a route that returns a 204 status code. The blueprint is registered with the main application instance. The test then uses the `client` to simulate a GET request to the URL constructed from the prefix and rule. The assertion checks that the response status code is 204, confirming that the route is functioning correctly.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprint Testing**: The test leverages Flask's blueprint feature to modularize routes, allowing for organized and reusable code.\n- **Client Simulation**: It uses Flask's test client to simulate HTTP requests, enabling the testing of route behavior without needing to run a live server.\n- **Parameterized Testing**: The test function accepts parameters (`prefix`, `rule`, `url`), suggesting that it may be part of a parameterized test suite, allowing for multiple scenarios to be tested with different inputs. This enhances test coverage and robustness."
    },
    {
      "name": "test_blueprint_url_defaults",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 131,
      "end_line_number": 148,
      "source_code": "def test_blueprint_url_defaults(app, client):\n    bp = flask.Blueprint(\"test\", __name__)\n\n    @bp.route(\"/foo\", defaults={\"baz\": 42})\n    def foo(bar, baz):\n        return f\"{bar}/{baz:d}\"\n\n    @bp.route(\"/bar\")\n    def bar(bar):\n        return str(bar)\n\n    app.register_blueprint(bp, url_prefix=\"/1\", url_defaults={\"bar\": 23})\n    app.register_blueprint(bp, name=\"test2\", url_prefix=\"/2\", url_defaults={\"bar\": 19})\n\n    assert client.get(\"/1/foo\").data == b\"23/42\"\n    assert client.get(\"/2/foo\").data == b\"19/42\"\n    assert client.get(\"/1/bar\").data == b\"23\"\n    assert client.get(\"/2/bar\").data == b\"19\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/1/foo').data == b'23/42'",
        "assert client.get('/2/foo').data == b'19/42'",
        "assert client.get('/1/bar').data == b'23'",
        "assert client.get('/2/bar').data == b'19'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_blueprint_url_defaults` function is designed to verify that Flask blueprints correctly apply URL defaults when routes are accessed. It ensures that the default values specified in the blueprint registration are correctly utilized in the route handlers.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a client makes GET requests to specific routes defined in the blueprint, the responses include the expected values derived from both the URL defaults and the route parameters. Specifically, it verifies that the `baz` default is set to 42 for the `/foo` route and that the `bar` default is set to 23 or 19 depending on the URL prefix.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves a Flask application with a blueprint that defines two routes: `/foo` and `/bar`. The `/foo` route has a default parameter `baz` set to 42, while the `bar` parameter is set through the blueprint registration with different URL prefixes (`/1` and `/2`). The test uses the Flask test client to simulate GET requests to these routes and checks the returned data against expected values, ensuring that the URL defaults are applied correctly.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of Flask's testing capabilities, specifically the `client` fixture to simulate HTTP requests. It also utilizes assertions to validate the responses, ensuring that the expected output matches the actual output. The use of blueprints to encapsulate route definitions and their associated defaults is a key pattern, promoting modularity and reusability in the application structure."
    },
    {
      "name": "test_blueprint_url_processors",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 151,
      "end_line_number": 173,
      "source_code": "def test_blueprint_url_processors(app, client):\n    bp = flask.Blueprint(\"frontend\", __name__, url_prefix=\"/<lang_code>\")\n\n    @bp.url_defaults\n    def add_language_code(endpoint, values):\n        values.setdefault(\"lang_code\", flask.g.lang_code)\n\n    @bp.url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop(\"lang_code\")\n\n    @bp.route(\"/\")\n    def index():\n        return flask.url_for(\".about\")\n\n    @bp.route(\"/about\")\n    def about():\n        return flask.url_for(\".index\")\n\n    app.register_blueprint(bp)\n\n    assert client.get(\"/de/\").data == b\"/de/about\"\n    assert client.get(\"/de/about\").data == b\"/de/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/de/').data == b'/de/about'",
        "assert client.get('/de/about').data == b'/de/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "values.setdefault",
          "body": "@app.route('/setdefault')\ndef setdefault():\n    return flask.session.setdefault('test', 'default')"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_blueprint_url_processors` test is to verify the correct functioning of URL processors and defaults in a Flask blueprint. It ensures that the language code extracted from the URL is correctly set in the Flask global context (`flask.g`) and that the URL generation for routes behaves as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically verifies that:\n1. The `url_value_preprocessor` correctly extracts the `lang_code` from the URL and sets it in `flask.g`.\n2. The `url_defaults` function sets the `lang_code` in the URL generation context.\n3. The routes defined in the blueprint return the expected URLs when accessed.\n\n**Code Being Tested and How It Works**:  \nThe test defines a Flask blueprint with two routes: `index` and `about`. The `url_value_preprocessor` function `pull_lang_code` extracts the `lang_code` from the URL and assigns it to `flask.g.lang_code`. The `url_defaults` function `add_language_code` sets the `lang_code` in the URL generation context. The routes use `flask.url_for` to generate URLs based on the current language code. The test then makes requests to the routes with a specific language code (`/de/` and `/de/about`) and asserts that the returned data matches the expected URLs.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprint Testing**: The test utilizes Flask's blueprint feature to encapsulate related routes and their behavior, allowing for modular testing.\n- **URL Processors**: It employs URL value preprocessors and defaults to manipulate request data and URL generation dynamically.\n- **Assertions**: The test uses assertions to validate the output of the client requests against expected byte strings, ensuring that the application behaves correctly under the defined conditions."
    },
    {
      "name": "test_templates_and_static",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 176,
      "end_line_number": 220,
      "source_code": "def test_templates_and_static(test_apps):\n    from blueprintapp import app\n\n    client = app.test_client()\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"Hello from the Frontend\"\n    rv = client.get(\"/admin/\")\n    assert rv.data == b\"Hello from the Admin\"\n    rv = client.get(\"/admin/index2\")\n    assert rv.data == b\"Hello from the Admin\"\n    rv = client.get(\"/admin/static/test.txt\")\n    assert rv.data.strip() == b\"Admin File\"\n    rv.close()\n    rv = client.get(\"/admin/static/css/test.css\")\n    assert rv.data.strip() == b\"/* nested file */\"\n    rv.close()\n\n    # try/finally, in case other tests use this app for Blueprint tests.\n    max_age_default = app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n    try:\n        expected_max_age = 3600\n        if app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] == expected_max_age:\n            expected_max_age = 7200\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = expected_max_age\n        rv = client.get(\"/admin/static/css/test.css\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == expected_max_age\n        rv.close()\n    finally:\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = max_age_default\n\n    with app.test_request_context():\n        assert (\n            flask.url_for(\"admin.static\", filename=\"test.txt\")\n            == \"/admin/static/test.txt\"\n        )\n\n    with app.test_request_context():\n        with pytest.raises(TemplateNotFound) as e:\n            flask.render_template(\"missing.html\")\n        assert e.value.name == \"missing.html\"\n\n    with flask.Flask(__name__).test_request_context():\n        assert flask.render_template(\"nested/nested.txt\") == \"I'm nested\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_apps"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'Hello from the Frontend'",
        "assert rv.data == b'Hello from the Admin'",
        "assert rv.data == b'Hello from the Admin'",
        "assert rv.data.strip() == b'Admin File'",
        "assert rv.data.strip() == b'/* nested file */'",
        "assert cc.max_age == expected_max_age",
        "assert flask.url_for('admin.static', filename='test.txt') == '/admin/static/test.txt'",
        "assert e.value.name == 'missing.html'",
        "assert flask.render_template('nested/nested.txt') == \"I'm nested\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_templates_and_static` function is designed to verify the correct rendering of templates and the proper serving of static files in a Flask application. It ensures that the application responds with the expected content for various routes, checks cache control headers, and validates template rendering behavior.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks multiple aspects:\n1. The root route (`/`) and admin routes (`/admin/`, `/admin/index2`) return the correct responses.\n2. Static files are served correctly, including text and CSS files.\n3. The cache control settings for static files are correctly applied.\n4. The URL generation for static files is accurate.\n5. The application raises a `TemplateNotFound` exception when attempting to render a non-existent template.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the Flask application defined in `blueprintapp`. It uses the `test_client()` method to simulate HTTP requests to various endpoints. The assertions check that the data returned from these requests matches expected byte strings. The test also manipulates the application's configuration to test the behavior of cache control settings and verifies the correct handling of template rendering.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The test uses `with app.test_request_context()` to create a request context for testing URL generation and template rendering, ensuring that the application behaves as it would in a real request.\n- **Try/Finally Block**: This pattern is used to ensure that the original configuration for `SEND_FILE_MAX_AGE_DEFAULT` is restored after the test, maintaining the integrity of the application state for subsequent tests.\n- **Exception Testing**: The test uses `pytest.raises` to assert that a specific exception is raised when attempting to render a missing template, demonstrating the handling of error conditions in the application."
    },
    {
      "name": "test_default_static_max_age",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 223,
      "end_line_number": 244,
      "source_code": "def test_default_static_max_age(app):\n    class MyBlueprint(flask.Blueprint):\n        def get_send_file_max_age(self, filename):\n            return 100\n\n    blueprint = MyBlueprint(\"blueprint\", __name__, static_folder=\"static\")\n    app.register_blueprint(blueprint)\n\n    # try/finally, in case other tests use this app for Blueprint tests.\n    max_age_default = app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n    try:\n        with app.test_request_context():\n            unexpected_max_age = 3600\n            if app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] == unexpected_max_age:\n                unexpected_max_age = 7200\n            app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = unexpected_max_age\n            rv = blueprint.send_static_file(\"index.html\")\n            cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n            assert cc.max_age == 100\n            rv.close()\n    finally:\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = max_age_default",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert cc.max_age == 100"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "rv.close",
          "body": "def close(self):\n    called.append(42)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_default_static_max_age` test is to verify that the `send_static_file` method of a Flask blueprint correctly sets the `Cache-Control` header's `max-age` directive when a custom maximum age is defined in the blueprint.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `max_age` returned by the `get_send_file_max_age` method of the custom blueprint is honored when serving static files. In this case, it ensures that the `max_age` is set to 100 seconds, overriding any default configuration.\n\n**Code Being Tested and How It Works**:  \nThe test creates a subclass of `flask.Blueprint` called `MyBlueprint`, which overrides the `get_send_file_max_age` method to return a fixed value of 100. The blueprint is registered with the Flask application, and the test simulates a request context to call `send_static_file` for a file named \"index.html\". The response's `Cache-Control` header is parsed to check that the `max_age` is indeed set to 100 seconds. The test also temporarily modifies the application's configuration for `SEND_FILE_MAX_AGE_DEFAULT` to ensure it does not interfere with the test's outcome.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The test uses a `try/finally` block to ensure that the original configuration is restored after the test runs, maintaining the integrity of the application state for subsequent tests.\n- **Request Context Simulation**: The use of `app.test_request_context()` allows the test to simulate a request environment, which is essential for testing Flask's request-dependent features.\n- **Assertions**: The test employs assertions to validate that the expected behavior (i.e., `max_age` being 100) is met, which is a fundamental aspect of unit testing to ensure correctness."
    },
    {
      "name": "test_templates_list",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 247,
      "end_line_number": 251,
      "source_code": "def test_templates_list(test_apps):\n    from blueprintapp import app\n\n    templates = sorted(app.jinja_env.list_templates())\n    assert templates == [\"admin/index.html\", \"frontend/index.html\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_apps"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert templates == ['admin/index.html', 'frontend/index.html']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_dotted_name_not_allowed",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 254,
      "end_line_number": 256,
      "source_code": "def test_dotted_name_not_allowed(app, client):\n    with pytest.raises(ValueError):\n        flask.Blueprint(\"app.ui\", __name__)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_empty_name_not_allowed",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 259,
      "end_line_number": 261,
      "source_code": "def test_empty_name_not_allowed(app, client):\n    with pytest.raises(ValueError):\n        flask.Blueprint(\"\", __name__)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_dotted_names_from_app",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 264,
      "end_line_number": 278,
      "source_code": "def test_dotted_names_from_app(app, client):\n    test = flask.Blueprint(\"test\", __name__)\n\n    @app.route(\"/\")\n    def app_index():\n        return flask.url_for(\"test.index\")\n\n    @test.route(\"/test/\")\n    def index():\n        return flask.url_for(\"app_index\")\n\n    app.register_blueprint(test)\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"/test/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'/test/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_dotted_names_from_app` test verifies that Flask's routing and URL generation work correctly when using blueprints. It ensures that the application can correctly resolve and return URLs defined in both the main application and the blueprint.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a request is made to the root URL (\"/\") of the main application, it correctly redirects to the URL defined in the blueprint (\"/test/\"). The expected behavior is that the response data should match the URL generated by the blueprint's route.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Flask application with a blueprint named \"test\". It defines a route in the main application that returns the URL for the blueprint's index route. The blueprint itself has a route that returns the URL for the main application's index route. The test then makes a GET request to the root URL and asserts that the response data is the expected URL (b\"/test/\"). This demonstrates the interaction between the main app and the blueprint.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprint Registration**: The test showcases the use of Flask blueprints, which allow for modular application design by grouping routes and handlers.\n- **Client Simulation**: It uses Flask's test client to simulate HTTP requests, allowing for easy testing of route responses without needing to run a live server.\n- **Assertions**: The test employs assertions to validate that the actual output matches the expected output, ensuring that the routing logic is functioning as intended."
    },
    {
      "name": "test_empty_url_defaults",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 281,
      "end_line_number": 292,
      "source_code": "def test_empty_url_defaults(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.route(\"/\", defaults={\"page\": 1})\n    @bp.route(\"/page/<int:page>\")\n    def something(page):\n        return str(page)\n\n    app.register_blueprint(bp)\n\n    assert client.get(\"/\").data == b\"1\"\n    assert client.get(\"/page/2\").data == b\"2\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/').data == b'1'",
        "assert client.get('/page/2').data == b'2'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_empty_url_defaults` function is designed to verify the behavior of Flask route handling, specifically the use of default URL parameters in a blueprint. It ensures that when a URL is accessed without a specified parameter, the default value is correctly applied.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when the root URL (\"/\") is accessed, the default value for the `page` parameter is used (which is set to 1). It also verifies that accessing the URL \"/page/2\" correctly returns the value 2, demonstrating that the routing and parameter parsing work as intended.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves a Flask blueprint that defines two routes: one for the root URL (\"/\") with a default parameter `page` set to 1, and another for \"/page/<int:page>\" that captures an integer parameter. The `something` function returns the value of `page` as a string. The test uses the Flask test client to simulate HTTP GET requests to these routes and checks the returned data against expected values.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of Flask's testing capabilities, specifically the `client` fixture to simulate requests. It also utilizes assertions to validate the responses, ensuring that the application behaves as expected under different URL conditions. The use of blueprints is a notable pattern, allowing for modular route definitions and better organization of the application structure."
    },
    {
      "name": "test_route_decorator_custom_endpoint",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 295,
      "end_line_number": 324,
      "source_code": "def test_route_decorator_custom_endpoint(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.route(\"/foo\")\n    def foo():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar\", endpoint=\"bar\")\n    def foo_bar():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar/123\", endpoint=\"123\")\n    def foo_bar_foo():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar/foo\")\n    def bar_foo():\n        return flask.request.endpoint\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.request.endpoint\n\n    assert client.get(\"/\").data == b\"index\"\n    assert client.get(\"/py/foo\").data == b\"bp.foo\"\n    assert client.get(\"/py/bar\").data == b\"bp.bar\"\n    assert client.get(\"/py/bar/123\").data == b\"bp.123\"\n    assert client.get(\"/py/bar/foo\").data == b\"bp.bar_foo\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/').data == b'index'",
        "assert client.get('/py/foo').data == b'bp.foo'",
        "assert client.get('/py/bar').data == b'bp.bar'",
        "assert client.get('/py/bar/123').data == b'bp.123'",
        "assert client.get('/py/bar/foo').data == b'bp.bar_foo'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_route_decorator_custom_endpoint` test is to verify that Flask's routing system correctly handles custom endpoints defined in a blueprint. It ensures that the endpoints return the expected values when accessed via HTTP requests.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the Flask application correctly resolves and returns the endpoint names for various routes defined in the blueprint. It verifies that the routes return the correct endpoint identifiers when accessed, confirming that the routing mechanism is functioning as intended.\n\n**Code Being Tested and How It Works**:  \nThe test defines a Flask blueprint with several routes (`/foo`, `/bar`, `/bar/123`, and `/bar/foo`). Each route returns the value of `flask.request.endpoint`, which is the name of the endpoint associated with that route. The blueprint is registered with a URL prefix (`/py`), and an additional route (`/`) is defined directly on the app. The test then uses the `client` to send GET requests to these routes and asserts that the returned data matches the expected endpoint names (e.g., `b\"bp.foo\"` for `/py/foo`).\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of Flask's test client to simulate HTTP requests, allowing for integration-style testing of the routing behavior. It also utilizes assertions to validate the responses against expected values, ensuring that the application behaves correctly under the defined routes. The use of blueprints to organize routes is a common pattern in Flask applications, promoting modularity and reusability of code."
    },
    {
      "name": "test_route_decorator_custom_endpoint_with_dots",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 327,
      "end_line_number": 342,
      "source_code": "def test_route_decorator_custom_endpoint_with_dots(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    with pytest.raises(ValueError):\n        bp.route(\"/\", endpoint=\"a.b\")(lambda: \"\")\n\n    with pytest.raises(ValueError):\n        bp.add_url_rule(\"/\", endpoint=\"a.b\")\n\n    def view():\n        return \"\"\n\n    view.__name__ = \"a.b\"\n\n    with pytest.raises(ValueError):\n        bp.add_url_rule(\"/\", view_func=view)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_endpoint_decorator",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 345,
      "end_line_number": 359,
      "source_code": "def test_endpoint_decorator(app, client):\n    from werkzeug.routing import Rule\n\n    app.url_map.add(Rule(\"/foo\", endpoint=\"bar\"))\n\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.endpoint(\"bar\")\n    def foobar():\n        return flask.request.endpoint\n\n    app.register_blueprint(bp, url_prefix=\"/bp_prefix\")\n\n    assert client.get(\"/foo\").data == b\"bar\"\n    assert client.get(\"/bp_prefix/bar\").status_code == 404",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/foo').data == b'bar'",
        "assert client.get('/bp_prefix/bar').status_code == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_map.add",
          "body": "def add(self, app):\n    self.count += 1"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_endpoint_decorator` function is designed to verify the behavior of Flask's routing and endpoint registration mechanisms, specifically how endpoints are defined and accessed through blueprints.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the application correctly routes requests to the defined endpoints. It ensures that the endpoint registered with the URL `/foo` returns the expected response and that accessing the same endpoint through a blueprint with a URL prefix results in a 404 error, confirming that the routing is isolated to the blueprint.\n\n**Code Being Tested and How It Works**:  \nThe test first adds a routing rule for the endpoint `bar` at the path `/foo`. It then creates a Flask blueprint and defines a function `foobar` that returns the name of the endpoint. The blueprint is registered with a URL prefix `/bp_prefix`. The assertions check:\n1. The response from a GET request to `/foo` should return the byte string `b\"bar\"`, indicating that the endpoint is correctly mapped.\n2. A GET request to `/bp_prefix/bar` should return a 404 status code, confirming that the endpoint is not accessible under the blueprint's prefix.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprints**: The test utilizes Flask's blueprint feature to modularize the application, allowing for organized routing and endpoint management.\n- **Assertions**: It employs assertions to validate the expected outcomes of HTTP requests, ensuring that the application behaves as intended.\n- **Isolation of Routes**: The test demonstrates how routes can be isolated within blueprints, which is a common practice in Flask applications to avoid route conflicts and maintain clean code structure."
    },
    {
      "name": "test_template_filter",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 362,
      "end_line_number": 372,
      "source_code": "def test_template_filter(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter()\n    def my_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'my_reverse' in app.jinja_env.filters.keys()",
        "assert app.jinja_env.filters['my_reverse'] == my_reverse",
        "assert app.jinja_env.filters['my_reverse']('abcd') == 'dcba'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_add_template_filter",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 375,
      "end_line_number": 385,
      "source_code": "def test_add_template_filter(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def my_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(my_reverse)\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'my_reverse' in app.jinja_env.filters.keys()",
        "assert app.jinja_env.filters['my_reverse'] == my_reverse",
        "assert app.jinja_env.filters['my_reverse']('abcd') == 'dcba'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_template_filter_with_name",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 388,
      "end_line_number": 398,
      "source_code": "def test_template_filter_with_name(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter(\"strrev\")\n    def my_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'strrev' in app.jinja_env.filters.keys()",
        "assert app.jinja_env.filters['strrev'] == my_reverse",
        "assert app.jinja_env.filters['strrev']('abcd') == 'dcba'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_add_template_filter_with_name",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 401,
      "end_line_number": 411,
      "source_code": "def test_add_template_filter_with_name(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def my_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(my_reverse, \"strrev\")\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'strrev' in app.jinja_env.filters.keys()",
        "assert app.jinja_env.filters['strrev'] == my_reverse",
        "assert app.jinja_env.filters['strrev']('abcd') == 'dcba'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_template_filter_with_template",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 414,
      "end_line_number": 428,
      "source_code": "def test_template_filter_with_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'dcba'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_template_filter_with_template` test is to verify that a custom Jinja2 template filter, `super_reverse`, correctly reverses a string when applied in a Flask template. This ensures that the template filter is properly registered and functional within the context of a Flask application.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when the string \"abcd\" is passed to the `super_reverse` filter in the `template_filter.html` template, the output is \"dcba\". This confirms that the filter processes the input string as expected and that the template rendering mechanism correctly utilizes the filter.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the registration of a Flask blueprint and the definition of a custom template filter. The `super_reverse` function is defined to reverse a string. The blueprint is registered with the Flask app, and a route is created that renders a template (`template_filter.html`) with the value \"abcd\". The test then simulates a GET request to the root URL (\"/\") using the `client.get` method, and it asserts that the response data matches the expected reversed string.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Blueprints**: It demonstrates the use of Flask blueprints to organize code and register template filters, which is a common practice in Flask applications.\n- **Client Simulation**: The use of `client.get` simulates a real HTTP request to the application, allowing for integration testing of the route and template rendering.\n- **Assertions**: The test uses assertions to validate the output, ensuring that the expected behavior matches the actual behavior of the application.\n- **Template Rendering**: It highlights the interaction between Flask's routing, template rendering, and custom filters, showcasing how these components work together in a web application."
    },
    {
      "name": "test_template_filter_after_route_with_template",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 431,
      "end_line_number": 444,
      "source_code": "def test_template_filter_after_route_with_template(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'dcba'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_template_filter_after_route_with_template` is designed to verify that a custom Jinja template filter, `super_reverse`, can be successfully applied to a rendered template after the route has been defined. It ensures that the filter correctly processes the input string and returns the expected output.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the string \"abcd\" is reversed to \"dcba\" when passed through the `super_reverse` filter in the context of rendering the `template_filter.html` template. It confirms that the filter is accessible and functional after being registered with the Flask application.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a Flask route defined at the root URL (\"/\") that renders a template called `template_filter.html`, passing the string \"abcd\" as a variable named `value`. The `super_reverse` filter is defined within a Flask blueprint and registered to the application. When the test makes a GET request to the root URL using the `client`, it checks that the response data matches the expected byte string `b\"dcba\"`, indicating that the filter was applied correctly during template rendering.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprints**: The test utilizes Flask blueprints to encapsulate the filter definition, demonstrating modular design and separation of concerns.\n- **Client Testing**: It employs Flask's test client to simulate HTTP requests and validate responses, which is a common practice in testing web applications.\n- **Assertions**: The test uses assertions to verify that the output matches the expected result, ensuring that the functionality behaves as intended.\n- **Template Rendering**: The test indirectly verifies the integration of template filters with Flask's rendering system, showcasing how custom filters can be applied in templates."
    },
    {
      "name": "test_add_template_filter_with_template",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 447,
      "end_line_number": 461,
      "source_code": "def test_add_template_filter_with_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def super_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(super_reverse)\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'dcba'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_add_template_filter_with_template` test is to verify that a custom template filter can be successfully added to a Flask application via a blueprint and that it functions correctly when rendering a template.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `super_reverse` filter, which reverses a string, is correctly applied to the `value` passed to the `render_template` function. The expected output of the rendered template is the reversed string \"dcba\" when the input is \"abcd\".\n\n**Code Being Tested and How It Works**:  \nThe test creates a Flask blueprint and defines a custom template filter `super_reverse` that reverses a string. This filter is added to the blueprint using `bp.add_app_template_filter(super_reverse)`. The blueprint is then registered with the main Flask application. The test defines a route that renders a template called `template_filter.html`, passing the string \"abcd\" as a value. When the test client makes a GET request to the root URL (\"/\"), it checks that the response data matches the expected byte string `b\"dcba\"`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprints**: The test demonstrates the use of Flask blueprints to modularize the application and encapsulate the template filter.\n- **Client Testing**: It utilizes Flask's test client to simulate a request to the application and verify the response.\n- **Assertions**: The test employs assertions to validate that the output of the rendered template matches the expected result, ensuring that the filter is applied correctly.\n- **Separation of Concerns**: The test maintains a clear separation between the application logic (filter definition and route handling) and the test logic, promoting maintainability and clarity."
    },
    {
      "name": "test_template_filter_with_name_and_template",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 464,
      "end_line_number": 478,
      "source_code": "def test_template_filter_with_name_and_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter(\"super_reverse\")\n    def my_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'dcba'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_template_filter_with_name_and_template` aims to verify that a custom Jinja2 template filter, named \"super_reverse\", is correctly registered and applied within a Flask application. It ensures that the filter can reverse a string when used in a rendered template.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the string \"abcd\" is transformed into \"dcba\" when passed through the \"super_reverse\" filter in the template rendering process. It confirms that the filter behaves as expected and that the application correctly integrates the filter into its rendering pipeline.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the registration of a template filter and the rendering of a template. The filter `my_reverse` is defined to reverse a string (`s[::-1]`) and is registered with the name \"super_reverse\". The route defined at `/` renders a template called \"template_filter.html\", passing the string \"abcd\" as a variable named `value`. The test then makes a GET request to this route and asserts that the response data matches the expected byte string `b\"dcba\"`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of Flask's testing client to simulate a request to the application, allowing for integration testing of the template rendering process. It also utilizes assertions to validate the output against expected results, which is a common practice in unit testing. The use of a blueprint to encapsulate the filter registration demonstrates modular design, making the test more organized and maintainable."
    },
    {
      "name": "test_add_template_filter_with_name_and_template",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 481,
      "end_line_number": 495,
      "source_code": "def test_add_template_filter_with_name_and_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def my_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(my_reverse, \"super_reverse\")\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'dcba'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_add_template_filter_with_name_and_template` is designed to verify that a custom template filter can be successfully added to a Flask application via a blueprint and that it functions correctly when rendering a template.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the custom filter `my_reverse`, which reverses a string, is correctly applied to the value passed to the template. The expected output is that the string \"abcd\" is transformed into \"dcba\" when rendered in the template.\n\n**Code Being Tested and How It Works**:  \nThe test creates a Flask blueprint and defines a function `my_reverse` that reverses a string. This function is registered as a template filter with the name \"super_reverse\". The blueprint is then registered with the main Flask application. The test defines a route that renders a template (`template_filter.html`) with the value \"abcd\". When the test client makes a GET request to the root URL, it checks that the response data matches the expected byte string `b\"dcba\"`, confirming that the filter was applied correctly.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprints**: The use of Flask blueprints allows for modular organization of the application, making it easier to manage and test components independently.\n- **Template Filters**: The test demonstrates the use of custom Jinja2 template filters, which enhance the templating capabilities of Flask applications.\n- **Client Testing**: The test utilizes Flask's test client to simulate a request to the application, allowing for verification of the rendered output without needing to run a live server.\n- **Assertions**: The test employs assertions to validate that the output of the rendered template matches the expected result, ensuring that the filter behaves as intended."
    },
    {
      "name": "test_template_test",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 498,
      "end_line_number": 508,
      "source_code": "def test_template_test(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_test()\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"is_boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"is_boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"is_boolean\"](False)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'is_boolean' in app.jinja_env.tests.keys()",
        "assert app.jinja_env.tests['is_boolean'] == is_boolean",
        "assert app.jinja_env.tests['is_boolean'](False)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_add_template_test",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 511,
      "end_line_number": 521,
      "source_code": "def test_add_template_test(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    bp.add_app_template_test(is_boolean)\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"is_boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"is_boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"is_boolean\"](False)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'is_boolean' in app.jinja_env.tests.keys()",
        "assert app.jinja_env.tests['is_boolean'] == is_boolean",
        "assert app.jinja_env.tests['is_boolean'](False)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_template_test_with_name",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 524,
      "end_line_number": 534,
      "source_code": "def test_template_test_with_name(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"boolean\"](False)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'boolean' in app.jinja_env.tests.keys()",
        "assert app.jinja_env.tests['boolean'] == is_boolean",
        "assert app.jinja_env.tests['boolean'](False)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_add_template_test_with_name",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 537,
      "end_line_number": 547,
      "source_code": "def test_add_template_test_with_name(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    bp.add_app_template_test(is_boolean, \"boolean\")\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"boolean\"](False)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'boolean' in app.jinja_env.tests.keys()",
        "assert app.jinja_env.tests['boolean'] == is_boolean",
        "assert app.jinja_env.tests['boolean'](False)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_template_test_with_template",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 550,
      "end_line_number": 564,
      "source_code": "def test_template_test_with_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert b'Success!' in rv.data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_template_test_with_template` function is designed to verify that a custom template test function can be successfully registered and utilized within a Flask application. It ensures that the application can render a template correctly when the custom test is applied.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the template renders successfully and includes the expected output (\"Success!\") when the `boolean` template test is applied to a value passed to the template. It confirms that the template logic behaves as intended when using the custom test.\n\n**Code Being Tested and How It Works**:  \nThe test registers a blueprint with a custom template test function named `boolean`, which checks if a value is of type `bool`. The test then defines a route (`/`) that renders a template (`template_test.html`) with a `value` set to `False`. The test sends a GET request to this route using the `client` fixture and asserts that the response data contains the byte string `b\"Success!\"`, indicating that the template rendered correctly.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprint Registration**: The test demonstrates the use of Flask blueprints to modularize the application, allowing for the registration of template tests within a specific context.\n- **Custom Template Tests**: It showcases how to define and register custom template tests using the `@bp.app_template_test()` decorator, which enhances the templating capabilities of Flask.\n- **Client Testing**: The use of the `client` fixture allows for simulating HTTP requests to the application, making it easier to test the behavior of routes and templates in isolation.\n- **Assertions**: The test employs assertions to validate the expected outcome, ensuring that the rendered template meets the specified criteria."
    },
    {
      "name": "test_template_test_after_route_with_template",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 567,
      "end_line_number": 580,
      "source_code": "def test_template_test_after_route_with_template(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert b'Success!' in rv.data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_template_test_after_route_with_template` aims to verify that a Flask application correctly renders a template using a custom template test function after the route has been defined. It ensures that the application behaves as expected when the template is rendered with specific context variables.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the rendered template includes the expected content (in this case, the string \"Success!\") when accessed via the defined route. It also indirectly verifies that the custom template test function (`boolean`) is correctly registered and can be utilized within the template.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a Flask route (`index`) that renders a template (`template_test.html`) with a context variable `value` set to `False`. A custom template test function (`boolean`) is defined to check if a value is a boolean. The test registers this function with the Flask application and then makes a GET request to the root URL (\"/\"). The response is checked to ensure it contains the expected byte string \"Success!\", indicating that the template was rendered correctly.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprints**: The test utilizes Flask's blueprint feature to encapsulate the template test function and route definition, promoting modularity and reusability.\n- **Client Simulation**: The `client` fixture simulates HTTP requests to the application, allowing for testing of the application's behavior in response to those requests.\n- **Assertions**: The test employs assertions to validate the response data, ensuring that the application behaves as expected when rendering templates with custom logic."
    },
    {
      "name": "test_add_template_test_with_template",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 583,
      "end_line_number": 597,
      "source_code": "def test_add_template_test_with_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def boolean(value):\n        return isinstance(value, bool)\n\n    bp.add_app_template_test(boolean)\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert b'Success!' in rv.data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:\nThe `test_add_template_test_with_template` function is designed to verify that a custom template test can be successfully added to a Flask application and that it functions correctly when rendering a template.\n\n**Specific Functionality or Behavior Verified**:\nThis test checks that the application can register a custom template test (in this case, a boolean check) and that the template renders correctly, returning the expected output when accessed via a client request.\n\n**Code Being Tested and How It Works**:\nThe test creates a Flask blueprint and defines a function `boolean` that checks if a value is of type `bool`. This function is registered as a template test using `bp.add_app_template_test(boolean)`. The blueprint is then registered with the main application under the URL prefix `/py`. The test defines a route `/` that renders a template `template_test.html`, passing `value=False` to it. The test then simulates a GET request to this route using the `client` and asserts that the response contains the byte string `b\"Success!\"`, indicating that the template rendered successfully.\n\n**Notable Testing Patterns or Techniques Used**:\n- **Blueprints**: The test utilizes Flask's blueprint feature to modularize the application, allowing for better organization of routes and template tests.\n- **Client Simulation**: The `client` fixture is used to simulate HTTP requests to the application, enabling the test to verify the behavior of routes and responses.\n- **Template Testing**: The test demonstrates the use of custom template tests, which can be defined and registered to extend Jinja2's templating capabilities within Flask applications."
    },
    {
      "name": "test_template_test_with_name_and_template",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 600,
      "end_line_number": 614,
      "source_code": "def test_template_test_with_name_and_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert b'Success!' in rv.data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_template_test_with_name_and_template` aims to verify that a custom template test function, `is_boolean`, is correctly registered and utilized within a Flask application. It checks that the application can render a template that uses this test and that the expected output is returned.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically verifies that the template renders successfully and includes the string \"Success!\" in the response data when the `value` passed to the template is `False`. This indicates that the template is functioning as intended and that the custom template test is being recognized.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a Flask route (`index`) that renders a template (`template_test.html`) with a context variable `value` set to `False`. The custom template test `is_boolean` checks if a value is of type `bool`. The test uses the Flask test client to simulate a GET request to the root URL (\"/\") and asserts that the response contains the expected output.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprints**: The test utilizes Flask's blueprint feature to encapsulate the template test and route registration, promoting modularity.\n- **Client Simulation**: It employs the Flask test client to simulate HTTP requests and validate responses, which is a common practice in testing web applications.\n- **Assertions**: The test uses assertions to confirm that the rendered output contains specific content, ensuring that the application behaves as expected under the defined conditions."
    },
    {
      "name": "test_add_template_test_with_name_and_template",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 617,
      "end_line_number": 631,
      "source_code": "def test_add_template_test_with_name_and_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    bp.add_app_template_test(is_boolean, \"boolean\")\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert b'Success!' in rv.data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_add_template_test_with_name_and_template` aims to verify that a custom template test function can be successfully added to a Flask application and that it behaves as expected when rendering a template.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the application can register a custom template test (in this case, a boolean check) and that the template renders correctly when accessed via a client request. It specifically asserts that the rendered output contains the string \"Success!\", indicating that the template was processed correctly.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the Flask application and its blueprint system. The test defines a blueprint and adds a custom template test function `is_boolean`, which checks if a value is of boolean type. The blueprint is registered with the application, and a route is defined that renders a template (`template_test.html`) with a boolean value (`False`). The test then simulates a GET request to the root URL (\"/\") and checks the response data for the expected output.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprints**: The test utilizes Flask's blueprint feature to modularize the application, allowing for better organization of routes and template tests.\n- **Client Simulation**: The `client` fixture is used to simulate HTTP requests to the application, enabling the test to verify the behavior of the application as a whole.\n- **Assertions**: The test employs assertions to validate that the expected output is present in the response data, ensuring that the template rendering logic works as intended."
    },
    {
      "name": "test_context_processing",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 634,
      "end_line_number": 672,
      "source_code": "def test_context_processing(app, client):\n    answer_bp = flask.Blueprint(\"answer_bp\", __name__)\n\n    def template_string():\n        return flask.render_template_string(\n            \"{% if notanswer %}{{ notanswer }} is not the answer. {% endif %}\"\n            \"{% if answer %}{{ answer }} is the answer.{% endif %}\"\n        )\n\n    # App global context processor\n    @answer_bp.app_context_processor\n    def not_answer_context_processor():\n        return {\"notanswer\": 43}\n\n    # Blueprint local context processor\n    @answer_bp.context_processor\n    def answer_context_processor():\n        return {\"answer\": 42}\n\n    # Setup endpoints for testing\n    @answer_bp.route(\"/bp\")\n    def bp_page():\n        return template_string()\n\n    @app.route(\"/\")\n    def app_page():\n        return template_string()\n\n    # Register the blueprint\n    app.register_blueprint(answer_bp)\n\n    app_page_bytes = client.get(\"/\").data\n    answer_page_bytes = client.get(\"/bp\").data\n\n    assert b\"43\" in app_page_bytes\n    assert b\"42\" not in app_page_bytes\n\n    assert b\"42\" in answer_page_bytes\n    assert b\"43\" in answer_page_bytes",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert b'43' in app_page_bytes",
        "assert b'42' not in app_page_bytes",
        "assert b'42' in answer_page_bytes",
        "assert b'43' in answer_page_bytes"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "template_string",
          "body": "def template_string():\n    return flask.render_template_string('{% if notanswer %}{{ notanswer }} is not the answer. {% endif %}{% if answer %}{{ answer }} is the answer.{% endif %}')"
        },
        {
          "name": "template_string",
          "body": "def template_string():\n    return flask.render_template_string('{% if notanswer %}{{ notanswer }} is not the answer. {% endif %}{% if answer %}{{ answer }} is the answer.{% endif %}')"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:\nThe `test_context_processing` function is designed to verify the correct functioning of Flask's context processors, both at the application level and the blueprint level. It ensures that the appropriate context variables are available in the rendered templates based on the context processors defined.\n\n**Specific Functionality or Behavior Verified**:\nThe test checks that the global context processor (`not_answer_context_processor`) correctly injects the variable `notanswer` with a value of `43` into the application context, while the local context processor (`answer_context_processor`) injects the variable `answer` with a value of `42` into the blueprint context. The test asserts that the correct values are rendered in the templates for the respective routes.\n\n**Code Being Tested and How It Works**:\nThe test sets up two routes: one for the application (`/`) and one for the blueprint (`/bp`). Both routes use the `template_string` function to render a template that conditionally displays the values of `notanswer` and `answer`. The assertions check the response data from both routes to ensure that:\n- The application route includes `notanswer` but not `answer`.\n- The blueprint route includes both `notanswer` and `answer`.\n\n**Notable Testing Patterns or Techniques Used**:\n- **Blueprints**: The test utilizes Flask's blueprint feature to encapsulate context processors and routes, allowing for modular application design.\n- **Context Processors**: It demonstrates the use of app-level and blueprint-level context processors to manage template context dynamically.\n- **Assertions**: The test employs assertions to validate the presence or absence of specific byte strings in the response data, ensuring that the correct context variables are rendered in the templates.\n- **Client Simulation**: The `client` fixture is used to simulate HTTP requests to the application, allowing for testing of the rendered output without needing to run a server."
    },
    {
      "name": "test_template_global",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 675,
      "end_line_number": 693,
      "source_code": "def test_template_global(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_global()\n    def get_answer():\n        return 42\n\n    # Make sure the function is not in the jinja_env already\n    assert \"get_answer\" not in app.jinja_env.globals.keys()\n    app.register_blueprint(bp)\n\n    # Tests\n    assert \"get_answer\" in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals[\"get_answer\"] is get_answer\n    assert app.jinja_env.globals[\"get_answer\"]() == 42\n\n    with app.app_context():\n        rv = flask.render_template_string(\"{{ get_answer() }}\")\n        assert rv == \"42\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'get_answer' not in app.jinja_env.globals.keys()",
        "assert 'get_answer' in app.jinja_env.globals.keys()",
        "assert app.jinja_env.globals['get_answer'] is get_answer",
        "assert app.jinja_env.globals['get_answer']() == 42",
        "assert rv == '42'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_request_processing",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 696,
      "end_line_number": 724,
      "source_code": "def test_request_processing(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n    evts = []\n\n    @bp.before_request\n    def before_bp():\n        evts.append(\"before\")\n\n    @bp.after_request\n    def after_bp(response):\n        response.data += b\"|after\"\n        evts.append(\"after\")\n        return response\n\n    @bp.teardown_request\n    def teardown_bp(exc):\n        evts.append(\"teardown\")\n\n    # Setup routes for testing\n    @bp.route(\"/bp\")\n    def bp_endpoint():\n        return \"request\"\n\n    app.register_blueprint(bp)\n\n    assert evts == []\n    rv = client.get(\"/bp\")\n    assert rv.data == b\"request|after\"\n    assert evts == [\"before\", \"after\", \"teardown\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert evts == []",
        "assert rv.data == b'request|after'",
        "assert evts == ['before', 'after', 'teardown']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_request_processing` function is to verify the correct execution order and behavior of Flask's request lifecycle hooks (before, after, and teardown) when handling a request to a specific endpoint defined in a blueprint.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the events registered in the `before_request`, `after_request`, and `teardown_request` hooks are executed in the expected order. It ensures that the response data is modified correctly by the after request hook and that the teardown hook is called after the response is returned.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves a Flask application with a blueprint that defines three hooks:\n- `before_bp`: Appends \"before\" to the `evts` list before processing the request.\n- `after_bp`: Modifies the response data by appending \"|after\" and appends \"after\" to the `evts` list after the request is processed.\n- `teardown_bp`: Appends \"teardown\" to the `evts` list after the request context is popped.\n\nThe test registers a route (`/bp`) that returns a simple string. It then makes a GET request to this endpoint using the `client` fixture and asserts that the response data is as expected and that the `evts` list contains the correct sequence of events.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Lifecycle Hook Testing**: The test effectively demonstrates how to test Flask's lifecycle hooks by asserting the order of execution and the modifications made to the response.\n- **Blueprint Usage**: It showcases the use of blueprints in Flask, allowing for modular application design and testing.\n- **Assertions on State**: The test uses assertions to verify both the state of the `evts` list and the content of the response, ensuring comprehensive coverage of the request handling process."
    },
    {
      "name": "test_app_request_processing",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 727,
      "end_line_number": 763,
      "source_code": "def test_app_request_processing(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n    evts = []\n\n    @bp.before_app_request\n    def before_app():\n        evts.append(\"before\")\n\n    @bp.after_app_request\n    def after_app(response):\n        response.data += b\"|after\"\n        evts.append(\"after\")\n        return response\n\n    @bp.teardown_app_request\n    def teardown_app(exc):\n        evts.append(\"teardown\")\n\n    app.register_blueprint(bp)\n\n    # Setup routes for testing\n    @app.route(\"/\")\n    def bp_endpoint():\n        return \"request\"\n\n    # before first request\n    assert evts == []\n\n    # first request\n    resp = client.get(\"/\").data\n    assert resp == b\"request|after\"\n    assert evts == [\"before\", \"after\", \"teardown\"]\n\n    # second request\n    resp = client.get(\"/\").data\n    assert resp == b\"request|after\"\n    assert evts == [\"before\", \"after\", \"teardown\"] * 2",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert evts == []",
        "assert resp == b'request|after'",
        "assert evts == ['before', 'after', 'teardown']",
        "assert resp == b'request|after'",
        "assert evts == ['before', 'after', 'teardown'] * 2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_app_request_processing` test is to verify the correct execution order and behavior of Flask's request lifecycle hooks (before, after, and teardown) when handling HTTP requests to a registered route.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the `before_app_request`, `after_app_request`, and `teardown_app_request` functions are called in the expected order during the request lifecycle. It ensures that the response data is modified correctly by the after request function and that the events are recorded accurately in the `evts` list.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Flask application with a blueprint that registers three lifecycle hooks:\n- `before_app`: Appends \"before\" to the `evts` list before processing the request.\n- `after_app`: Modifies the response data by appending \"|after\" and appends \"after\" to the `evts` list after processing the request.\n- `teardown_app`: Appends \"teardown\" to the `evts` list after the request has been processed, regardless of whether an exception occurred.\n\nThe test then registers a route (`/`) that returns a simple string. It performs two GET requests to this route and asserts that the response data and the recorded events match the expected outcomes.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Lifecycle Hook Testing**: The test effectively demonstrates how to test Flask's lifecycle hooks by asserting the order and occurrence of events.\n- **State Verification**: It uses assertions to verify the state of the `evts` list before and after requests, ensuring that the hooks are functioning as intended.\n- **Blueprint Usage**: The test showcases the use of Flask blueprints to encapsulate related routes and hooks, promoting modularity in the application structure.\n- **Client Simulation**: The `client` fixture simulates HTTP requests to the application, allowing for integration-style testing of the request handling process."
    },
    {
      "name": "test_app_url_processors",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 766,
      "end_line_number": 790,
      "source_code": "def test_app_url_processors(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    # Register app-wide url defaults and preprocessor on blueprint\n    @bp.app_url_defaults\n    def add_language_code(endpoint, values):\n        values.setdefault(\"lang_code\", flask.g.lang_code)\n\n    @bp.app_url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop(\"lang_code\")\n\n    # Register route rules at the app level\n    @app.route(\"/<lang_code>/\")\n    def index():\n        return flask.url_for(\"about\")\n\n    @app.route(\"/<lang_code>/about\")\n    def about():\n        return flask.url_for(\"index\")\n\n    app.register_blueprint(bp)\n\n    assert client.get(\"/de/\").data == b\"/de/about\"\n    assert client.get(\"/de/about\").data == b\"/de/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/de/').data == b'/de/about'",
        "assert client.get('/de/about').data == b'/de/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "values.setdefault",
          "body": "@app.route('/setdefault')\ndef setdefault():\n    return flask.session.setdefault('test', 'default')"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_app_url_processors` test is to verify the correct functioning of URL processors in a Flask application, specifically how language codes are handled in URL routing and how they affect URL generation.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the application correctly appends a language code to URLs and that the URL generation works as expected when navigating between routes. It ensures that the language code is properly set and retrieved during the request lifecycle.\n\n**Code Being Tested and How It Works**:  \nThe test defines a Flask blueprint with two URL processors: `add_language_code` and `pull_lang_code`. The `add_language_code` function sets a default language code in the URL values, while `pull_lang_code` extracts the language code from the URL and assigns it to the global context (`flask.g`). The test registers two routes (`index` and `about`) that utilize these processors. The assertions check that accessing the `/de/` route returns the correct URL for the `about` page and vice versa.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of Flask's blueprint system to encapsulate URL processing logic, demonstrating modular design. It also utilizes assertions to validate the expected output of HTTP GET requests, ensuring that the application behaves correctly under different URL conditions. The use of `client.get` simulates actual HTTP requests, allowing for integration-style testing within the unit test framework."
    },
    {
      "name": "test_nested_blueprint",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 793,
      "end_line_number": 839,
      "source_code": "def test_nested_blueprint(app, client):\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__)\n    grandchild = flask.Blueprint(\"grandchild\", __name__)\n\n    @parent.errorhandler(403)\n    def forbidden(e):\n        return \"Parent no\", 403\n\n    @parent.route(\"/\")\n    def parent_index():\n        return \"Parent yes\"\n\n    @parent.route(\"/no\")\n    def parent_no():\n        flask.abort(403)\n\n    @child.route(\"/\")\n    def child_index():\n        return \"Child yes\"\n\n    @child.route(\"/no\")\n    def child_no():\n        flask.abort(403)\n\n    @grandchild.errorhandler(403)\n    def grandchild_forbidden(e):\n        return \"Grandchild no\", 403\n\n    @grandchild.route(\"/\")\n    def grandchild_index():\n        return \"Grandchild yes\"\n\n    @grandchild.route(\"/no\")\n    def grandchild_no():\n        flask.abort(403)\n\n    child.register_blueprint(grandchild, url_prefix=\"/grandchild\")\n    parent.register_blueprint(child, url_prefix=\"/child\")\n    app.register_blueprint(parent, url_prefix=\"/parent\")\n\n    assert client.get(\"/parent/\").data == b\"Parent yes\"\n    assert client.get(\"/parent/child/\").data == b\"Child yes\"\n    assert client.get(\"/parent/child/grandchild/\").data == b\"Grandchild yes\"\n    assert client.get(\"/parent/no\").data == b\"Parent no\"\n    assert client.get(\"/parent/child/no\").data == b\"Parent no\"\n    assert client.get(\"/parent/child/grandchild/no\").data == b\"Grandchild no\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/parent/').data == b'Parent yes'",
        "assert client.get('/parent/child/').data == b'Child yes'",
        "assert client.get('/parent/child/grandchild/').data == b'Grandchild yes'",
        "assert client.get('/parent/no').data == b'Parent no'",
        "assert client.get('/parent/child/no').data == b'Parent no'",
        "assert client.get('/parent/child/grandchild/no').data == b'Grandchild no'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_nested_blueprint` function is to verify the correct behavior of nested Flask blueprints, ensuring that routes and error handlers are properly registered and accessible through the expected URL paths.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. The root route of each blueprint returns the correct response.\n2. The error handling for 403 Forbidden responses works as intended for both parent and child blueprints.\n3. The nested structure of the blueprints allows for proper routing, ensuring that requests to specific paths return the expected data.\n\n**Code Being Tested and How It Works**:  \nThe code defines three blueprints: `parent`, `child`, and `grandchild`. Each blueprint has its own routes and error handlers:\n- The `parent` blueprint has a route for the root path (`/`) and a route that triggers a 403 error.\n- The `child` blueprint has similar routes, and it is registered under the `parent` blueprint with a URL prefix of `/child`.\n- The `grandchild` blueprint is registered under the `child` blueprint with a URL prefix of `/grandchild`.\n\nThe test uses the `client` to simulate HTTP requests to various endpoints, asserting that the responses match the expected output.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprint Registration**: The test demonstrates the use of Flask's blueprint system to organize routes and handlers, allowing for modular application design.\n- **Error Handling Verification**: It checks the functionality of error handlers by simulating requests that should trigger them, ensuring that the application responds correctly to errors.\n- **Assertions**: The test employs assertions to validate the responses from the client, ensuring that the application behaves as expected across different routes and scenarios."
    },
    {
      "name": "test_nested_callback_order",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 842,
      "end_line_number": 919,
      "source_code": "def test_nested_callback_order(app, client):\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__)\n\n    @app.before_request\n    def app_before1():\n        flask.g.setdefault(\"seen\", []).append(\"app_1\")\n\n    @app.teardown_request\n    def app_teardown1(e=None):\n        assert flask.g.seen.pop() == \"app_1\"\n\n    @app.before_request\n    def app_before2():\n        flask.g.setdefault(\"seen\", []).append(\"app_2\")\n\n    @app.teardown_request\n    def app_teardown2(e=None):\n        assert flask.g.seen.pop() == \"app_2\"\n\n    @app.context_processor\n    def app_ctx():\n        return dict(key=\"app\")\n\n    @parent.before_request\n    def parent_before1():\n        flask.g.setdefault(\"seen\", []).append(\"parent_1\")\n\n    @parent.teardown_request\n    def parent_teardown1(e=None):\n        assert flask.g.seen.pop() == \"parent_1\"\n\n    @parent.before_request\n    def parent_before2():\n        flask.g.setdefault(\"seen\", []).append(\"parent_2\")\n\n    @parent.teardown_request\n    def parent_teardown2(e=None):\n        assert flask.g.seen.pop() == \"parent_2\"\n\n    @parent.context_processor\n    def parent_ctx():\n        return dict(key=\"parent\")\n\n    @child.before_request\n    def child_before1():\n        flask.g.setdefault(\"seen\", []).append(\"child_1\")\n\n    @child.teardown_request\n    def child_teardown1(e=None):\n        assert flask.g.seen.pop() == \"child_1\"\n\n    @child.before_request\n    def child_before2():\n        flask.g.setdefault(\"seen\", []).append(\"child_2\")\n\n    @child.teardown_request\n    def child_teardown2(e=None):\n        assert flask.g.seen.pop() == \"child_2\"\n\n    @child.context_processor\n    def child_ctx():\n        return dict(key=\"child\")\n\n    @child.route(\"/a\")\n    def a():\n        return \", \".join(flask.g.seen)\n\n    @child.route(\"/b\")\n    def b():\n        return flask.render_template_string(\"{{ key }}\")\n\n    parent.register_blueprint(child)\n    app.register_blueprint(parent)\n    assert (\n        client.get(\"/a\").data == b\"app_1, app_2, parent_1, parent_2, child_1, child_2\"\n    )\n    assert client.get(\"/b\").data == b\"child\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/a').data == b'app_1, app_2, parent_1, parent_2, child_1, child_2'",
        "assert client.get('/b').data == b'child'",
        "assert flask.g.seen.pop() == 'app_1'",
        "assert flask.g.seen.pop() == 'app_2'",
        "assert flask.g.seen.pop() == 'parent_1'",
        "assert flask.g.seen.pop() == 'parent_2'",
        "assert flask.g.seen.pop() == 'child_1'",
        "assert flask.g.seen.pop() == 'child_2'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "flask.g.setdefault",
          "body": "@app.route('/setdefault')\ndef setdefault():\n    return flask.session.setdefault('test', 'default')"
        },
        {
          "name": "flask.g.setdefault",
          "body": "@app.route('/setdefault')\ndef setdefault():\n    return flask.session.setdefault('test', 'default')"
        },
        {
          "name": "flask.g.setdefault",
          "body": "@app.route('/setdefault')\ndef setdefault():\n    return flask.session.setdefault('test', 'default')"
        },
        {
          "name": "flask.g.setdefault",
          "body": "@app.route('/setdefault')\ndef setdefault():\n    return flask.session.setdefault('test', 'default')"
        },
        {
          "name": "flask.g.setdefault",
          "body": "@app.route('/setdefault')\ndef setdefault():\n    return flask.session.setdefault('test', 'default')"
        },
        {
          "name": "flask.g.setdefault",
          "body": "@app.route('/setdefault')\ndef setdefault():\n    return flask.session.setdefault('test', 'default')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_nested_callback_order` function is designed to verify the order of execution for Flask's request lifecycle callbacks (before and teardown requests) when using nested blueprints. It ensures that the callbacks are executed in the expected sequence and that the state maintained in `flask.g` is correctly manipulated.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the `flask.g.seen` list accumulates entries in the correct order as various before request and teardown request functions are executed. It also verifies that the correct values are returned from the routes defined in the child blueprint, confirming that the context processors are functioning as intended.\n\n**Code Being Tested and How It Works**:  \nThe test sets up two blueprints (`parent` and `child`) and registers multiple before request and teardown request functions for each. When a request is made to the `/a` route, the test checks that the `flask.g.seen` list contains the expected sequence of entries, which reflects the order of the executed callbacks. The `/b` route checks that the context processor for the child blueprint returns the correct key. The assertions at the end validate the expected output of these routes.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Setup and Teardown**: The test uses Flask's lifecycle hooks (`before_request` and `teardown_request`) to manage state across requests, demonstrating the use of setup and teardown patterns in testing.\n- **Blueprints**: The use of blueprints allows for modular organization of routes and callbacks, which is a common pattern in Flask applications.\n- **Assertions**: The test employs assertions to validate the state of `flask.g.seen` and the output of the routes, ensuring that the application behaves as expected under the defined conditions.\n- **Context Processors**: The test verifies the functionality of context processors, which are used to inject variables into the template context, showcasing how Flask manages application context."
    },
    {
      "name": "test_nesting_url_prefixes",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 931,
      "end_line_number": 950,
      "source_code": "def test_nesting_url_prefixes(\n    parent_init,\n    child_init,\n    parent_registration,\n    child_registration,\n    app,\n    client,\n) -> None:\n    parent = flask.Blueprint(\"parent\", __name__, url_prefix=parent_init)\n    child = flask.Blueprint(\"child\", __name__, url_prefix=child_init)\n\n    @child.route(\"/\")\n    def index():\n        return \"index\"\n\n    parent.register_blueprint(child, url_prefix=child_registration)\n    app.register_blueprint(parent, url_prefix=parent_registration)\n\n    response = client.get(\"/parent/child/\")\n    assert response.status_code == 200",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('parent_init, child_init, parent_registration, child_registration', [('/parent', '/child', None, None), ('/parent', None, None, '/child'), (None, None, '/parent', '/child'), ('/other', '/something', '/parent', '/child')])"
      ],
      "arguments": [
        "parent_init",
        "child_init",
        "parent_registration",
        "child_registration",
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_nesting_url_prefixes` function is designed to verify that nested Flask blueprints can be registered and accessed correctly with the appropriate URL prefixes. It ensures that the routing works as expected when a child blueprint is registered under a parent blueprint.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that a GET request to the URL `/parent/child/` returns a successful HTTP status code (200). This indicates that the child blueprint's route is correctly accessible under the specified URL structure.\n\n**Code Being Tested and How It Works**:  \nThe test creates two Flask blueprints: `parent` and `child`, each with their respective URL prefixes. The child blueprint has a route defined at the root (\"/\") that returns the string \"index\". The child blueprint is registered to the parent blueprint with a specified URL prefix (`child_registration`), and the parent blueprint is registered to the Flask application with another URL prefix (`parent_registration`). The test then simulates a client GET request to the combined URL `/parent/child/` and asserts that the response status code is 200, confirming that the routing is functioning correctly.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test utilizes parameterized inputs for the URL prefixes, allowing it to run multiple scenarios with different configurations of URL prefixes. This enhances test coverage without duplicating code.\n- **Blueprint Registration**: The test demonstrates the use of Flask's blueprint registration mechanism, which is a common pattern for organizing routes in larger applications.\n- **Client Simulation**: The use of `client.get()` simulates HTTP requests to the application, allowing for testing of the application's response to real-world interactions."
    },
    {
      "name": "test_nesting_subdomains",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 953,
      "end_line_number": 971,
      "source_code": "def test_nesting_subdomains(app, client) -> None:\n    subdomain = \"api\"\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__)\n\n    @child.route(\"/child/\")\n    def index():\n        return \"child\"\n\n    parent.register_blueprint(child)\n    app.register_blueprint(parent, subdomain=subdomain)\n\n    client.allow_subdomain_redirects = True\n\n    domain_name = \"domain.tld\"\n    app.config[\"SERVER_NAME\"] = domain_name\n    response = client.get(\"/child/\", base_url=\"http://api.\" + domain_name)\n\n    assert response.status_code == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_nesting_subdomains` function is designed to verify that a Flask application correctly handles requests to nested blueprints when using subdomains. Specifically, it checks that a route defined in a child blueprint can be accessed via a specified subdomain.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a request is made to the `/child/` route under the `api` subdomain, the application responds with a status code of 200 (OK). This indicates that the routing and subdomain handling are functioning as expected.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Flask application with two blueprints: a parent and a child. The child blueprint defines a route (`/child/`) that returns the string \"child\". The parent blueprint is registered with the subdomain \"api\". The test then simulates a client request to the child route using the base URL `http://api.domain.tld`. The application is expected to correctly route this request to the child blueprint and return a successful response.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprints**: The test utilizes Flask's blueprint feature to organize routes, allowing for modular application design.\n- **Subdomain Handling**: It tests the application's ability to handle requests based on subdomains, which is crucial for applications that serve multiple domains or subdomains.\n- **Client Simulation**: The test uses Flask's test client to simulate HTTP requests, enabling the verification of response codes and behaviors without needing to run a live server.\n- **Assertions**: The test employs assertions to validate the expected outcome, ensuring that the application behaves correctly under the specified conditions."
    },
    {
      "name": "test_child_and_parent_subdomain",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 974,
      "end_line_number": 999,
      "source_code": "def test_child_and_parent_subdomain(app, client) -> None:\n    child_subdomain = \"api\"\n    parent_subdomain = \"parent\"\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__, subdomain=child_subdomain)\n\n    @child.route(\"/\")\n    def index():\n        return \"child\"\n\n    parent.register_blueprint(child)\n    app.register_blueprint(parent, subdomain=parent_subdomain)\n\n    client.allow_subdomain_redirects = True\n\n    domain_name = \"domain.tld\"\n    app.config[\"SERVER_NAME\"] = domain_name\n    response = client.get(\n        \"/\", base_url=f\"http://{child_subdomain}.{parent_subdomain}.{domain_name}\"\n    )\n\n    assert response.status_code == 200\n\n    response = client.get(\"/\", base_url=f\"http://{parent_subdomain}.{domain_name}\")\n\n    assert response.status_code == 404",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.status_code == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_child_and_parent_subdomain` function is designed to verify the correct behavior of Flask blueprints when handling requests across different subdomains. Specifically, it checks that a child blueprint registered under a specific subdomain can be accessed correctly, while ensuring that requests to the parent subdomain do not inadvertently access the child blueprint.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies two key behaviors:\n1. A request to the child blueprint (accessed via the child subdomain) returns a successful response (HTTP status code 200).\n2. A request to the parent subdomain does not find the child blueprint and returns a 404 Not Found status code.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Flask application with two blueprints: a parent blueprint and a child blueprint. The child blueprint is registered with a subdomain (`api`), while the parent blueprint is registered with another subdomain (`parent`). The test then simulates HTTP GET requests to both the child and parent subdomains using the Flask test client. The first request targets the child blueprint, and the second targets the parent blueprint. The expected outcomes are asserted using the `assert` statements.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprints**: The test utilizes Flask's blueprint feature to modularize the application, allowing for organized routing and handling of requests.\n- **Subdomain Testing**: It specifically tests the subdomain routing capabilities of Flask, ensuring that requests are correctly routed based on the subdomain specified in the URL.\n- **Client Simulation**: The Flask test client is used to simulate HTTP requests, allowing for easy testing of the application's response without needing to run a live server.\n- **Assertions**: The test employs assertions to validate the expected outcomes, ensuring that the application behaves as intended under different routing scenarios."
    },
    {
      "name": "test_unique_blueprint_names",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 1002,
      "end_line_number": 1016,
      "source_code": "def test_unique_blueprint_names(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    bp2 = flask.Blueprint(\"bp\", __name__)\n\n    app.register_blueprint(bp)\n\n    with pytest.raises(ValueError):\n        app.register_blueprint(bp)  # same bp, same name, error\n\n    app.register_blueprint(bp, name=\"again\")  # same bp, different name, ok\n\n    with pytest.raises(ValueError):\n        app.register_blueprint(bp2)  # different bp, same name, error\n\n    app.register_blueprint(bp2, name=\"alt\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_self_registration",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 1019,
      "end_line_number": 1022,
      "source_code": "def test_self_registration(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    with pytest.raises(ValueError):\n        bp.register_blueprint(bp)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_blueprint_renaming",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_blueprints.py",
      "line_number": 1025,
      "end_line_number": 1054,
      "source_code": "def test_blueprint_renaming(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    bp2 = flask.Blueprint(\"bp2\", __name__)\n\n    @bp.get(\"/\")\n    def index():\n        return flask.request.endpoint\n\n    @bp.get(\"/error\")\n    def error():\n        flask.abort(403)\n\n    @bp.errorhandler(403)\n    def forbidden(_: Exception):\n        return \"Error\", 403\n\n    @bp2.get(\"/\")\n    def index2():\n        return flask.request.endpoint\n\n    bp.register_blueprint(bp2, url_prefix=\"/a\", name=\"sub\")\n    app.register_blueprint(bp, url_prefix=\"/a\")\n    app.register_blueprint(bp, url_prefix=\"/b\", name=\"alt\")\n\n    assert client.get(\"/a/\").data == b\"bp.index\"\n    assert client.get(\"/b/\").data == b\"alt.index\"\n    assert client.get(\"/a/a/\").data == b\"bp.sub.index2\"\n    assert client.get(\"/b/a/\").data == b\"alt.sub.index2\"\n    assert client.get(\"/a/error\").data == b\"Error\"\n    assert client.get(\"/b/error\").data == b\"Error\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "jinja2.TemplateNotFound",
        "werkzeug.http.parse_cache_control_header",
        "flask",
        "blueprintapp.app",
        "blueprintapp.app",
        "werkzeug.routing.Rule"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/a/').data == b'bp.index'",
        "assert client.get('/b/').data == b'alt.index'",
        "assert client.get('/a/a/').data == b'bp.sub.index2'",
        "assert client.get('/b/a/').data == b'alt.sub.index2'",
        "assert client.get('/a/error').data == b'Error'",
        "assert client.get('/b/error').data == b'Error'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "bp.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "bp.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "bp2.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_blueprint_renaming` function is designed to verify the correct behavior of Flask blueprints when they are registered with different names and URL prefixes. It ensures that the endpoints respond with the expected values based on their registration context.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. The root endpoint of the first blueprint (`bp`) returns the correct endpoint name when accessed via different URL prefixes.\n2. The nested blueprint (`bp2`) correctly responds when accessed through the parent blueprint (`bp`) with the appropriate URL prefix.\n3. The error handling mechanism works as expected, returning a 403 error with the correct message.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves two blueprints (`bp` and `bp2`). The `bp` blueprint has two routes: the root route (`/`) and an error route (`/error`). The `bp2` blueprint has its own root route. The blueprints are registered with the main application (`app`) under different URL prefixes (`/a` and `/b`). The assertions at the end of the test check the responses from the client for various endpoints, ensuring they return the expected endpoint names and error messages.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprint Registration**: The test demonstrates the use of Flask's blueprint system, which allows for modular application design.\n- **Client Simulation**: The `client` object simulates HTTP requests to the application, allowing for testing of the response data without needing to run a server.\n- **Assertions**: The test uses assertions to validate that the responses from the application match the expected output, which is a common practice in unit testing to ensure correctness."
    },
    {
      "name": "test_config_from_pyfile",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_config.py",
      "line_number": 19,
      "end_line_number": 22,
      "source_code": "def test_config_from_pyfile():\n    app = flask.Flask(__name__)\n    app.config.from_pyfile(f\"{__file__.rsplit('.', 1)[0]}.py\")\n    common_object_test(app)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "json",
        "os",
        "pytest",
        "flask"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "common_object_test",
          "body": "def common_object_test(app):\n    assert app.secret_key == 'config'\n    assert app.config['TEST_KEY'] == 'foo'\n    assert 'TestConfig' not in app.config"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_config_from_pyfile` function is designed to verify that a Flask application can correctly load its configuration settings from a Python file. This ensures that the application can dynamically adjust its behavior based on external configuration files, which is a common practice in Flask applications.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the application\u2019s configuration is set up correctly after loading from the specified Python file. It verifies that the `secret_key` and a custom configuration key (`TEST_KEY`) are set to expected values, and it ensures that a specific configuration key (`TestConfig`) is not present in the application\u2019s configuration.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `from_pyfile` method of the Flask application's configuration object. This method reads configuration values from a specified Python file, which is dynamically determined by the test's file name. The `common_object_test` function is then called to assert that the application\u2019s configuration matches the expected values. The assertions check for the presence and correctness of specific configuration keys.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Separation of Concerns**: The test uses a helper function (`common_object_test`) to encapsulate the assertions, promoting code reuse and clarity.\n- **Dynamic File Handling**: The test constructs the filename for the configuration file dynamically using `__file__`, which allows for flexible testing of different configurations based on the test file's name.\n- **Assertions**: The test employs assertions to validate the expected state of the application\u2019s configuration, which is a fundamental practice in unit testing to ensure correctness.\n- **Flask Testing Context**: Although not explicitly shown in this test, the context of Flask applications is crucial for testing, as it allows for the proper handling of application state and configuration during tests."
    },
    {
      "name": "test_config_from_object",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_config.py",
      "line_number": 25,
      "end_line_number": 28,
      "source_code": "def test_config_from_object():\n    app = flask.Flask(__name__)\n    app.config.from_object(__name__)\n    common_object_test(app)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "json",
        "os",
        "pytest",
        "flask"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "common_object_test",
          "body": "def common_object_test(app):\n    assert app.secret_key == 'config'\n    assert app.config['TEST_KEY'] == 'foo'\n    assert 'TestConfig' not in app.config"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_config_from_object` function is designed to verify that a Flask application can correctly load its configuration from a specified object, in this case, the current module (`__name__`). This ensures that the application can access configuration values defined at the module level.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the Flask application has the correct `secret_key` and a specific configuration key (`TEST_KEY`) set to expected values. It also verifies that a configuration key (`TestConfig`) is not present in the application's configuration, ensuring that the loading mechanism does not inadvertently include unwanted keys.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `common_object_test` function, which asserts three conditions on the Flask app's configuration:\n1. `app.secret_key` should equal `'config'`.\n2. `app.config['TEST_KEY']` should equal `'foo'`.\n3. The key `'TestConfig'` should not be present in `app.config`.\n\nThe `test_config_from_object` function initializes a Flask app instance, loads the configuration from the current module using `app.config.from_object(__name__)`, and then calls `common_object_test(app)` to perform the assertions.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Modular Testing**: The test uses a helper function (`common_object_test`) to encapsulate the assertions, promoting code reuse and clarity.\n- **Configuration Loading**: It demonstrates the use of Flask's configuration loading mechanism, specifically the `from_object` method, which allows for dynamic loading of configuration values from a Python module.\n- **Isolation**: The test is isolated from other tests, ensuring that it only verifies the behavior of configuration loading without side effects from other tests or configurations."
    },
    {
      "name": "test_config_from_file_json",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_config.py",
      "line_number": 31,
      "end_line_number": 35,
      "source_code": "def test_config_from_file_json():\n    app = flask.Flask(__name__)\n    current_dir = os.path.dirname(os.path.abspath(__file__))\n    app.config.from_file(os.path.join(current_dir, \"static\", \"config.json\"), json.load)\n    common_object_test(app)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "json",
        "os",
        "pytest",
        "flask"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "common_object_test",
          "body": "def common_object_test(app):\n    assert app.secret_key == 'config'\n    assert app.config['TEST_KEY'] == 'foo'\n    assert 'TestConfig' not in app.config"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_config_from_file_json` function is designed to verify that a Flask application can correctly load its configuration settings from a JSON file. This ensures that the application can dynamically configure itself based on external configuration files, which is a common practice in web applications.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the application\u2019s `secret_key` and a specific configuration key (`TEST_KEY`) are set correctly after loading the configuration from the specified JSON file. It also verifies that a key named `TestConfig` does not exist in the application\u2019s configuration, ensuring that the application is not inadvertently loading unwanted configurations.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `from_file` method of the Flask application's configuration object, which reads configuration data from a JSON file. The test constructs the path to the JSON file located in the `static` directory relative to the test file's location. It then loads the configuration using `json.load`, which deserializes the JSON data into Python objects. The `common_object_test` function is called to assert the expected values against the loaded configuration.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Isolation**: The test creates a new Flask application instance, ensuring that each test runs in isolation without side effects from other tests.\n- **Assertions**: The use of assertions in the `common_object_test` function allows for clear verification of expected outcomes, making it easy to identify configuration issues.\n- **File Handling**: The test demonstrates the use of file path manipulation to locate the configuration file, which is a common pattern in tests that involve external resources.\n- **Modularity**: The separation of configuration verification into the `common_object_test` function promotes code reuse and clarity, allowing for consistent checks across different configuration loading tests."
    },
    {
      "name": "test_config_from_file_toml",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_config.py",
      "line_number": 38,
      "end_line_number": 45,
      "source_code": "def test_config_from_file_toml():\n    tomllib = pytest.importorskip(\"tomllib\", reason=\"tomllib added in 3.11\")\n    app = flask.Flask(__name__)\n    current_dir = os.path.dirname(os.path.abspath(__file__))\n    app.config.from_file(\n        os.path.join(current_dir, \"static\", \"config.toml\"), tomllib.load, text=False\n    )\n    common_object_test(app)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "json",
        "os",
        "pytest",
        "flask"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "common_object_test",
          "body": "def common_object_test(app):\n    assert app.secret_key == 'config'\n    assert app.config['TEST_KEY'] == 'foo'\n    assert 'TestConfig' not in app.config"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_config_from_file_toml` function is designed to verify that a Flask application can correctly load its configuration from a TOML file using the `tomllib` module. This ensures that the application can handle configuration files in this format, which is important for flexibility in application setup.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the application\u2019s configuration is set up correctly after loading from the specified TOML file. It specifically verifies that the `secret_key` and a custom configuration key (`TEST_KEY`) are set to expected values, and that a specific configuration key (`TestConfig`) is not present in the application\u2019s configuration.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `from_file` method of the Flask app's configuration object, which loads configuration settings from a file. The path to the TOML file is constructed using the current directory and the expected file location. The `tomllib.load` function is used to parse the TOML file. After loading the configuration, the `common_object_test` function is called to assert the expected values.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Dependency Management**: The test uses `pytest.importorskip` to conditionally import the `tomllib` module, ensuring that the test only runs if the module is available (Python 3.11 or later). This prevents failures in environments where the module is not present.\n- **Modular Testing**: The use of the `common_object_test` function allows for reusable assertions across different configuration tests, promoting DRY (Don't Repeat Yourself) principles.\n- **File Path Handling**: The test demonstrates good practice in handling file paths using `os.path` to ensure compatibility across different operating systems."
    },
    {
      "name": "test_from_prefixed_env",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_config.py",
      "line_number": 48,
      "end_line_number": 66,
      "source_code": "def test_from_prefixed_env(monkeypatch):\n    monkeypatch.setenv(\"FLASK_STRING\", \"value\")\n    monkeypatch.setenv(\"FLASK_BOOL\", \"true\")\n    monkeypatch.setenv(\"FLASK_INT\", \"1\")\n    monkeypatch.setenv(\"FLASK_FLOAT\", \"1.2\")\n    monkeypatch.setenv(\"FLASK_LIST\", \"[1, 2]\")\n    monkeypatch.setenv(\"FLASK_DICT\", '{\"k\": \"v\"}')\n    monkeypatch.setenv(\"NOT_FLASK_OTHER\", \"other\")\n\n    app = flask.Flask(__name__)\n    app.config.from_prefixed_env()\n\n    assert app.config[\"STRING\"] == \"value\"\n    assert app.config[\"BOOL\"] is True\n    assert app.config[\"INT\"] == 1\n    assert app.config[\"FLOAT\"] == 1.2\n    assert app.config[\"LIST\"] == [1, 2]\n    assert app.config[\"DICT\"] == {\"k\": \"v\"}\n    assert \"OTHER\" not in app.config",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "json",
        "os",
        "pytest",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.config['STRING'] == 'value'",
        "assert app.config['BOOL'] is True",
        "assert app.config['INT'] == 1",
        "assert app.config['FLOAT'] == 1.2",
        "assert app.config['LIST'] == [1, 2]",
        "assert app.config['DICT'] == {'k': 'v'}",
        "assert 'OTHER' not in app.config"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_from_prefixed_env_custom_prefix",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_config.py",
      "line_number": 69,
      "end_line_number": 76,
      "source_code": "def test_from_prefixed_env_custom_prefix(monkeypatch):\n    monkeypatch.setenv(\"FLASK_A\", \"a\")\n    monkeypatch.setenv(\"NOT_FLASK_A\", \"b\")\n\n    app = flask.Flask(__name__)\n    app.config.from_prefixed_env(\"NOT_FLASK\")\n\n    assert app.config[\"A\"] == \"b\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "json",
        "os",
        "pytest",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.config['A'] == 'b'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_from_prefixed_env_nested",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_config.py",
      "line_number": 79,
      "end_line_number": 107,
      "source_code": "def test_from_prefixed_env_nested(monkeypatch):\n    monkeypatch.setenv(\"FLASK_EXIST__ok\", \"other\")\n    monkeypatch.setenv(\"FLASK_EXIST__inner__ik\", \"2\")\n    monkeypatch.setenv(\"FLASK_EXIST__new__more\", '{\"k\": false}')\n    monkeypatch.setenv(\"FLASK_NEW__K\", \"v\")\n\n    app = flask.Flask(__name__)\n    app.config[\"EXIST\"] = {\"ok\": \"value\", \"flag\": True, \"inner\": {\"ik\": 1}}\n    app.config.from_prefixed_env()\n\n    if os.name != \"nt\":\n        assert app.config[\"EXIST\"] == {\n            \"ok\": \"other\",\n            \"flag\": True,\n            \"inner\": {\"ik\": 2},\n            \"new\": {\"more\": {\"k\": False}},\n        }\n    else:\n        # Windows env var keys are always uppercase.\n        assert app.config[\"EXIST\"] == {\n            \"ok\": \"value\",\n            \"OK\": \"other\",\n            \"flag\": True,\n            \"inner\": {\"ik\": 1},\n            \"INNER\": {\"IK\": 2},\n            \"NEW\": {\"MORE\": {\"k\": False}},\n        }\n\n    assert app.config[\"NEW\"] == {\"K\": \"v\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "json",
        "os",
        "pytest",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.config['NEW'] == {'K': 'v'}",
        "assert app.config['EXIST'] == {'ok': 'other', 'flag': True, 'inner': {'ik': 2}, 'new': {'more': {'k': False}}}",
        "assert app.config['EXIST'] == {'ok': 'value', 'OK': 'other', 'flag': True, 'inner': {'ik': 1}, 'INNER': {'IK': 2}, 'NEW': {'MORE': {'k': False}}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_config_from_mapping",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_config.py",
      "line_number": 110,
      "end_line_number": 129,
      "source_code": "def test_config_from_mapping():\n    app = flask.Flask(__name__)\n    app.config.from_mapping({\"SECRET_KEY\": \"config\", \"TEST_KEY\": \"foo\"})\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    app.config.from_mapping([(\"SECRET_KEY\", \"config\"), (\"TEST_KEY\", \"foo\")])\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    app.config.from_mapping(SECRET_KEY=\"config\", TEST_KEY=\"foo\")\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    app.config.from_mapping(SECRET_KEY=\"config\", TEST_KEY=\"foo\", skip_key=\"skip\")\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    with pytest.raises(TypeError):\n        app.config.from_mapping({}, {})",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "json",
        "os",
        "pytest",
        "flask"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "common_object_test",
          "body": "def common_object_test(app):\n    assert app.secret_key == 'config'\n    assert app.config['TEST_KEY'] == 'foo'\n    assert 'TestConfig' not in app.config"
        },
        {
          "name": "common_object_test",
          "body": "def common_object_test(app):\n    assert app.secret_key == 'config'\n    assert app.config['TEST_KEY'] == 'foo'\n    assert 'TestConfig' not in app.config"
        },
        {
          "name": "common_object_test",
          "body": "def common_object_test(app):\n    assert app.secret_key == 'config'\n    assert app.config['TEST_KEY'] == 'foo'\n    assert 'TestConfig' not in app.config"
        },
        {
          "name": "common_object_test",
          "body": "def common_object_test(app):\n    assert app.secret_key == 'config'\n    assert app.config['TEST_KEY'] == 'foo'\n    assert 'TestConfig' not in app.config"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:\nThe `test_config_from_mapping` function is designed to verify the behavior of the Flask application's configuration system when loading configuration values from various mapping formats. It ensures that the application correctly sets the `SECRET_KEY` and `TEST_KEY` from different input types and handles errors appropriately.\n\n**Specific Functionality or Behavior Verified**:\nThe test checks that the application can successfully load configuration values from:\n1. A dictionary.\n2. A list of tuples.\n3. Keyword arguments.\n4. A dictionary with additional keys.\nAdditionally, it verifies that a `TypeError` is raised when an invalid input (two empty dictionaries) is provided.\n\n**Code Being Tested and How It Works**:\nThe code under test is the `from_mapping` method of the Flask application's configuration object. This method is responsible for populating the app's configuration from the provided mapping. The `common_object_test` function is called after each configuration load to assert that the `SECRET_KEY` is set to \"config\", the `TEST_KEY` is set to \"foo\", and that \"TestConfig\" is not present in the configuration.\n\n**Notable Testing Patterns or Techniques Used**:\n- **Parameterization**: The test uses multiple calls to `app.config.from_mapping` with different input formats to ensure comprehensive coverage of the method's functionality.\n- **Error Handling**: The test includes a context manager (`with pytest.raises(TypeError)`) to assert that the correct exception is raised for invalid input, demonstrating the importance of robust error handling in configuration management.\n- **Common Assertion Function**: The use of `common_object_test` encapsulates the assertions, promoting code reuse and clarity in the test structure. This pattern helps maintain consistency in verifying expected outcomes across different test cases."
    },
    {
      "name": "test_config_from_class",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_config.py",
      "line_number": 132,
      "end_line_number": 141,
      "source_code": "def test_config_from_class():\n    class Base:\n        TEST_KEY = \"foo\"\n\n    class Test(Base):\n        SECRET_KEY = \"config\"\n\n    app = flask.Flask(__name__)\n    app.config.from_object(Test)\n    common_object_test(app)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "json",
        "os",
        "pytest",
        "flask"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "common_object_test",
          "body": "def common_object_test(app):\n    assert app.secret_key == 'config'\n    assert app.config['TEST_KEY'] == 'foo'\n    assert 'TestConfig' not in app.config"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_config_from_class` function is designed to verify that a Flask application can correctly load configuration settings from a specified class. This ensures that the application can utilize configuration values defined in a class structure, which is a common practice in Flask applications for organizing settings.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the Flask application correctly sets the `SECRET_KEY` and retrieves the `TEST_KEY` from the configuration class. It also verifies that the configuration does not include any unexpected keys, specifically checking that 'TestConfig' is not present in the app's configuration.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `from_object` method of the Flask app's configuration, which loads configuration values from a given class. In this case, the `Test` class inherits from `Base`, which contains a `TEST_KEY`. The `SECRET_KEY` is directly defined in the `Test` class. The `common_object_test` function is then called to assert that the values are correctly set in the Flask app's configuration.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Class-based Configuration**: The test demonstrates the use of class inheritance to organize configuration settings, which promotes better structure and maintainability.\n- **Assertion Testing**: The test employs assertions to validate the expected state of the application configuration after loading it from the class.\n- **Separation of Concerns**: The use of a separate function (`common_object_test`) to perform assertions allows for reusability and cleaner test organization, making it easier to maintain and extend tests for different configurations."
    },
    {
      "name": "test_config_from_envvar",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_config.py",
      "line_number": 144,
      "end_line_number": 158,
      "source_code": "def test_config_from_envvar(monkeypatch):\n    monkeypatch.setattr(\"os.environ\", {})\n    app = flask.Flask(__name__)\n\n    with pytest.raises(RuntimeError) as e:\n        app.config.from_envvar(\"FOO_SETTINGS\")\n\n    assert \"'FOO_SETTINGS' is not set\" in str(e.value)\n    assert not app.config.from_envvar(\"FOO_SETTINGS\", silent=True)\n\n    monkeypatch.setattr(\n        \"os.environ\", {\"FOO_SETTINGS\": f\"{__file__.rsplit('.', 1)[0]}.py\"}\n    )\n    assert app.config.from_envvar(\"FOO_SETTINGS\")\n    common_object_test(app)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "json",
        "os",
        "pytest",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert \"'FOO_SETTINGS' is not set\" in str(e.value)",
        "assert not app.config.from_envvar('FOO_SETTINGS', silent=True)",
        "assert app.config.from_envvar('FOO_SETTINGS')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "common_object_test",
          "body": "def common_object_test(app):\n    assert app.secret_key == 'config'\n    assert app.config['TEST_KEY'] == 'foo'\n    assert 'TestConfig' not in app.config"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_config_from_envvar` function is designed to verify the behavior of the Flask application configuration when loading settings from environment variables. It ensures that the application correctly raises errors when the expected environment variable is not set and successfully loads configuration when it is set.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main scenarios: \n1. It verifies that a `RuntimeError` is raised with the appropriate message when the environment variable `FOO_SETTINGS` is not defined.\n2. It confirms that the application can successfully load configuration settings from a specified file when the environment variable is set to a valid file path.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `from_envvar` method of the Flask application's configuration object. This method attempts to load configuration settings from a file specified by an environment variable. If the variable is not set, it raises a `RuntimeError`. If the variable points to a non-existent file, it raises an `IOError`. The test uses `monkeypatch` to manipulate the environment variables during the test execution, allowing it to simulate both scenarios.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Monkeypatching**: The test uses the `monkeypatch` fixture from `pytest` to temporarily modify the `os.environ` dictionary, allowing the test to simulate different environment variable states without affecting the global environment.\n- **Exception Testing**: The test employs `pytest.raises` to assert that specific exceptions are raised under certain conditions, ensuring that error handling in the application is functioning as expected.\n- **Assertions**: The test includes assertions to verify the correctness of error messages and the successful loading of configuration settings, ensuring that the application behaves as intended in both success and failure scenarios."
    },
    {
      "name": "test_config_from_envvar_missing",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_config.py",
      "line_number": 161,
      "end_line_number": 171,
      "source_code": "def test_config_from_envvar_missing(monkeypatch):\n    monkeypatch.setattr(\"os.environ\", {\"FOO_SETTINGS\": \"missing.cfg\"})\n    app = flask.Flask(__name__)\n    with pytest.raises(IOError) as e:\n        app.config.from_envvar(\"FOO_SETTINGS\")\n    msg = str(e.value)\n    assert msg.startswith(\n        \"[Errno 2] Unable to load configuration file (No such file or directory):\"\n    )\n    assert msg.endswith(\"missing.cfg'\")\n    assert not app.config.from_envvar(\"FOO_SETTINGS\", silent=True)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "json",
        "os",
        "pytest",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg.startswith('[Errno 2] Unable to load configuration file (No such file or directory):')",
        "assert msg.endswith(\"missing.cfg'\")",
        "assert not app.config.from_envvar('FOO_SETTINGS', silent=True)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_config_missing",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_config.py",
      "line_number": 174,
      "end_line_number": 183,
      "source_code": "def test_config_missing():\n    app = flask.Flask(__name__)\n    with pytest.raises(IOError) as e:\n        app.config.from_pyfile(\"missing.cfg\")\n    msg = str(e.value)\n    assert msg.startswith(\n        \"[Errno 2] Unable to load configuration file (No such file or directory):\"\n    )\n    assert msg.endswith(\"missing.cfg'\")\n    assert not app.config.from_pyfile(\"missing.cfg\", silent=True)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "json",
        "os",
        "pytest",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg.startswith('[Errno 2] Unable to load configuration file (No such file or directory):')",
        "assert msg.endswith(\"missing.cfg'\")",
        "assert not app.config.from_pyfile('missing.cfg', silent=True)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_config_missing_file",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_config.py",
      "line_number": 186,
      "end_line_number": 195,
      "source_code": "def test_config_missing_file():\n    app = flask.Flask(__name__)\n    with pytest.raises(IOError) as e:\n        app.config.from_file(\"missing.json\", load=json.load)\n    msg = str(e.value)\n    assert msg.startswith(\n        \"[Errno 2] Unable to load configuration file (No such file or directory):\"\n    )\n    assert msg.endswith(\"missing.json'\")\n    assert not app.config.from_file(\"missing.json\", load=json.load, silent=True)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "json",
        "os",
        "pytest",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg.startswith('[Errno 2] Unable to load configuration file (No such file or directory):')",
        "assert msg.endswith(\"missing.json'\")",
        "assert not app.config.from_file('missing.json', load=json.load, silent=True)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_custom_config_class",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_config.py",
      "line_number": 198,
      "end_line_number": 208,
      "source_code": "def test_custom_config_class():\n    class Config(flask.Config):\n        pass\n\n    class Flask(flask.Flask):\n        config_class = Config\n\n    app = Flask(__name__)\n    assert isinstance(app.config, Config)\n    app.config.from_object(__name__)\n    common_object_test(app)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "json",
        "os",
        "pytest",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(app.config, Config)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "common_object_test",
          "body": "def common_object_test(app):\n    assert app.secret_key == 'config'\n    assert app.config['TEST_KEY'] == 'foo'\n    assert 'TestConfig' not in app.config"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_custom_config_class` unit test is designed to verify that a custom configuration class can be successfully used with a Flask application. It ensures that the application correctly recognizes and utilizes the specified configuration class, which is crucial for managing application settings.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the `app.config` is an instance of the custom `Config` class. It also verifies that the application can load configuration values from the current module and that the `common_object_test` function correctly validates specific configuration values, such as `secret_key` and `TEST_KEY`.\n\n**Code Being Tested and How It Works**:  \nThe test defines a custom `Config` class that inherits from `flask.Config` and a custom `Flask` class that sets `config_class` to the custom `Config`. An instance of the custom `Flask` application is created, and the test asserts that `app.config` is an instance of `Config`. The `app.config.from_object(__name__)` method is called to load configuration values from the current module, which should include `secret_key` and `TEST_KEY`. The `common_object_test` function is then invoked to perform additional assertions on the configuration.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate expected behaviors, which is a common pattern in unit testing. It also utilizes a custom configuration class to demonstrate the flexibility of Flask's configuration system. The test structure is straightforward, focusing on instantiation and configuration loading, which is typical in testing frameworks like pytest. Additionally, the test leverages the `assert` statement for clarity and simplicity in verifying conditions."
    },
    {
      "name": "test_session_lifetime",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_config.py",
      "line_number": 211,
      "end_line_number": 214,
      "source_code": "def test_session_lifetime():\n    app = flask.Flask(__name__)\n    app.config[\"PERMANENT_SESSION_LIFETIME\"] = 42\n    assert app.permanent_session_lifetime.seconds == 42",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "json",
        "os",
        "pytest",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.permanent_session_lifetime.seconds == 42"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_get_namespace",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_config.py",
      "line_number": 217,
      "end_line_number": 240,
      "source_code": "def test_get_namespace():\n    app = flask.Flask(__name__)\n    app.config[\"FOO_OPTION_1\"] = \"foo option 1\"\n    app.config[\"FOO_OPTION_2\"] = \"foo option 2\"\n    app.config[\"BAR_STUFF_1\"] = \"bar stuff 1\"\n    app.config[\"BAR_STUFF_2\"] = \"bar stuff 2\"\n    foo_options = app.config.get_namespace(\"FOO_\")\n    assert 2 == len(foo_options)\n    assert \"foo option 1\" == foo_options[\"option_1\"]\n    assert \"foo option 2\" == foo_options[\"option_2\"]\n    bar_options = app.config.get_namespace(\"BAR_\", lowercase=False)\n    assert 2 == len(bar_options)\n    assert \"bar stuff 1\" == bar_options[\"STUFF_1\"]\n    assert \"bar stuff 2\" == bar_options[\"STUFF_2\"]\n    foo_options = app.config.get_namespace(\"FOO_\", trim_namespace=False)\n    assert 2 == len(foo_options)\n    assert \"foo option 1\" == foo_options[\"foo_option_1\"]\n    assert \"foo option 2\" == foo_options[\"foo_option_2\"]\n    bar_options = app.config.get_namespace(\n        \"BAR_\", lowercase=False, trim_namespace=False\n    )\n    assert 2 == len(bar_options)\n    assert \"bar stuff 1\" == bar_options[\"BAR_STUFF_1\"]\n    assert \"bar stuff 2\" == bar_options[\"BAR_STUFF_2\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "json",
        "os",
        "pytest",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert 2 == len(foo_options)",
        "assert 'foo option 1' == foo_options['option_1']",
        "assert 'foo option 2' == foo_options['option_2']",
        "assert 2 == len(bar_options)",
        "assert 'bar stuff 1' == bar_options['STUFF_1']",
        "assert 'bar stuff 2' == bar_options['STUFF_2']",
        "assert 2 == len(foo_options)",
        "assert 'foo option 1' == foo_options['foo_option_1']",
        "assert 'foo option 2' == foo_options['foo_option_2']",
        "assert 2 == len(bar_options)",
        "assert 'bar stuff 1' == bar_options['BAR_STUFF_1']",
        "assert 'bar stuff 2' == bar_options['BAR_STUFF_2']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_from_pyfile_weird_encoding",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_config.py",
      "line_number": 244,
      "end_line_number": 250,
      "source_code": "def test_from_pyfile_weird_encoding(tmp_path, encoding):\n    f = tmp_path / \"my_config.py\"\n    f.write_text(f'# -*- coding: {encoding} -*-\\nTEST_VALUE = \"f\u00f6\u00f6\"\\n', encoding)\n    app = flask.Flask(__name__)\n    app.config.from_pyfile(os.fspath(f))\n    value = app.config[\"TEST_VALUE\"]\n    assert value == \"f\u00f6\u00f6\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('encoding', ['utf-8', 'iso-8859-15', 'latin-1'])"
      ],
      "arguments": [
        "tmp_path",
        "encoding"
      ],
      "imports": [
        "json",
        "os",
        "pytest",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert value == 'f\u00f6\u00f6'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_basic_view",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_views.py",
      "line_number": 17,
      "end_line_number": 25,
      "source_code": "def test_basic_view(app):\n    class Index(flask.views.View):\n        methods = [\"GET\", \"POST\"]\n\n        def dispatch_request(self):\n            return flask.request.method\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n    common_test(app)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "werkzeug.http.parse_set_header",
        "flask.views"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "common_test",
          "body": "def common_test(app):\n    c = app.test_client()\n    assert c.get('/').data == b'GET'\n    assert c.post('/').data == b'POST'\n    assert c.put('/').status_code == 405\n    meths = parse_set_header(c.open('/', method='OPTIONS').headers['Allow'])\n    assert sorted(meths) == ['GET', 'HEAD', 'OPTIONS', 'POST']"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_basic_view` function is designed to verify the behavior of a basic Flask view that handles HTTP GET and POST requests. It ensures that the view correctly responds to these methods and that the appropriate HTTP status codes are returned for unsupported methods.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n- A GET request to the root URL (\"/\") returns \"GET\".\n- A POST request to the same URL returns \"POST\".\n- A PUT request to the URL returns a 405 Method Not Allowed status.\n- The OPTIONS request returns the correct allowed methods, which should include GET, HEAD, OPTIONS, and POST.\n\n**Code Being Tested and How It Works**:  \nThe code under test defines a class `Index` that inherits from `flask.views.View`. It specifies that the view can handle GET and POST requests through the `methods` attribute. The `dispatch_request` method returns the HTTP method of the request. The view is registered with the Flask application using `app.add_url_rule`, mapping the root URL to the `Index` view. The `common_test` function is then called to perform the assertions.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Test Client**: The test utilizes Flask's built-in test client (`app.test_client()`) to simulate HTTP requests to the application without needing to run a server.\n- **Assertions**: The test employs assertions to validate the responses from the client, checking both the response data and status codes.\n- **Separation of Concerns**: The `common_test` function encapsulates the common assertions for different views, promoting code reuse and clarity in testing multiple view implementations."
    },
    {
      "name": "test_method_based_view",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_views.py",
      "line_number": 28,
      "end_line_number": 38,
      "source_code": "def test_method_based_view(app):\n    class Index(flask.views.MethodView):\n        def get(self):\n            return \"GET\"\n\n        def post(self):\n            return \"POST\"\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n\n    common_test(app)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "werkzeug.http.parse_set_header",
        "flask.views"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "common_test",
          "body": "def common_test(app):\n    c = app.test_client()\n    assert c.get('/').data == b'GET'\n    assert c.post('/').data == b'POST'\n    assert c.put('/').status_code == 405\n    meths = parse_set_header(c.open('/', method='OPTIONS').headers['Allow'])\n    assert sorted(meths) == ['GET', 'HEAD', 'OPTIONS', 'POST']"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_method_based_view` function is designed to verify the behavior of a Flask `MethodView`, specifically ensuring that it correctly handles HTTP GET and POST requests, while also confirming that unsupported methods return the appropriate status code.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that:\n1. A GET request to the root URL (\"/\") returns the string \"GET\".\n2. A POST request to the same URL returns the string \"POST\".\n3. A PUT request to the URL returns a 405 Method Not Allowed status code.\n4. The OPTIONS request correctly lists the allowed methods for the view.\n\n**Code Being Tested and How It Works**:  \nThe code under test defines a class `Index` that inherits from `flask.views.MethodView`. It implements two methods: `get` and `post`, which return \"GET\" and \"POST\" respectively. The `app.add_url_rule` method registers this view with the root URL. The `common_test` function is then called to perform the actual assertions against the registered view.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Test Client**: The test utilizes Flask's test client to simulate HTTP requests to the application, allowing for easy verification of responses.\n- **Assertions**: The test employs assertions to validate the expected outcomes of the requests, ensuring that the view behaves as intended.\n- **Separation of Concerns**: The use of a `common_test` function allows for code reuse across different tests, promoting DRY (Don't Repeat Yourself) principles and making the tests easier to maintain."
    },
    {
      "name": "test_view_patching",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_views.py",
      "line_number": 41,
      "end_line_number": 59,
      "source_code": "def test_view_patching(app):\n    class Index(flask.views.MethodView):\n        def get(self):\n            raise ZeroDivisionError\n\n        def post(self):\n            raise ZeroDivisionError\n\n    class Other(Index):\n        def get(self):\n            return \"GET\"\n\n        def post(self):\n            return \"POST\"\n\n    view = Index.as_view(\"index\")\n    view.view_class = Other\n    app.add_url_rule(\"/\", view_func=view)\n    common_test(app)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "werkzeug.http.parse_set_header",
        "flask.views"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "common_test",
          "body": "def common_test(app):\n    c = app.test_client()\n    assert c.get('/').data == b'GET'\n    assert c.post('/').data == b'POST'\n    assert c.put('/').status_code == 405\n    meths = parse_set_header(c.open('/', method='OPTIONS').headers['Allow'])\n    assert sorted(meths) == ['GET', 'HEAD', 'OPTIONS', 'POST']"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_view_patching` function is designed to verify the behavior of Flask's method-based views when a view class is dynamically replaced. It ensures that the new view class correctly handles HTTP methods and that the routing behaves as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when the `Index` view class, which raises exceptions for GET and POST requests, is replaced by the `Other` class (which returns \"GET\" and \"POST\" responses), the application correctly responds to these methods. It also verifies that unsupported methods (like PUT) return a 405 status code, and that the OPTIONS method returns the correct allowed methods.\n\n**Code Being Tested and How It Works**:  \nThe test defines two classes: `Index`, which raises `ZeroDivisionError` for GET and POST requests, and `Other`, which provides valid responses for the same methods. The `view` is created from `Index`, but its `view_class` is set to `Other`. The view is then registered with the Flask app at the root URL (\"/\"). The `common_test` function is called to perform the actual assertions, checking the responses for GET, POST, and PUT requests, as well as the allowed methods via OPTIONS.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Class-based Views**: The test utilizes Flask's class-based views to encapsulate HTTP method handling, demonstrating how to extend and modify view behavior.\n- **Dynamic View Replacement**: It showcases the ability to change the view class dynamically, which is a powerful feature in Flask for modifying behavior at runtime.\n- **Test Client**: The use of `app.test_client()` allows for simulating requests to the application, making it easy to assert expected outcomes without needing to run a server.\n- **Common Test Function**: The `common_test` function is a reusable pattern that encapsulates common assertions, promoting DRY (Don't Repeat Yourself) principles in the test suite."
    },
    {
      "name": "test_view_inheritance",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_views.py",
      "line_number": 62,
      "end_line_number": 77,
      "source_code": "def test_view_inheritance(app, client):\n    class Index(flask.views.MethodView):\n        def get(self):\n            return \"GET\"\n\n        def post(self):\n            return \"POST\"\n\n    class BetterIndex(Index):\n        def delete(self):\n            return \"DELETE\"\n\n    app.add_url_rule(\"/\", view_func=BetterIndex.as_view(\"index\"))\n\n    meths = parse_set_header(client.open(\"/\", method=\"OPTIONS\").headers[\"Allow\"])\n    assert sorted(meths) == [\"DELETE\", \"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "werkzeug.http.parse_set_header",
        "flask.views"
      ],
      "fixtures": [],
      "assertions": [
        "assert sorted(meths) == ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_view_decorators",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_views.py",
      "line_number": 80,
      "end_line_number": 98,
      "source_code": "def test_view_decorators(app, client):\n    def add_x_parachute(f):\n        def new_function(*args, **kwargs):\n            resp = flask.make_response(f(*args, **kwargs))\n            resp.headers[\"X-Parachute\"] = \"awesome\"\n            return resp\n\n        return new_function\n\n    class Index(flask.views.View):\n        decorators = [add_x_parachute]\n\n        def dispatch_request(self):\n            return \"Awesome\"\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n    rv = client.get(\"/\")\n    assert rv.headers[\"X-Parachute\"] == \"awesome\"\n    assert rv.data == b\"Awesome\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "werkzeug.http.parse_set_header",
        "flask.views"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.headers['X-Parachute'] == 'awesome'",
        "assert rv.data == b'Awesome'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_view_decorators` test is to verify that the custom decorator `add_x_parachute` correctly modifies the response of a Flask view by adding a specific header and returning the expected response body.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a GET request is made to the root URL (\"/\"), the response includes a header \"X-Parachute\" with the value \"awesome\" and that the response body is \"Awesome\". This ensures that the decorator is functioning as intended.\n\n**Code Being Tested and How It Works**:  \nThe code under test defines a Flask view class `Index` that uses the `add_x_parachute` decorator. The decorator wraps the original view function, modifies the response by adding a header, and then returns the modified response. The test sets up a Flask application, registers the view, and uses a test client to simulate a GET request to the root URL. The assertions check the presence and correctness of the header and response body.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Decorator Testing**: It tests the behavior of a decorator applied to a view, ensuring that it modifies the response as expected.\n- **Flask Testing Client**: It uses Flask's test client to simulate HTTP requests and capture responses, allowing for easy verification of the application's behavior.\n- **Assertions**: The test uses assertions to validate the response's headers and body, which is a common practice in unit testing to ensure correctness."
    },
    {
      "name": "test_view_provide_automatic_options_attr",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_views.py",
      "line_number": 101,
      "end_line_number": 138,
      "source_code": "def test_view_provide_automatic_options_attr():\n    app = flask.Flask(__name__)\n\n    class Index1(flask.views.View):\n        provide_automatic_options = False\n\n        def dispatch_request(self):\n            return \"Hello World!\"\n\n    app.add_url_rule(\"/\", view_func=Index1.as_view(\"index\"))\n    c = app.test_client()\n    rv = c.open(\"/\", method=\"OPTIONS\")\n    assert rv.status_code == 405\n\n    app = flask.Flask(__name__)\n\n    class Index2(flask.views.View):\n        methods = [\"OPTIONS\"]\n        provide_automatic_options = True\n\n        def dispatch_request(self):\n            return \"Hello World!\"\n\n    app.add_url_rule(\"/\", view_func=Index2.as_view(\"index\"))\n    c = app.test_client()\n    rv = c.open(\"/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"OPTIONS\"]\n\n    app = flask.Flask(__name__)\n\n    class Index3(flask.views.View):\n        def dispatch_request(self):\n            return \"Hello World!\"\n\n    app.add_url_rule(\"/\", view_func=Index3.as_view(\"index\"))\n    c = app.test_client()\n    rv = c.open(\"/\", method=\"OPTIONS\")\n    assert \"OPTIONS\" in rv.allow",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "werkzeug.http.parse_set_header",
        "flask.views"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 405",
        "assert sorted(rv.allow) == ['OPTIONS']",
        "assert 'OPTIONS' in rv.allow"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_implicit_head",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_views.py",
      "line_number": 141,
      "end_line_number": 152,
      "source_code": "def test_implicit_head(app, client):\n    class Index(flask.views.MethodView):\n        def get(self):\n            return flask.Response(\"Blub\", headers={\"X-Method\": flask.request.method})\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n    rv = client.get(\"/\")\n    assert rv.data == b\"Blub\"\n    assert rv.headers[\"X-Method\"] == \"GET\"\n    rv = client.head(\"/\")\n    assert rv.data == b\"\"\n    assert rv.headers[\"X-Method\"] == \"HEAD\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "werkzeug.http.parse_set_header",
        "flask.views"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'Blub'",
        "assert rv.headers['X-Method'] == 'GET'",
        "assert rv.data == b''",
        "assert rv.headers['X-Method'] == 'HEAD'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.head",
          "body": "def head(self):\n    return flask.Response('', headers={'X-Method': 'HEAD'})"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_implicit_head` function is designed to verify the behavior of a Flask application when handling HTTP GET and HEAD requests. It specifically checks that the application correctly responds to these requests with the expected data and headers.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies that:\n1. A GET request to the root URL (\"/\") returns the expected response body (\"Blub\") and the correct method in the headers (\"GET\").\n2. A HEAD request to the same URL returns an empty response body and the correct method in the headers (\"HEAD\").\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a Flask view class `Index` that defines a `get` method returning a response with the body \"Blub\" and a header indicating the request method. The test sets up this view at the root URL (\"/\") and uses the Flask test client to simulate GET and HEAD requests. The assertions check that the responses match the expected values.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Flask Test Client**: The test utilizes Flask's built-in test client to simulate HTTP requests, allowing for easy verification of response data and headers.\n- **Assertions**: The test employs assertions to validate that the actual responses match the expected outcomes, ensuring that the application behaves correctly for both GET and HEAD requests.\n- **MethodView**: The use of `flask.views.MethodView` allows for a clean separation of HTTP methods within the same view class, promoting organized and maintainable code."
    },
    {
      "name": "test_explicit_head",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_views.py",
      "line_number": 155,
      "end_line_number": 168,
      "source_code": "def test_explicit_head(app, client):\n    class Index(flask.views.MethodView):\n        def get(self):\n            return \"GET\"\n\n        def head(self):\n            return flask.Response(\"\", headers={\"X-Method\": \"HEAD\"})\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n    rv = client.get(\"/\")\n    assert rv.data == b\"GET\"\n    rv = client.head(\"/\")\n    assert rv.data == b\"\"\n    assert rv.headers[\"X-Method\"] == \"HEAD\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "werkzeug.http.parse_set_header",
        "flask.views"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'GET'",
        "assert rv.data == b''",
        "assert rv.headers['X-Method'] == 'HEAD'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.head",
          "body": "def head(self):\n    return flask.Response('', headers={'X-Method': 'HEAD'})"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_explicit_head` function is designed to verify the behavior of a Flask view that explicitly handles both GET and HEAD HTTP methods. It ensures that the view correctly responds to these methods with the expected data and headers.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that:\n1. A GET request to the root URL (\"/\") returns the string \"GET\".\n2. A HEAD request to the same URL returns an empty body but includes a custom header indicating the method used (i.e., \"HEAD\").\n\n**Code Being Tested and How It Works**:  \nThe code under test defines a Flask view class `Index` that implements two methods:\n- `get`: Returns the string \"GET\".\n- `head`: Returns an empty response with a header `X-Method` set to \"HEAD\".\n\nThe test adds this view to the Flask application and then uses the test client to make GET and HEAD requests to the root URL. The assertions check that the responses match the expected outputs.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Flask Testing Client**: The test utilizes Flask's built-in testing client to simulate HTTP requests, allowing for easy verification of response data and headers.\n- **Assertions**: The test employs assertions to validate the response data and headers, ensuring that the view behaves as intended for both GET and HEAD requests.\n- **Method Overriding**: The test demonstrates the use of method overriding in Flask views, showcasing how different HTTP methods can be handled distinctly within the same view class."
    },
    {
      "name": "test_endpoint_override",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_views.py",
      "line_number": 171,
      "end_line_number": 186,
      "source_code": "def test_endpoint_override(app):\n    app.debug = True\n\n    class Index(flask.views.View):\n        methods = [\"GET\", \"POST\"]\n\n        def dispatch_request(self):\n            return flask.request.method\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n\n    with pytest.raises(AssertionError):\n        app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n\n    # But these tests should still pass. We just log a warning.\n    common_test(app)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "werkzeug.http.parse_set_header",
        "flask.views"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "common_test",
          "body": "def common_test(app):\n    c = app.test_client()\n    assert c.get('/').data == b'GET'\n    assert c.post('/').data == b'POST'\n    assert c.put('/').status_code == 405\n    meths = parse_set_header(c.open('/', method='OPTIONS').headers['Allow'])\n    assert sorted(meths) == ['GET', 'HEAD', 'OPTIONS', 'POST']"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_endpoint_override` function is designed to verify that adding a URL rule for an existing endpoint in a Flask application raises an `AssertionError`. This ensures that the application correctly handles attempts to override existing routes, which is crucial for maintaining the integrity of the routing system.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when an attempt is made to add a URL rule for the root endpoint (\"/\") using the same view function (`Index`), an `AssertionError` is raised. This behavior is expected because Flask should not allow the same endpoint to be registered multiple times with different view functions.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `Index` class, which is a subclass of `flask.views.View`. It defines a `dispatch_request` method that returns the HTTP method of the request. The test first adds this view to the Flask app for the root URL. It then attempts to add the same view again, which should trigger an `AssertionError`. The `common_test` function is called afterward to ensure that the application still behaves correctly for GET and POST requests, confirming that the initial route setup is valid.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The test uses a context manager (`with pytest.raises(AssertionError)`) to assert that a specific exception is raised during the execution of the code block, which is a common pattern in unit testing for verifying error conditions.\n- **Separation of Concerns**: The test separates the verification of the route registration from the functional tests in `common_test`, allowing for focused testing of specific behaviors.\n- **Use of Flask's Test Client**: The `common_test` function utilizes Flask's test client to simulate requests to the application, which is a standard technique for testing web applications. This allows for comprehensive testing of the application's response to various HTTP methods."
    },
    {
      "name": "test_methods_var_inheritance",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_views.py",
      "line_number": 189,
      "end_line_number": 204,
      "source_code": "def test_methods_var_inheritance(app, client):\n    class BaseView(flask.views.MethodView):\n        methods = [\"GET\", \"PROPFIND\"]\n\n    class ChildView(BaseView):\n        def get(self):\n            return \"GET\"\n\n        def propfind(self):\n            return \"PROPFIND\"\n\n    app.add_url_rule(\"/\", view_func=ChildView.as_view(\"index\"))\n\n    assert client.get(\"/\").data == b\"GET\"\n    assert client.open(\"/\", method=\"PROPFIND\").data == b\"PROPFIND\"\n    assert ChildView.methods == {\"PROPFIND\", \"GET\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "werkzeug.http.parse_set_header",
        "flask.views"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/').data == b'GET'",
        "assert client.open('/', method='PROPFIND').data == b'PROPFIND'",
        "assert ChildView.methods == {'PROPFIND', 'GET'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_methods_var_inheritance` test verifies the behavior of method inheritance in Flask's `MethodView` class, specifically ensuring that child classes correctly inherit and can override HTTP methods defined in their parent classes.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the `ChildView` class can handle both `GET` and `PROPFIND` requests, returning the expected responses. It also verifies that the `methods` attribute of the `ChildView` class correctly reflects the inherited methods from its parent class, `BaseView`.\n\n**Code Being Tested and How It Works**:  \nThe test defines a `BaseView` class that specifies the allowed HTTP methods. The `ChildView` class inherits from `BaseView` and implements the `get` and `propfind` methods. The Flask application adds a URL rule that maps the root URL (\"/\") to the `ChildView`. The test then uses the Flask test client to send requests to this URL and asserts that the responses match the expected output for both methods. It also checks that the `methods` attribute of `ChildView` contains both `GET` and `PROPFIND`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Class-based Views**: The test utilizes Flask's class-based views to demonstrate method inheritance.\n- **Flask Test Client**: It employs the Flask test client to simulate HTTP requests and validate responses.\n- **Assertions**: The test uses assertions to confirm that the actual outputs match the expected results, ensuring that the inheritance and method handling work as intended."
    },
    {
      "name": "test_multiple_inheritance",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_views.py",
      "line_number": 207,
      "end_line_number": 223,
      "source_code": "def test_multiple_inheritance(app, client):\n    class GetView(flask.views.MethodView):\n        def get(self):\n            return \"GET\"\n\n    class DeleteView(flask.views.MethodView):\n        def delete(self):\n            return \"DELETE\"\n\n    class GetDeleteView(GetView, DeleteView):\n        pass\n\n    app.add_url_rule(\"/\", view_func=GetDeleteView.as_view(\"index\"))\n\n    assert client.get(\"/\").data == b\"GET\"\n    assert client.delete(\"/\").data == b\"DELETE\"\n    assert sorted(GetDeleteView.methods) == [\"DELETE\", \"GET\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "werkzeug.http.parse_set_header",
        "flask.views"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/').data == b'GET'",
        "assert client.delete('/').data == b'DELETE'",
        "assert sorted(GetDeleteView.methods) == ['DELETE', 'GET']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.delete",
          "body": "def delete(self):\n    return 'DELETE'"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_multiple_inheritance` function is designed to verify the behavior of Flask's method views when using multiple inheritance. It ensures that the combined functionality of inherited views works correctly when registered with a Flask application.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. A GET request to the root URL (\"/\") returns the expected response from the `GetView` class.\n2. A DELETE request to the same URL returns the expected response from the `DeleteView` class.\n3. The methods available in the `GetDeleteView` class are correctly identified as both \"GET\" and \"DELETE\".\n\n**Code Being Tested and How It Works**:  \nThe test defines three classes:\n- `GetView`: Inherits from `flask.views.MethodView` and implements a `get` method that returns \"GET\".\n- `DeleteView`: Also inherits from `flask.views.MethodView` and implements a `delete` method that returns \"DELETE\".\n- `GetDeleteView`: Inherits from both `GetView` and `DeleteView`, thus combining their functionalities.\n\nThe `app.add_url_rule` method registers `GetDeleteView` to handle requests to the root URL. The assertions then test the responses from GET and DELETE requests, as well as the methods available in `GetDeleteView`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Method Overriding**: The test demonstrates the use of method overriding in Python through multiple inheritance, allowing the combined view to handle different HTTP methods.\n- **Flask Testing Client**: It utilizes Flask's testing client to simulate HTTP requests and verify responses, which is a common practice in testing web applications.\n- **Assertions**: The test employs assertions to validate the expected outcomes, ensuring that the application behaves as intended under the defined conditions."
    },
    {
      "name": "test_remove_method_from_parent",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_views.py",
      "line_number": 226,
      "end_line_number": 242,
      "source_code": "def test_remove_method_from_parent(app, client):\n    class GetView(flask.views.MethodView):\n        def get(self):\n            return \"GET\"\n\n    class OtherView(flask.views.MethodView):\n        def post(self):\n            return \"POST\"\n\n    class View(GetView, OtherView):\n        methods = [\"GET\"]\n\n    app.add_url_rule(\"/\", view_func=View.as_view(\"index\"))\n\n    assert client.get(\"/\").data == b\"GET\"\n    assert client.post(\"/\").status_code == 405\n    assert sorted(View.methods) == [\"GET\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "werkzeug.http.parse_set_header",
        "flask.views"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/').data == b'GET'",
        "assert client.post('/').status_code == 405",
        "assert sorted(View.methods) == ['GET']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_remove_method_from_parent` unit test is designed to verify the behavior of a Flask view that inherits from multiple parent views while restricting the allowed HTTP methods. Specifically, it checks that only the `GET` method is permitted, and that any attempt to use the `POST` method results in a `405 Method Not Allowed` response.\n\n**Specific Functionality or Behavior Verified**:  \nThe test ensures that the `View` class, which inherits from both `GetView` and `OtherView`, correctly limits its allowed methods to only `GET`. It verifies that a `GET` request returns the expected response and that a `POST` request is rejected with a `405` status code. Additionally, it checks that the `methods` attribute of the `View` class reflects this restriction.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the creation of a Flask view class (`View`) that inherits from two other view classes (`GetView` and `OtherView`). The `View` class explicitly sets its `methods` attribute to `[\"GET\"]`, overriding the inherited methods from its parent classes. The test adds this view to the Flask application at the root URL (`\"/\"`) and then uses the test client to simulate `GET` and `POST` requests to this endpoint. The expected behavior is that the `GET` request returns the string `\"GET\"` while the `POST` request results in a `405` error.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n1. **Class-based Views**: It utilizes Flask's class-based views (`MethodView`) to define the behavior of HTTP methods in a structured way.\n2. **Inheritance**: The test demonstrates multiple inheritance, showing how methods can be combined and overridden in a subclass.\n3. **Assertions**: It uses assertions to validate the responses from the client, ensuring that the application behaves as expected under different request methods.\n4. **Flask Test Client**: The test leverages Flask's test client to simulate HTTP requests, allowing for easy verification of the application's response without needing to run a live server."
    },
    {
      "name": "test_init_once",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_views.py",
      "line_number": 245,
      "end_line_number": 260,
      "source_code": "def test_init_once(app, client):\n    n = 0\n\n    class CountInit(flask.views.View):\n        init_every_request = False\n\n        def __init__(self):\n            nonlocal n\n            n += 1\n\n        def dispatch_request(self):\n            return str(n)\n\n    app.add_url_rule(\"/\", view_func=CountInit.as_view(\"index\"))\n    assert client.get(\"/\").data == b\"1\"\n    assert client.get(\"/\").data == b\"1\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "werkzeug.http.parse_set_header",
        "flask.views"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/').data == b'1'",
        "assert client.get('/').data == b'1'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_init_once` function is designed to verify that a Flask view class, when configured to not initialize a new instance for every request (`init_every_request = False`), correctly maintains state across multiple requests. Specifically, it checks that the instance of the view is only created once, and thus the initialization counter (`n`) should only increment once.\n\n**Specific Functionality or Behavior Verified**:  \nThe test asserts that when the view is accessed multiple times, the response remains consistent, indicating that the same instance of the view is being reused. The expected behavior is that the counter `n` should equal `1` for both requests, confirming that the view's constructor is called only once.\n\n**Code Being Tested and How It Works**:  \nThe code under test is a Flask view class `CountInit`, which overrides the `__init__` method to increment a counter `n` each time an instance is created. The view is registered to the root URL (\"/\"). The test uses a Flask test client to make two GET requests to this URL. The assertions check that both requests return the same data (`b\"1\"`), which indicates that the view instance was not re-initialized between requests.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Nonlocal Variable**: The use of `nonlocal n` allows the counter to be shared across the inner function scope, which is a technique to maintain state in nested functions.\n- **Flask Test Client**: The test utilizes Flask's test client to simulate HTTP requests, allowing for easy verification of the application's behavior without needing to run a live server.\n- **Assertions**: The test employs assertions to validate the expected outcomes, ensuring that the view behaves as intended under the specified conditions."
    },
    {
      "name": "test_error_handler_no_match",
      "module": "test_user_error_handler",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
      "line_number": 10,
      "end_line_number": 58,
      "source_code": "def test_error_handler_no_match(app, client):\n    class CustomException(Exception):\n        pass\n\n    @app.errorhandler(CustomException)\n    def custom_exception_handler(e):\n        assert isinstance(e, CustomException)\n        return \"custom\"\n\n    with pytest.raises(TypeError) as exc_info:\n        app.register_error_handler(CustomException(), None)\n\n    assert \"CustomException() is an instance, not a class.\" in str(exc_info.value)\n\n    with pytest.raises(ValueError) as exc_info:\n        app.register_error_handler(list, None)\n\n    assert \"'list' is not a subclass of Exception.\" in str(exc_info.value)\n\n    @app.errorhandler(500)\n    def handle_500(e):\n        assert isinstance(e, InternalServerError)\n\n        if e.original_exception is not None:\n            return f\"wrapped {type(e.original_exception).__name__}\"\n\n        return \"direct\"\n\n    with pytest.raises(ValueError) as exc_info:\n        app.register_error_handler(999, None)\n\n    assert \"Use a subclass of HTTPException\" in str(exc_info.value)\n\n    @app.route(\"/custom\")\n    def custom_test():\n        raise CustomException()\n\n    @app.route(\"/keyerror\")\n    def key_error():\n        raise KeyError()\n\n    @app.route(\"/abort\")\n    def do_abort():\n        flask.abort(500)\n\n    app.testing = False\n    assert client.get(\"/custom\").data == b\"custom\"\n    assert client.get(\"/keyerror\").data == b\"wrapped KeyError\"\n    assert client.get(\"/abort\").data == b\"direct\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.HTTPException",
        "werkzeug.exceptions.InternalServerError",
        "werkzeug.exceptions.NotFound",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'CustomException() is an instance, not a class.' in str(exc_info.value)",
        "assert \"'list' is not a subclass of Exception.\" in str(exc_info.value)",
        "assert 'Use a subclass of HTTPException' in str(exc_info.value)",
        "assert client.get('/custom').data == b'custom'",
        "assert client.get('/keyerror').data == b'wrapped KeyError'",
        "assert client.get('/abort').data == b'direct'",
        "assert isinstance(e, CustomException)",
        "assert isinstance(e, InternalServerError)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_error_handler_no_match` test is to verify the behavior of Flask's error handling mechanism when custom exceptions and HTTP exceptions are raised. It ensures that the application correctly registers error handlers and responds appropriately to various types of exceptions.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. Custom exceptions are handled correctly by the registered error handler.\n2. The application raises appropriate errors when trying to register invalid error handlers (e.g., instances instead of classes, non-exception types).\n3. The application correctly handles HTTP exceptions, specifically the `InternalServerError`, and wraps other exceptions as needed.\n4. The routes return the expected responses when exceptions are raised.\n\n**Code Being Tested and How It Works**:  \nThe test defines a custom exception `CustomException` and registers an error handler for it. It also tests the registration of error handlers for invalid cases, such as passing an instance of `CustomException` instead of the class itself, and for non-exception types like `list`. The test then defines routes that raise `CustomException`, `KeyError`, and abort with a 500 error. The `client.get` method is used to simulate requests to these routes, and the responses are asserted against expected values.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Exception Handling**: The test uses `pytest.raises` to assert that specific exceptions are raised when invalid error handlers are registered.\n- **Route Testing**: It leverages Flask's test client to simulate HTTP requests and validate the responses from the application.\n- **Assertions**: The test includes assertions to verify that the correct types of exceptions are raised and that the responses from the routes match the expected output.\n- **Error Handler Registration**: The test demonstrates the dynamic registration of error handlers and their expected behavior when exceptions occur."
    },
    {
      "name": "test_error_handler_subclass",
      "module": "test_user_error_handler",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
      "line_number": 61,
      "end_line_number": 97,
      "source_code": "def test_error_handler_subclass(app):\n    class ParentException(Exception):\n        pass\n\n    class ChildExceptionUnregistered(ParentException):\n        pass\n\n    class ChildExceptionRegistered(ParentException):\n        pass\n\n    @app.errorhandler(ParentException)\n    def parent_exception_handler(e):\n        assert isinstance(e, ParentException)\n        return \"parent\"\n\n    @app.errorhandler(ChildExceptionRegistered)\n    def child_exception_handler(e):\n        assert isinstance(e, ChildExceptionRegistered)\n        return \"child-registered\"\n\n    @app.route(\"/parent\")\n    def parent_test():\n        raise ParentException()\n\n    @app.route(\"/child-unregistered\")\n    def unregistered_test():\n        raise ChildExceptionUnregistered()\n\n    @app.route(\"/child-registered\")\n    def registered_test():\n        raise ChildExceptionRegistered()\n\n    c = app.test_client()\n\n    assert c.get(\"/parent\").data == b\"parent\"\n    assert c.get(\"/child-unregistered\").data == b\"parent\"\n    assert c.get(\"/child-registered\").data == b\"child-registered\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.HTTPException",
        "werkzeug.exceptions.InternalServerError",
        "werkzeug.exceptions.NotFound",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert c.get('/parent').data == b'parent'",
        "assert c.get('/child-unregistered').data == b'parent'",
        "assert c.get('/child-registered').data == b'child-registered'",
        "assert isinstance(e, ParentException)",
        "assert isinstance(e, ChildExceptionRegistered)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_error_handler_subclass` test is to verify the behavior of Flask's error handling mechanism when dealing with custom exceptions. It ensures that the appropriate error handlers are invoked for both registered and unregistered subclasses of a parent exception.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a `ParentException` is raised, the corresponding error handler returns the expected response. It also verifies that raising an unregistered subclass (`ChildExceptionUnregistered`) falls back to the parent exception handler, while raising a registered subclass (`ChildExceptionRegistered`) invokes its specific handler.\n\n**Code Being Tested and How It Works**:  \nThe test defines a Flask application with three routes that raise different exceptions. The `parent_exception_handler` is registered to handle `ParentException`, while `child_exception_handler` is registered for `ChildExceptionRegistered`. The test client makes GET requests to these routes, and the assertions check that the responses match the expected outputs based on the exception raised.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Error Handling Verification**: The test uses Flask's `@app.errorhandler` decorator to register custom error handlers, allowing for specific responses based on the type of exception raised.\n- **Assertions on Response Data**: The test employs assertions to validate the response data returned by the Flask application, ensuring that the correct handler is invoked based on the exception type.\n- **Use of Test Client**: The `app.test_client()` method is utilized to simulate requests to the application, enabling the testing of route behavior in a controlled environment."
    },
    {
      "name": "test_error_handler_http_subclass",
      "module": "test_user_error_handler",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
      "line_number": 100,
      "end_line_number": 133,
      "source_code": "def test_error_handler_http_subclass(app):\n    class ForbiddenSubclassRegistered(Forbidden):\n        pass\n\n    class ForbiddenSubclassUnregistered(Forbidden):\n        pass\n\n    @app.errorhandler(403)\n    def code_exception_handler(e):\n        assert isinstance(e, Forbidden)\n        return \"forbidden\"\n\n    @app.errorhandler(ForbiddenSubclassRegistered)\n    def subclass_exception_handler(e):\n        assert isinstance(e, ForbiddenSubclassRegistered)\n        return \"forbidden-registered\"\n\n    @app.route(\"/forbidden\")\n    def forbidden_test():\n        raise Forbidden()\n\n    @app.route(\"/forbidden-registered\")\n    def registered_test():\n        raise ForbiddenSubclassRegistered()\n\n    @app.route(\"/forbidden-unregistered\")\n    def unregistered_test():\n        raise ForbiddenSubclassUnregistered()\n\n    c = app.test_client()\n\n    assert c.get(\"/forbidden\").data == b\"forbidden\"\n    assert c.get(\"/forbidden-unregistered\").data == b\"forbidden\"\n    assert c.get(\"/forbidden-registered\").data == b\"forbidden-registered\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.HTTPException",
        "werkzeug.exceptions.InternalServerError",
        "werkzeug.exceptions.NotFound",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert c.get('/forbidden').data == b'forbidden'",
        "assert c.get('/forbidden-unregistered').data == b'forbidden'",
        "assert c.get('/forbidden-registered').data == b'forbidden-registered'",
        "assert isinstance(e, Forbidden)",
        "assert isinstance(e, ForbiddenSubclassRegistered)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_error_handler_http_subclass` test is to verify that the Flask application correctly handles HTTP errors, specifically the 403 Forbidden error, and its subclasses. It ensures that the appropriate error handlers are invoked based on the type of exception raised.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a `Forbidden` exception or its subclasses are raised, the correct response is returned. It verifies that the response for a standard `Forbidden` error is \"forbidden\", while a `ForbiddenSubclassRegistered` error returns \"forbidden-registered\". Additionally, it confirms that an unregistered subclass of `Forbidden` does not trigger a specific handler and defaults to the general 403 handler.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes Flask route handlers that raise exceptions and the corresponding error handlers that process these exceptions. The `forbidden_test` route raises a `Forbidden` exception, while `registered_test` raises a `ForbiddenSubclassRegistered` exception. The error handlers are defined using the `@app.errorhandler` decorator, which associates specific exception types with their handling functions. The test client (`c`) is used to simulate HTTP requests to these routes and check the responses.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Error Handling Verification**: It uses Flask's error handling mechanism to ensure that specific exceptions are caught and handled correctly.\n- **Subclass Testing**: It tests both registered and unregistered subclasses of exceptions to ensure that the application behaves as expected in different scenarios.\n- **Assertions**: The test includes assertions to validate the response data and the type of exceptions, ensuring that the correct error handling logic is executed.\n- **Test Client**: The use of `app.test_client()` allows for simulating requests to the application without needing to run a server, making the tests faster and more isolated."
    },
    {
      "name": "test_error_handler_blueprint",
      "module": "test_user_error_handler",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
      "line_number": 136,
      "end_line_number": 160,
      "source_code": "def test_error_handler_blueprint(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.errorhandler(500)\n    def bp_exception_handler(e):\n        return \"bp-error\"\n\n    @bp.route(\"/error\")\n    def bp_test():\n        raise InternalServerError()\n\n    @app.errorhandler(500)\n    def app_exception_handler(e):\n        return \"app-error\"\n\n    @app.route(\"/error\")\n    def app_test():\n        raise InternalServerError()\n\n    app.register_blueprint(bp, url_prefix=\"/bp\")\n\n    c = app.test_client()\n\n    assert c.get(\"/error\").data == b\"app-error\"\n    assert c.get(\"/bp/error\").data == b\"bp-error\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.HTTPException",
        "werkzeug.exceptions.InternalServerError",
        "werkzeug.exceptions.NotFound",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert c.get('/error').data == b'app-error'",
        "assert c.get('/bp/error').data == b'bp-error'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_error_handler_blueprint` unit test is designed to verify the behavior of error handling in a Flask application, specifically how different error handlers respond to exceptions raised in both the main application and a registered blueprint.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when an `InternalServerError` is raised in both the main application and the blueprint, the correct error handler is invoked, returning the expected error messages (\"app-error\" for the main app and \"bp-error\" for the blueprint).\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Flask application with a blueprint that has its own error handler for `InternalServerError`. It defines two routes: one in the main app and one in the blueprint, both of which raise an `InternalServerError`. The test client (`c`) is then used to make GET requests to both routes, and the responses are asserted against the expected error messages. The main app's error handler is registered to return \"app-error\", while the blueprint's handler returns \"bp-error\".\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprint Registration**: The test demonstrates the use of Flask blueprints to modularize the application and handle errors separately.\n- **Error Handling**: It showcases how Flask's error handling mechanism can be customized at both the application and blueprint levels.\n- **Assertions**: The test uses assertions to validate that the correct error messages are returned, ensuring that the error handling logic is functioning as intended.\n- **Test Client**: The use of `app.test_client()` allows for simulating requests to the application, making it easier to test the behavior of routes and error handlers in a controlled environment."
    },
    {
      "name": "test_default_error_handler",
      "module": "test_user_error_handler",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
      "line_number": 163,
      "end_line_number": 214,
      "source_code": "def test_default_error_handler():\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.errorhandler(HTTPException)\n    def bp_exception_handler(e):\n        assert isinstance(e, HTTPException)\n        assert isinstance(e, NotFound)\n        return \"bp-default\"\n\n    @bp.errorhandler(Forbidden)\n    def bp_forbidden_handler(e):\n        assert isinstance(e, Forbidden)\n        return \"bp-forbidden\"\n\n    @bp.route(\"/undefined\")\n    def bp_registered_test():\n        raise NotFound()\n\n    @bp.route(\"/forbidden\")\n    def bp_forbidden_test():\n        raise Forbidden()\n\n    app = flask.Flask(__name__)\n\n    @app.errorhandler(HTTPException)\n    def catchall_exception_handler(e):\n        assert isinstance(e, HTTPException)\n        assert isinstance(e, NotFound)\n        return \"default\"\n\n    @app.errorhandler(Forbidden)\n    def catchall_forbidden_handler(e):\n        assert isinstance(e, Forbidden)\n        return \"forbidden\"\n\n    @app.route(\"/forbidden\")\n    def forbidden():\n        raise Forbidden()\n\n    @app.route(\"/slash/\")\n    def slash():\n        return \"slash\"\n\n    app.register_blueprint(bp, url_prefix=\"/bp\")\n\n    c = app.test_client()\n    assert c.get(\"/bp/undefined\").data == b\"bp-default\"\n    assert c.get(\"/bp/forbidden\").data == b\"bp-forbidden\"\n    assert c.get(\"/undefined\").data == b\"default\"\n    assert c.get(\"/forbidden\").data == b\"forbidden\"\n    # Don't handle RequestRedirect raised when adding slash.\n    assert c.get(\"/slash\", follow_redirects=True).data == b\"slash\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.HTTPException",
        "werkzeug.exceptions.InternalServerError",
        "werkzeug.exceptions.NotFound",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert c.get('/bp/undefined').data == b'bp-default'",
        "assert c.get('/bp/forbidden').data == b'bp-forbidden'",
        "assert c.get('/undefined').data == b'default'",
        "assert c.get('/forbidden').data == b'forbidden'",
        "assert c.get('/slash', follow_redirects=True).data == b'slash'",
        "assert isinstance(e, HTTPException)",
        "assert isinstance(e, NotFound)",
        "assert isinstance(e, Forbidden)",
        "assert isinstance(e, HTTPException)",
        "assert isinstance(e, NotFound)",
        "assert isinstance(e, Forbidden)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_default_error_handler` is to verify that the Flask application correctly handles HTTP exceptions, specifically `NotFound` and `Forbidden`, both at the blueprint level and the application level. It ensures that the appropriate error handlers are invoked and that the expected responses are returned when these exceptions are raised.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a `NotFound` exception is raised, the response is \"bp-default\" for the blueprint route and \"default\" for the application route. Similarly, when a `Forbidden` exception is raised, the response should be \"bp-forbidden\" for the blueprint and \"forbidden\" for the application. Additionally, it verifies that a request to a valid route returns the expected response without error handling interference.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes two error handlers for `HTTPException` and `Forbidden` defined within a Flask blueprint (`bp`) and the main Flask application (`app`). The blueprint has routes that intentionally raise `NotFound` and `Forbidden` exceptions. The application also has its own routes and error handlers. The test client (`c`) is used to simulate requests to these routes, and assertions are made on the returned data to ensure the correct error handling behavior.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n1. **Blueprints**: It demonstrates the use of Flask blueprints to modularize error handling and route definitions.\n2. **Error Handlers**: It showcases the registration of custom error handlers for specific exceptions, allowing for tailored responses based on the type of error encountered.\n3. **Assertions**: The test uses assertions to validate the output of the error handlers, ensuring that the expected responses match the actual responses from the application.\n4. **Test Client**: The use of Flask's test client allows for easy simulation of HTTP requests and responses, facilitating the testing of application behavior in a controlled environment."
    },
    {
      "name": "test_handle_class_or_code",
      "module": "test_user_error_handler",
      "class_name": "TestGenericHandlers",
      "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
      "line_number": 253,
      "end_line_number": 267,
      "source_code": "def test_handle_class_or_code(self, app, client, to_handle):\n        \"\"\"``InternalServerError`` and ``500`` are aliases, they should\n        have the same behavior. Both should only receive\n        ``InternalServerError``, which might wrap another error.\n        \"\"\"\n\n        @app.errorhandler(to_handle)\n        def handle_500(e):\n            assert isinstance(e, InternalServerError)\n            return self.report_error(e)\n\n        assert client.get(\"/custom\").data == b\"wrapped Custom\"\n        assert client.get(\"/error\").data == b\"wrapped KeyError\"\n        assert client.get(\"/abort\").data == b\"direct InternalServerError\"\n        assert client.get(\"/raise\").data == b\"direct InternalServerError\"",
      "docstring": "``InternalServerError`` and ``500`` are aliases, they should\nhave the same behavior. Both should only receive\n``InternalServerError``, which might wrap another error.",
      "decorators": [
        "pytest.mark.parametrize('to_handle', (InternalServerError, 500))"
      ],
      "arguments": [
        "self",
        "app",
        "client",
        "to_handle"
      ],
      "imports": [
        "pytest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.HTTPException",
        "werkzeug.exceptions.InternalServerError",
        "werkzeug.exceptions.NotFound",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/custom').data == b'wrapped Custom'",
        "assert client.get('/error').data == b'wrapped KeyError'",
        "assert client.get('/abort').data == b'direct InternalServerError'",
        "assert client.get('/raise').data == b'direct InternalServerError'",
        "assert isinstance(e, InternalServerError)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.report_error",
          "body": "def report_error(self, e):\n    original = getattr(e, 'original_exception', None)\n    if original is not None:\n        return f'wrapped {type(original).__name__}'\n    return f'direct {type(e).__name__}'"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_handle_class_or_code` test is to verify that both `InternalServerError` and the HTTP status code `500` are handled consistently by the Flask application. It ensures that when these errors occur, they are processed in the same manner, specifically that they invoke the same error handler and return the expected error messages.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the error handler correctly identifies instances of `InternalServerError` and returns a formatted string indicating whether the error was wrapped (i.e., caused by another exception) or direct. It verifies that the application responds appropriately to various routes that trigger different types of errors, ensuring that the error handling mechanism behaves as intended.\n\n**Code Being Tested and How It Works**:  \nThe code being tested includes the `report_error` method, which formats the error message based on whether the error has an `original_exception` attribute. The test also involves Flask routes that raise different exceptions (`Custom`, `KeyError`, and `InternalServerError`) and checks the responses from these routes using the Flask test client. The error handler is registered for both `InternalServerError` and `500`, and the assertions confirm that the responses match the expected output.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of parameterized testing with `pytest.mark.parametrize`, allowing it to run the same test logic for both `InternalServerError` and `500` without duplicating code. It also utilizes Flask's error handling mechanism by defining an error handler within the test, which is a common pattern for testing error responses in web applications. The assertions are straightforward, directly comparing the response data to expected byte strings, which is a clear and effective way to validate the output."
    },
    {
      "name": "test_handle_generic_http",
      "module": "test_user_error_handler",
      "class_name": "TestGenericHandlers",
      "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
      "line_number": 269,
      "end_line_number": 281,
      "source_code": "def test_handle_generic_http(self, app, client):\n        \"\"\"``HTTPException`` should only receive ``HTTPException``\n        subclasses. It will receive ``404`` routing exceptions.\n        \"\"\"\n\n        @app.errorhandler(HTTPException)\n        def handle_http(e):\n            assert isinstance(e, HTTPException)\n            return str(e.code)\n\n        assert client.get(\"/error\").data == b\"500\"\n        assert client.get(\"/abort\").data == b\"500\"\n        assert client.get(\"/not-found\").data == b\"404\"",
      "docstring": "``HTTPException`` should only receive ``HTTPException``\nsubclasses. It will receive ``404`` routing exceptions.",
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.HTTPException",
        "werkzeug.exceptions.InternalServerError",
        "werkzeug.exceptions.NotFound",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/error').data == b'500'",
        "assert client.get('/abort').data == b'500'",
        "assert client.get('/not-found').data == b'404'",
        "assert isinstance(e, HTTPException)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_handle_generic_http` test is to verify that the Flask application correctly handles HTTP exceptions, specifically ensuring that only instances of `HTTPException` or its subclasses are processed by the error handler. It also checks that the application returns the appropriate HTTP status codes for various routes that trigger errors.\n\n**Specific Functionality or Behavior Verified**:  \nThis test verifies that when specific routes are accessed, the application responds with the expected HTTP status codes. It checks that accessing the `/error` and `/abort` routes returns a `500` status code, while accessing the `/not-found` route returns a `404` status code. Additionally, it ensures that the error handler correctly identifies the type of exception being raised.\n\n**Code Being Tested and How It Works**:  \nThe code being tested includes an error handler defined for `HTTPException` that asserts the exception type and returns the corresponding HTTP status code as a string. The test uses the Flask test client to simulate GET requests to various routes, which are expected to raise different exceptions. The routes are not explicitly defined in the provided code, but they are assumed to trigger the respective exceptions when accessed.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of Flask's error handling mechanism by registering an error handler for `HTTPException`. It uses assertions to validate the response data and status codes returned by the client for different routes. The test also utilizes the Flask test client to simulate requests, which is a common pattern in testing Flask applications to ensure that the application behaves as expected under various conditions."
    },
    {
      "name": "test_handle_generic",
      "module": "test_user_error_handler",
      "class_name": "TestGenericHandlers",
      "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
      "line_number": 283,
      "end_line_number": 295,
      "source_code": "def test_handle_generic(self, app, client):\n        \"\"\"Generic ``Exception`` will handle all exceptions directly,\n        including ``HTTPExceptions``.\n        \"\"\"\n\n        @app.errorhandler(Exception)\n        def handle_exception(e):\n            return self.report_error(e)\n\n        assert client.get(\"/custom\").data == b\"direct Custom\"\n        assert client.get(\"/error\").data == b\"direct KeyError\"\n        assert client.get(\"/abort\").data == b\"direct InternalServerError\"\n        assert client.get(\"/not-found\").data == b\"direct NotFound\"",
      "docstring": "Generic ``Exception`` will handle all exceptions directly,\nincluding ``HTTPExceptions``.",
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.HTTPException",
        "werkzeug.exceptions.InternalServerError",
        "werkzeug.exceptions.NotFound",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/custom').data == b'direct Custom'",
        "assert client.get('/error').data == b'direct KeyError'",
        "assert client.get('/abort').data == b'direct InternalServerError'",
        "assert client.get('/not-found').data == b'direct NotFound'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.report_error",
          "body": "def report_error(self, e):\n    original = getattr(e, 'original_exception', None)\n    if original is not None:\n        return f'wrapped {type(original).__name__}'\n    return f'direct {type(e).__name__}'"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_handle_generic` function is designed to verify that the Flask application correctly handles various exceptions, including custom exceptions and HTTP exceptions, by returning appropriate error messages. It ensures that the generic error handler is functioning as intended.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when specific routes are accessed, the application responds with predefined error messages that indicate the type of exception encountered. It verifies that the error handler correctly identifies and processes exceptions, returning a string that describes the exception type.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `handle_exception` function, which is registered as an error handler for all exceptions (`Exception`). This function calls `self.report_error(e)`, which formats the error message based on the type of exception. The test asserts that accessing various routes (`/custom`, `/error`, `/abort`, and `/not-found`) returns specific byte strings that indicate the type of exception handled, such as `b'direct Custom'` for a custom exception and `b'direct KeyError'` for a `KeyError`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of Flask's error handling mechanism by registering an error handler for `Exception`. It utilizes assertions to validate the output of the client requests against expected results. The test also demonstrates the use of a custom error handler to manage different types of exceptions uniformly, showcasing a common pattern in Flask applications for centralized error management."
    },
    {
      "name": "test_handle_class_or_code",
      "module": "test_user_error_handler",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
      "line_number": 253,
      "end_line_number": 267,
      "source_code": "def test_handle_class_or_code(self, app, client, to_handle):\n        \"\"\"``InternalServerError`` and ``500`` are aliases, they should\n        have the same behavior. Both should only receive\n        ``InternalServerError``, which might wrap another error.\n        \"\"\"\n\n        @app.errorhandler(to_handle)\n        def handle_500(e):\n            assert isinstance(e, InternalServerError)\n            return self.report_error(e)\n\n        assert client.get(\"/custom\").data == b\"wrapped Custom\"\n        assert client.get(\"/error\").data == b\"wrapped KeyError\"\n        assert client.get(\"/abort\").data == b\"direct InternalServerError\"\n        assert client.get(\"/raise\").data == b\"direct InternalServerError\"",
      "docstring": "``InternalServerError`` and ``500`` are aliases, they should\nhave the same behavior. Both should only receive\n``InternalServerError``, which might wrap another error.",
      "decorators": [
        "pytest.mark.parametrize('to_handle', (InternalServerError, 500))"
      ],
      "arguments": [
        "self",
        "app",
        "client",
        "to_handle"
      ],
      "imports": [
        "pytest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.HTTPException",
        "werkzeug.exceptions.InternalServerError",
        "werkzeug.exceptions.NotFound",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/custom').data == b'wrapped Custom'",
        "assert client.get('/error').data == b'wrapped KeyError'",
        "assert client.get('/abort').data == b'direct InternalServerError'",
        "assert client.get('/raise').data == b'direct InternalServerError'",
        "assert isinstance(e, InternalServerError)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.report_error",
          "body": "def report_error(self, e):\n    original = getattr(e, 'original_exception', None)\n    if original is not None:\n        return f'wrapped {type(original).__name__}'\n    return f'direct {type(e).__name__}'"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_handle_class_or_code` test is to verify that the Flask application correctly handles errors associated with `InternalServerError` and its HTTP status code `500`. It ensures that both error types are treated equivalently and that the error handling mechanism returns the expected responses when these errors occur.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when specific routes trigger errors (either a custom exception, a `KeyError`, or an `InternalServerError`), the application responds with the correct wrapped or direct error messages. It asserts that the error handler correctly identifies the type of error and formats the response accordingly.\n\n**Code Being Tested and How It Works**:  \nThe code being tested includes the `report_error` method, which formats the error message based on whether the error has an `original_exception` attribute. The test also involves Flask routes that intentionally raise exceptions or abort with a 500 status code. The error handler registered for `to_handle` (which can be either `InternalServerError` or `500`) checks the type of the exception and calls `report_error` to generate the appropriate response.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.mark.parametrize` decorator to run the same test logic for both `InternalServerError` and `500`, ensuring that the behavior is consistent across these two aliases. Additionally, it uses assertions to validate the output of the client requests against expected byte strings, which is a common practice in testing web applications to ensure that the responses are as intended. The use of an error handler within the test setup is also a notable technique, allowing for direct testing of error handling logic in a controlled environment."
    },
    {
      "name": "test_handle_generic_http",
      "module": "test_user_error_handler",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
      "line_number": 269,
      "end_line_number": 281,
      "source_code": "def test_handle_generic_http(self, app, client):\n        \"\"\"``HTTPException`` should only receive ``HTTPException``\n        subclasses. It will receive ``404`` routing exceptions.\n        \"\"\"\n\n        @app.errorhandler(HTTPException)\n        def handle_http(e):\n            assert isinstance(e, HTTPException)\n            return str(e.code)\n\n        assert client.get(\"/error\").data == b\"500\"\n        assert client.get(\"/abort\").data == b\"500\"\n        assert client.get(\"/not-found\").data == b\"404\"",
      "docstring": "``HTTPException`` should only receive ``HTTPException``\nsubclasses. It will receive ``404`` routing exceptions.",
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.HTTPException",
        "werkzeug.exceptions.InternalServerError",
        "werkzeug.exceptions.NotFound",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/error').data == b'500'",
        "assert client.get('/abort').data == b'500'",
        "assert client.get('/not-found').data == b'404'",
        "assert isinstance(e, HTTPException)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_handle_generic_http` test is to verify that the Flask application correctly handles HTTP exceptions, specifically ensuring that only instances of `HTTPException` or its subclasses are processed by the error handler. It also checks that the application returns the appropriate HTTP status codes for various routes that trigger errors.\n\n**Specific Functionality or Behavior Verified**:  \nThis test verifies that when specific routes are accessed, the application responds with the expected HTTP status codes. It checks that accessing the `/error` and `/abort` routes returns a `500` status code, while accessing the `/not-found` route returns a `404` status code. Additionally, it ensures that the error handler correctly identifies the type of exception being raised.\n\n**Code Being Tested and How It Works**:  \nThe code being tested includes an error handler defined for `HTTPException` that asserts the exception is indeed an instance of `HTTPException` and returns the exception's HTTP status code as a string. The test uses the Flask test client to simulate requests to various routes, checking the response data against expected values. The routes are expected to raise exceptions that the error handler will catch and process.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of Flask's error handling mechanism, specifically the `@app.errorhandler` decorator to define custom error handlers. It also utilizes assertions to validate the response data from the client requests, ensuring that the application behaves as expected under error conditions. The test structure follows a clear pattern of setup (defining routes and error handlers), execution (making requests), and verification (asserting response data)."
    },
    {
      "name": "test_handle_generic",
      "module": "test_user_error_handler",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_user_error_handler.py",
      "line_number": 283,
      "end_line_number": 295,
      "source_code": "def test_handle_generic(self, app, client):\n        \"\"\"Generic ``Exception`` will handle all exceptions directly,\n        including ``HTTPExceptions``.\n        \"\"\"\n\n        @app.errorhandler(Exception)\n        def handle_exception(e):\n            return self.report_error(e)\n\n        assert client.get(\"/custom\").data == b\"direct Custom\"\n        assert client.get(\"/error\").data == b\"direct KeyError\"\n        assert client.get(\"/abort\").data == b\"direct InternalServerError\"\n        assert client.get(\"/not-found\").data == b\"direct NotFound\"",
      "docstring": "Generic ``Exception`` will handle all exceptions directly,\nincluding ``HTTPExceptions``.",
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "werkzeug.exceptions.Forbidden",
        "werkzeug.exceptions.HTTPException",
        "werkzeug.exceptions.InternalServerError",
        "werkzeug.exceptions.NotFound",
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/custom').data == b'direct Custom'",
        "assert client.get('/error').data == b'direct KeyError'",
        "assert client.get('/abort').data == b'direct InternalServerError'",
        "assert client.get('/not-found').data == b'direct NotFound'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.report_error",
          "body": "def report_error(self, e):\n    original = getattr(e, 'original_exception', None)\n    if original is not None:\n        return f'wrapped {type(original).__name__}'\n    return f'direct {type(e).__name__}'"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_handle_generic` function is designed to verify that the Flask application correctly handles various exceptions, including custom exceptions and HTTP exceptions, by returning appropriate error messages. It ensures that the generic error handler is functioning as intended for different routes that trigger exceptions.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when specific routes are accessed, the application responds with predefined error messages that indicate the type of exception encountered. It verifies that the error handler correctly identifies and processes exceptions, returning a string that describes the exception type.\n\n**Code Being Tested and How It Works**:  \nThe test sets up an error handler for the base `Exception` class using the `@app.errorhandler(Exception)` decorator. The `handle_exception` function calls `self.report_error(e)`, which formats the error message based on the type of exception. The test then makes requests to various routes (`/custom`, `/error`, `/abort`, and `/not-found`) and asserts that the responses match the expected error messages, such as `b'direct Custom'` for a custom exception and `b'direct KeyError'` for a key error.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Error Handling Testing**: The test employs a common pattern of testing error handling in web applications by simulating requests that trigger exceptions and verifying the responses.\n- **Assertions**: It uses assertions to validate that the output from the client matches the expected byte strings, ensuring that the error handling logic is correctly implemented.\n- **Flask Testing Client**: The test utilizes Flask's testing client to simulate HTTP requests, allowing for isolated testing of the application's behavior without needing to run a live server."
    },
    {
      "name": "test_custom_converters",
      "module": "test_converters",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_converters.py",
      "line_number": 8,
      "end_line_number": 26,
      "source_code": "def test_custom_converters(app, client):\n    class ListConverter(BaseConverter):\n        def to_python(self, value):\n            return value.split(\",\")\n\n        def to_url(self, value):\n            base_to_url = super().to_url\n            return \",\".join(base_to_url(x) for x in value)\n\n    app.url_map.converters[\"list\"] = ListConverter\n\n    @app.route(\"/<list:args>\")\n    def index(args):\n        return \"|\".join(args)\n\n    assert client.get(\"/1,2,3\").data == b\"1|2|3\"\n\n    with app.test_request_context():\n        assert url_for(\"index\", args=[4, 5, 6]) == \"/4,5,6\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "werkzeug.routing.BaseConverter",
        "flask.request",
        "flask.session",
        "flask.url_for"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/1,2,3').data == b'1|2|3'",
        "assert url_for('index', args=[4, 5, 6]) == '/4,5,6'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_custom_converters` function is designed to verify the functionality of a custom URL converter in a Flask application. It ensures that the converter correctly transforms URL path parameters into Python objects and vice versa.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main behaviors: \n1. It verifies that a URL containing a comma-separated list (e.g., `/1,2,3`) is correctly parsed into a Python list (i.e., `[\"1\", \"2\", \"3\"]`) by the custom `ListConverter`.\n2. It confirms that the `url_for` function generates the correct URL format for a list of arguments (e.g., `args=[4, 5, 6]` should yield `/4,5,6`).\n\n**Code Being Tested and How It Works**:  \nThe test defines a `ListConverter` class that inherits from `BaseConverter`. The `to_python` method splits a comma-separated string into a list, while the `to_url` method joins a list into a comma-separated string. The Flask app registers this converter, and a route (`/index`) is defined to utilize it. The assertions check the output of a GET request to the route and the URL generation using `url_for`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Custom Converter Implementation**: The test demonstrates how to create and register a custom URL converter in Flask, showcasing extensibility.\n- **Flask Testing Client**: It uses the Flask testing client (`client.get`) to simulate HTTP requests and validate responses.\n- **Context Management**: The test employs `app.test_request_context()` to create a request context for testing URL generation, ensuring that the `url_for` function operates correctly within the application context."
    },
    {
      "name": "test_context_available",
      "module": "test_converters",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_converters.py",
      "line_number": 29,
      "end_line_number": 42,
      "source_code": "def test_context_available(app, client):\n    class ContextConverter(BaseConverter):\n        def to_python(self, value):\n            assert request is not None\n            assert session is not None\n            return value\n\n    app.url_map.converters[\"ctx\"] = ContextConverter\n\n    @app.get(\"/<ctx:name>\")\n    def index(name):\n        return name\n\n    assert client.get(\"/admin\").data == b\"admin\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "werkzeug.routing.BaseConverter",
        "flask.request",
        "flask.session",
        "flask.url_for"
      ],
      "fixtures": [],
      "assertions": [
        "assert client.get('/admin').data == b'admin'",
        "assert request is not None",
        "assert session is not None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_context_available` function is designed to verify that a custom URL converter (`ContextConverter`) can correctly handle context-related data in a Flask application. It ensures that the Flask request and session contexts are available when the converter is invoked.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the `ContextConverter` can access the `request` and `session` objects, confirming that they are not `None`. It also verifies that the route defined with the custom converter correctly returns the expected response when accessed via the test client.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a custom URL converter (`ContextConverter`) that inherits from `BaseConverter`. The `to_python` method asserts the availability of `request` and `session`, returning the value passed to it. The route `@app.get(\"/<ctx:name>\")` uses this converter to handle requests. The test client sends a GET request to the `/admin` endpoint, and the expected output is asserted to be `b\"admin\"`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of Flask's testing capabilities, specifically the `client` fixture to simulate HTTP requests. It also utilizes assertions to validate the behavior of the application under test. The use of a custom converter demonstrates the extensibility of Flask's routing system, while the assertions within the `to_python` method ensure that the necessary context is available during the conversion process."
    },
    {
      "name": "test_aborting",
      "module": "test_regression",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_regression.py",
      "line_number": 4,
      "end_line_number": 30,
      "source_code": "def test_aborting(app):\n    class Foo(Exception):\n        whatever = 42\n\n    @app.errorhandler(Foo)\n    def handle_foo(e):\n        return str(e.whatever)\n\n    @app.route(\"/\")\n    def index():\n        raise flask.abort(flask.redirect(flask.url_for(\"test\")))\n\n    @app.route(\"/test\")\n    def test():\n        raise Foo()\n\n    with app.test_client() as c:\n        rv = c.get(\"/\")\n        location_parts = rv.headers[\"Location\"].rpartition(\"/\")\n\n        if location_parts[0]:\n            # For older Werkzeug that used absolute redirects.\n            assert location_parts[0] == \"http://localhost\"\n\n        assert location_parts[2] == \"test\"\n        rv = c.get(\"/test\")\n        assert rv.data == b\"42\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "flask"
      ],
      "fixtures": [],
      "assertions": [
        "assert location_parts[2] == 'test'",
        "assert rv.data == b'42'",
        "assert location_parts[0] == 'http://localhost'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "flask.redirect",
          "body": "def redirect(location, code=302):\n    raise ValueError"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:\nThe `test_aborting` function is designed to verify the behavior of Flask's error handling and redirection mechanisms when a custom exception is raised. It ensures that the application correctly handles the redirection and that the custom error handler returns the expected response.\n\n**Specific Functionality or Behavior Verified**:\nThe test checks that when a request is made to the root route (\"/\"), it triggers a redirect to the \"/test\" route, which raises a custom exception (`Foo`). The test then verifies that the custom error handler returns the expected value (42) when the \"/test\" route is accessed. Additionally, it confirms that the redirect location is correctly formatted.\n\n**Code Being Tested and How It Works**:\n1. **Custom Exception**: A class `Foo` is defined, which inherits from `Exception` and has an attribute `whatever` set to 42.\n2. **Error Handler**: The `handle_foo` function is registered as an error handler for the `Foo` exception, returning the string representation of `e.whatever`.\n3. **Routes**:\n   - The `index` route raises a redirect to the \"test\" route using `flask.abort`.\n   - The `test` route raises the `Foo` exception.\n4. **Test Client**: The test uses Flask's test client to simulate requests to the application, checking the response headers and data.\n\n**Notable Testing Patterns or Techniques Used**:\n- **Error Handling**: The test demonstrates how to handle custom exceptions in Flask applications by defining an error handler.\n- **Redirection Testing**: It verifies the behavior of redirects and checks the response headers to ensure the correct location is set.\n- **Assertions**: The test uses assertions to validate the expected outcomes, such as checking the redirect location and the response data from the custom error handler.\n- **Context Management**: The use of `with app.test_client() as c:` ensures that the test client is properly managed, providing a clean context for each test execution."
    },
    {
      "name": "test_basic_url_generation",
      "module": "test_appctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_appctx.py",
      "line_number": 8,
      "end_line_number": 18,
      "source_code": "def test_basic_url_generation(app):\n    app.config[\"SERVER_NAME\"] = \"localhost\"\n    app.config[\"PREFERRED_URL_SCHEME\"] = \"https\"\n\n    @app.route(\"/\")\n    def index():\n        pass\n\n    with app.app_context():\n        rv = flask.url_for(\"index\")\n        assert rv == \"https://localhost/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "flask",
        "flask.globals.app_ctx",
        "flask.globals.request_ctx"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv == 'https://localhost/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_url_generation_requires_server_name",
      "module": "test_appctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_appctx.py",
      "line_number": 21,
      "end_line_number": 24,
      "source_code": "def test_url_generation_requires_server_name(app):\n    with app.app_context():\n        with pytest.raises(RuntimeError):\n            flask.url_for(\"index\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "flask",
        "flask.globals.app_ctx",
        "flask.globals.request_ctx"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_url_generation_without_context_fails",
      "module": "test_appctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_appctx.py",
      "line_number": 27,
      "end_line_number": 29,
      "source_code": "def test_url_generation_without_context_fails():\n    with pytest.raises(RuntimeError):\n        flask.url_for(\"index\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "flask",
        "flask.globals.app_ctx",
        "flask.globals.request_ctx"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_request_context_means_app_context",
      "module": "test_appctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_appctx.py",
      "line_number": 32,
      "end_line_number": 35,
      "source_code": "def test_request_context_means_app_context(app):\n    with app.test_request_context():\n        assert flask.current_app._get_current_object() is app\n    assert not flask.current_app",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "flask",
        "flask.globals.app_ctx",
        "flask.globals.request_ctx"
      ],
      "fixtures": [],
      "assertions": [
        "assert not flask.current_app",
        "assert flask.current_app._get_current_object() is app"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_app_context_provides_current_app",
      "module": "test_appctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_appctx.py",
      "line_number": 38,
      "end_line_number": 41,
      "source_code": "def test_app_context_provides_current_app(app):\n    with app.app_context():\n        assert flask.current_app._get_current_object() is app\n    assert not flask.current_app",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "flask",
        "flask.globals.app_ctx",
        "flask.globals.request_ctx"
      ],
      "fixtures": [],
      "assertions": [
        "assert not flask.current_app",
        "assert flask.current_app._get_current_object() is app"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_app_tearing_down",
      "module": "test_appctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_appctx.py",
      "line_number": 44,
      "end_line_number": 54,
      "source_code": "def test_app_tearing_down(app):\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    with app.app_context():\n        pass\n\n    assert cleanup_stuff == [None]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "flask",
        "flask.globals.app_ctx",
        "flask.globals.request_ctx"
      ],
      "fixtures": [],
      "assertions": [
        "assert cleanup_stuff == [None]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_app_tearing_down_with_previous_exception",
      "module": "test_appctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_appctx.py",
      "line_number": 57,
      "end_line_number": 72,
      "source_code": "def test_app_tearing_down_with_previous_exception(app):\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    try:\n        raise Exception(\"dummy\")\n    except Exception:\n        pass\n\n    with app.app_context():\n        pass\n\n    assert cleanup_stuff == [None]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "flask",
        "flask.globals.app_ctx",
        "flask.globals.request_ctx"
      ],
      "fixtures": [],
      "assertions": [
        "assert cleanup_stuff == [None]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_app_tearing_down_with_handled_exception_by_except_block",
      "module": "test_appctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_appctx.py",
      "line_number": 75,
      "end_line_number": 88,
      "source_code": "def test_app_tearing_down_with_handled_exception_by_except_block(app):\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    with app.app_context():\n        try:\n            raise Exception(\"dummy\")\n        except Exception:\n            pass\n\n    assert cleanup_stuff == [None]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "flask",
        "flask.globals.app_ctx",
        "flask.globals.request_ctx"
      ],
      "fixtures": [],
      "assertions": [
        "assert cleanup_stuff == [None]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_app_tearing_down_with_handled_exception_by_app_handler",
      "module": "test_appctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_appctx.py",
      "line_number": 91,
      "end_line_number": 110,
      "source_code": "def test_app_tearing_down_with_handled_exception_by_app_handler(app, client):\n    app.config[\"PROPAGATE_EXCEPTIONS\"] = True\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    @app.route(\"/\")\n    def index():\n        raise Exception(\"dummy\")\n\n    @app.errorhandler(Exception)\n    def handler(f):\n        return flask.jsonify(str(f))\n\n    with app.app_context():\n        client.get(\"/\")\n\n    assert cleanup_stuff == [None]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "flask",
        "flask.globals.app_ctx",
        "flask.globals.request_ctx"
      ],
      "fixtures": [],
      "assertions": [
        "assert cleanup_stuff == [None]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_app_tearing_down_with_handled_exception_by_app_handler` is designed to verify that the Flask application correctly handles exceptions raised during a request and ensures that the application teardown process is executed without any unhandled exceptions. Specifically, it checks that the cleanup function is called with `None` when an exception is handled by the error handler.\n\n**Specific Functionality or Behavior Verified**:  \nThis test verifies that when an exception is raised in a route handler (in this case, a dummy exception), and that exception is caught and handled by a registered error handler, the cleanup function registered with `@app.teardown_appcontext` is invoked with `None`. This indicates that the application context is torn down cleanly without any unhandled exceptions.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a Flask route (`index`) that raises an exception, and an error handler that catches this exception and returns a JSON response. The `cleanup` function is registered to run at the end of the application context, and it appends the exception (if any) to the `cleanup_stuff` list. The test simulates a request to the route and checks the contents of `cleanup_stuff` to ensure it contains `None`, indicating that the exception was handled properly.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Teardown Functionality**: The use of `@app.teardown_appcontext` to register a cleanup function demonstrates the teardown pattern, which is essential for resource management in web applications.\n- **Error Handling**: The test showcases the use of Flask's error handling mechanism, where exceptions are caught and processed by a dedicated error handler.\n- **Context Management**: The test utilizes `app.app_context()` to create an application context for the test, ensuring that the Flask application behaves as it would in a real request scenario.\n- **Assertions**: The test employs assertions to validate the expected state of `cleanup_stuff`, ensuring that the cleanup process behaves as intended when exceptions are handled."
    },
    {
      "name": "test_app_tearing_down_with_unhandled_exception",
      "module": "test_appctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_appctx.py",
      "line_number": 113,
      "end_line_number": 131,
      "source_code": "def test_app_tearing_down_with_unhandled_exception(app, client):\n    app.config[\"PROPAGATE_EXCEPTIONS\"] = True\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    @app.route(\"/\")\n    def index():\n        raise ValueError(\"dummy\")\n\n    with pytest.raises(ValueError, match=\"dummy\"):\n        with app.app_context():\n            client.get(\"/\")\n\n    assert len(cleanup_stuff) == 1\n    assert isinstance(cleanup_stuff[0], ValueError)\n    assert str(cleanup_stuff[0]) == \"dummy\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "flask",
        "flask.globals.app_ctx",
        "flask.globals.request_ctx"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(cleanup_stuff) == 1",
        "assert isinstance(cleanup_stuff[0], ValueError)",
        "assert str(cleanup_stuff[0]) == 'dummy'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_app_tearing_down_with_unhandled_exception` test is to verify that the Flask application correctly invokes the teardown function when an unhandled exception occurs during a request. Specifically, it checks that the exception is passed to the teardown function and that the application context is properly cleaned up.\n\n**Specific Functionality or Behavior Verified**:  \nThis test verifies that when a `ValueError` is raised in the route handler, the teardown function is executed, and it receives the exception as an argument. It ensures that the exception is captured and stored in a list, allowing the test to assert that the cleanup process behaves as expected in the presence of unhandled exceptions.\n\n**Code Being Tested and How It Works**:  \nThe code being tested includes a Flask route (`index`) that raises a `ValueError` when accessed. The test sets up a teardown function using the `@app.teardown_appcontext` decorator, which appends any exception raised during the request to the `cleanup_stuff` list. The test then simulates a request to the route using the test client and expects a `ValueError` to be raised. After the request, it asserts that the exception was captured in the `cleanup_stuff` list, confirming that the teardown function was executed with the correct exception.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable testing patterns:\n- **Context Management**: It uses `app.app_context()` to ensure that the application context is active during the request, which is crucial for accessing Flask's features.\n- **Exception Assertion**: The test uses `pytest.raises` to assert that the expected exception is raised, along with a specific message, ensuring that the error handling is functioning correctly.\n- **Teardown Verification**: It verifies the behavior of the teardown function by checking the contents of the `cleanup_stuff` list, which is a common pattern in testing to ensure that cleanup actions are performed as expected after a request."
    },
    {
      "name": "test_app_ctx_globals_methods",
      "module": "test_appctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_appctx.py",
      "line_number": 134,
      "end_line_number": 154,
      "source_code": "def test_app_ctx_globals_methods(app, app_ctx):\n    # get\n    assert flask.g.get(\"foo\") is None\n    assert flask.g.get(\"foo\", \"bar\") == \"bar\"\n    # __contains__\n    assert \"foo\" not in flask.g\n    flask.g.foo = \"bar\"\n    assert \"foo\" in flask.g\n    # setdefault\n    flask.g.setdefault(\"bar\", \"the cake is a lie\")\n    flask.g.setdefault(\"bar\", \"hello world\")\n    assert flask.g.bar == \"the cake is a lie\"\n    # pop\n    assert flask.g.pop(\"bar\") == \"the cake is a lie\"\n    with pytest.raises(KeyError):\n        flask.g.pop(\"bar\")\n    assert flask.g.pop(\"bar\", \"more cake\") == \"more cake\"\n    # __iter__\n    assert list(flask.g) == [\"foo\"]\n    # __repr__\n    assert repr(flask.g) == \"<flask.g of 'flask_test'>\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "app_ctx"
      ],
      "imports": [
        "pytest",
        "flask",
        "flask.globals.app_ctx",
        "flask.globals.request_ctx"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.g.get('foo') is None",
        "assert flask.g.get('foo', 'bar') == 'bar'",
        "assert 'foo' not in flask.g",
        "assert 'foo' in flask.g",
        "assert flask.g.bar == 'the cake is a lie'",
        "assert flask.g.pop('bar') == 'the cake is a lie'",
        "assert flask.g.pop('bar', 'more cake') == 'more cake'",
        "assert list(flask.g) == ['foo']",
        "assert repr(flask.g) == \"<flask.g of 'flask_test'>\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "flask.g.setdefault",
          "body": "@app.route('/setdefault')\ndef setdefault():\n    return flask.session.setdefault('test', 'default')"
        },
        {
          "name": "flask.g.setdefault",
          "body": "@app.route('/setdefault')\ndef setdefault():\n    return flask.session.setdefault('test', 'default')"
        },
        {
          "name": "flask.g.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "flask.g.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_app_ctx_globals_methods` unit test is designed to verify the behavior and functionality of the Flask application context's global object `flask.g`. It ensures that the methods and properties of `flask.g` work as expected, including getting, setting, and manipulating values.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks several functionalities of `flask.g`:\n- The `get` method retrieves values, returning `None` for non-existent keys and a default value when specified.\n- The `__contains__` method verifies the presence of keys.\n- The `setdefault` method sets a value only if the key does not already exist.\n- The `pop` method removes a key and returns its value, raising a `KeyError` if the key does not exist.\n- The `__iter__` method allows iteration over the keys in `flask.g`.\n- The `__repr__` method provides a string representation of the `flask.g` object.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `flask.g` object, which is a special object provided by Flask to store data during a request. It acts like a dictionary, allowing developers to store and retrieve data that is specific to the current application context. The test uses assertions to validate the expected outcomes of various operations on `flask.g`, such as checking for the existence of keys, retrieving values, and ensuring that the correct exceptions are raised when attempting to access non-existent keys.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable testing patterns:\n- **Assertions**: It uses assertions to validate expected outcomes, which is a fundamental practice in unit testing.\n- **Context Management**: The test operates within the Flask application context, ensuring that the `flask.g` object behaves correctly in a simulated request environment.\n- **Error Handling**: It tests for expected exceptions (e.g., `KeyError`) using `pytest.raises`, which is a common technique to ensure that error conditions are handled properly.\n- **State Verification**: The test verifies the state of `flask.g` before and after operations, ensuring that the object maintains the expected state throughout the test."
    },
    {
      "name": "test_custom_app_ctx_globals_class",
      "module": "test_appctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_appctx.py",
      "line_number": 157,
      "end_line_number": 164,
      "source_code": "def test_custom_app_ctx_globals_class(app):\n    class CustomRequestGlobals:\n        def __init__(self):\n            self.spam = \"eggs\"\n\n    app.app_ctx_globals_class = CustomRequestGlobals\n    with app.app_context():\n        assert flask.render_template_string(\"{{ g.spam }}\") == \"eggs\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "flask",
        "flask.globals.app_ctx",
        "flask.globals.request_ctx"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.render_template_string('{{ g.spam }}') == 'eggs'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_context_refcounts",
      "module": "test_appctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_appctx.py",
      "line_number": 167,
      "end_line_number": 190,
      "source_code": "def test_context_refcounts(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_req(error=None):\n        called.append(\"request\")\n\n    @app.teardown_appcontext\n    def teardown_app(error=None):\n        called.append(\"app\")\n\n    @app.route(\"/\")\n    def index():\n        with app_ctx:\n            with request_ctx:\n                pass\n\n        assert flask.request.environ[\"werkzeug.request\"] is not None\n        return \"\"\n\n    res = client.get(\"/\")\n    assert res.status_code == 200\n    assert res.data == b\"\"\n    assert called == [\"request\", \"app\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "pytest",
        "flask",
        "flask.globals.app_ctx",
        "flask.globals.request_ctx"
      ],
      "fixtures": [],
      "assertions": [
        "assert res.status_code == 200",
        "assert res.data == b''",
        "assert called == ['request', 'app']",
        "assert flask.request.environ['werkzeug.request'] is not None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_context_refcounts` unit test is designed to verify the correct behavior of Flask's application and request context teardown mechanisms. It ensures that the teardown functions are called appropriately after a request is processed, confirming that the application context and request context are managed correctly.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that:\n1. The `teardown_request` function is invoked after handling a request.\n2. The `teardown_appcontext` function is called after the application context is popped.\n3. The request environment is correctly populated, specifically verifying that `werkzeug.request` is not `None`.\n\n**Code Being Tested and How It Works**:  \nThe test defines two teardown functions:\n- `teardown_req`: Appends \"request\" to the `called` list when a request teardown occurs.\n- `teardown_app`: Appends \"app\" to the `called` list when the application context teardown occurs.\n\nThe test then defines a route (`index`) that simulates a request context by using `with app_ctx` and `with request_ctx`. After making a GET request to the root endpoint (`/`), it asserts that:\n- The response status code is 200.\n- The response data is empty (`b\"\"`).\n- The `called` list contains the expected teardown order: `[\"request\", \"app\"]`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Teardown Functions**: The use of `@app.teardown_request` and `@app.teardown_appcontext` decorators to register cleanup functions that are automatically called after a request and application context, respectively.\n- **Context Management**: The test leverages Flask's context management to ensure that the request and application contexts are properly pushed and popped during the test execution.\n- **Assertions**: The test employs assertions to validate the expected outcomes, ensuring that the application behaves as intended under the test conditions."
    },
    {
      "name": "test_clean_pop",
      "module": "test_appctx",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_appctx.py",
      "line_number": 193,
      "end_line_number": 209,
      "source_code": "def test_clean_pop(app):\n    app.testing = False\n    called = []\n\n    @app.teardown_request\n    def teardown_req(error=None):\n        raise ZeroDivisionError\n\n    @app.teardown_appcontext\n    def teardown_app(error=None):\n        called.append(\"TEARDOWN\")\n\n    with app.app_context():\n        called.append(flask.current_app.name)\n\n    assert called == [\"flask_test\", \"TEARDOWN\"]\n    assert not flask.current_app",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "flask",
        "flask.globals.app_ctx",
        "flask.globals.request_ctx"
      ],
      "fixtures": [],
      "assertions": [
        "assert called == ['flask_test', 'TEARDOWN']",
        "assert not flask.current_app"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_bad_request_debug_message",
      "module": "test_json",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json.py",
      "line_number": 15,
      "end_line_number": 27,
      "source_code": "def test_bad_request_debug_message(app, client, debug):\n    app.config[\"DEBUG\"] = debug\n    app.config[\"TRAP_BAD_REQUEST_ERRORS\"] = False\n\n    @app.route(\"/json\", methods=[\"POST\"])\n    def post_json():\n        flask.request.get_json()\n        return None\n\n    rv = client.post(\"/json\", data=None, content_type=\"application/json\")\n    assert rv.status_code == 400\n    contains = b\"Failed to decode JSON object\" in rv.data\n    assert contains == debug",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('debug', (True, False))"
      ],
      "arguments": [
        "app",
        "client",
        "debug"
      ],
      "imports": [
        "datetime",
        "decimal",
        "io",
        "uuid",
        "pytest",
        "werkzeug.http.http_date",
        "flask",
        "flask.json",
        "flask.json.provider.DefaultJSONProvider",
        "codecs"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 400",
        "assert contains == debug"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_bad_request_debug_message` test is to verify the behavior of the Flask application when a malformed JSON request is sent to the `/json` endpoint. Specifically, it checks whether the application correctly returns a 400 Bad Request status and whether the debug message about the JSON decoding failure is included in the response based on the application's debug configuration.\n\n**Specific Functionality or Behavior Verified**:  \nThis test verifies two key behaviors: \n1. The HTTP status code returned by the application when a bad request is made (it should be 400).\n2. The presence of a specific debug message in the response body, which indicates whether the application is running in debug mode. The message \"Failed to decode JSON object\" should be present if `DEBUG` is set to `True` and absent if `DEBUG` is set to `False`.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the Flask route defined within the `test_bad_request_debug_message` function. The route `/json` is set up to handle POST requests and attempts to parse the incoming JSON data using `flask.request.get_json()`. If the data is malformed (in this case, `None` is sent), Flask raises a `BadRequest` exception, which results in a 400 status code being returned. The test then checks the response's status code and the content of the response body to ensure it behaves as expected based on the debug configuration.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses `pytest.mark.parametrize` to run the same test logic with different values for the `debug` configuration (both `True` and `False`). This allows for efficient testing of multiple scenarios without duplicating code.\n- **Assertion**: The test employs assertions to validate the expected outcomes, specifically checking the status code and the presence of a debug message in the response data.\n- **Flask Test Client**: The test utilizes Flask's test client to simulate HTTP requests to the application, allowing for integration-style testing of the route's behavior."
    },
    {
      "name": "test_json_bad_requests",
      "module": "test_json",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json.py",
      "line_number": 30,
      "end_line_number": 36,
      "source_code": "def test_json_bad_requests(app, client):\n    @app.route(\"/json\", methods=[\"POST\"])\n    def return_json():\n        return flask.jsonify(foo=str(flask.request.get_json()))\n\n    rv = client.post(\"/json\", data=\"malformed\", content_type=\"application/json\")\n    assert rv.status_code == 400",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "datetime",
        "decimal",
        "io",
        "uuid",
        "pytest",
        "werkzeug.http.http_date",
        "flask",
        "flask.json",
        "flask.json.provider.DefaultJSONProvider",
        "codecs"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 400"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_json_bad_requests` test is to verify that the Flask application correctly handles malformed JSON input in a POST request to the `/json` endpoint, returning a 400 Bad Request status code.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks the application's response to invalid JSON data. It ensures that when the client sends malformed JSON (in this case, a plain string instead of a valid JSON object), the application responds with a 400 status code, indicating that the request could not be processed due to client error.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the Flask route defined within the `test_json_bad_requests` function. The route `/json` is set up to accept POST requests and attempts to parse the incoming JSON data using `flask.request.get_json()`. If the data is malformed (like the string \"malformed\"), the Flask framework raises a `BadRequest` exception, which results in a 400 status code being returned to the client.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of Flask's test client to simulate a POST request to the application. It uses assertions to validate the response status code. This pattern of testing routes with various inputs is common in unit tests for web applications, allowing developers to ensure that their endpoints behave correctly under different scenarios. Additionally, the test is structured to be self-contained, defining the route within the test function, which is a common practice in unit testing to isolate tests and avoid side effects."
    },
    {
      "name": "test_json_custom_mimetypes",
      "module": "test_json",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json.py",
      "line_number": 39,
      "end_line_number": 45,
      "source_code": "def test_json_custom_mimetypes(app, client):\n    @app.route(\"/json\", methods=[\"POST\"])\n    def return_json():\n        return flask.request.get_json()\n\n    rv = client.post(\"/json\", data='\"foo\"', content_type=\"application/x+json\")\n    assert rv.data == b\"foo\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "datetime",
        "decimal",
        "io",
        "uuid",
        "pytest",
        "werkzeug.http.http_date",
        "flask",
        "flask.json",
        "flask.json.provider.DefaultJSONProvider",
        "codecs"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'foo'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_json_custom_mimetypes` test is to verify that the Flask application correctly handles JSON data sent with a custom MIME type (`application/x+json`). It ensures that the application can parse and return JSON data accurately when the request is made with this specific content type.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a POST request is made to the `/json` endpoint with JSON data (`\"foo\"`) and the content type set to `application/x+json`, the response data matches the expected output (`b\"foo\"`). This confirms that the application correctly interprets the incoming request and returns the appropriate JSON response.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a Flask route defined as `return_json`, which uses `flask.request.get_json()` to extract JSON data from the incoming request. The test simulates a POST request to this route using the Flask test client, sending the JSON string `\"foo\"` as the request body. The `client.post` method is used to send the request, and the response is captured in the variable `rv`. The assertion checks that `rv.data` equals `b\"foo\"`, validating that the application correctly processes the JSON input.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of Flask's test client to simulate HTTP requests, which is a common pattern in testing web applications. It also utilizes assertions to verify the correctness of the response data. The test is structured to be concise and focused, ensuring that it only tests the specific behavior of handling custom MIME types for JSON. Additionally, the test leverages Flask's routing and request handling capabilities, demonstrating how to set up a simple endpoint for testing purposes."
    },
    {
      "name": "test_json_as_unicode",
      "module": "test_json",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json.py",
      "line_number": 51,
      "end_line_number": 54,
      "source_code": "def test_json_as_unicode(test_value, expected, app, app_ctx):\n    app.json.ensure_ascii = test_value\n    rv = app.json.dumps(\"\\N{SNOWMAN}\")\n    assert rv == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('test_value,expected', [(True, '\"\\\\u2603\"'), (False, '\"\u2603\"')])"
      ],
      "arguments": [
        "test_value",
        "expected",
        "app",
        "app_ctx"
      ],
      "imports": [
        "datetime",
        "decimal",
        "io",
        "uuid",
        "pytest",
        "werkzeug.http.http_date",
        "flask",
        "flask.json",
        "flask.json.provider.DefaultJSONProvider",
        "codecs"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_json_dump_to_file",
      "module": "test_json",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json.py",
      "line_number": 57,
      "end_line_number": 64,
      "source_code": "def test_json_dump_to_file(app, app_ctx):\n    test_data = {\"name\": \"Flask\"}\n    out = io.StringIO()\n\n    flask.json.dump(test_data, out)\n    out.seek(0)\n    rv = flask.json.load(out)\n    assert rv == test_data",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "app_ctx"
      ],
      "imports": [
        "datetime",
        "decimal",
        "io",
        "uuid",
        "pytest",
        "werkzeug.http.http_date",
        "flask",
        "flask.json",
        "flask.json.provider.DefaultJSONProvider",
        "codecs"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv == test_data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_jsonify_basic_types",
      "module": "test_json",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json.py",
      "line_number": 70,
      "end_line_number": 75,
      "source_code": "def test_jsonify_basic_types(test_value, app, client):\n    url = \"/jsonify_basic_types\"\n    app.add_url_rule(url, url, lambda x=test_value: flask.jsonify(x))\n    rv = client.get(url)\n    assert rv.mimetype == \"application/json\"\n    assert flask.json.loads(rv.data) == test_value",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('test_value', [0, -1, 1, 23, 3.14, 's', 'longer string', True, False, None])"
      ],
      "arguments": [
        "test_value",
        "app",
        "client"
      ],
      "imports": [
        "datetime",
        "decimal",
        "io",
        "uuid",
        "pytest",
        "werkzeug.http.http_date",
        "flask",
        "flask.json",
        "flask.json.provider.DefaultJSONProvider",
        "codecs"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.mimetype == 'application/json'",
        "assert flask.json.loads(rv.data) == test_value"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "flask.json.loads",
          "body": "def loads(self, s, **kwargs):\n    kwargs.setdefault('object_hook', self.object_hook)\n    return super().loads(s, **kwargs)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_jsonify_basic_types` function is designed to verify that the Flask application correctly serializes basic data types into JSON format and returns the appropriate content type in the HTTP response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks two main aspects: \n1. The response's MIME type is `application/json`, ensuring that the server indicates the correct content type for JSON data.\n2. The actual JSON data returned matches the expected `test_value`, confirming that the serialization process works as intended.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a temporary route (`/jsonify_basic_types`) in the Flask application that returns a JSON response using `flask.jsonify`. The `test_value` parameter is passed to this route, which is then serialized into JSON format. The test client (`client`) makes a GET request to this route, and the response is evaluated for its MIME type and content. The `flask.json.loads` function is used to deserialize the response data back into a Python object for comparison with `test_value`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Dynamic Route Creation**: The test dynamically adds a route to the Flask app for the duration of the test, allowing for isolated testing of specific functionality without affecting the overall application.\n- **Client Simulation**: The use of `client.get(url)` simulates a real HTTP request to the application, enabling the test to verify the behavior of the application as it would operate in a production environment.\n- **Assertions**: The test employs assertions to validate both the response's MIME type and the content of the response, ensuring comprehensive verification of the expected behavior."
    },
    {
      "name": "test_jsonify_dicts",
      "module": "test_json",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json.py",
      "line_number": 78,
      "end_line_number": 102,
      "source_code": "def test_jsonify_dicts(app, client):\n    d = {\n        \"a\": 0,\n        \"b\": 23,\n        \"c\": 3.14,\n        \"d\": \"t\",\n        \"e\": \"Hi\",\n        \"f\": True,\n        \"g\": False,\n        \"h\": [\"test list\", 10, False],\n        \"i\": {\"test\": \"dict\"},\n    }\n\n    @app.route(\"/kw\")\n    def return_kwargs():\n        return flask.jsonify(**d)\n\n    @app.route(\"/dict\")\n    def return_dict():\n        return flask.jsonify(d)\n\n    for url in \"/kw\", \"/dict\":\n        rv = client.get(url)\n        assert rv.mimetype == \"application/json\"\n        assert flask.json.loads(rv.data) == d",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "datetime",
        "decimal",
        "io",
        "uuid",
        "pytest",
        "werkzeug.http.http_date",
        "flask",
        "flask.json",
        "flask.json.provider.DefaultJSONProvider",
        "codecs"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.mimetype == 'application/json'",
        "assert flask.json.loads(rv.data) == d"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "flask.json.loads",
          "body": "def loads(self, s, **kwargs):\n    kwargs.setdefault('object_hook', self.object_hook)\n    return super().loads(s, **kwargs)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_jsonify_dicts` function is designed to verify that the Flask application correctly serializes Python dictionaries into JSON format when accessed via specific routes. It ensures that the response is of the correct MIME type and that the data returned matches the expected dictionary structure.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks two routes (`/kw` and `/dict`) to confirm that both return a JSON response with the correct content type (`application/json`) and that the JSON data matches the predefined dictionary `d`. It validates that the Flask `jsonify` function can handle both keyword arguments and dictionary arguments appropriately.\n\n**Code Being Tested and How It Works**:  \nThe test defines a dictionary `d` containing various data types (integers, floats, strings, booleans, lists, and nested dictionaries). It sets up two routes in the Flask application: one that uses keyword arguments to unpack the dictionary (`return_kwargs`) and another that directly passes the dictionary (`return_dict`). The test then makes GET requests to both routes using the `client` fixture and asserts that the response's MIME type is `application/json` and that the JSON data matches the original dictionary `d` after being loaded.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Route Definition within Tests**: The test dynamically defines routes within the test function, allowing for isolated testing of specific behaviors without modifying the global application state.\n- **Client Simulation**: It uses the `client` fixture to simulate HTTP requests to the application, enabling the testing of response behaviors as if they were made by a real user.\n- **Assertions**: The test employs assertions to validate both the MIME type and the content of the response, ensuring comprehensive verification of the output.\n- **Data Structure Testing**: It tests the serialization of complex data structures (dictionaries with various data types), which is crucial for ensuring that the application can handle real-world data effectively."
    },
    {
      "name": "test_jsonify_arrays",
      "module": "test_json",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json.py",
      "line_number": 105,
      "end_line_number": 130,
      "source_code": "def test_jsonify_arrays(app, client):\n    \"\"\"Test jsonify of lists and args unpacking.\"\"\"\n    a_list = [\n        0,\n        42,\n        3.14,\n        \"t\",\n        \"hello\",\n        True,\n        False,\n        [\"test list\", 2, False],\n        {\"test\": \"dict\"},\n    ]\n\n    @app.route(\"/args_unpack\")\n    def return_args_unpack():\n        return flask.jsonify(*a_list)\n\n    @app.route(\"/array\")\n    def return_array():\n        return flask.jsonify(a_list)\n\n    for url in \"/args_unpack\", \"/array\":\n        rv = client.get(url)\n        assert rv.mimetype == \"application/json\"\n        assert flask.json.loads(rv.data) == a_list",
      "docstring": "Test jsonify of lists and args unpacking.",
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "datetime",
        "decimal",
        "io",
        "uuid",
        "pytest",
        "werkzeug.http.http_date",
        "flask",
        "flask.json",
        "flask.json.provider.DefaultJSONProvider",
        "codecs"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.mimetype == 'application/json'",
        "assert flask.json.loads(rv.data) == a_list"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "flask.json.loads",
          "body": "def loads(self, s, **kwargs):\n    kwargs.setdefault('object_hook', self.object_hook)\n    return super().loads(s, **kwargs)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_jsonify_arrays` function is designed to verify the correct behavior of the Flask `jsonify` function when handling lists and unpacking arguments. It ensures that both a list passed directly and a list unpacked as arguments are serialized into valid JSON responses.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the responses from two different routes (`/args_unpack` and `/array`) return the correct MIME type (`application/json`) and that the JSON data returned matches the expected list (`a_list`). This confirms that the `jsonify` function can handle both direct list serialization and argument unpacking correctly.\n\n**Code Being Tested and How It Works**:  \nThe test defines two routes within the Flask application:\n1. `/args_unpack`: Uses argument unpacking to pass the elements of `a_list` to `flask.jsonify`.\n2. `/array`: Directly passes `a_list` to `flask.jsonify`.\n\nThe test then makes GET requests to both routes using the `client` fixture, which simulates a client making requests to the Flask application. The responses are checked for the correct MIME type and the correctness of the JSON data returned.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Route Definition within Tests**: The test dynamically defines routes within the test function, allowing for isolated testing of specific behaviors without affecting the global application state.\n- **Client Simulation**: The use of the `client` fixture to simulate HTTP requests is a common pattern in Flask testing, enabling the verification of response properties and content.\n- **Assertions**: The test employs assertions to validate the response's MIME type and the correctness of the JSON data, ensuring that the functionality behaves as expected."
    },
    {
      "name": "test_jsonify_datetime",
      "module": "test_json",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json.py",
      "line_number": 136,
      "end_line_number": 142,
      "source_code": "def test_jsonify_datetime(app, client, value):\n    @app.route(\"/\")\n    def index():\n        return flask.jsonify(value=value)\n\n    r = client.get()\n    assert r.json[\"value\"] == http_date(value)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('value', [datetime.datetime(1973, 3, 11, 6, 30, 45), datetime.date(1975, 1, 5)])"
      ],
      "arguments": [
        "app",
        "client",
        "value"
      ],
      "imports": [
        "datetime",
        "decimal",
        "io",
        "uuid",
        "pytest",
        "werkzeug.http.http_date",
        "flask",
        "flask.json",
        "flask.json.provider.DefaultJSONProvider",
        "codecs"
      ],
      "fixtures": [],
      "assertions": [
        "assert r.json['value'] == http_date(value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_jsonify_datetime` test is designed to verify that the Flask application correctly serializes datetime objects into a JSON format that adheres to the HTTP date format. This ensures that datetime values are properly handled and returned in a standardized way when converted to JSON.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that when a datetime value is passed to the Flask application, it is returned in the expected HTTP date format. The assertion confirms that the JSON response contains the correctly formatted date string, which is generated by the `http_date` function.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a Flask route defined at the root URL (\"/\") that returns a JSON response containing a value. The `client.get()` method is used to simulate a GET request to this route. The response is then checked to ensure that the \"value\" key in the JSON response matches the expected output of the `http_date(value)` function, which formats the datetime value appropriately.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test utilizes the Flask testing client to simulate HTTP requests and responses, allowing for integration-style testing of the application routes. It also employs parameterization (though not shown in the provided snippet) to potentially test multiple datetime values, ensuring that the serialization works consistently across different inputs. The use of assertions to validate the response data is a common practice in unit testing to confirm that the application behaves as expected."
    },
    {
      "name": "test_jsonify_aware_datetimes",
      "module": "test_json",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json.py",
      "line_number": 167,
      "end_line_number": 173,
      "source_code": "def test_jsonify_aware_datetimes(tz):\n    \"\"\"Test if aware datetime.datetime objects are converted into GMT.\"\"\"\n    tzinfo = FixedOffset(hours=tz[1], name=tz[0])\n    dt = datetime.datetime(2017, 1, 1, 12, 34, 56, tzinfo=tzinfo)\n    gmt = FixedOffset(hours=0, name=\"GMT\")\n    expected = dt.astimezone(gmt).strftime('\"%a, %d %b %Y %H:%M:%S %Z\"')\n    assert flask.json.dumps(dt) == expected",
      "docstring": "Test if aware datetime.datetime objects are converted into GMT.",
      "decorators": [
        "pytest.mark.parametrize('tz', (('UTC', 0), ('PST', -8), ('KST', 9)))"
      ],
      "arguments": [
        "tz"
      ],
      "imports": [
        "datetime",
        "decimal",
        "io",
        "uuid",
        "pytest",
        "werkzeug.http.http_date",
        "flask",
        "flask.json",
        "flask.json.provider.DefaultJSONProvider",
        "codecs"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.json.dumps(dt) == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_jsonify_uuid_types",
      "module": "test_json",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json.py",
      "line_number": 176,
      "end_line_number": 188,
      "source_code": "def test_jsonify_uuid_types(app, client):\n    \"\"\"Test jsonify with uuid.UUID types\"\"\"\n\n    test_uuid = uuid.UUID(bytes=b\"\\xde\\xad\\xbe\\xef\" * 4)\n    url = \"/uuid_test\"\n    app.add_url_rule(url, url, lambda: flask.jsonify(x=test_uuid))\n\n    rv = client.get(url)\n\n    rv_x = flask.json.loads(rv.data)[\"x\"]\n    assert rv_x == str(test_uuid)\n    rv_uuid = uuid.UUID(rv_x)\n    assert rv_uuid == test_uuid",
      "docstring": "Test jsonify with uuid.UUID types",
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "datetime",
        "decimal",
        "io",
        "uuid",
        "pytest",
        "werkzeug.http.http_date",
        "flask",
        "flask.json",
        "flask.json.provider.DefaultJSONProvider",
        "codecs"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv_x == str(test_uuid)",
        "assert rv_uuid == test_uuid"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "flask.json.loads",
          "body": "def loads(self, s, **kwargs):\n    kwargs.setdefault('object_hook', self.object_hook)\n    return super().loads(s, **kwargs)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_jsonify_uuid_types` test is designed to verify that the Flask application correctly serializes and deserializes UUID objects when returned as JSON responses. It ensures that UUIDs are properly converted to string format and can be accurately reconstructed from that string.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main behaviors: \n1. The UUID is serialized to a string format when returned in a JSON response.\n2. The string representation of the UUID can be deserialized back into a UUID object, confirming that the original UUID and the deserialized UUID are equivalent.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Flask route (`/uuid_test`) that returns a JSON response containing a UUID. It uses the `flask.jsonify` function to create the response. The test then makes a GET request to this route using the test client, retrieves the JSON data, and checks that the UUID is correctly serialized as a string. It also reconstructs the UUID from the string and asserts that it matches the original UUID.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Use of Flask Test Client**: The test utilizes Flask's test client to simulate HTTP requests to the application, allowing for integration-style testing of the route.\n- **Assertions**: The test employs assertions to validate the expected outcomes, ensuring that both the serialized string and the deserialized UUID match the original UUID.\n- **Lambda Function for Route Handling**: A lambda function is used to define the route's behavior inline, which is a concise way to set up simple routes for testing purposes."
    },
    {
      "name": "test_json_decimal",
      "module": "test_json",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json.py",
      "line_number": 191,
      "end_line_number": 193,
      "source_code": "def test_json_decimal():\n    rv = flask.json.dumps(decimal.Decimal(\"0.003\"))\n    assert rv == '\"0.003\"'",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime",
        "decimal",
        "io",
        "uuid",
        "pytest",
        "werkzeug.http.http_date",
        "flask",
        "flask.json",
        "flask.json.provider.DefaultJSONProvider",
        "codecs"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv == '\"0.003\"'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_json_attr",
      "module": "test_json",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json.py",
      "line_number": 196,
      "end_line_number": 207,
      "source_code": "def test_json_attr(app, client):\n    @app.route(\"/add\", methods=[\"POST\"])\n    def add():\n        json = flask.request.get_json()\n        return str(json[\"a\"] + json[\"b\"])\n\n    rv = client.post(\n        \"/add\",\n        data=flask.json.dumps({\"a\": 1, \"b\": 2}),\n        content_type=\"application/json\",\n    )\n    assert rv.data == b\"3\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "datetime",
        "decimal",
        "io",
        "uuid",
        "pytest",
        "werkzeug.http.http_date",
        "flask",
        "flask.json",
        "flask.json.provider.DefaultJSONProvider",
        "codecs"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'3'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_json_attr` function is designed to verify the behavior of a Flask route that processes JSON input. Specifically, it tests the `/add` endpoint to ensure that it correctly sums two numbers provided in a JSON payload.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a POST request is made to the `/add` route with a JSON body containing two integers (`a` and `b`), the response correctly returns their sum as a string. In this case, it verifies that the sum of `1` and `2` results in the string `\"3\"`.\n\n**Code Being Tested and How It Works**:  \nThe code under test defines a Flask route `/add` that accepts POST requests. Inside the route, it retrieves the JSON data from the request using `flask.request.get_json()`, accesses the values of `a` and `b`, and returns their sum as a string. The test simulates a client making a POST request to this route with a JSON body `{\"a\": 1, \"b\": 2}` and asserts that the response data matches the expected output.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of Flask's test client to simulate HTTP requests, allowing for isolated testing of the route without needing to run a live server. It also uses assertions to validate the response, ensuring that the output matches the expected result. The test is structured to be straightforward, focusing on a single functionality, which is a common practice in unit testing to ensure clarity and maintainability."
    },
    {
      "name": "test_tojson_filter",
      "module": "test_json",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json.py",
      "line_number": 210,
      "end_line_number": 220,
      "source_code": "def test_tojson_filter(app, req_ctx):\n    # The tojson filter is tested in Jinja, this confirms that it's\n    # using Flask's dumps.\n    rv = flask.render_template_string(\n        \"const data = {{ data|tojson }};\",\n        data={\"name\": \"</script>\", \"time\": datetime.datetime(2021, 2, 1, 7, 15)},\n    )\n    assert rv == (\n        'const data = {\"name\": \"\\\\u003c/script\\\\u003e\",'\n        ' \"time\": \"Mon, 01 Feb 2021 07:15:00 GMT\"};'\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "req_ctx"
      ],
      "imports": [
        "datetime",
        "decimal",
        "io",
        "uuid",
        "pytest",
        "werkzeug.http.http_date",
        "flask",
        "flask.json",
        "flask.json.provider.DefaultJSONProvider",
        "codecs"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv == 'const data = {\"name\": \"\\\\u003c/script\\\\u003e\", \"time\": \"Mon, 01 Feb 2021 07:15:00 GMT\"};'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_json_customization",
      "module": "test_json",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json.py",
      "line_number": 223,
      "end_line_number": 257,
      "source_code": "def test_json_customization(app, client):\n    class X:  # noqa: B903, for Python2 compatibility\n        def __init__(self, val):\n            self.val = val\n\n    def default(o):\n        if isinstance(o, X):\n            return f\"<{o.val}>\"\n\n        return DefaultJSONProvider.default(o)\n\n    class CustomProvider(DefaultJSONProvider):\n        def object_hook(self, obj):\n            if len(obj) == 1 and \"_foo\" in obj:\n                return X(obj[\"_foo\"])\n\n            return obj\n\n        def loads(self, s, **kwargs):\n            kwargs.setdefault(\"object_hook\", self.object_hook)\n            return super().loads(s, **kwargs)\n\n    app.json = CustomProvider(app)\n    app.json.default = default\n\n    @app.route(\"/\", methods=[\"POST\"])\n    def index():\n        return flask.json.dumps(flask.request.get_json()[\"x\"])\n\n    rv = client.post(\n        \"/\",\n        data=flask.json.dumps({\"x\": {\"_foo\": 42}}),\n        content_type=\"application/json\",\n    )\n    assert rv.data == b'\"<42>\"'",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "datetime",
        "decimal",
        "io",
        "uuid",
        "pytest",
        "werkzeug.http.http_date",
        "flask",
        "flask.json",
        "flask.json.provider.DefaultJSONProvider",
        "codecs"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'\"<42>\"'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.post",
          "body": "def post(self):\n    return 'Create'"
        },
        {
          "name": "DefaultJSONProvider.default",
          "body": "def default(o):\n    if isinstance(o, X):\n        return f'<{o.val}>'\n    return DefaultJSONProvider.default(o)"
        },
        {
          "name": "kwargs.setdefault",
          "body": "@app.route('/setdefault')\ndef setdefault():\n    return flask.session.setdefault('test', 'default')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_json_customization` function is designed to verify the customization of JSON serialization and deserialization in a Flask application. It ensures that specific objects can be serialized in a custom format when returned as JSON responses.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a POST request is made to the root endpoint with a JSON payload containing a specific structure, the response correctly serializes an instance of a custom class (`X`) into a string format defined by the `default` function. Specifically, it verifies that the output is `b'\"<42>\"'` when the input is `{\"x\": {\"_foo\": 42}}`.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Flask application with a custom JSON provider (`CustomProvider`) that overrides the default behavior of JSON serialization. The `object_hook` method in `CustomProvider` transforms JSON objects with a single key `_foo` into instances of class `X`. The `default` function is also defined to customize how instances of `X` are serialized. The test then sends a POST request to the `/` route, which extracts the JSON data, and the response is generated using the customized JSON serialization logic.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Custom JSON Provider**: The test demonstrates the use of a custom JSON provider to modify serialization behavior, showcasing extensibility in Flask applications.\n- **Flask Test Client**: It utilizes Flask's test client to simulate HTTP requests and validate responses, which is a common pattern in testing web applications.\n- **Assertions**: The test employs assertions to verify that the actual output matches the expected output, ensuring that the customization works as intended."
    },
    {
      "name": "test_json_key_sorting",
      "module": "test_json",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json.py",
      "line_number": 270,
      "end_line_number": 337,
      "source_code": "def test_json_key_sorting(app, client):\n    app.debug = True\n    assert app.json.sort_keys\n    d = dict.fromkeys(range(20), \"foo\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.jsonify(values=d)\n\n    rv = client.get(\"/\")\n    lines = [x.strip() for x in rv.data.strip().decode(\"utf-8\").splitlines()]\n    sorted_by_str = [\n        \"{\",\n        '\"values\": {',\n        '\"0\": \"foo\",',\n        '\"1\": \"foo\",',\n        '\"10\": \"foo\",',\n        '\"11\": \"foo\",',\n        '\"12\": \"foo\",',\n        '\"13\": \"foo\",',\n        '\"14\": \"foo\",',\n        '\"15\": \"foo\",',\n        '\"16\": \"foo\",',\n        '\"17\": \"foo\",',\n        '\"18\": \"foo\",',\n        '\"19\": \"foo\",',\n        '\"2\": \"foo\",',\n        '\"3\": \"foo\",',\n        '\"4\": \"foo\",',\n        '\"5\": \"foo\",',\n        '\"6\": \"foo\",',\n        '\"7\": \"foo\",',\n        '\"8\": \"foo\",',\n        '\"9\": \"foo\"',\n        \"}\",\n        \"}\",\n    ]\n    sorted_by_int = [\n        \"{\",\n        '\"values\": {',\n        '\"0\": \"foo\",',\n        '\"1\": \"foo\",',\n        '\"2\": \"foo\",',\n        '\"3\": \"foo\",',\n        '\"4\": \"foo\",',\n        '\"5\": \"foo\",',\n        '\"6\": \"foo\",',\n        '\"7\": \"foo\",',\n        '\"8\": \"foo\",',\n        '\"9\": \"foo\",',\n        '\"10\": \"foo\",',\n        '\"11\": \"foo\",',\n        '\"12\": \"foo\",',\n        '\"13\": \"foo\",',\n        '\"14\": \"foo\",',\n        '\"15\": \"foo\",',\n        '\"16\": \"foo\",',\n        '\"17\": \"foo\",',\n        '\"18\": \"foo\",',\n        '\"19\": \"foo\"',\n        \"}\",\n        \"}\",\n    ]\n\n    try:\n        assert lines == sorted_by_int\n    except AssertionError:\n        assert lines == sorted_by_str",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "datetime",
        "decimal",
        "io",
        "uuid",
        "pytest",
        "werkzeug.http.http_date",
        "flask",
        "flask.json",
        "flask.json.provider.DefaultJSONProvider",
        "codecs"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.json.sort_keys",
        "assert lines == sorted_by_int",
        "assert lines == sorted_by_str"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_json_key_sorting` function is designed to verify that the JSON response from a Flask application returns keys in a sorted order when the `sort_keys` option is enabled in the Flask app's JSON configuration. This ensures that the output is consistent and predictable, which is crucial for clients consuming the API.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the keys in the JSON response are sorted numerically (as integers) rather than lexicographically (as strings). It asserts that the output matches the expected sorted order of keys, confirming that the application correctly implements the sorting behavior specified by the `sort_keys` configuration.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a Flask route defined in the `index` function, which returns a JSON response containing a dictionary `d` with keys ranging from 0 to 19, all mapped to the value \"foo\". The test sends a GET request to this route using the `client` fixture and captures the response. It then processes the response data to compare the order of keys against two expected formats: one sorted by string representation and another sorted by integer representation.\n\n**Notable Testing Patterns or Techniques Used**:  \n1. **Assertion Handling**: The test uses a try-except block to handle assertions, first checking against the integer-sorted expected output and falling back to the string-sorted output if the first assertion fails. This pattern allows for a clear distinction between the two sorting behaviors.\n2. **Flask Testing Client**: The use of the `client` fixture to simulate HTTP requests to the Flask application is a common practice in Flask testing, enabling the verification of route behavior and response formats.\n3. **Dynamic Route Definition**: The route is defined within the test function, showcasing a technique where routes can be dynamically created for testing purposes, ensuring isolation and specificity in tests."
    },
    {
      "name": "test_html_method",
      "module": "test_json",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_json.py",
      "line_number": 340,
      "end_line_number": 346,
      "source_code": "def test_html_method():\n    class ObjectWithHTML:\n        def __html__(self):\n            return \"<p>test</p>\"\n\n    result = json.dumps(ObjectWithHTML())\n    assert result == '\"<p>test</p>\"'",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime",
        "decimal",
        "io",
        "uuid",
        "pytest",
        "werkzeug.http.http_date",
        "flask",
        "flask.json",
        "flask.json.provider.DefaultJSONProvider",
        "codecs"
      ],
      "fixtures": [],
      "assertions": [
        "assert result == '\"<p>test</p>\"'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_logger",
      "module": "test_logging",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_logging.py",
      "line_number": 36,
      "end_line_number": 39,
      "source_code": "def test_logger(app):\n    assert app.logger.name == \"flask_test\"\n    assert app.logger.level == logging.NOTSET\n    assert app.logger.handlers == [default_handler]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "sys",
        "io.StringIO",
        "pytest",
        "flask.logging.default_handler",
        "flask.logging.has_level_handler",
        "flask.logging.wsgi_errors_stream"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.logger.name == 'flask_test'",
        "assert app.logger.level == logging.NOTSET",
        "assert app.logger.handlers == [default_handler]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_logger_debug",
      "module": "test_logging",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_logging.py",
      "line_number": 42,
      "end_line_number": 45,
      "source_code": "def test_logger_debug(app):\n    app.debug = True\n    assert app.logger.level == logging.DEBUG\n    assert app.logger.handlers == [default_handler]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "sys",
        "io.StringIO",
        "pytest",
        "flask.logging.default_handler",
        "flask.logging.has_level_handler",
        "flask.logging.wsgi_errors_stream"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.logger.level == logging.DEBUG",
        "assert app.logger.handlers == [default_handler]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_existing_handler",
      "module": "test_logging",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_logging.py",
      "line_number": 48,
      "end_line_number": 51,
      "source_code": "def test_existing_handler(app):\n    logging.root.addHandler(logging.StreamHandler())\n    assert app.logger.level == logging.NOTSET\n    assert not app.logger.handlers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "sys",
        "io.StringIO",
        "pytest",
        "flask.logging.default_handler",
        "flask.logging.has_level_handler",
        "flask.logging.wsgi_errors_stream"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.logger.level == logging.NOTSET",
        "assert not app.logger.handlers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_wsgi_errors_stream",
      "module": "test_logging",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_logging.py",
      "line_number": 54,
      "end_line_number": 67,
      "source_code": "def test_wsgi_errors_stream(app, client):\n    @app.route(\"/\")\n    def index():\n        app.logger.error(\"test\")\n        return \"\"\n\n    stream = StringIO()\n    client.get(\"/\", errors_stream=stream)\n    assert \"ERROR in test_logging: test\" in stream.getvalue()\n\n    assert wsgi_errors_stream._get_current_object() is sys.stderr\n\n    with app.test_request_context(errors_stream=stream):\n        assert wsgi_errors_stream._get_current_object() is stream",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "logging",
        "sys",
        "io.StringIO",
        "pytest",
        "flask.logging.default_handler",
        "flask.logging.has_level_handler",
        "flask.logging.wsgi_errors_stream"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'ERROR in test_logging: test' in stream.getvalue()",
        "assert wsgi_errors_stream._get_current_object() is sys.stderr",
        "assert wsgi_errors_stream._get_current_object() is stream"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        },
        {
          "name": "app.logger.error",
          "body": "@app.route('/error')\ndef error():\n    raise ZeroDivisionError"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_wsgi_errors_stream` unit test is designed to verify the correct behavior of the Flask application's error logging mechanism, specifically ensuring that errors are logged to the appropriate stream based on the request context.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when an error occurs (in this case, a logged error message), it is correctly captured in the specified error stream. It also verifies that the error stream changes appropriately depending on whether a request context is active.\n\n**Code Being Tested and How It Works**:  \nThe test defines a simple route (`index`) that logs an error message using `app.logger.error`. It then simulates a request to this route using the Flask test client, capturing any output to a `StringIO` stream. The assertions confirm that the logged error message appears in the stream and that the error stream is correctly set to `sys.stderr` when no request context is active, and to the `StringIO` stream when a request context is established.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The test utilizes Flask's `test_request_context` to simulate a request context, allowing for testing of behavior that depends on the request lifecycle.\n- **Assertions**: It employs assertions to validate that the expected error messages are present in the output stream and that the error stream is correctly assigned based on the context.\n- **Mocking**: The use of `StringIO` acts as a mock for capturing log output, enabling the test to verify logging behavior without needing to write to actual log files or the console."
    },
    {
      "name": "test_has_level_handler",
      "module": "test_logging",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_logging.py",
      "line_number": 70,
      "end_line_number": 83,
      "source_code": "def test_has_level_handler():\n    logger = logging.getLogger(\"flask.app\")\n    assert not has_level_handler(logger)\n\n    handler = logging.StreamHandler()\n    logging.root.addHandler(handler)\n    assert has_level_handler(logger)\n\n    logger.propagate = False\n    assert not has_level_handler(logger)\n    logger.propagate = True\n\n    handler.setLevel(logging.ERROR)\n    assert not has_level_handler(logger)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "sys",
        "io.StringIO",
        "pytest",
        "flask.logging.default_handler",
        "flask.logging.has_level_handler",
        "flask.logging.wsgi_errors_stream"
      ],
      "fixtures": [],
      "assertions": [
        "assert not has_level_handler(logger)",
        "assert has_level_handler(logger)",
        "assert not has_level_handler(logger)",
        "assert not has_level_handler(logger)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_log_view_exception",
      "module": "test_logging",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_logging.py",
      "line_number": 86,
      "end_line_number": 98,
      "source_code": "def test_log_view_exception(app, client):\n    @app.route(\"/\")\n    def index():\n        raise Exception(\"test\")\n\n    app.testing = False\n    stream = StringIO()\n    rv = client.get(\"/\", errors_stream=stream)\n    assert rv.status_code == 500\n    assert rv.data\n    err = stream.getvalue()\n    assert \"Exception on / [GET]\" in err\n    assert \"Exception: test\" in err",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "logging",
        "sys",
        "io.StringIO",
        "pytest",
        "flask.logging.default_handler",
        "flask.logging.has_level_handler",
        "flask.logging.wsgi_errors_stream"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.status_code == 500",
        "assert rv.data",
        "assert 'Exception on / [GET]' in err",
        "assert 'Exception: test' in err"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_log_view_exception` test is to verify that the Flask application correctly handles exceptions raised during a request to the root route (\"/\"). Specifically, it checks that the application returns a 500 Internal Server Error status code and logs the appropriate error message.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when an exception is raised in a route handler, the application responds with a 500 status code, indicating a server error. Additionally, it verifies that the error message is correctly captured in the error stream, confirming that the exception details are logged as expected.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the Flask route defined by the `index` function, which raises an exception when accessed. The test uses the Flask test client to simulate a GET request to the root URL (\"/\"). The `errors_stream` parameter is utilized to capture any error messages generated during the request. The assertions check that the response status code is 500, that there is data in the response, and that the error stream contains specific messages indicating the nature of the exception.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Exception Handling**: The test deliberately raises an exception to test the application's error handling capabilities.\n- **Flask Test Client**: It employs the Flask test client to simulate HTTP requests and capture responses, which is a common practice in testing Flask applications.\n- **Error Stream Capture**: The use of `errors_stream` allows the test to capture and assert on the error output, ensuring that logging behavior is also verified alongside the HTTP response.\n- **Assertions**: Multiple assertions are used to validate different aspects of the response and error logging, ensuring comprehensive coverage of the expected behavior."
    },
    {
      "name": "test_cli_name",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 41,
      "end_line_number": 45,
      "source_code": "def test_cli_name(test_apps):\n    \"\"\"Make sure the CLI object's name is the app's name and not the app itself\"\"\"\n    from cliapp.app import testapp\n\n    assert testapp.cli.name == testapp.name",
      "docstring": "Make sure the CLI object's name is the app's name and not the app itself",
      "decorators": [],
      "arguments": [
        "test_apps"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert testapp.cli.name == testapp.name"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_find_best_app",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 48,
      "end_line_number": 132,
      "source_code": "def test_find_best_app(test_apps):\n    class Module:\n        app = Flask(\"appname\")\n\n    assert find_best_app(Module) == Module.app\n\n    class Module:\n        application = Flask(\"appname\")\n\n    assert find_best_app(Module) == Module.application\n\n    class Module:\n        myapp = Flask(\"appname\")\n\n    assert find_best_app(Module) == Module.myapp\n\n    class Module:\n        @staticmethod\n        def create_app():\n            return Flask(\"appname\")\n\n    app = find_best_app(Module)\n    assert isinstance(app, Flask)\n    assert app.name == \"appname\"\n\n    class Module:\n        @staticmethod\n        def create_app(**kwargs):\n            return Flask(\"appname\")\n\n    app = find_best_app(Module)\n    assert isinstance(app, Flask)\n    assert app.name == \"appname\"\n\n    class Module:\n        @staticmethod\n        def make_app():\n            return Flask(\"appname\")\n\n    app = find_best_app(Module)\n    assert isinstance(app, Flask)\n    assert app.name == \"appname\"\n\n    class Module:\n        myapp = Flask(\"appname1\")\n\n        @staticmethod\n        def create_app():\n            return Flask(\"appname2\")\n\n    assert find_best_app(Module) == Module.myapp\n\n    class Module:\n        myapp = Flask(\"appname1\")\n\n        @staticmethod\n        def create_app():\n            return Flask(\"appname2\")\n\n    assert find_best_app(Module) == Module.myapp\n\n    class Module:\n        pass\n\n    pytest.raises(NoAppException, find_best_app, Module)\n\n    class Module:\n        myapp1 = Flask(\"appname1\")\n        myapp2 = Flask(\"appname2\")\n\n    pytest.raises(NoAppException, find_best_app, Module)\n\n    class Module:\n        @staticmethod\n        def create_app(foo, bar):\n            return Flask(\"appname2\")\n\n    pytest.raises(NoAppException, find_best_app, Module)\n\n    class Module:\n        @staticmethod\n        def create_app():\n            raise TypeError(\"bad bad factory!\")\n\n    pytest.raises(TypeError, find_best_app, Module)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_apps"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert find_best_app(Module) == Module.app",
        "assert find_best_app(Module) == Module.application",
        "assert find_best_app(Module) == Module.myapp",
        "assert isinstance(app, Flask)",
        "assert app.name == 'appname'",
        "assert isinstance(app, Flask)",
        "assert app.name == 'appname'",
        "assert isinstance(app, Flask)",
        "assert app.name == 'appname'",
        "assert find_best_app(Module) == Module.myapp",
        "assert find_best_app(Module) == Module.myapp"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_prepare_import",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 161,
      "end_line_number": 177,
      "source_code": "def test_prepare_import(request, value, path, result):\n    \"\"\"Expect the correct path to be set and the correct import and app names\n    to be returned.\n\n    :func:`prepare_exec_for_file` has a side effect where the parent directory\n    of the given import is added to :data:`sys.path`. This is reset after the\n    test runs.\n    \"\"\"\n    original_path = sys.path[:]\n\n    def reset_path():\n        sys.path[:] = original_path\n\n    request.addfinalizer(reset_path)\n\n    assert prepare_import(value) == result\n    assert sys.path[0] == str(path)",
      "docstring": "Expect the correct path to be set and the correct import and app names\nto be returned.\n\n:func:`prepare_exec_for_file` has a side effect where the parent directory\nof the given import is added to :data:`sys.path`. This is reset after the\ntest runs.",
      "decorators": [
        "pytest.mark.parametrize('value,path,result', (('test', cwd, 'test'), ('test.py', cwd, 'test'), ('a/test', cwd / 'a', 'test'), ('test/__init__.py', cwd, 'test'), ('test/__init__', cwd, 'test'), (test_path / 'cliapp' / 'inner1' / '__init__', test_path, 'cliapp.inner1'), (test_path / 'cliapp' / 'inner1' / 'inner2', test_path, 'cliapp.inner1.inner2'), ('test.a.b', cwd, 'test.a.b'), (test_path / 'cliapp.app', test_path, 'cliapp.app'), (test_path / 'cliapp' / 'message.txt', test_path, 'cliapp.message.txt')))"
      ],
      "arguments": [
        "request",
        "value",
        "path",
        "result"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert prepare_import(value) == result",
        "assert sys.path[0] == str(path)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_locate_app",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 195,
      "end_line_number": 196,
      "source_code": "def test_locate_app(test_apps, iname, aname, result):\n    assert locate_app(iname, aname).name == result",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('iname,aname,result', (('cliapp.app', None, 'testapp'), ('cliapp.app', 'testapp', 'testapp'), ('cliapp.factory', None, 'app'), ('cliapp.factory', 'create_app', 'app'), ('cliapp.factory', 'create_app()', 'app'), ('cliapp.factory', 'create_app2(\"foo\", \"bar\")', 'app2_foo_bar'), ('cliapp.factory', 'create_app2(\"foo\", \"bar\", )', 'app2_foo_bar'), ('cliapp.factory', ' create_app () ', 'app')))"
      ],
      "arguments": [
        "test_apps",
        "iname",
        "aname",
        "result"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert locate_app(iname, aname).name == result"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_locate_app_raises",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 217,
      "end_line_number": 219,
      "source_code": "def test_locate_app_raises(test_apps, iname, aname):\n    with pytest.raises(NoAppException):\n        locate_app(iname, aname)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('iname,aname', (('notanapp.py', None), ('cliapp/app', None), ('cliapp.app', 'notanapp'), ('cliapp.factory', 'create_app2(\"foo\")'), ('cliapp.factory', 'create_app('), ('cliapp.factory', 'no_app'), ('cliapp.importerrorapp', None), ('cliapp.message.txt', None)))"
      ],
      "arguments": [
        "test_apps",
        "iname",
        "aname"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_locate_app_suppress_raise",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 222,
      "end_line_number": 228,
      "source_code": "def test_locate_app_suppress_raise(test_apps):\n    app = locate_app(\"notanapp.py\", None, raise_if_not_found=False)\n    assert app is None\n\n    # only direct import error is suppressed\n    with pytest.raises(NoAppException):\n        locate_app(\"cliapp.importerrorapp\", None, raise_if_not_found=False)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_apps"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert app is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_get_version",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 231,
      "end_line_number": 244,
      "source_code": "def test_get_version(test_apps, capsys):\n    class MockCtx:\n        resilient_parsing = False\n        color = None\n\n        def exit(self):\n            return\n\n    ctx = MockCtx()\n    get_version(ctx, None, \"test\")\n    out, err = capsys.readouterr()\n    assert f\"Python {platform.python_version()}\" in out\n    assert f\"Flask {importlib.metadata.version('flask')}\" in out\n    assert f\"Werkzeug {importlib.metadata.version('werkzeug')}\" in out",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_apps",
        "capsys"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert f'Python {platform.python_version()}' in out",
        "assert f\"Flask {importlib.metadata.version('flask')}\" in out",
        "assert f\"Werkzeug {importlib.metadata.version('werkzeug')}\" in out"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_scriptinfo",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 247,
      "end_line_number": 286,
      "source_code": "def test_scriptinfo(test_apps, monkeypatch):\n    obj = ScriptInfo(app_import_path=\"cliapp.app:testapp\")\n    app = obj.load_app()\n    assert app.name == \"testapp\"\n    assert obj.load_app() is app\n\n    # import app with module's absolute path\n    cli_app_path = str(test_path / \"cliapp\" / \"app.py\")\n\n    obj = ScriptInfo(app_import_path=cli_app_path)\n    app = obj.load_app()\n    assert app.name == \"testapp\"\n    assert obj.load_app() is app\n    obj = ScriptInfo(app_import_path=f\"{cli_app_path}:testapp\")\n    app = obj.load_app()\n    assert app.name == \"testapp\"\n    assert obj.load_app() is app\n\n    def create_app():\n        return Flask(\"createapp\")\n\n    obj = ScriptInfo(create_app=create_app)\n    app = obj.load_app()\n    assert app.name == \"createapp\"\n    assert obj.load_app() is app\n\n    obj = ScriptInfo()\n    pytest.raises(NoAppException, obj.load_app)\n\n    # import app from wsgi.py in current directory\n    monkeypatch.chdir(test_path / \"helloworld\")\n    obj = ScriptInfo()\n    app = obj.load_app()\n    assert app.name == \"hello\"\n\n    # import app from app.py in current directory\n    monkeypatch.chdir(test_path / \"cliapp\")\n    obj = ScriptInfo()\n    app = obj.load_app()\n    assert app.name == \"testapp\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_apps",
        "monkeypatch"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.name == 'testapp'",
        "assert obj.load_app() is app",
        "assert app.name == 'testapp'",
        "assert obj.load_app() is app",
        "assert app.name == 'testapp'",
        "assert obj.load_app() is app",
        "assert app.name == 'createapp'",
        "assert obj.load_app() is app",
        "assert app.name == 'hello'",
        "assert app.name == 'testapp'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_app_cli_has_app_context",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 289,
      "end_line_number": 304,
      "source_code": "def test_app_cli_has_app_context(app, runner):\n    def _param_cb(ctx, param, value):\n        # current_app should be available in parameter callbacks\n        return bool(current_app)\n\n    @app.cli.command()\n    @click.argument(\"value\", callback=_param_cb)\n    def check(value):\n        app = click.get_current_context().obj.load_app()\n        # the loaded app should be the same as current_app\n        same_app = current_app._get_current_object() is app\n        return same_app, value\n\n    cli = FlaskGroup(create_app=lambda: app)\n    result = runner.invoke(cli, [\"check\", \"x\"], standalone_mode=False)\n    assert result.return_value == (True, True)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "runner"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.return_value == (True, True)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_app_cli_has_app_context` verifies that the Flask CLI command can access the current application context when invoked. It ensures that the `current_app` variable correctly reflects the application instance being used within the command's execution context.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a CLI command is executed, the `current_app` is available and matches the application instance loaded by the command. It specifically asserts that the command returns a tuple indicating that the loaded app is the same as the `current_app`, along with the value passed to the command.\n\n**Code Being Tested and How It Works**:  \nThe test defines a CLI command `check` that takes an argument `value`. The command uses a callback `_param_cb` to ensure that `current_app` is accessible. Inside the command, it retrieves the current application context using `click.get_current_context().obj.load_app()` and compares it to `current_app`. The command is then invoked using the `runner.invoke` method, which simulates command-line execution. The test asserts that the command's return value is `(True, \"x\")`, confirming that the application context is correctly set.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The test utilizes the `runner` fixture from `pytest` to create a `CliRunner` instance, which is a common pattern for testing CLI applications in Flask.\n- **Command Callback**: The use of a callback function for argument validation demonstrates how to leverage Flask's CLI capabilities to ensure that the application context is available during command execution.\n- **Assertions**: The test employs assertions to validate the expected behavior of the command, ensuring that the application context is correctly managed and accessible."
    },
    {
      "name": "test_with_appcontext",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 307,
      "end_line_number": 317,
      "source_code": "def test_with_appcontext(runner):\n    @click.command()\n    @with_appcontext\n    def testcmd():\n        click.echo(current_app.name)\n\n    obj = ScriptInfo(create_app=lambda: Flask(\"testapp\"))\n\n    result = runner.invoke(testcmd, obj=obj)\n    assert result.exit_code == 0\n    assert result.output == \"testapp\\n\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "runner"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 0",
        "assert result.output == 'testapp\\n'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_with_appcontext` function is designed to verify that a command-line interface (CLI) command correctly accesses the Flask application's context and outputs the application's name. This ensures that the command behaves as expected when executed within the application context.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when the `testcmd` command is invoked, it successfully retrieves the name of the current Flask application (in this case, \"testapp\") and that the command exits without errors (exit code 0). It confirms that the command's output matches the expected string.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a CLI command defined using the `click` library, decorated with `@with_appcontext`, which allows it to access the Flask application context. The `ScriptInfo` object is created with a lambda function that initializes a Flask app named \"testapp\". The `runner.invoke` method is then used to simulate the command-line invocation of `testcmd`, capturing the result, which includes the exit code and output.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Use of Fixtures**: The `runner` fixture, provided by `pytest`, creates an instance of `CliRunner`, which is used to invoke CLI commands in a test environment.\n- **Context Management**: The `@with_appcontext` decorator ensures that the command runs within the Flask application context, allowing access to `current_app`.\n- **Assertions**: The test employs assertions to validate both the exit code and the output of the command, ensuring that the command behaves as expected under the defined conditions."
    },
    {
      "name": "test_appgroup_app_context",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 320,
      "end_line_number": 345,
      "source_code": "def test_appgroup_app_context(runner):\n    @click.group(cls=AppGroup)\n    def cli():\n        pass\n\n    @cli.command()\n    def test():\n        click.echo(current_app.name)\n\n    @cli.group()\n    def subgroup():\n        pass\n\n    @subgroup.command()\n    def test2():\n        click.echo(current_app.name)\n\n    obj = ScriptInfo(create_app=lambda: Flask(\"testappgroup\"))\n\n    result = runner.invoke(cli, [\"test\"], obj=obj)\n    assert result.exit_code == 0\n    assert result.output == \"testappgroup\\n\"\n\n    result = runner.invoke(cli, [\"subgroup\", \"test2\"], obj=obj)\n    assert result.exit_code == 0\n    assert result.output == \"testappgroup\\n\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "runner"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 0",
        "assert result.output == 'testappgroup\\n'",
        "assert result.exit_code == 0",
        "assert result.output == 'testappgroup\\n'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        },
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:\nThe primary purpose of the `test_appgroup_app_context` test is to verify that the Flask application context is correctly set up and accessible when executing CLI commands defined within a Click command group. It ensures that the application name can be retrieved correctly from the current application context during command execution.\n\n**Specific Functionality or Behavior Verified**:\nThis test specifically checks that when the CLI commands `test` and `test2` are invoked, they correctly output the name of the Flask application (`\"testappgroup\"`). It verifies that the application context is active and that the commands can access the `current_app` variable, which holds the application instance.\n\n**Code Being Tested and How It Works**:\nThe code under test involves a Click command group (`cli`) that contains two commands: `test` and `test2`. Each command uses `click.echo` to print the name of the current application, accessed via `current_app.name`. The test creates a `ScriptInfo` object with a lambda function that initializes a Flask app named `\"testappgroup\"`. The `runner.invoke` method is then used to simulate command-line execution of the CLI commands, capturing their output and exit codes for assertions.\n\n**Notable Testing Patterns or Techniques Used**:\nThe test employs several notable testing patterns:\n1. **Command Invocation**: It uses `runner.invoke` to simulate command-line interactions, allowing for testing of CLI commands in isolation.\n2. **Assertions**: The test asserts both the exit code and the output of the commands to ensure they behave as expected.\n3. **Application Context Management**: The test leverages Flask's application context management to ensure that the commands have access to the correct application instance during execution.\n4. **Fixture Usage**: The `runner` fixture is likely provided by pytest, which simplifies the setup for running CLI commands in a test environment."
    },
    {
      "name": "test_flaskgroup_app_context",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 348,
      "end_line_number": 362,
      "source_code": "def test_flaskgroup_app_context(runner):\n    def create_app():\n        return Flask(\"flaskgroup\")\n\n    @click.group(cls=FlaskGroup, create_app=create_app)\n    def cli(**params):\n        pass\n\n    @cli.command()\n    def test():\n        click.echo(current_app.name)\n\n    result = runner.invoke(cli, [\"test\"])\n    assert result.exit_code == 0\n    assert result.output == \"flaskgroup\\n\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "runner"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 0",
        "assert result.output == 'flaskgroup\\n'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_flaskgroup_app_context` unit test is designed to verify that the Flask CLI command correctly outputs the name of the application when invoked. It ensures that the application context is properly set up and that the command behaves as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when the `test` command is executed within the Flask CLI, it outputs the name of the Flask application (\"flaskgroup\") and that the command exits successfully (exit code 0). This confirms that the command is functioning correctly within the application context.\n\n**Code Being Tested and How It Works**:  \nThe test defines a `create_app` function that returns a Flask application instance named \"flaskgroup\". It then sets up a CLI group using `FlaskGroup`, which is a custom command group for Flask applications. Within this group, a command named `test` is defined, which outputs the name of the current application using `click.echo(current_app.name)`. The test invokes this command using the `runner.invoke` method, passing the command name as an argument, and asserts that the exit code is 0 and the output matches the expected application name.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **CLI Testing**: The test utilizes the `CliRunner` from the `click.testing` module to simulate command-line interface interactions, allowing for easy testing of CLI commands.\n- **Application Context Management**: The test leverages Flask's application context to ensure that the command has access to the current application instance, which is crucial for commands that rely on application-specific data.\n- **Assertions**: The test employs assertions to validate both the exit code and the output of the command, ensuring that the command behaves as intended under the defined conditions."
    },
    {
      "name": "test_flaskgroup_debug",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 366,
      "end_line_number": 382,
      "source_code": "def test_flaskgroup_debug(runner, set_debug_flag):\n    def create_app():\n        app = Flask(\"flaskgroup\")\n        app.debug = True\n        return app\n\n    @click.group(cls=FlaskGroup, create_app=create_app, set_debug_flag=set_debug_flag)\n    def cli(**params):\n        pass\n\n    @cli.command()\n    def test():\n        click.echo(str(current_app.debug))\n\n    result = runner.invoke(cli, [\"test\"])\n    assert result.exit_code == 0\n    assert result.output == f\"{not set_debug_flag}\\n\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('set_debug_flag', (True, False))"
      ],
      "arguments": [
        "runner",
        "set_debug_flag"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 0",
        "assert result.output == f'{not set_debug_flag}\\n'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_flaskgroup_debug` unit test is designed to verify the behavior of a Flask command-line interface (CLI) group when the debug flag is set. It specifically checks whether the debug status of the application is correctly reflected when invoking a command.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when the `test` command is executed, the output correctly indicates the application's debug status based on the `set_debug_flag` parameter. It asserts that the exit code of the command is `0`, indicating successful execution, and that the output matches the expected debug state.\n\n**Code Being Tested and How It Works**:  \nThe test defines a `create_app` function that initializes a Flask application with the debug mode enabled. It then creates a CLI group using `FlaskGroup`, which is a custom command group for Flask applications. The `test` command within this group outputs the current debug status of the application. The test invokes this command using the `runner.invoke` method, which simulates command-line execution and captures the output and exit code.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The test utilizes fixtures like `runner` and `set_debug_flag` to set up the necessary context and parameters for the test.\n- **Command Invocation**: The `runner.invoke` method is a key technique used to simulate command-line interactions, allowing for testing of CLI commands in isolation.\n- **Assertions**: The test employs assertions to validate both the exit code and the output, ensuring that the command behaves as expected under different configurations of the debug flag."
    },
    {
      "name": "test_flaskgroup_nested",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 385,
      "end_line_number": 395,
      "source_code": "def test_flaskgroup_nested(app, runner):\n    cli = click.Group(\"cli\")\n    flask_group = FlaskGroup(name=\"flask\", create_app=lambda: app)\n    cli.add_command(flask_group)\n\n    @flask_group.command()\n    def show():\n        click.echo(current_app.name)\n\n    result = runner.invoke(cli, [\"flask\", \"show\"])\n    assert result.output == \"flask_test\\n\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "runner"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.output == 'flask_test\\n'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_flaskgroup_nested` function is designed to verify that a command defined within a Flask CLI group correctly outputs the name of the current Flask application when invoked. This ensures that the command behaves as expected in the context of the Flask application.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that when the `show` command is executed, it outputs the name of the Flask application (in this case, \"flask_test\"). This confirms that the command is properly set up and that the application context is correctly utilized.\n\n**Code Being Tested and How It Works**:  \nThe test creates a Click command group (`cli`) and adds a `FlaskGroup` command to it, which is initialized with a lambda function that returns the Flask application instance (`app`). The `show` command is defined to print the name of the current application using `click.echo(current_app.name)`. The test then invokes this command using the `runner.invoke` method, passing the command line arguments `[\"flask\", \"show\"]`. The output is asserted against the expected string \"flask_test\\n\".\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The test relies on fixtures (`app` and `runner`) to provide the necessary context and tools for testing. The `app` fixture sets up a Flask application, while the `runner` fixture provides a Click testing utility (`CliRunner`) to simulate command-line interactions.\n- **Command Grouping**: The use of `FlaskGroup` allows for the organization of CLI commands related to the Flask application, demonstrating a structured approach to command management.\n- **Output Assertion**: The test employs a straightforward assertion to verify that the command's output matches the expected result, ensuring that the command behaves correctly in the given context."
    },
    {
      "name": "test_no_command_echo_loading_error",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 398,
      "end_line_number": 405,
      "source_code": "def test_no_command_echo_loading_error():\n    from flask.cli import cli\n\n    runner = CliRunner(mix_stderr=False)\n    result = runner.invoke(cli, [\"missing\"])\n    assert result.exit_code == 2\n    assert \"FLASK_APP\" in result.stderr\n    assert \"Usage:\" in result.stderr",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 2",
        "assert 'FLASK_APP' in result.stderr",
        "assert 'Usage:' in result.stderr"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_no_command_echo_loading_error` unit test is designed to verify the behavior of the Flask command-line interface (CLI) when an invalid command is invoked. Specifically, it checks that the CLI correctly handles a missing command by returning an appropriate exit code and error messages.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a non-existent command (in this case, \"missing\") is executed, the CLI returns an exit code of `2`, which indicates a command error. Additionally, it verifies that the error output includes references to the `FLASK_APP` environment variable and the general usage instructions for the CLI.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `CliRunner` from the `click` library to simulate command-line interactions with the Flask CLI. The `runner.invoke` method is called with the CLI and the invalid command as arguments. The resulting `result` object contains the exit code and standard error output, which are then asserted against expected values to confirm correct behavior.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Isolation**: The test isolates the CLI command execution from the rest of the application, ensuring that it only tests the command handling logic.\n- **Assertions**: It employs assertions to validate both the exit code and the content of the error messages, which is a common practice in unit testing to ensure that the code behaves as expected.\n- **Use of Fixtures**: The test likely relies on a fixture (`runner`) to provide a consistent testing environment for invoking CLI commands, which is a common pattern in pytest-based tests."
    },
    {
      "name": "test_help_echo_loading_error",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 408,
      "end_line_number": 415,
      "source_code": "def test_help_echo_loading_error():\n    from flask.cli import cli\n\n    runner = CliRunner(mix_stderr=False)\n    result = runner.invoke(cli, [\"--help\"])\n    assert result.exit_code == 0\n    assert \"FLASK_APP\" in result.stderr\n    assert \"Usage:\" in result.stdout",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 0",
        "assert 'FLASK_APP' in result.stderr",
        "assert 'Usage:' in result.stdout"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_help_echo_loading_error` function is designed to verify the behavior of the Flask command-line interface (CLI) when the `--help` option is invoked. It ensures that the CLI provides the correct exit code and displays the expected help information.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when the `--help` command is executed, the CLI returns an exit code of `0`, indicating success. Additionally, it verifies that the output contains the string \"FLASK_APP\" in the standard error output and \"Usage:\" in the standard output, confirming that the help message is correctly formatted and includes necessary information.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the Flask CLI, specifically the command handling for the `--help` option. The `runner.invoke` method is used to simulate the command-line invocation of the CLI. The `CliRunner` is a utility provided by the `click` library (which Flask CLI is built upon) that allows for testing command-line interfaces in a controlled environment. The `invoke` method executes the CLI command and captures the output and exit code.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Isolation**: The test is isolated from the actual application environment by using a test runner (`CliRunner`), which allows for testing the CLI without needing to run a full Flask application.\n- **Assertions**: The test employs assertions to validate the expected outcomes, ensuring that both the exit code and the content of the output and error streams meet the specified criteria.\n- **Command Simulation**: By using `runner.invoke`, the test simulates user interaction with the CLI, allowing for comprehensive testing of command behavior without manual input."
    },
    {
      "name": "test_help_echo_exception",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 418,
      "end_line_number": 427,
      "source_code": "def test_help_echo_exception():\n    def create_app():\n        raise Exception(\"oh no\")\n\n    cli = FlaskGroup(create_app=create_app)\n    runner = CliRunner(mix_stderr=False)\n    result = runner.invoke(cli, [\"--help\"])\n    assert result.exit_code == 0\n    assert \"Exception: oh no\" in result.stderr\n    assert \"Usage:\" in result.stdout",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 0",
        "assert 'Exception: oh no' in result.stderr",
        "assert 'Usage:' in result.stdout"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_help_echo_exception` unit test is designed to verify the behavior of the Flask CLI when an exception is raised during the application creation process. Specifically, it checks that the CLI correctly handles the exception and provides appropriate output to the user.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when the `create_app` function raises an exception, the CLI still exits with a success code (0) and that the error message is included in the standard error output. Additionally, it verifies that the help message (usage information) is present in the standard output.\n\n**Code Being Tested and How It Works**:  \nThe test defines a `create_app` function that raises an exception. It then creates a `FlaskGroup` instance with this function and uses `CliRunner` to invoke the CLI with the `--help` argument. The `runner.invoke` method simulates the command-line invocation and captures the output. The assertions check that the exit code is 0, the error message is present in `stderr`, and the usage information is in `stdout`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Exception Handling**: The test specifically checks how the application handles exceptions during the app creation phase, which is crucial for robust CLI behavior.\n- **CLI Testing**: It utilizes `CliRunner`, a testing utility provided by Flask, to simulate command-line interactions, allowing for comprehensive testing of CLI commands.\n- **Assertions on Output**: The test employs assertions to validate both the exit code and the content of the output streams, ensuring that the CLI behaves as expected under error conditions."
    },
    {
      "name": "test_simple",
      "module": "test_cli",
      "class_name": "TestRoutes",
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 453,
      "end_line_number": 456,
      "source_code": "def test_simple(self, invoke):\n        result = invoke([\"routes\"])\n        assert result.exit_code == 0\n        self.expect_order([\"aaa_post\", \"static\", \"yyy_get_post\"], result.output)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "invoke"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 0"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        },
        {
          "name": "self.expect_order",
          "body": "def expect_order(self, order, output):\n    for (expect, line) in zip(order, output.splitlines()[2:]):\n        assert line[:len(expect)] == expect"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_simple` function is designed to verify the correct behavior of the Flask CLI command that lists the application's routes. It ensures that the command executes successfully and that the output matches the expected order of defined routes.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main aspects: first, it asserts that the command executed without errors (indicated by an exit code of 0). Second, it verifies that the output of the command lists the routes in the expected order: `[\"aaa_post\", \"static\", \"yyy_get_post\"]`.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `invoke` fixture, which sets up a command-line interface (CLI) runner for the Flask application. The `invoke` function is called with the argument `[\"routes\"]`, which triggers the CLI command to list the routes. The `expect_order` method is then used to compare the actual output against the expected order, ensuring that the output format is correct and that the routes are listed as intended.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n1. **Fixtures**: The use of `@pytest.fixture` allows for the setup of reusable components (like the Flask app and CLI runner) that can be shared across multiple tests.\n2. **Partial Application**: The `partial` function from `functools` is used to create a specialized version of the `runner.invoke` method, making it easier to call with the necessary parameters.\n3. **Output Verification**: The `expect_order` method is a custom assertion that checks the output format, enhancing the clarity of the test by abstracting the order-checking logic.\n4. **Parameterized Testing**: While not directly in `test_simple`, the overall test suite demonstrates the use of parameterized tests in other functions, showcasing a flexible approach to testing various input scenarios."
    },
    {
      "name": "test_sort",
      "module": "test_cli",
      "class_name": "TestRoutes",
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 458,
      "end_line_number": 471,
      "source_code": "def test_sort(self, app, invoke):\n        default_output = invoke([\"routes\"]).output\n        endpoint_output = invoke([\"routes\", \"-s\", \"endpoint\"]).output\n        assert default_output == endpoint_output\n        self.expect_order(\n            [\"static\", \"yyy_get_post\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"methods\"]).output,\n        )\n        self.expect_order(\n            [\"yyy_get_post\", \"static\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"rule\"]).output,\n        )\n        match_order = [r.endpoint for r in app.url_map.iter_rules()]\n        self.expect_order(match_order, invoke([\"routes\", \"-s\", \"match\"]).output)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "invoke"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert default_output == endpoint_output"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.expect_order",
          "body": "def expect_order(self, order, output):\n    for (expect, line) in zip(order, output.splitlines()[2:]):\n        assert line[:len(expect)] == expect"
        },
        {
          "name": "self.expect_order",
          "body": "def expect_order(self, order, output):\n    for (expect, line) in zip(order, output.splitlines()[2:]):\n        assert line[:len(expect)] == expect"
        },
        {
          "name": "self.expect_order",
          "body": "def expect_order(self, order, output):\n    for (expect, line) in zip(order, output.splitlines()[2:]):\n        assert line[:len(expect)] == expect"
        },
        {
          "name": "invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        },
        {
          "name": "invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        },
        {
          "name": "invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        },
        {
          "name": "invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        },
        {
          "name": "invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_sort` function is designed to verify the correct sorting and output of registered routes in a Flask application. It ensures that the routes can be displayed in different orders based on specified sorting criteria, confirming that the application behaves as expected when interacting with the command-line interface.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the output of the `routes` command remains consistent regardless of the sorting option used. It verifies that the routes are correctly sorted by endpoint, methods, and rule, and that the output matches the expected order defined in the test. Additionally, it ensures that the default output matches the output when sorted by endpoint.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `routes_command` function, which retrieves and displays the application's registered routes. It sorts the routes based on the specified criteria (endpoint, methods, rule) and formats the output for display. The `invoke` fixture simulates command-line invocations of this function, allowing the test to capture and assert the output generated by the command.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The `invoke` fixture is used to create a reusable command-line interface for testing, allowing for clean and consistent invocation of the `routes` command.\n- **Output Comparison**: The test employs assertions to compare the actual output against expected values, ensuring that the sorting and display logic functions correctly.\n- **Custom Assertion Method**: The `expect_order` method is utilized to verify that the output lines match the expected order, enhancing the clarity of the assertions and providing better error messages in case of failure."
    },
    {
      "name": "test_all_methods",
      "module": "test_cli",
      "class_name": "TestRoutes",
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 473,
      "end_line_number": 477,
      "source_code": "def test_all_methods(self, invoke):\n        output = invoke([\"routes\"]).output\n        assert \"GET, HEAD, OPTIONS, POST\" not in output\n        output = invoke([\"routes\", \"--all-methods\"]).output\n        assert \"GET, HEAD, OPTIONS, POST\" in output",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "invoke"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'GET, HEAD, OPTIONS, POST' not in output",
        "assert 'GET, HEAD, OPTIONS, POST' in output"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        },
        {
          "name": "invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_all_methods` unit test is designed to verify the behavior of the Flask CLI command that lists the routes of the application, specifically checking whether the output includes or excludes HTTP methods when the `--all-methods` flag is used.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two scenarios: \n1. When the command is invoked without the `--all-methods` flag, it asserts that the output does not contain the string \"GET, HEAD, OPTIONS, POST\".\n2. When the command is invoked with the `--all-methods` flag, it asserts that the output does include the string \"GET, HEAD, OPTIONS, POST\". This ensures that the command behaves correctly based on the presence of the flag.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is part of a Flask application that utilizes the Flask CLI to manage routes. The `invoke` fixture creates a command-line interface (CLI) runner for the Flask application, allowing the test to simulate command-line invocations. The `invoke` function is called with different arguments to test the output of the `routes` command, which lists the application's routes and their associated HTTP methods.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixtures**: The `invoke` fixture is used to set up the CLI runner, which is a common pattern in pytest to manage setup and teardown for tests.\n- **Assertions**: The test uses assertions to validate the expected output, ensuring that the command behaves as intended under different conditions.\n- **Parameterized Testing**: While not directly used in this specific test, the surrounding test structure employs parameterization in other tests, showcasing a flexible approach to testing various inputs and expected outcomes."
    },
    {
      "name": "test_no_routes",
      "module": "test_cli",
      "class_name": "TestRoutes",
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 479,
      "end_line_number": 484,
      "source_code": "def test_no_routes(self, runner):\n        app = Flask(__name__, static_folder=None)\n        cli = FlaskGroup(create_app=lambda: app)\n        result = runner.invoke(cli, [\"routes\"])\n        assert result.exit_code == 0\n        assert \"No routes were registered.\" in result.output",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "runner"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 0",
        "assert 'No routes were registered.' in result.output"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_no_routes` function is designed to verify the behavior of a Flask application when no routes are registered. It ensures that the command-line interface (CLI) correctly reports the absence of routes.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when the `routes` command is invoked on a Flask application with no defined routes, the application exits with a success code (0) and outputs the message \"No routes were registered.\" This confirms that the CLI handles the scenario of an empty route list gracefully.\n\n**Code Being Tested and How It Works**:  \nThe test creates a minimal Flask application instance without any routes by initializing `Flask(__name__, static_folder=None)`. It then sets up a `FlaskGroup` CLI instance, which is a utility for creating command-line interfaces for Flask applications. The `runner.invoke` method is used to simulate the execution of the CLI command `routes`, capturing the result. The assertions check both the exit code and the output message.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The test utilizes the `runner` fixture, which is likely provided by pytest, to facilitate the invocation of CLI commands in a controlled manner.\n- **Command Invocation**: The use of `runner.invoke` allows for testing CLI commands without requiring actual command-line interaction, making the tests more automated and repeatable.\n- **Assertions**: The test employs assertions to validate both the exit code and the output, ensuring that the application behaves as expected under the tested conditions."
    },
    {
      "name": "test_subdomain",
      "module": "test_cli",
      "class_name": "TestRoutes",
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 486,
      "end_line_number": 493,
      "source_code": "def test_subdomain(self, runner):\n        app = Flask(__name__, static_folder=None)\n        app.add_url_rule(\"/a\", subdomain=\"a\", endpoint=\"a\")\n        app.add_url_rule(\"/b\", subdomain=\"b\", endpoint=\"b\")\n        cli = FlaskGroup(create_app=lambda: app)\n        result = runner.invoke(cli, [\"routes\"])\n        assert result.exit_code == 0\n        assert \"Subdomain\" in result.output",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "runner"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 0",
        "assert 'Subdomain' in result.output"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_subdomain` function is designed to verify that the Flask application correctly registers and recognizes routes associated with specific subdomains. It ensures that the CLI can list these routes and confirms that the subdomain functionality is operational.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when routes are defined with subdomains (in this case, `/a` for subdomain `a` and `/b` for subdomain `b`), the CLI command `routes` successfully executes without errors (exit code 0) and that the output includes the word \"Subdomain,\" indicating that the subdomain routes are recognized by the application.\n\n**Code Being Tested and How It Works**:  \nThe test creates a Flask application instance and adds two URL rules with subdomains. It then uses the `FlaskGroup` to create a CLI context for the application. The `runner.invoke` method simulates running the CLI command `routes`, which lists all registered routes. The assertions check that the command executed successfully and that the expected output is present.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The test utilizes a `runner` fixture provided by `pytest` to create a `CliRunner` instance, which is a common pattern for testing CLI applications in Flask.\n- **Assertions**: The test employs assertions to validate both the exit code and the output of the command, ensuring that the expected behavior is met.\n- **Lambda Function for App Creation**: The use of a lambda function to create the Flask app allows for a clean and concise way to pass the app instance to the `FlaskGroup`, promoting modularity and reusability in the test setup."
    },
    {
      "name": "test_host",
      "module": "test_cli",
      "class_name": "TestRoutes",
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 495,
      "end_line_number": 502,
      "source_code": "def test_host(self, runner):\n        app = Flask(__name__, static_folder=None, host_matching=True)\n        app.add_url_rule(\"/a\", host=\"a\", endpoint=\"a\")\n        app.add_url_rule(\"/b\", host=\"b\", endpoint=\"b\")\n        cli = FlaskGroup(create_app=lambda: app)\n        result = runner.invoke(cli, [\"routes\"])\n        assert result.exit_code == 0\n        assert \"Host\" in result.output",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "runner"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 0",
        "assert 'Host' in result.output"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_host` function is designed to verify that the Flask application correctly registers and displays routes that are associated with specific hostnames. This is particularly important for applications that utilize host-based routing, ensuring that the application behaves as expected when accessed via different hosts.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when the application is run with host matching enabled, it successfully registers two routes (`/a` and `/b`) for the hosts `a` and `b`, respectively. It asserts that the command-line interface (CLI) output includes the word \"Host,\" indicating that the routes are recognized and displayed correctly.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the Flask application setup, where two URL rules are added with specific hosts. The `FlaskGroup` is used to create a CLI for the application, allowing the test to invoke the `routes` command. The `runner.invoke` method simulates running this command, capturing the output and exit code. The assertions check that the exit code is `0` (indicating success) and that the output contains the expected string.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The test utilizes the `runner` fixture to create a test runner for the Flask CLI commands, promoting code reuse and separation of concerns.\n- **Command Invocation**: The `runner.invoke` method is a common pattern in testing CLI applications, allowing for simulation of command execution and capturing of results.\n- **Assertions**: The test employs assertions to validate both the exit code and the content of the output, ensuring that the application behaves as expected under the specified conditions."
    },
    {
      "name": "test_load_dotenv",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 520,
      "end_line_number": 540,
      "source_code": "def test_load_dotenv(monkeypatch):\n    # can't use monkeypatch.delitem since the keys don't exist yet\n    for item in (\"FOO\", \"BAR\", \"SPAM\", \"HAM\"):\n        monkeypatch._setitem.append((os.environ, item, notset))\n\n    monkeypatch.setenv(\"EGGS\", \"3\")\n    monkeypatch.chdir(test_path)\n    assert load_dotenv()\n    assert Path.cwd() == test_path\n    # .flaskenv doesn't overwrite .env\n    assert os.environ[\"FOO\"] == \"env\"\n    # set only in .flaskenv\n    assert os.environ[\"BAR\"] == \"bar\"\n    # set only in .env\n    assert os.environ[\"SPAM\"] == \"1\"\n    # set manually, files don't overwrite\n    assert os.environ[\"EGGS\"] == \"3\"\n    # test env file encoding\n    assert os.environ[\"HAM\"] == \"\u706b\u817f\"\n    # Non existent file should not load\n    assert not load_dotenv(\"non-existent-file\")",
      "docstring": null,
      "decorators": [
        "need_dotenv"
      ],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert load_dotenv()",
        "assert Path.cwd() == test_path",
        "assert os.environ['FOO'] == 'env'",
        "assert os.environ['BAR'] == 'bar'",
        "assert os.environ['SPAM'] == '1'",
        "assert os.environ['EGGS'] == '3'",
        "assert os.environ['HAM'] == '\u706b\u817f'",
        "assert not load_dotenv('non-existent-file')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_dotenv_path",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 544,
      "end_line_number": 550,
      "source_code": "def test_dotenv_path(monkeypatch):\n    for item in (\"FOO\", \"BAR\", \"EGGS\"):\n        monkeypatch._setitem.append((os.environ, item, notset))\n\n    load_dotenv(test_path / \".flaskenv\")\n    assert Path.cwd() == cwd\n    assert \"FOO\" in os.environ",
      "docstring": null,
      "decorators": [
        "need_dotenv"
      ],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert Path.cwd() == cwd",
        "assert 'FOO' in os.environ"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_dotenv_optional",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 553,
      "end_line_number": 557,
      "source_code": "def test_dotenv_optional(monkeypatch):\n    monkeypatch.setitem(sys.modules, \"dotenv\", None)\n    monkeypatch.chdir(test_path)\n    load_dotenv()\n    assert \"FOO\" not in os.environ",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'FOO' not in os.environ"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_disable_dotenv_from_env",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 561,
      "end_line_number": 565,
      "source_code": "def test_disable_dotenv_from_env(monkeypatch, runner):\n    monkeypatch.chdir(test_path)\n    monkeypatch.setitem(os.environ, \"FLASK_SKIP_DOTENV\", \"1\")\n    runner.invoke(FlaskGroup())\n    assert \"FOO\" not in os.environ",
      "docstring": null,
      "decorators": [
        "need_dotenv"
      ],
      "arguments": [
        "monkeypatch",
        "runner"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'FOO' not in os.environ"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_disable_dotenv_from_env` is designed to verify that when the environment variable `FLASK_SKIP_DOTENV` is set to \"1\", the Flask application does not load environment variables from `.env` or `.flaskenv` files. This is crucial for ensuring that the application behaves correctly when it is configured to skip loading these files, which may contain sensitive or unwanted configurations.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that the environment variable `FOO` is not present in `os.environ` after invoking the Flask CLI command. This confirms that the application respects the `FLASK_SKIP_DOTENV` setting and does not load any environment variables from the dotenv files.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `runner.invoke` method from the `FlaskCliRunner` class to simulate the invocation of the Flask CLI. The `FlaskGroup` is instantiated with a lambda function that creates the Flask app. The `monkeypatch` fixture is used to change the current working directory to `test_path` and to set the `FLASK_SKIP_DOTENV` environment variable. After invoking the CLI command, the test asserts that `FOO` is not in `os.environ`, indicating that the dotenv loading was effectively skipped.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `monkeypatch` fixture from `pytest` to modify the environment and working directory dynamically, allowing for isolated and controlled testing conditions. It also uses the `runner.invoke` method to simulate command-line interactions with the Flask application, which is a common pattern in testing CLI applications. The use of assertions to check the state of `os.environ` after the command execution is a straightforward yet effective way to validate the expected behavior."
    },
    {
      "name": "test_run_cert_path",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 568,
      "end_line_number": 583,
      "source_code": "def test_run_cert_path():\n    # no key\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", __file__])\n\n    # no cert\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--key\", __file__])\n\n    # cert specified first\n    ctx = run_command.make_context(\"run\", [\"--cert\", __file__, \"--key\", __file__])\n    assert ctx.params[\"cert\"] == (__file__, __file__)\n\n    # key specified first\n    ctx = run_command.make_context(\"run\", [\"--key\", __file__, \"--cert\", __file__])\n    assert ctx.params[\"cert\"] == (__file__, __file__)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert ctx.params['cert'] == (__file__, __file__)",
        "assert ctx.params['cert'] == (__file__, __file__)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_run_cert_adhoc",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 586,
      "end_line_number": 600,
      "source_code": "def test_run_cert_adhoc(monkeypatch):\n    monkeypatch.setitem(sys.modules, \"cryptography\", None)\n\n    # cryptography not installed\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"adhoc\"])\n\n    # cryptography installed\n    monkeypatch.setitem(sys.modules, \"cryptography\", types.ModuleType(\"cryptography\"))\n    ctx = run_command.make_context(\"run\", [\"--cert\", \"adhoc\"])\n    assert ctx.params[\"cert\"] == \"adhoc\"\n\n    # no key with adhoc\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"adhoc\", \"--key\", __file__])",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert ctx.params['cert'] == 'adhoc'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_run_cert_import",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 603,
      "end_line_number": 622,
      "source_code": "def test_run_cert_import(monkeypatch):\n    monkeypatch.setitem(sys.modules, \"not_here\", None)\n\n    # ImportError\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"not_here\"])\n\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"flask\"])\n\n    # SSLContext\n    ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n\n    monkeypatch.setitem(sys.modules, \"ssl_context\", ssl_context)\n    ctx = run_command.make_context(\"run\", [\"--cert\", \"ssl_context\"])\n    assert ctx.params[\"cert\"] is ssl_context\n\n    # no --key with SSLContext\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"ssl_context\", \"--key\", __file__])",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert ctx.params['cert'] is ssl_context"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_run_cert_no_ssl",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 625,
      "end_line_number": 629,
      "source_code": "def test_run_cert_no_ssl(monkeypatch):\n    monkeypatch.setitem(sys.modules, \"ssl\", None)\n\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"not_here\"])",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_cli_blueprints",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 632,
      "end_line_number": 672,
      "source_code": "def test_cli_blueprints(app):\n    \"\"\"Test blueprint commands register correctly to the application\"\"\"\n    custom = Blueprint(\"custom\", __name__, cli_group=\"customized\")\n    nested = Blueprint(\"nested\", __name__)\n    merged = Blueprint(\"merged\", __name__, cli_group=None)\n    late = Blueprint(\"late\", __name__)\n\n    @custom.cli.command(\"custom\")\n    def custom_command():\n        click.echo(\"custom_result\")\n\n    @nested.cli.command(\"nested\")\n    def nested_command():\n        click.echo(\"nested_result\")\n\n    @merged.cli.command(\"merged\")\n    def merged_command():\n        click.echo(\"merged_result\")\n\n    @late.cli.command(\"late\")\n    def late_command():\n        click.echo(\"late_result\")\n\n    app.register_blueprint(custom)\n    app.register_blueprint(nested)\n    app.register_blueprint(merged)\n    app.register_blueprint(late, cli_group=\"late_registration\")\n\n    app_runner = app.test_cli_runner()\n\n    result = app_runner.invoke(args=[\"customized\", \"custom\"])\n    assert \"custom_result\" in result.output\n\n    result = app_runner.invoke(args=[\"nested\", \"nested\"])\n    assert \"nested_result\" in result.output\n\n    result = app_runner.invoke(args=[\"merged\"])\n    assert \"merged_result\" in result.output\n\n    result = app_runner.invoke(args=[\"late_registration\", \"late\"])\n    assert \"late_result\" in result.output",
      "docstring": "Test blueprint commands register correctly to the application",
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'custom_result' in result.output",
        "assert 'nested_result' in result.output",
        "assert 'merged_result' in result.output",
        "assert 'late_result' in result.output"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        },
        {
          "name": "app_runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        },
        {
          "name": "app_runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        },
        {
          "name": "app_runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_cli_blueprints` function is to verify that command-line interface (CLI) commands defined in Flask blueprints are correctly registered and can be invoked as expected within the Flask application context.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that each CLI command associated with the registered blueprints produces the expected output when invoked. It ensures that commands are accessible under their respective CLI groups and that the output matches the predefined results.\n\n**Code Being Tested and How It Works**:  \nThe code being tested involves the registration of multiple Flask blueprints, each containing a CLI command. The `app.register_blueprint()` method is used to register these blueprints with the application. The `app.test_cli_runner()` method creates a test runner that simulates command-line interactions. The test then invokes each command using `app_runner.invoke()` with the appropriate arguments and checks the output against expected results using assertions.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of fixtures (e.g., `app`) to provide a test instance of the Flask application. It also utilizes the `invoke` method from the test runner to simulate CLI command execution, which is a common pattern in testing CLI applications. Assertions are used to validate the output, ensuring that the commands behave as intended. The test structure follows a clear Arrange-Act-Assert pattern, making it easy to understand the setup, execution, and verification steps."
    },
    {
      "name": "test_cli_empty",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 675,
      "end_line_number": 681,
      "source_code": "def test_cli_empty(app):\n    \"\"\"If a Blueprint's CLI group is empty, do not register it.\"\"\"\n    bp = Blueprint(\"blue\", __name__, cli_group=\"blue\")\n    app.register_blueprint(bp)\n\n    result = app.test_cli_runner().invoke(args=[\"blue\", \"--help\"])\n    assert result.exit_code == 2, f\"Unexpected success:\\n\\n{result.output}\"",
      "docstring": "If a Blueprint's CLI group is empty, do not register it.",
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 2, f'Unexpected success:\\n\\n{result.output}'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_run_exclude_patterns",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 684,
      "end_line_number": 686,
      "source_code": "def test_run_exclude_patterns():\n    ctx = run_command.make_context(\"run\", [\"--exclude-patterns\", __file__])\n    assert ctx.params[\"exclude_patterns\"] == [__file__]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert ctx.params['exclude_patterns'] == [__file__]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_simple",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 453,
      "end_line_number": 456,
      "source_code": "def test_simple(self, invoke):\n        result = invoke([\"routes\"])\n        assert result.exit_code == 0\n        self.expect_order([\"aaa_post\", \"static\", \"yyy_get_post\"], result.output)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "invoke"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 0"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        },
        {
          "name": "self.expect_order",
          "body": "def expect_order(self, order, output):\n    for (expect, line) in zip(order, output.splitlines()[2:]):\n        assert line[:len(expect)] == expect"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_simple` function is designed to verify the correct behavior of the Flask CLI command that lists the application's routes. It ensures that the command executes successfully and that the output matches the expected order of defined routes.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main aspects: \n1. It asserts that the command execution returns an exit code of `0`, indicating success.\n2. It verifies that the output of the command lists the routes in the expected order: `[\"aaa_post\", \"static\", \"yyy_get_post\"]`.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `invoke` fixture, which sets up a command-line interface (CLI) runner for the Flask application. The `invoke` function uses `FlaskGroup` to create a CLI context for the app, allowing the test to simulate command-line interactions. The `test_simple` function calls `invoke([\"routes\"])`, which triggers the CLI command to list routes. The output is then processed to check the order of the routes using the `expect_order` method.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixtures**: The use of `@pytest.fixture` allows for the setup of reusable components (like the app and CLI runner) that can be shared across multiple tests, promoting code reuse and reducing redundancy.\n- **Partial Function Application**: The `partial` function from `functools` is used to create a specialized version of the `runner.invoke` method, which simplifies the invocation of CLI commands with the app context.\n- **Output Verification**: The `expect_order` method is a custom assertion that checks the output format and order, enhancing the clarity of the test's intent and providing better error messages if the test fails."
    },
    {
      "name": "test_sort",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 458,
      "end_line_number": 471,
      "source_code": "def test_sort(self, app, invoke):\n        default_output = invoke([\"routes\"]).output\n        endpoint_output = invoke([\"routes\", \"-s\", \"endpoint\"]).output\n        assert default_output == endpoint_output\n        self.expect_order(\n            [\"static\", \"yyy_get_post\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"methods\"]).output,\n        )\n        self.expect_order(\n            [\"yyy_get_post\", \"static\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"rule\"]).output,\n        )\n        match_order = [r.endpoint for r in app.url_map.iter_rules()]\n        self.expect_order(match_order, invoke([\"routes\", \"-s\", \"match\"]).output)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app",
        "invoke"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert default_output == endpoint_output"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.expect_order",
          "body": "def expect_order(self, order, output):\n    for (expect, line) in zip(order, output.splitlines()[2:]):\n        assert line[:len(expect)] == expect"
        },
        {
          "name": "self.expect_order",
          "body": "def expect_order(self, order, output):\n    for (expect, line) in zip(order, output.splitlines()[2:]):\n        assert line[:len(expect)] == expect"
        },
        {
          "name": "self.expect_order",
          "body": "def expect_order(self, order, output):\n    for (expect, line) in zip(order, output.splitlines()[2:]):\n        assert line[:len(expect)] == expect"
        },
        {
          "name": "invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        },
        {
          "name": "invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        },
        {
          "name": "invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        },
        {
          "name": "invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        },
        {
          "name": "invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_sort` function is designed to verify the correct sorting and output of registered routes in a Flask application. It ensures that the routes can be displayed in different orders based on specified sorting criteria, such as by endpoint, methods, and rules.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the output of the `invoke([\"routes\"])` command matches the output of `invoke([\"routes\", \"-s\", \"endpoint\"])`, confirming that the default and sorted outputs are equivalent. It also verifies that the routes are correctly sorted when using different sorting options (`methods`, `rule`, and `match`), ensuring that the application behaves as expected when displaying routes.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `routes_command` function, which retrieves and displays the application's registered routes. It sorts the routes based on the specified criteria and formats the output for display. The `invoke` fixture simulates command-line interface (CLI) invocations, allowing the test to call the `routes` command with different sorting options and capture the output for assertions.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The `invoke` fixture is used to create a reusable command-line interface for testing, which simplifies the invocation of the `routes` command.\n- **Output Comparison**: The test employs assertions to compare the output of different invocations, ensuring that the sorting functionality works as intended.\n- **Custom Assertion Method**: The `expect_order` method is utilized to verify that the output matches the expected order, providing clearer error messages during test failures by checking the start of each line rather than using `startswith`. This enhances the readability of test results."
    },
    {
      "name": "test_all_methods",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 473,
      "end_line_number": 477,
      "source_code": "def test_all_methods(self, invoke):\n        output = invoke([\"routes\"]).output\n        assert \"GET, HEAD, OPTIONS, POST\" not in output\n        output = invoke([\"routes\", \"--all-methods\"]).output\n        assert \"GET, HEAD, OPTIONS, POST\" in output",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "invoke"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'GET, HEAD, OPTIONS, POST' not in output",
        "assert 'GET, HEAD, OPTIONS, POST' in output"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        },
        {
          "name": "invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_all_methods` unit test is designed to verify the behavior of the Flask CLI command that lists the routes of the application, specifically checking whether the output includes or excludes HTTP methods when the `--all-methods` flag is used.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two scenarios: \n1. When the command is invoked without the `--all-methods` flag, it asserts that the output does not contain the string \"GET, HEAD, OPTIONS, POST\".\n2. When the command is invoked with the `--all-methods` flag, it asserts that the output does include the string \"GET, HEAD, OPTIONS, POST\". This ensures that the command behaves correctly based on the presence of the flag.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is part of a Flask application that defines routes with various HTTP methods. The `invoke` fixture is used to create a command-line interface (CLI) runner for the Flask application. The `invoke` function simulates the execution of CLI commands, allowing the test to capture the output of the `routes` command. The test checks the output of this command under different conditions to ensure that the expected HTTP methods are displayed correctly based on the command-line arguments provided.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The `invoke` fixture is a key component that encapsulates the setup for running CLI commands, promoting code reuse and clarity in the tests.\n- **Assertions**: The test employs assertions to validate the presence or absence of specific strings in the output, which is a common practice in unit testing to ensure expected behavior.\n- **Parameterized Testing**: While not directly used in this specific test, the surrounding tests in the codebase utilize parameterization to run multiple scenarios, showcasing a broader testing strategy that could be applied to similar tests."
    },
    {
      "name": "test_no_routes",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 479,
      "end_line_number": 484,
      "source_code": "def test_no_routes(self, runner):\n        app = Flask(__name__, static_folder=None)\n        cli = FlaskGroup(create_app=lambda: app)\n        result = runner.invoke(cli, [\"routes\"])\n        assert result.exit_code == 0\n        assert \"No routes were registered.\" in result.output",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "runner"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 0",
        "assert 'No routes were registered.' in result.output"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_no_routes` function is designed to verify the behavior of a Flask application when no routes are registered. It ensures that the command-line interface (CLI) correctly reports that there are no routes available.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when the `routes` command is invoked on a Flask application with no defined routes, the application exits with a success code (0) and outputs the message \"No routes were registered.\" This confirms that the CLI handles the absence of routes gracefully.\n\n**Code Being Tested and How It Works**:  \nThe test creates a minimal Flask application instance without any routes by initializing `Flask(__name__, static_folder=None)`. It then sets up a `FlaskGroup` CLI instance, which is a utility for creating command-line interfaces for Flask applications. The `runner.invoke(cli, [\"routes\"])` method simulates invoking the `routes` command on the CLI, capturing the output and exit code. The assertions check that the exit code is 0 and that the expected message is present in the output.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The test utilizes the `runner` fixture, which is likely provided by pytest, to facilitate the invocation of CLI commands. This promotes reusability and separation of concerns in the test setup.\n- **Assertions**: The test employs assertions to validate both the exit code and the output message, ensuring that the application behaves as expected under the tested conditions.\n- **Lambda Function for App Creation**: The use of a lambda function to create the app instance allows for a clean and concise way to pass the app to the `FlaskGroup`, maintaining clarity in the test structure."
    },
    {
      "name": "test_subdomain",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 486,
      "end_line_number": 493,
      "source_code": "def test_subdomain(self, runner):\n        app = Flask(__name__, static_folder=None)\n        app.add_url_rule(\"/a\", subdomain=\"a\", endpoint=\"a\")\n        app.add_url_rule(\"/b\", subdomain=\"b\", endpoint=\"b\")\n        cli = FlaskGroup(create_app=lambda: app)\n        result = runner.invoke(cli, [\"routes\"])\n        assert result.exit_code == 0\n        assert \"Subdomain\" in result.output",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "runner"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 0",
        "assert 'Subdomain' in result.output"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_subdomain` function is designed to verify that the Flask application correctly registers and recognizes routes associated with specific subdomains. It ensures that when subdomains are defined, the CLI can list these routes appropriately.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the application can successfully register routes for the subdomains \"a\" and \"b\". It verifies that the CLI command `routes` returns an exit code of 0 (indicating success) and that the output contains the word \"Subdomain\", confirming that the subdomain routes are recognized.\n\n**Code Being Tested and How It Works**:  \nThe test creates a Flask application instance and adds two URL rules with subdomains using `app.add_url_rule()`. The `FlaskGroup` is instantiated to create a CLI context for the app. The `runner.invoke()` method is then called with the CLI command `[\"routes\"]`, which triggers the route listing functionality of the Flask CLI. The assertions check the exit code and the output of the command.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The test utilizes a `runner` fixture provided by `pytest` to create a CLI runner, which simplifies the invocation of CLI commands and captures their output.\n- **Assertions**: The test employs assertions to validate both the exit code and the content of the output, ensuring that the expected behavior occurs.\n- **Lambda Function for App Creation**: The use of a lambda function to create the app instance allows for a clean and concise way to pass the app to the `FlaskGroup`, maintaining separation of concerns and enhancing readability."
    },
    {
      "name": "test_host",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_cli.py",
      "line_number": 495,
      "end_line_number": 502,
      "source_code": "def test_host(self, runner):\n        app = Flask(__name__, static_folder=None, host_matching=True)\n        app.add_url_rule(\"/a\", host=\"a\", endpoint=\"a\")\n        app.add_url_rule(\"/b\", host=\"b\", endpoint=\"b\")\n        cli = FlaskGroup(create_app=lambda: app)\n        result = runner.invoke(cli, [\"routes\"])\n        assert result.exit_code == 0\n        assert \"Host\" in result.output",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "runner"
      ],
      "imports": [
        "importlib.metadata",
        "os",
        "platform",
        "ssl",
        "sys",
        "types",
        "functools.partial",
        "pathlib.Path",
        "click",
        "pytest",
        "_pytest.monkeypatch.notset",
        "click.testing.CliRunner",
        "flask.Blueprint",
        "flask.current_app",
        "flask.Flask",
        "flask.cli.AppGroup",
        "flask.cli.find_best_app",
        "flask.cli.FlaskGroup",
        "flask.cli.get_version",
        "flask.cli.load_dotenv",
        "flask.cli.locate_app",
        "flask.cli.NoAppException",
        "flask.cli.prepare_import",
        "flask.cli.run_command",
        "flask.cli.ScriptInfo",
        "flask.cli.with_appcontext",
        "cliapp.app.testapp",
        "flask.cli.cli",
        "flask.cli.cli",
        "dotenv"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 0",
        "assert 'Host' in result.output"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "runner.invoke",
          "body": "@pytest.fixture\ndef invoke(self, app, runner):\n    cli = FlaskGroup(create_app=lambda : app)\n    return partial(runner.invoke, cli)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_host` function is designed to verify that the Flask application correctly registers and displays routes that are associated with specific hostnames. This is particularly important for applications that utilize host-based routing, ensuring that the application behaves as expected when accessed via different hosts.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when routes are defined with specific hostnames (in this case, `/a` for host `a` and `/b` for host `b`), the command-line interface (CLI) correctly lists these routes when the `routes` command is invoked. It asserts that the exit code of the command is `0`, indicating success, and that the output contains the string \"Host\", confirming that the host-based routes are recognized.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the Flask application setup, where two routes are added with specific hostnames using `app.add_url_rule()`. The `FlaskGroup` is used to create a CLI for the application, allowing the test to invoke the `routes` command. The `runner.invoke` method simulates running the CLI command and captures the output and exit code. The test then checks the results to ensure that the application behaves correctly in terms of route registration and output.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The test utilizes the `runner` fixture, which provides a test runner for the app's Click commands, allowing for easy invocation of CLI commands within tests.\n- **Assertions**: The test employs assertions to validate both the exit code and the presence of expected output in the command's result, ensuring that the application behaves as intended.\n- **Separation of Concerns**: By isolating the route definitions and CLI invocation within the test, it maintains a clear focus on testing the specific functionality of host-based routing without interference from other application components."
    },
    {
      "name": "test_context_processing",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 11,
      "end_line_number": 21,
      "source_code": "def test_context_processing(app, client):\n    @app.context_processor\n    def context_processor():\n        return {\"injected_value\": 42}\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"context_template.html\", value=23)\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"<p>23|42\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'<p>23|42'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_context_processing` function is to verify that the Flask application correctly injects context variables into templates using a context processor. It ensures that the value returned by the context processor is accessible within the rendered template.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the value `42`, which is injected by the context processor, is correctly combined with the value `23` passed to the template. The expected output of the rendered template is `b\"<p>23|42\"`, confirming that both values are rendered as intended.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a Flask route defined at the root URL (`\"/\"`), which renders a template called `context_template.html`. The context processor defined within the test returns a dictionary containing `{\"injected_value\": 42}`. When the route is accessed via the test client, it calls `flask.render_template`, which merges the context variables into the template. The test then asserts that the response data matches the expected byte string.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of Flask's test client to simulate a request to the application. It also utilizes a context processor to inject additional context into the template rendering process. The assertion checks the raw response data, which is a common practice in unit tests to ensure that the output matches expected values. Additionally, the test is structured to be self-contained, setting up the necessary application context and routes within the test function itself."
    },
    {
      "name": "test_original_win",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 24,
      "end_line_number": 30,
      "source_code": "def test_original_win(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.render_template_string(\"{{ config }}\", config=42)\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"42\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'42'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_original_win` function is designed to verify that the Flask application correctly renders a template string that outputs the value of a configuration variable. Specifically, it checks that the root route (`\"/\"`) returns the expected output when accessed.\n\n**Specific Functionality or Behavior Verified**:  \nThis test confirms that the application can render a template string with a variable passed to it. It ensures that the value `42` is correctly rendered as a byte string in the HTTP response when the root URL is accessed.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a Flask route defined by the `@app.route(\"/\")` decorator, which returns a rendered template string containing the value of the `config` variable set to `42`. The test uses the `client.get(\"/\")` method to simulate an HTTP GET request to the root URL, and it asserts that the response data matches the expected byte string `b\"42\"`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of Flask's test client to simulate requests to the application, allowing for isolated testing of route behavior without needing to run a full server. It also utilizes assertions to validate the response, which is a common practice in unit testing to ensure that the actual output matches the expected output. The use of a simple route and template rendering demonstrates a straightforward approach to testing Flask applications."
    },
    {
      "name": "test_simple_stream",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 33,
      "end_line_number": 39,
      "source_code": "def test_simple_stream(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.stream_template_string(\"{{ config }}\", config=42)\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"42\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'42'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_simple_stream` function is designed to verify the behavior of Flask's `stream_template_string` method, ensuring that it correctly streams a template with a given context variable.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when the root route (\"/\") is accessed, the response data matches the expected output of the streamed template, which in this case should be the string representation of the integer `42`.\n\n**Code Being Tested and How It Works**:  \nThe code under test defines a Flask route that uses `flask.stream_template_string` to render a template string that includes a context variable `config`. The context variable is set to `42`. When the test makes a GET request to the root route, it expects the response data to be `b\"42\"`, which is the byte representation of the string \"42\".\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Route Definition**: The test defines a route within the test function, which is a common pattern in Flask testing to isolate the behavior being tested.\n- **Client Simulation**: The `client` fixture is used to simulate HTTP requests to the application, allowing for easy testing of route responses.\n- **Assertion**: The test uses a simple assertion to compare the actual response data with the expected output, which is a fundamental practice in unit testing to validate functionality."
    },
    {
      "name": "test_request_less_rendering",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 42,
      "end_line_number": 50,
      "source_code": "def test_request_less_rendering(app, app_ctx):\n    app.config[\"WORLD_NAME\"] = \"Special World\"\n\n    @app.context_processor\n    def context_processor():\n        return dict(foo=42)\n\n    rv = flask.render_template_string(\"Hello {{ config.WORLD_NAME }} {{ foo }}\")\n    assert rv == \"Hello Special World 42\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "app_ctx"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv == 'Hello Special World 42'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_standard_context",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 53,
      "end_line_number": 68,
      "source_code": "def test_standard_context(app, client):\n    @app.route(\"/\")\n    def index():\n        flask.g.foo = 23\n        flask.session[\"test\"] = \"aha\"\n        return flask.render_template_string(\n            \"\"\"\n            {{ request.args.foo }}\n            {{ g.foo }}\n            {{ config.DEBUG }}\n            {{ session.test }}\n        \"\"\"\n        )\n\n    rv = client.get(\"/?foo=42\")\n    assert rv.data.split() == [b\"42\", b\"23\", b\"False\", b\"aha\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data.split() == [b'42', b'23', b'False', b'aha']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:\nThe `test_standard_context` function is designed to verify that the Flask application correctly processes and renders a template with various context variables, including request arguments, global variables, configuration settings, and session data.\n\n**Specific Functionality or Behavior Verified**:\nThis test checks that the values rendered in the response match the expected output when accessing the root URL (\"/\") with a query parameter. It ensures that the application correctly retrieves and displays the request argument `foo`, a global variable `g.foo`, the application's debug configuration, and a session variable `session.test`.\n\n**Code Being Tested and How It Works**:\nThe test defines a route for the root URL (\"/\") that sets a global variable `g.foo` to 23 and a session variable `session[\"test\"]` to \"aha\". It then renders a template string that includes these variables along with the request argument `foo` and the application's debug configuration (`config.DEBUG`). The test simulates a GET request to the root URL with a query parameter `foo=42` and asserts that the response data matches the expected byte sequence `[b\"42\", b\"23\", b\"False\", b\"aha\"]`.\n\n**Notable Testing Patterns or Techniques Used**:\n- **Client Simulation**: The test uses Flask's test client to simulate a request to the application, allowing for easy verification of the response without needing to run a live server.\n- **Context Management**: The test leverages Flask's context management features, such as `flask.g` for global variables and `flask.session` for session data, to ensure that the application behaves as expected in a request context.\n- **Assertion of Response Data**: The test asserts the response data by splitting it into components and comparing it to the expected values, ensuring that all context variables are rendered correctly in the response."
    },
    {
      "name": "test_escaping",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 71,
      "end_line_number": 88,
      "source_code": "def test_escaping(app, client):\n    text = \"<p>Hello World!\"\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\n            \"escaping_template.html\", text=text, html=Markup(text)\n        )\n\n    lines = client.get(\"/\").data.splitlines()\n    assert lines == [\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n    ]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert lines == [b'&lt;p&gt;Hello World!', b'<p>Hello World!', b'<p>Hello World!', b'<p>Hello World!', b'&lt;p&gt;Hello World!', b'<p>Hello World!']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_escaping` function is designed to verify the correct HTML escaping behavior of a Flask application when rendering templates. It ensures that potentially dangerous HTML content is properly escaped to prevent XSS (Cross-Site Scripting) vulnerabilities.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the text `\"<p>Hello World!\"` is rendered in two different ways: once as escaped HTML (`&lt;p&gt;Hello World!`) and once as raw HTML (`<p>Hello World!`). The expected output is a list of byte strings that represent the rendered content of the template, confirming that the escaping is applied correctly.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a Flask route defined by the `@app.route(\"/\")` decorator, which renders a template called `escaping_template.html`. The template receives two variables: `text` (the raw HTML string) and `html` (the Markup-wrapped string). The `client.get(\"/\")` call simulates a request to the root URL, and the response data is split into lines for assertion. The test asserts that the response matches the expected list of byte strings.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Client Simulation**: The use of `client.get(\"/\")` simulates a request to the Flask application, allowing for testing of the response without needing to run a server.\n- **Assertions**: The test employs assertions to compare the actual output against the expected output, ensuring that the application behaves as intended.\n- **Template Rendering**: The test leverages Flask's template rendering capabilities, specifically checking how the application handles HTML content within templates.\n- **Markup Usage**: The use of `Markup` from `flask` indicates an intention to safely handle HTML content, which is crucial for preventing XSS attacks."
    },
    {
      "name": "test_no_escaping",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 91,
      "end_line_number": 110,
      "source_code": "def test_no_escaping(app, client):\n    text = \"<p>Hello World!\"\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\n            \"non_escaping_template.txt\", text=text, html=Markup(text)\n        )\n\n    lines = client.get(\"/\").data.splitlines()\n    assert lines == [\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n    ]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert lines == [b'<p>Hello World!', b'<p>Hello World!', b'<p>Hello World!', b'<p>Hello World!', b'&lt;p&gt;Hello World!', b'<p>Hello World!', b'<p>Hello World!', b'<p>Hello World!']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_no_escaping` function is designed to verify the behavior of a Flask application when rendering a template that does not escape HTML content. It ensures that the raw HTML is returned as-is, allowing for the correct display of HTML elements in the response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the output of the rendered template contains both the raw HTML and its escaped version. Specifically, it verifies that the string `<p>Hello World!` is rendered correctly in multiple lines, with some lines showing the unescaped version and others showing the escaped version (`&lt;p&gt;Hello World!`).\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a Flask route defined in the `index` function, which renders a template named `non_escaping_template.txt`. The template is expected to display the variable `text` both as raw HTML (using `Markup(text)`) and as escaped HTML. The test uses the Flask test client to make a GET request to the root URL (`/`) and captures the response data, which is then split into lines for assertion.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Flask Testing Client**: The test utilizes Flask's built-in testing client to simulate requests to the application, allowing for easy verification of response content.\n- **Assertions**: The test employs assertions to compare the actual output against the expected output, ensuring that the rendered content matches the specified format.\n- **Separation of Concerns**: The test is structured to focus solely on the rendering behavior of the template, isolating it from other application logic, which is a good practice in unit testing."
    },
    {
      "name": "test_escaping_without_template_filename",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 113,
      "end_line_number": 115,
      "source_code": "def test_escaping_without_template_filename(app, client, req_ctx):\n    assert flask.render_template_string(\"{{ foo }}\", foo=\"<test>\") == \"&lt;test&gt;\"\n    assert flask.render_template(\"mail.txt\", foo=\"<test>\") == \"<test> Mail\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client",
        "req_ctx"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert flask.render_template_string('{{ foo }}', foo='<test>') == '&lt;test&gt;'",
        "assert flask.render_template('mail.txt', foo='<test>') == '<test> Mail'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_macros",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 118,
      "end_line_number": 120,
      "source_code": "def test_macros(app, req_ctx):\n    macro = flask.get_template_attribute(\"_macro.html\", \"hello\")\n    assert macro(\"World\") == \"Hello World!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "req_ctx"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert macro('World') == 'Hello World!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_template_filter",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 123,
      "end_line_number": 130,
      "source_code": "def test_template_filter(app):\n    @app.template_filter()\n    def my_reverse(s):\n        return s[::-1]\n\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'my_reverse' in app.jinja_env.filters.keys()",
        "assert app.jinja_env.filters['my_reverse'] == my_reverse",
        "assert app.jinja_env.filters['my_reverse']('abcd') == 'dcba'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_add_template_filter",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 133,
      "end_line_number": 140,
      "source_code": "def test_add_template_filter(app):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse)\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'my_reverse' in app.jinja_env.filters.keys()",
        "assert app.jinja_env.filters['my_reverse'] == my_reverse",
        "assert app.jinja_env.filters['my_reverse']('abcd') == 'dcba'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_template_filter_with_name",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 143,
      "end_line_number": 150,
      "source_code": "def test_template_filter_with_name(app):\n    @app.template_filter(\"strrev\")\n    def my_reverse(s):\n        return s[::-1]\n\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'strrev' in app.jinja_env.filters.keys()",
        "assert app.jinja_env.filters['strrev'] == my_reverse",
        "assert app.jinja_env.filters['strrev']('abcd') == 'dcba'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_add_template_filter_with_name",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 153,
      "end_line_number": 160,
      "source_code": "def test_add_template_filter_with_name(app):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse, \"strrev\")\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'strrev' in app.jinja_env.filters.keys()",
        "assert app.jinja_env.filters['strrev'] == my_reverse",
        "assert app.jinja_env.filters['strrev']('abcd') == 'dcba'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_template_filter_with_template",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 163,
      "end_line_number": 173,
      "source_code": "def test_template_filter_with_template(app, client):\n    @app.template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'dcba'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:\nThe main purpose of the `test_template_filter_with_template` test is to verify that a custom template filter, `super_reverse`, correctly reverses a string when used within a Flask template. This ensures that the template filter functionality is working as expected in the context of rendering templates.\n\n**Specific Functionality or Behavior Verified**:\nThis test specifically checks that when the string \"abcd\" is passed to the `super_reverse` filter in the `template_filter.html` template, the output is \"dcba\". It confirms that the filter is applied correctly and that the rendered output matches the expected result.\n\n**Code Being Tested and How It Works**:\nThe code being tested includes the definition of the `super_reverse` filter and the `index` route that renders the `template_filter.html` template. The filter is registered with the Flask app using the `@app.template_filter()` decorator. The `index` route returns the rendered template with the value \"abcd\". The test then makes a GET request to the root URL (\"/\") using the test client and asserts that the response data matches the expected byte string `b\"dcba\"`.\n\n**Notable Testing Patterns or Techniques Used**:\nThe test employs several notable patterns:\n1. **Flask Testing Client**: It uses Flask's built-in testing client to simulate HTTP requests and capture responses, allowing for integration-style testing of the application.\n2. **Template Rendering**: The test checks the output of a rendered template, ensuring that the application behaves as expected when integrating custom filters.\n3. **Assertions**: It uses assertions to validate that the output of the rendered template matches the expected result, which is a common practice in unit testing to confirm correctness."
    },
    {
      "name": "test_add_template_filter_with_template",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 176,
      "end_line_number": 187,
      "source_code": "def test_add_template_filter_with_template(app, client):\n    def super_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(super_reverse)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'dcba'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_add_template_filter_with_template` aims to verify that a custom template filter can be successfully added to a Flask application and that it functions correctly when rendering a template.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `super_reverse` filter, which reverses a string, is applied correctly to the `value` passed to the template. The expected output is that the string \"abcd\" is rendered as \"dcba\" when the template is processed.\n\n**Code Being Tested and How It Works**:  \nThe test defines a function `super_reverse` that takes a string `s` and returns it reversed (`s[::-1]`). This function is added as a template filter to the Flask app using `bp.add_app_template_filter(super_reverse)`. The test then sets up a route (`@app.route(\"/\")`) that renders a template named `template_filter.html`, passing the string \"abcd\" as the `value`. The test makes a GET request to the root URL and asserts that the response data matches the expected byte string `b\"dcba\"`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprints**: The test utilizes Flask's Blueprint feature to encapsulate the template filter, demonstrating modular design.\n- **Client Simulation**: The `client` fixture is used to simulate HTTP requests to the application, allowing for testing of the rendered output without needing to run a live server.\n- **Assertions**: The test employs assertions to validate that the output of the rendered template matches the expected result, ensuring that the filter behaves as intended."
    },
    {
      "name": "test_template_filter_with_name_and_template",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 190,
      "end_line_number": 200,
      "source_code": "def test_template_filter_with_name_and_template(app, client):\n    @app.template_filter(\"super_reverse\")\n    def my_reverse(s):\n        return s[::-1]\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'dcba'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_template_filter_with_name_and_template` is designed to verify that a custom Jinja2 template filter, named \"super_reverse\", correctly reverses a string when applied within a Flask application context. It ensures that the filter is properly registered and functional when rendering a template.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when the template filter \"super_reverse\" is applied to the string \"abcd\" in the `template_filter.html` template, the output is \"dcba\". This confirms that the filter behaves as expected, transforming the input string by reversing its characters.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the definition of the `super_reverse` filter and the route that renders the template. The filter is defined using the `@app.template_filter(\"super_reverse\")` decorator, which registers it with the Flask app's Jinja2 environment. The route `@app.route(\"/\")` serves the template `template_filter.html`, passing the string \"abcd\" as the value. The test then simulates a GET request to the root URL (\"/\") using the `client.get(\"/\")` method, capturing the response and asserting that the returned data matches the expected byte string `b\"dcba\"`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n1. **Flask Testing Client**: It uses Flask's test client to simulate HTTP requests, allowing for integration-style testing of the application routes and their responses.\n2. **Template Rendering Verification**: The test checks the output of a rendered template, ensuring that the custom filter is applied correctly within the template context.\n3. **Assertion of Byte Data**: The test asserts the response data as a byte string, which is a common practice when dealing with raw HTTP responses in Flask tests, ensuring that the output format is as expected."
    },
    {
      "name": "test_add_template_filter_with_name_and_template",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 203,
      "end_line_number": 214,
      "source_code": "def test_add_template_filter_with_name_and_template(app, client):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse, \"super_reverse\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'dcba'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_add_template_filter_with_name_and_template` is designed to verify that a custom template filter can be added to a Flask application and that it functions correctly when rendering a template. Specifically, it checks that the filter correctly reverses a string when applied in a template context.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the `add_template_filter` method of the Flask app correctly registers a new filter named \"super_reverse\" and that this filter can be used in a rendered template to transform the input string \"abcd\" into \"dcba\". The test asserts that the output of the rendered template matches the expected byte string.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `add_template_filter` method, which registers the `my_reverse` function as a template filter with the name \"super_reverse\". The test defines a route that renders a template (`template_filter.html`) with a context variable `value` set to \"abcd\". When the client makes a GET request to the root URL (\"/\"), the application uses the registered filter to process the value, reversing it before rendering. The test checks that the response data matches the expected reversed string.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Fixture Usage**: It uses `app` and `client` fixtures, which are common in Flask testing to set up the application context and simulate HTTP requests.\n- **Route Definition**: The test dynamically defines a route within the test function, allowing for isolated testing of the filter's functionality.\n- **Assertion**: It uses a straightforward assertion to compare the actual output (`rv.data`) with the expected output (`b\"dcba\"`), ensuring that the filter behaves as intended when applied in a template context."
    },
    {
      "name": "test_template_test",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 217,
      "end_line_number": 224,
      "source_code": "def test_template_test(app):\n    @app.template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == boolean\n    assert app.jinja_env.tests[\"boolean\"](False)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'boolean' in app.jinja_env.tests.keys()",
        "assert app.jinja_env.tests['boolean'] == boolean",
        "assert app.jinja_env.tests['boolean'](False)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_add_template_test",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 227,
      "end_line_number": 234,
      "source_code": "def test_add_template_test(app):\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(boolean)\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == boolean\n    assert app.jinja_env.tests[\"boolean\"](False)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'boolean' in app.jinja_env.tests.keys()",
        "assert app.jinja_env.tests['boolean'] == boolean",
        "assert app.jinja_env.tests['boolean'](False)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_template_test_with_name",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 237,
      "end_line_number": 244,
      "source_code": "def test_template_test_with_name(app):\n    @app.template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"boolean\"](False)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'boolean' in app.jinja_env.tests.keys()",
        "assert app.jinja_env.tests['boolean'] == is_boolean",
        "assert app.jinja_env.tests['boolean'](False)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_add_template_test_with_name",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 247,
      "end_line_number": 254,
      "source_code": "def test_add_template_test_with_name(app):\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(is_boolean, \"boolean\")\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"boolean\"](False)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'boolean' in app.jinja_env.tests.keys()",
        "assert app.jinja_env.tests['boolean'] == is_boolean",
        "assert app.jinja_env.tests['boolean'](False)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_template_test_with_template",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 257,
      "end_line_number": 267,
      "source_code": "def test_template_test_with_template(app, client):\n    @app.template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert b'Success!' in rv.data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_template_test_with_template` function is to verify that a custom Jinja template test, named `boolean`, is correctly registered and can be utilized within a Flask application to render a template. The test checks if the rendered output contains the expected content when the template is processed.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically verifies that the template renders correctly when passed a boolean value (`False` in this case) and that the output includes the string \"Success!\". It ensures that the custom template test behaves as expected, confirming that the application can correctly identify boolean values.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the registration of a custom template test (`boolean`) that checks if a value is of type `bool`. The test is registered to the Flask application via a blueprint. The `index` route renders a template (`template_test.html`) with a context variable `value` set to `False`. The test then makes a GET request to the root URL (\"/\") using the test client and asserts that the response data contains the byte string `b\"Success!\"`, indicating that the template rendered successfully.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprints**: The test utilizes Flask's blueprint feature to encapsulate the template test registration, promoting modularity and separation of concerns.\n- **Client Testing**: The test employs Flask's test client to simulate HTTP requests and validate responses, allowing for end-to-end testing of the route and template rendering.\n- **Assertions**: The use of assertions to check the presence of expected content in the response data is a common practice in unit testing, ensuring that the application behaves as intended."
    },
    {
      "name": "test_add_template_test_with_template",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 270,
      "end_line_number": 281,
      "source_code": "def test_add_template_test_with_template(app, client):\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(boolean)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert b'Success!' in rv.data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_add_template_test_with_template` function aims to verify that a custom template test function can be successfully added to a Flask application and that it behaves as expected when rendering a template.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the custom template test function `boolean`, which determines if a value is a boolean, is correctly registered with the Flask application. It also ensures that when the root route (`\"/\"`) is accessed, the rendered template (`\"template_test.html\"`) includes the expected content, specifically the string \"Success!\".\n\n**Code Being Tested and How It Works**:  \nThe test first defines a function `boolean` that checks if a given value is of type `bool`. This function is then added to the Flask application as a template test using `bp.add_app_template_test(boolean)`. The application registers a blueprint and defines a route that renders a template with a context variable `value` set to `False`. The test then simulates a GET request to the root route and asserts that the response data contains the byte string `b\"Success!\"`, indicating that the template rendered correctly.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprints**: The test utilizes Flask's blueprint feature to encapsulate the template test function, promoting modularity and separation of concerns.\n- **Client Simulation**: The test uses Flask's test client to simulate HTTP requests, allowing for the verification of the application's behavior without needing to run a live server.\n- **Assertions**: The test employs assertions to validate that the expected output is present in the response, ensuring that the application behaves as intended when the route is accessed."
    },
    {
      "name": "test_template_test_with_name_and_template",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 284,
      "end_line_number": 294,
      "source_code": "def test_template_test_with_name_and_template(app, client):\n    @app.template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert b'Success!' in rv.data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_template_test_with_name_and_template` aims to verify that a custom Jinja template test function, `is_boolean`, is correctly registered and utilized within a Flask application. It checks that the template renders as expected when the test is applied to a value passed to it.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically verifies that when the `index` route is accessed, the rendered template `template_test.html` contains the string \"Success!\". This indicates that the template is correctly processing the `value` passed to it (in this case, `False`) and that the custom template test `is_boolean` is functioning as intended.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the route definition for `index`, which uses `flask.render_template` to render `template_test.html` with a context variable `value` set to `False`. The custom template test `is_boolean` checks if a given value is of type `bool`. The test then makes a GET request to the root URL (\"/\") using the `client` fixture, and asserts that the response data contains \"Success!\", indicating that the template rendered correctly.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of Flask's testing client to simulate HTTP requests and responses, allowing for integration testing of the application routes. It also utilizes the concept of template tests in Jinja, which allows for custom logic to be applied within templates. The use of assertions to check the presence of specific content in the response data is a common pattern in unit testing to validate expected outcomes."
    },
    {
      "name": "test_add_template_test_with_name_and_template",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 297,
      "end_line_number": 308,
      "source_code": "def test_add_template_test_with_name_and_template(app, client):\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(is_boolean, \"boolean\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert b'Success!' in rv.data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_add_template_test_with_name_and_template` aims to verify that a custom template test function can be successfully added to a Flask application and that it can be utilized within a rendered template.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the application correctly recognizes and applies the custom template test `is_boolean`, which determines if a value is a boolean. It also verifies that the rendered template returns the expected output, specifically checking for the presence of the string \"Success!\" in the response data.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the Flask route defined by `@app.route(\"/\")`, which renders the template `template_test.html` with a context variable `value` set to `False`. The test first adds the `is_boolean` function as a template test under the name \"boolean\". When the client makes a GET request to the root URL, the application renders the specified template, which presumably checks the `value` using the custom test. The assertion checks that the response contains the expected success message.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of Flask's testing client to simulate HTTP requests and responses, allowing for integration-style testing of the application. It also utilizes the concept of template tests in Jinja2, which allows for custom logic to be applied within templates. The test structure follows the Arrange-Act-Assert pattern, where the setup (adding the template test and defining the route) is followed by the action (making a GET request), and finally the assertion checks the outcome."
    },
    {
      "name": "test_add_template_global",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 311,
      "end_line_number": 321,
      "source_code": "def test_add_template_global(app, app_ctx):\n    @app.template_global()\n    def get_stuff():\n        return 42\n\n    assert \"get_stuff\" in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals[\"get_stuff\"] == get_stuff\n    assert app.jinja_env.globals[\"get_stuff\"](), 42\n\n    rv = flask.render_template_string(\"{{ get_stuff() }}\")\n    assert rv == \"42\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "app_ctx"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'get_stuff' in app.jinja_env.globals.keys()",
        "assert app.jinja_env.globals['get_stuff'] == get_stuff",
        "assert app.jinja_env.globals['get_stuff'](), 42",
        "assert rv == '42'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_custom_template_loader",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 324,
      "end_line_number": 339,
      "source_code": "def test_custom_template_loader(client):\n    class MyFlask(flask.Flask):\n        def create_global_jinja_loader(self):\n            from jinja2 import DictLoader\n\n            return DictLoader({\"index.html\": \"Hello Custom World!\"})\n\n    app = MyFlask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"index.html\")\n\n    c = app.test_client()\n    rv = c.get(\"/\")\n    assert rv.data == b\"Hello Custom World!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "client"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'Hello Custom World!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_custom_template_loader` unit test is designed to verify that a custom Jinja2 template loader can successfully render a template in a Flask application. Specifically, it checks that the application can return the expected content when a specific route is accessed.\n\n**Specific Functionality or Behavior Verified**:  \nThe test ensures that when the root route (\"/\") is accessed, the application correctly renders the \"index.html\" template, which is provided by the custom loader. The expected output is the string \"Hello Custom World!\", confirming that the template loading mechanism is functioning as intended.\n\n**Code Being Tested and How It Works**:  \nThe test defines a subclass of `flask.Flask`, named `MyFlask`, which overrides the `create_global_jinja_loader` method to return a `DictLoader` containing a single template (\"index.html\") with the content \"Hello Custom World!\". The test then sets up a route that renders this template using `flask.render_template`. A test client is created to simulate a request to the root route, and the response is checked to ensure that the data returned matches the expected byte string.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Subclassing**: The test uses subclassing to create a custom Flask application with a specific template loader, demonstrating how to extend functionality in a test environment.\n- **Test Client**: It utilizes Flask's test client to simulate HTTP requests and capture responses, allowing for easy verification of the application's behavior.\n- **Direct Assertion**: The test employs a direct assertion to compare the response data against the expected output, ensuring that the template rendering works as intended."
    },
    {
      "name": "test_iterable_loader",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 342,
      "end_line_number": 359,
      "source_code": "def test_iterable_loader(app, client):\n    @app.context_processor\n    def context_processor():\n        return {\"whiskey\": \"Jameson\"}\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\n            [\n                \"no_template.xml\",  # should skip this one\n                \"simple_template.html\",  # should render this\n                \"context_template.html\",\n            ],\n            value=23,\n        )\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"<h1>Jameson</h1>\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "client"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert rv.data == b'<h1>Jameson</h1>'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_iterable_loader` function is designed to verify that the Flask application correctly renders a template when multiple templates are provided, specifically ensuring that it skips templates that do not exist and renders those that do.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when the application attempts to render a list of templates, it successfully renders the `simple_template.html` and `context_template.html` while skipping `no_template.xml`, and that the rendered output contains the expected content based on the context provided.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Flask application with a context processor that injects a variable (`whiskey`) into the template context. The `index` route attempts to render a list of templates. The `client.get(\"/\")` call simulates a request to the root URL, and the assertion checks that the response data matches the expected byte string `b\"<h1>Jameson</h1>\"`, which indicates that the correct template was rendered with the injected context.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Processor**: The use of a context processor allows for the injection of variables into the template context, which is a common pattern in Flask applications to share data across templates.\n- **Client Simulation**: The `client` fixture is used to simulate HTTP requests to the application, allowing for testing of the application's response to those requests.\n- **Assertions**: The test employs assertions to validate that the output matches expected results, which is a fundamental aspect of unit testing to ensure correctness."
    },
    {
      "name": "test_templates_auto_reload",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 362,
      "end_line_number": 391,
      "source_code": "def test_templates_auto_reload(app):\n    # debug is False, config option is None\n    assert app.debug is False\n    assert app.config[\"TEMPLATES_AUTO_RELOAD\"] is None\n    assert app.jinja_env.auto_reload is False\n    # debug is False, config option is False\n    app = flask.Flask(__name__)\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = False\n    assert app.debug is False\n    assert app.jinja_env.auto_reload is False\n    # debug is False, config option is True\n    app = flask.Flask(__name__)\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = True\n    assert app.debug is False\n    assert app.jinja_env.auto_reload is True\n    # debug is True, config option is None\n    app = flask.Flask(__name__)\n    app.config[\"DEBUG\"] = True\n    assert app.config[\"TEMPLATES_AUTO_RELOAD\"] is None\n    assert app.jinja_env.auto_reload is True\n    # debug is True, config option is False\n    app = flask.Flask(__name__)\n    app.config[\"DEBUG\"] = True\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = False\n    assert app.jinja_env.auto_reload is False\n    # debug is True, config option is True\n    app = flask.Flask(__name__)\n    app.config[\"DEBUG\"] = True\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = True\n    assert app.jinja_env.auto_reload is True",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.debug is False",
        "assert app.config['TEMPLATES_AUTO_RELOAD'] is None",
        "assert app.jinja_env.auto_reload is False",
        "assert app.debug is False",
        "assert app.jinja_env.auto_reload is False",
        "assert app.debug is False",
        "assert app.jinja_env.auto_reload is True",
        "assert app.config['TEMPLATES_AUTO_RELOAD'] is None",
        "assert app.jinja_env.auto_reload is True",
        "assert app.jinja_env.auto_reload is False",
        "assert app.jinja_env.auto_reload is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_templates_auto_reload_debug_run",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 394,
      "end_line_number": 404,
      "source_code": "def test_templates_auto_reload_debug_run(app, monkeypatch):\n    def run_simple_mock(*args, **kwargs):\n        pass\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n\n    app.run()\n    assert not app.jinja_env.auto_reload\n\n    app.run(debug=True)\n    assert app.jinja_env.auto_reload",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "monkeypatch"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert not app.jinja_env.auto_reload",
        "assert app.jinja_env.auto_reload"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_template_loader_debugging",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 407,
      "end_line_number": 440,
      "source_code": "def test_template_loader_debugging(test_apps, monkeypatch):\n    from blueprintapp import app\n\n    called = []\n\n    class _TestHandler(logging.Handler):\n        def handle(self, record):\n            called.append(True)\n            text = str(record.msg)\n            assert \"1: trying loader of application 'blueprintapp'\" in text\n            assert (\n                \"2: trying loader of blueprint 'admin' (blueprintapp.apps.admin)\"\n            ) in text\n            assert (\n                \"trying loader of blueprint 'frontend' (blueprintapp.apps.frontend)\"\n            ) in text\n            assert \"Error: the template could not be found\" in text\n            assert (\n                \"looked up from an endpoint that belongs to the blueprint 'frontend'\"\n            ) in text\n            assert \"See https://flask.palletsprojects.com/blueprints/#templates\" in text\n\n    with app.test_client() as c:\n        monkeypatch.setitem(app.config, \"EXPLAIN_TEMPLATE_LOADING\", True)\n        monkeypatch.setattr(\n            logging.getLogger(\"blueprintapp\"), \"handlers\", [_TestHandler()]\n        )\n\n        with pytest.raises(TemplateNotFound) as excinfo:\n            c.get(\"/missing\")\n\n        assert \"missing_template.html\" in str(excinfo.value)\n\n    assert len(called) == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "test_apps",
        "monkeypatch"
      ],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(called) == 1",
        "assert 'missing_template.html' in str(excinfo.value)",
        "assert \"1: trying loader of application 'blueprintapp'\" in text",
        "assert \"2: trying loader of blueprint 'admin' (blueprintapp.apps.admin)\" in text",
        "assert \"trying loader of blueprint 'frontend' (blueprintapp.apps.frontend)\" in text",
        "assert 'Error: the template could not be found' in text",
        "assert \"looked up from an endpoint that belongs to the blueprint 'frontend'\" in text",
        "assert 'See https://flask.palletsprojects.com/blueprints/#templates' in text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "c.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_template_loader_debugging` test is to verify that the Flask application correctly logs detailed debugging information when a template is not found. This is particularly useful for developers to understand the template loading process and diagnose issues related to missing templates.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a request is made to a non-existent template (in this case, `/missing`), the application raises a `TemplateNotFound` exception and logs specific messages indicating the steps taken during the template loading process. It ensures that the logging output contains expected messages that provide context about the application and blueprint loaders involved.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the Flask application (`app`) and its template loading mechanism. The test uses Flask's test client to simulate a request to a route that is expected to fail due to a missing template. The `monkeypatch` utility is employed to modify the application's configuration to enable template loading explanations and to replace the logging handlers with a custom handler (`_TestHandler`) that captures log messages. The test then asserts that the correct exception is raised and that the log messages contain specific expected strings.\n\n**Notable Testing Patterns or Techniques Used**:  \n1. **Monkeypatching**: The test uses `monkeypatch` to modify the application's configuration and logging behavior dynamically, allowing for controlled testing of the logging output without altering the actual application code.\n2. **Custom Logging Handler**: A custom logging handler (`_TestHandler`) is defined to capture log messages and perform assertions on them, which is a common technique for verifying logging behavior in tests.\n3. **Exception Assertion**: The test uses `pytest.raises` to assert that a specific exception (`TemplateNotFound`) is raised during the request, ensuring that error handling is functioning as expected.\n4. **Assertions on Log Output**: The test includes multiple assertions to verify that the log messages contain the expected content, which is crucial for debugging and understanding the template loading process."
    },
    {
      "name": "test_custom_jinja_env",
      "module": "test_templating",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_templating.py",
      "line_number": 443,
      "end_line_number": 451,
      "source_code": "def test_custom_jinja_env():\n    class CustomEnvironment(flask.templating.Environment):\n        pass\n\n    class CustomFlask(flask.Flask):\n        jinja_environment = CustomEnvironment\n\n    app = CustomFlask(__name__)\n    assert isinstance(app.jinja_env, CustomEnvironment)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "pytest",
        "werkzeug.serving",
        "jinja2.TemplateNotFound",
        "markupsafe.Markup",
        "flask",
        "blueprintapp.app",
        "jinja2.DictLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(app.jinja_env, CustomEnvironment)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "No methods under test found"
    },
    {
      "name": "test_open_session_with_endpoint",
      "module": "test_session_interface",
      "class_name": null,
      "file_path": "__internal__/data/flask/tests/test_session_interface.py",
      "line_number": 6,
      "end_line_number": 28,
      "source_code": "def test_open_session_with_endpoint():\n    \"\"\"If request.endpoint (or other URL matching behavior) is needed\n    while loading the session, RequestContext.match_request() can be\n    called manually.\n    \"\"\"\n\n    class MySessionInterface(SessionInterface):\n        def save_session(self, app, session, response):\n            pass\n\n        def open_session(self, app, request):\n            request_ctx.match_request()\n            assert request.endpoint is not None\n\n    app = flask.Flask(__name__)\n    app.session_interface = MySessionInterface()\n\n    @app.get(\"/\")\n    def index():\n        return \"Hello, World!\"\n\n    response = app.test_client().get(\"/\")\n    assert response.status_code == 200",
      "docstring": "If request.endpoint (or other URL matching behavior) is needed\nwhile loading the session, RequestContext.match_request() can be\ncalled manually.",
      "decorators": [],
      "arguments": [],
      "imports": [
        "flask",
        "flask.globals.request_ctx",
        "flask.sessions.SessionInterface"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert request.endpoint is not None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "@app.route('/get')\ndef get():\n    v = flask.session.get('value', 'None')\n    return v"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_open_session_with_endpoint` test is to verify that the Flask session interface can correctly access the request's endpoint information when opening a session. This is particularly important for scenarios where the session's behavior depends on the request context.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the `request.endpoint` is not `None` after manually matching the request context using `request_ctx.match_request()`. This ensures that the session interface can retrieve the endpoint information, which is crucial for routing and session management.\n\n**Code Being Tested and How It Works**:  \nThe test defines a custom session interface, `MySessionInterface`, which overrides the `open_session` method. Inside this method, it calls `request_ctx.match_request()` to manually match the current request context. The test then asserts that `request.endpoint` is not `None`, confirming that the endpoint has been correctly identified. The Flask application is set up with a simple route that returns \"Hello, World!\" and is tested using the Flask test client to ensure it responds with a 200 status code.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Custom Session Interface**: It creates a subclass of `SessionInterface` to implement specific session behavior for testing.\n- **Manual Request Context Matching**: It demonstrates how to manually match the request context, which is useful for testing scenarios where automatic context matching may not occur.\n- **Assertions**: The use of assertions to validate the expected state of the request context and the response status code is a standard practice in unit testing, ensuring that the code behaves as intended."
    }
  ]
}