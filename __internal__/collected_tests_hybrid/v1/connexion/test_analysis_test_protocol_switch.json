{
  "test_name": "test_protocol_switch",
  "test_file": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/tests/test_connection.py",
  "static_methods": [
    {
      "name": "setup",
      "source_code": "    def setup() -> ConnectionPair:\n        p = ConnectionPair()\n        p.send(\n            CLIENT,\n            Request(\n                method=\"GET\",\n                target=\"/\",\n                headers=[\n                    (\"Host\", \"example.com\"),\n                    (\"Content-Length\", \"100\"),\n                    (\"Expect\", \"100-continue\"),\n                ],\n            ),\n        )\n        for conn in p.conns:\n            assert conn.client_is_waiting_for_100_continue\n        assert not p.conn[CLIENT].they_are_waiting_for_100_continue\n        assert p.conn[SERVER].they_are_waiting_for_100_continue\n        return p",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/tests/test_connection.py",
      "line_number": 371
    },
    {
      "name": "p.send",
      "source_code": "    def send(self, message: Message) -> None:\n        self._receive_queue.put(message)\n        if hasattr(self, \"_queue_event\"):\n            self.portal.start_task_soon(self._queue_event.set)",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/starlette/testclient.py",
      "line_number": 183
    },
    {
      "name": "p.send",
      "source_code": "    def send(self, message: Message) -> None:\n        self._receive_queue.put(message)\n        if hasattr(self, \"_queue_event\"):\n            self.portal.start_task_soon(self._queue_event.set)",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/starlette/testclient.py",
      "line_number": 183
    },
    {
      "name": "setup",
      "source_code": "    def setup() -> ConnectionPair:\n        p = ConnectionPair()\n        p.send(\n            CLIENT,\n            Request(\n                method=\"GET\",\n                target=\"/\",\n                headers=[\n                    (\"Host\", \"example.com\"),\n                    (\"Content-Length\", \"100\"),\n                    (\"Expect\", \"100-continue\"),\n                ],\n            ),\n        )\n        for conn in p.conns:\n            assert conn.client_is_waiting_for_100_continue\n        assert not p.conn[CLIENT].they_are_waiting_for_100_continue\n        assert p.conn[SERVER].they_are_waiting_for_100_continue\n        return p",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/tests/test_connection.py",
      "line_number": 371
    },
    {
      "name": "p.send",
      "source_code": "    def send(self, message: Message) -> None:\n        self._receive_queue.put(message)\n        if hasattr(self, \"_queue_event\"):\n            self.portal.start_task_soon(self._queue_event.set)",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/starlette/testclient.py",
      "line_number": 183
    },
    {
      "name": "setup",
      "source_code": "    def setup() -> ConnectionPair:\n        p = ConnectionPair()\n        p.send(\n            CLIENT,\n            Request(\n                method=\"GET\",\n                target=\"/\",\n                headers=[\n                    (\"Host\", \"example.com\"),\n                    (\"Content-Length\", \"100\"),\n                    (\"Expect\", \"100-continue\"),\n                ],\n            ),\n        )\n        for conn in p.conns:\n            assert conn.client_is_waiting_for_100_continue\n        assert not p.conn[CLIENT].they_are_waiting_for_100_continue\n        assert p.conn[SERVER].they_are_waiting_for_100_continue\n        return p",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/tests/test_connection.py",
      "line_number": 371
    },
    {
      "name": "sc.receive_data",
      "source_code": "    def receive_data(self, data: bytes | None) -> None:\n        if data is None:\n            self.complete = True\n        elif (\n            self.max_form_memory_size is not None\n            and len(self.buffer) + len(data) > self.max_form_memory_size\n        ):\n            # Ensure that data within single event does not exceed limit.\n            # Also checked across accumulated events in MultiPartParser.\n            raise RequestEntityTooLarge()\n        else:\n            self.buffer.extend(data)",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/werkzeug/sansio/multipart.py",
      "line_number": 136
    },
    {
      "name": "sc.send",
      "source_code": "    def send(self, message: Message) -> None:\n        self._receive_queue.put(message)\n        if hasattr(self, \"_queue_event\"):\n            self.portal.start_task_soon(self._queue_event.set)",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/starlette/testclient.py",
      "line_number": 183
    },
    {
      "name": "sc.send",
      "source_code": "    def send(self, message: Message) -> None:\n        self._receive_queue.put(message)\n        if hasattr(self, \"_queue_event\"):\n            self.portal.start_task_soon(self._queue_event.set)",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/starlette/testclient.py",
      "line_number": 183
    },
    {
      "name": "sc.start_next_cycle",
      "source_code": "    def start_next_cycle(self) -> None:\n        if self.states != {CLIENT: DONE, SERVER: DONE}:\n            raise LocalProtocolError(\n                \"not in a reusable state. self.states={}\".format(self.states)\n            )\n        # Can't reach DONE/DONE with any of these active, but still, let's be\n        # sure.\n        assert self.keep_alive\n        assert not self.pending_switch_proposals\n        self.states = {CLIENT: IDLE, SERVER: IDLE}",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/_state.py",
      "line_number": 358
    },
    {
      "name": "setup",
      "source_code": "    def setup() -> ConnectionPair:\n        p = ConnectionPair()\n        p.send(\n            CLIENT,\n            Request(\n                method=\"GET\",\n                target=\"/\",\n                headers=[\n                    (\"Host\", \"example.com\"),\n                    (\"Content-Length\", \"100\"),\n                    (\"Expect\", \"100-continue\"),\n                ],\n            ),\n        )\n        for conn in p.conns:\n            assert conn.client_is_waiting_for_100_continue\n        assert not p.conn[CLIENT].they_are_waiting_for_100_continue\n        assert p.conn[SERVER].they_are_waiting_for_100_continue\n        return p",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/tests/test_connection.py",
      "line_number": 371
    },
    {
      "name": "sc.receive_data",
      "source_code": "    def receive_data(self, data: bytes | None) -> None:\n        if data is None:\n            self.complete = True\n        elif (\n            self.max_form_memory_size is not None\n            and len(self.buffer) + len(data) > self.max_form_memory_size\n        ):\n            # Ensure that data within single event does not exceed limit.\n            # Also checked across accumulated events in MultiPartParser.\n            raise RequestEntityTooLarge()\n        else:\n            self.buffer.extend(data)",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/werkzeug/sansio/multipart.py",
      "line_number": 136
    },
    {
      "name": "p.send",
      "source_code": "    def send(self, message: Message) -> None:\n        self._receive_queue.put(message)\n        if hasattr(self, \"_queue_event\"):\n            self.portal.start_task_soon(self._queue_event.set)",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/starlette/testclient.py",
      "line_number": 183
    },
    {
      "name": "setup",
      "source_code": "    def setup() -> ConnectionPair:\n        p = ConnectionPair()\n        p.send(\n            CLIENT,\n            Request(\n                method=\"GET\",\n                target=\"/\",\n                headers=[\n                    (\"Host\", \"example.com\"),\n                    (\"Content-Length\", \"100\"),\n                    (\"Expect\", \"100-continue\"),\n                ],\n            ),\n        )\n        for conn in p.conns:\n            assert conn.client_is_waiting_for_100_continue\n        assert not p.conn[CLIENT].they_are_waiting_for_100_continue\n        assert p.conn[SERVER].they_are_waiting_for_100_continue\n        return p",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/tests/test_connection.py",
      "line_number": 371
    },
    {
      "name": "sc.receive_data",
      "source_code": "    def receive_data(self, data: bytes | None) -> None:\n        if data is None:\n            self.complete = True\n        elif (\n            self.max_form_memory_size is not None\n            and len(self.buffer) + len(data) > self.max_form_memory_size\n        ):\n            # Ensure that data within single event does not exceed limit.\n            # Also checked across accumulated events in MultiPartParser.\n            raise RequestEntityTooLarge()\n        else:\n            self.buffer.extend(data)",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/werkzeug/sansio/multipart.py",
      "line_number": 136
    },
    {
      "name": "sc.send",
      "source_code": "    def send(self, message: Message) -> None:\n        self._receive_queue.put(message)\n        if hasattr(self, \"_queue_event\"):\n            self.portal.start_task_soon(self._queue_event.set)",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/starlette/testclient.py",
      "line_number": 183
    },
    {
      "name": "setup",
      "source_code": "    def setup() -> ConnectionPair:\n        p = ConnectionPair()\n        p.send(\n            CLIENT,\n            Request(\n                method=\"GET\",\n                target=\"/\",\n                headers=[\n                    (\"Host\", \"example.com\"),\n                    (\"Content-Length\", \"100\"),\n                    (\"Expect\", \"100-continue\"),\n                ],\n            ),\n        )\n        for conn in p.conns:\n            assert conn.client_is_waiting_for_100_continue\n        assert not p.conn[CLIENT].they_are_waiting_for_100_continue\n        assert p.conn[SERVER].they_are_waiting_for_100_continue\n        return p",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/tests/test_connection.py",
      "line_number": 371
    },
    {
      "name": "setup",
      "source_code": "    def setup() -> ConnectionPair:\n        p = ConnectionPair()\n        p.send(\n            CLIENT,\n            Request(\n                method=\"GET\",\n                target=\"/\",\n                headers=[\n                    (\"Host\", \"example.com\"),\n                    (\"Content-Length\", \"100\"),\n                    (\"Expect\", \"100-continue\"),\n                ],\n            ),\n        )\n        for conn in p.conns:\n            assert conn.client_is_waiting_for_100_continue\n        assert not p.conn[CLIENT].they_are_waiting_for_100_continue\n        assert p.conn[SERVER].they_are_waiting_for_100_continue\n        return p",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/tests/test_connection.py",
      "line_number": 371
    },
    {
      "name": "p.send",
      "source_code": "    def send(self, message: Message) -> None:\n        self._receive_queue.put(message)\n        if hasattr(self, \"_queue_event\"):\n            self.portal.start_task_soon(self._queue_event.set)",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/starlette/testclient.py",
      "line_number": 183
    },
    {
      "name": "Request",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "Response",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "Response",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "Request",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "Response",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "InformationalResponse",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "Request",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "Response",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "Response",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "Request",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "Response",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "InformationalResponse",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "ConnectionPair",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "p.send",
      "source_code": "    def send(self, message: Message) -> None:\n        self._receive_queue.put(message)\n        if hasattr(self, \"_queue_event\"):\n            self.portal.start_task_soon(self._queue_event.set)",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/starlette/testclient.py",
      "line_number": 183
    },
    {
      "name": "p.send",
      "source_code": "    def send(self, message: Message) -> None:\n        self._receive_queue.put(message)\n        if hasattr(self, \"_queue_event\"):\n            self.portal.start_task_soon(self._queue_event.set)",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/starlette/testclient.py",
      "line_number": 183
    },
    {
      "name": "EndOfMessage",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "conn.start_next_cycle",
      "source_code": "    def start_next_cycle(self) -> None:\n        if self.states != {CLIENT: DONE, SERVER: DONE}:\n            raise LocalProtocolError(\n                \"not in a reusable state. self.states={}\".format(self.states)\n            )\n        # Can't reach DONE/DONE with any of these active, but still, let's be\n        # sure.\n        assert self.keep_alive\n        assert not self.pending_switch_proposals\n        self.states = {CLIENT: IDLE, SERVER: IDLE}",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/_state.py",
      "line_number": 358
    },
    {
      "name": "conn.receive_data",
      "source_code": "    def receive_data(self, data: bytes | None) -> None:\n        if data is None:\n            self.complete = True\n        elif (\n            self.max_form_memory_size is not None\n            and len(self.buffer) + len(data) > self.max_form_memory_size\n        ):\n            # Ensure that data within single event does not exceed limit.\n            # Also checked across accumulated events in MultiPartParser.\n            raise RequestEntityTooLarge()\n        else:\n            self.buffer.extend(data)",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/werkzeug/sansio/multipart.py",
      "line_number": 136
    },
    {
      "name": "conn.receive_data",
      "source_code": "    def receive_data(self, data: bytes | None) -> None:\n        if data is None:\n            self.complete = True\n        elif (\n            self.max_form_memory_size is not None\n            and len(self.buffer) + len(data) > self.max_form_memory_size\n        ):\n            # Ensure that data within single event does not exceed limit.\n            # Also checked across accumulated events in MultiPartParser.\n            raise RequestEntityTooLarge()\n        else:\n            self.buffer.extend(data)",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/werkzeug/sansio/multipart.py",
      "line_number": 136
    },
    {
      "name": "sc.next_event",
      "source_code": "    def next_event(self) -> Event:\n        event: Event = NEED_DATA",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/werkzeug/sansio/multipart.py",
      "line_number": 149
    },
    {
      "name": "sc.next_event",
      "source_code": "    def next_event(self) -> Event:\n        event: Event = NEED_DATA",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/werkzeug/sansio/multipart.py",
      "line_number": 149
    },
    {
      "name": "EndOfMessage",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "get_all_events",
      "source_code": "def get_all_events(conn: Connection) -> List[Event]:\n    got_events = []\n    while True:\n        event = conn.next_event()\n        if event in (NEED_DATA, PAUSED):\n            break\n        event = cast(Event, event)\n        got_events.append(event)\n        if type(event) is ConnectionClosed:\n            break\n    return got_events",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/tests/helpers.py",
      "line_number": 22
    },
    {
      "name": "sc.next_event",
      "source_code": "    def next_event(self) -> Event:\n        event: Event = NEED_DATA",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/werkzeug/sansio/multipart.py",
      "line_number": 149
    },
    {
      "name": "sc.next_event",
      "source_code": "    def next_event(self) -> Event:\n        event: Event = NEED_DATA",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/werkzeug/sansio/multipart.py",
      "line_number": 149
    },
    {
      "name": "sc.next_event",
      "source_code": "    def next_event(self) -> Event:\n        event: Event = NEED_DATA",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/werkzeug/sansio/multipart.py",
      "line_number": 149
    },
    {
      "name": "sc.next_event",
      "source_code": "    def next_event(self) -> Event:\n        event: Event = NEED_DATA",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/werkzeug/sansio/multipart.py",
      "line_number": 149
    },
    {
      "name": "ConnectionClosed",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "p.conn.send",
      "source_code": "    def send(self, message: Message) -> None:\n        self._receive_queue.put(message)\n        if hasattr(self, \"_queue_event\"):\n            self.portal.start_task_soon(self._queue_event.set)",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/starlette/testclient.py",
      "line_number": 183
    },
    {
      "name": "p.conn.send",
      "source_code": "    def send(self, message: Message) -> None:\n        self._receive_queue.put(message)\n        if hasattr(self, \"_queue_event\"):\n            self.portal.start_task_soon(self._queue_event.set)",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/starlette/testclient.py",
      "line_number": 183
    },
    {
      "name": "p.conn.next_event",
      "source_code": "    def next_event(self) -> Event:\n        event: Event = NEED_DATA",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/werkzeug/sansio/multipart.py",
      "line_number": 149
    },
    {
      "name": "conn.next_event",
      "source_code": "    def next_event(self) -> Event:\n        event: Event = NEED_DATA",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/werkzeug/sansio/multipart.py",
      "line_number": 149
    },
    {
      "name": "conn.next_event",
      "source_code": "    def next_event(self) -> Event:\n        event: Event = NEED_DATA",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/werkzeug/sansio/multipart.py",
      "line_number": 149
    },
    {
      "name": "Request",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "EndOfMessage",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "Request",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "Data",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "Data",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "EndOfMessage",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    }
  ],
  "dynamic_methods": [
    {
      "function": "setup",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/tests/test_connection.py",
      "line": 371,
      "caller": "test_protocol_switch",
      "source_code": "    def setup() -> ConnectionPair:\n        p = ConnectionPair()\n        p.send(\n            CLIENT,\n            Request(\n                method=\"GET\",\n                target=\"/\",\n                headers=[\n                    (\"Host\", \"example.com\"),\n                    (\"Content-Length\", \"100\"),\n                    (\"Expect\", \"100-continue\"),\n                ],\n            ),\n        )\n        for conn in p.conns:\n            assert conn.client_is_waiting_for_100_continue\n        assert not p.conn[CLIENT].they_are_waiting_for_100_continue\n        assert p.conn[SERVER].they_are_waiting_for_100_continue\n        return p\n\n"
    },
    {
      "function": "p.send",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/starlette/testclient.py",
      "line": 183,
      "caller": "test_protocol_switch",
      "source_code": "    def send(self, message: Message) -> None:\n        self._receive_queue.put(message)\n        if hasattr(self, \"_queue_event\"):\n            self.portal.start_task_soon(self._queue_event.set)\n\n"
    },
    {
      "function": "p.send",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/starlette/testclient.py",
      "line": 183,
      "caller": "test_protocol_switch",
      "source_code": "    def send(self, message: Message) -> None:\n        self._receive_queue.put(message)\n        if hasattr(self, \"_queue_event\"):\n            self.portal.start_task_soon(self._queue_event.set)\n\n"
    },
    {
      "function": "setup",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/tests/test_connection.py",
      "line": 371,
      "caller": "test_protocol_switch",
      "source_code": "    def setup() -> ConnectionPair:\n        p = ConnectionPair()\n        p.send(\n            CLIENT,\n            Request(\n                method=\"GET\",\n                target=\"/\",\n                headers=[\n                    (\"Host\", \"example.com\"),\n                    (\"Content-Length\", \"100\"),\n                    (\"Expect\", \"100-continue\"),\n                ],\n            ),\n        )\n        for conn in p.conns:\n            assert conn.client_is_waiting_for_100_continue\n        assert not p.conn[CLIENT].they_are_waiting_for_100_continue\n        assert p.conn[SERVER].they_are_waiting_for_100_continue\n        return p\n\n"
    },
    {
      "function": "p.send",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/starlette/testclient.py",
      "line": 183,
      "caller": "test_protocol_switch",
      "source_code": "    def send(self, message: Message) -> None:\n        self._receive_queue.put(message)\n        if hasattr(self, \"_queue_event\"):\n            self.portal.start_task_soon(self._queue_event.set)\n\n"
    },
    {
      "function": "setup",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/tests/test_connection.py",
      "line": 371,
      "caller": "test_protocol_switch",
      "source_code": "    def setup() -> ConnectionPair:\n        p = ConnectionPair()\n        p.send(\n            CLIENT,\n            Request(\n                method=\"GET\",\n                target=\"/\",\n                headers=[\n                    (\"Host\", \"example.com\"),\n                    (\"Content-Length\", \"100\"),\n                    (\"Expect\", \"100-continue\"),\n                ],\n            ),\n        )\n        for conn in p.conns:\n            assert conn.client_is_waiting_for_100_continue\n        assert not p.conn[CLIENT].they_are_waiting_for_100_continue\n        assert p.conn[SERVER].they_are_waiting_for_100_continue\n        return p\n\n"
    },
    {
      "function": "sc.receive_data",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/werkzeug/sansio/multipart.py",
      "line": 136,
      "caller": "test_protocol_switch",
      "source_code": "    def receive_data(self, data: bytes | None) -> None:\n        if data is None:\n            self.complete = True\n        elif (\n            self.max_form_memory_size is not None\n            and len(self.buffer) + len(data) > self.max_form_memory_size\n        ):\n            # Ensure that data within single event does not exceed limit.\n            # Also checked across accumulated events in MultiPartParser.\n            raise RequestEntityTooLarge()\n        else:\n            self.buffer.extend(data)\n\n"
    },
    {
      "function": "sc.send",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/starlette/testclient.py",
      "line": 183,
      "caller": "test_protocol_switch",
      "source_code": "    def send(self, message: Message) -> None:\n        self._receive_queue.put(message)\n        if hasattr(self, \"_queue_event\"):\n            self.portal.start_task_soon(self._queue_event.set)\n\n"
    },
    {
      "function": "sc.send",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/starlette/testclient.py",
      "line": 183,
      "caller": "test_protocol_switch",
      "source_code": "    def send(self, message: Message) -> None:\n        self._receive_queue.put(message)\n        if hasattr(self, \"_queue_event\"):\n            self.portal.start_task_soon(self._queue_event.set)\n\n"
    },
    {
      "function": "sc.start_next_cycle",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/_state.py",
      "line": 358,
      "caller": "test_protocol_switch",
      "source_code": "    def start_next_cycle(self) -> None:\n        if self.states != {CLIENT: DONE, SERVER: DONE}:\n            raise LocalProtocolError(\n                \"not in a reusable state. self.states={}\".format(self.states)\n            )\n        # Can't reach DONE/DONE with any of these active, but still, let's be\n        # sure.\n        assert self.keep_alive\n        assert not self.pending_switch_proposals\n        self.states = {CLIENT: IDLE, SERVER: IDLE}\n"
    },
    {
      "function": "setup",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/tests/test_connection.py",
      "line": 371,
      "caller": "test_protocol_switch",
      "source_code": "    def setup() -> ConnectionPair:\n        p = ConnectionPair()\n        p.send(\n            CLIENT,\n            Request(\n                method=\"GET\",\n                target=\"/\",\n                headers=[\n                    (\"Host\", \"example.com\"),\n                    (\"Content-Length\", \"100\"),\n                    (\"Expect\", \"100-continue\"),\n                ],\n            ),\n        )\n        for conn in p.conns:\n            assert conn.client_is_waiting_for_100_continue\n        assert not p.conn[CLIENT].they_are_waiting_for_100_continue\n        assert p.conn[SERVER].they_are_waiting_for_100_continue\n        return p\n\n"
    },
    {
      "function": "sc.receive_data",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/werkzeug/sansio/multipart.py",
      "line": 136,
      "caller": "test_protocol_switch",
      "source_code": "    def receive_data(self, data: bytes | None) -> None:\n        if data is None:\n            self.complete = True\n        elif (\n            self.max_form_memory_size is not None\n            and len(self.buffer) + len(data) > self.max_form_memory_size\n        ):\n            # Ensure that data within single event does not exceed limit.\n            # Also checked across accumulated events in MultiPartParser.\n            raise RequestEntityTooLarge()\n        else:\n            self.buffer.extend(data)\n\n"
    },
    {
      "function": "p.send",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/starlette/testclient.py",
      "line": 183,
      "caller": "test_protocol_switch",
      "source_code": "    def send(self, message: Message) -> None:\n        self._receive_queue.put(message)\n        if hasattr(self, \"_queue_event\"):\n            self.portal.start_task_soon(self._queue_event.set)\n\n"
    },
    {
      "function": "setup",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/tests/test_connection.py",
      "line": 371,
      "caller": "test_protocol_switch",
      "source_code": "    def setup() -> ConnectionPair:\n        p = ConnectionPair()\n        p.send(\n            CLIENT,\n            Request(\n                method=\"GET\",\n                target=\"/\",\n                headers=[\n                    (\"Host\", \"example.com\"),\n                    (\"Content-Length\", \"100\"),\n                    (\"Expect\", \"100-continue\"),\n                ],\n            ),\n        )\n        for conn in p.conns:\n            assert conn.client_is_waiting_for_100_continue\n        assert not p.conn[CLIENT].they_are_waiting_for_100_continue\n        assert p.conn[SERVER].they_are_waiting_for_100_continue\n        return p\n\n"
    },
    {
      "function": "sc.receive_data",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/werkzeug/sansio/multipart.py",
      "line": 136,
      "caller": "test_protocol_switch",
      "source_code": "    def receive_data(self, data: bytes | None) -> None:\n        if data is None:\n            self.complete = True\n        elif (\n            self.max_form_memory_size is not None\n            and len(self.buffer) + len(data) > self.max_form_memory_size\n        ):\n            # Ensure that data within single event does not exceed limit.\n            # Also checked across accumulated events in MultiPartParser.\n            raise RequestEntityTooLarge()\n        else:\n            self.buffer.extend(data)\n\n"
    },
    {
      "function": "sc.send",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/starlette/testclient.py",
      "line": 183,
      "caller": "test_protocol_switch",
      "source_code": "    def send(self, message: Message) -> None:\n        self._receive_queue.put(message)\n        if hasattr(self, \"_queue_event\"):\n            self.portal.start_task_soon(self._queue_event.set)\n\n"
    },
    {
      "function": "setup",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/tests/test_connection.py",
      "line": 371,
      "caller": "test_protocol_switch",
      "source_code": "    def setup() -> ConnectionPair:\n        p = ConnectionPair()\n        p.send(\n            CLIENT,\n            Request(\n                method=\"GET\",\n                target=\"/\",\n                headers=[\n                    (\"Host\", \"example.com\"),\n                    (\"Content-Length\", \"100\"),\n                    (\"Expect\", \"100-continue\"),\n                ],\n            ),\n        )\n        for conn in p.conns:\n            assert conn.client_is_waiting_for_100_continue\n        assert not p.conn[CLIENT].they_are_waiting_for_100_continue\n        assert p.conn[SERVER].they_are_waiting_for_100_continue\n        return p\n\n"
    },
    {
      "function": "setup",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/tests/test_connection.py",
      "line": 371,
      "caller": "test_protocol_switch",
      "source_code": "    def setup() -> ConnectionPair:\n        p = ConnectionPair()\n        p.send(\n            CLIENT,\n            Request(\n                method=\"GET\",\n                target=\"/\",\n                headers=[\n                    (\"Host\", \"example.com\"),\n                    (\"Content-Length\", \"100\"),\n                    (\"Expect\", \"100-continue\"),\n                ],\n            ),\n        )\n        for conn in p.conns:\n            assert conn.client_is_waiting_for_100_continue\n        assert not p.conn[CLIENT].they_are_waiting_for_100_continue\n        assert p.conn[SERVER].they_are_waiting_for_100_continue\n        return p\n\n"
    },
    {
      "function": "p.send",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/starlette/testclient.py",
      "line": 183,
      "caller": "test_protocol_switch",
      "source_code": "    def send(self, message: Message) -> None:\n        self._receive_queue.put(message)\n        if hasattr(self, \"_queue_event\"):\n            self.portal.start_task_soon(self._queue_event.set)\n\n"
    },
    {
      "function": "Request",
      "filename": "",
      "line": 0,
      "caller": "test_protocol_switch",
      "source_code": ""
    },
    {
      "function": "Response",
      "filename": "",
      "line": 0,
      "caller": "test_protocol_switch",
      "source_code": ""
    },
    {
      "function": "Response",
      "filename": "",
      "line": 0,
      "caller": "test_protocol_switch",
      "source_code": ""
    },
    {
      "function": "Request",
      "filename": "",
      "line": 0,
      "caller": "test_protocol_switch",
      "source_code": ""
    },
    {
      "function": "Response",
      "filename": "",
      "line": 0,
      "caller": "test_protocol_switch",
      "source_code": ""
    },
    {
      "function": "InformationalResponse",
      "filename": "",
      "line": 0,
      "caller": "test_protocol_switch",
      "source_code": ""
    },
    {
      "function": "Request",
      "filename": "",
      "line": 0,
      "caller": "test_protocol_switch",
      "source_code": ""
    },
    {
      "function": "Response",
      "filename": "",
      "line": 0,
      "caller": "test_protocol_switch",
      "source_code": ""
    },
    {
      "function": "Response",
      "filename": "",
      "line": 0,
      "caller": "test_protocol_switch",
      "source_code": ""
    },
    {
      "function": "Request",
      "filename": "",
      "line": 0,
      "caller": "test_protocol_switch",
      "source_code": ""
    },
    {
      "function": "Response",
      "filename": "",
      "line": 0,
      "caller": "test_protocol_switch",
      "source_code": ""
    },
    {
      "function": "InformationalResponse",
      "filename": "",
      "line": 0,
      "caller": "test_protocol_switch",
      "source_code": ""
    },
    {
      "function": "ConnectionPair",
      "filename": "",
      "line": 0,
      "caller": "test_protocol_switch",
      "source_code": ""
    },
    {
      "function": "p.send",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/starlette/testclient.py",
      "line": 183,
      "caller": "test_protocol_switch",
      "source_code": "    def send(self, message: Message) -> None:\n        self._receive_queue.put(message)\n        if hasattr(self, \"_queue_event\"):\n            self.portal.start_task_soon(self._queue_event.set)\n\n"
    },
    {
      "function": "p.send",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/starlette/testclient.py",
      "line": 183,
      "caller": "test_protocol_switch",
      "source_code": "    def send(self, message: Message) -> None:\n        self._receive_queue.put(message)\n        if hasattr(self, \"_queue_event\"):\n            self.portal.start_task_soon(self._queue_event.set)\n\n"
    },
    {
      "function": "EndOfMessage",
      "filename": "",
      "line": 0,
      "caller": "test_protocol_switch",
      "source_code": ""
    },
    {
      "function": "conn.start_next_cycle",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/_state.py",
      "line": 358,
      "caller": "test_protocol_switch",
      "source_code": "    def start_next_cycle(self) -> None:\n        if self.states != {CLIENT: DONE, SERVER: DONE}:\n            raise LocalProtocolError(\n                \"not in a reusable state. self.states={}\".format(self.states)\n            )\n        # Can't reach DONE/DONE with any of these active, but still, let's be\n        # sure.\n        assert self.keep_alive\n        assert not self.pending_switch_proposals\n        self.states = {CLIENT: IDLE, SERVER: IDLE}\n"
    },
    {
      "function": "conn.receive_data",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/werkzeug/sansio/multipart.py",
      "line": 136,
      "caller": "test_protocol_switch",
      "source_code": "    def receive_data(self, data: bytes | None) -> None:\n        if data is None:\n            self.complete = True\n        elif (\n            self.max_form_memory_size is not None\n            and len(self.buffer) + len(data) > self.max_form_memory_size\n        ):\n            # Ensure that data within single event does not exceed limit.\n            # Also checked across accumulated events in MultiPartParser.\n            raise RequestEntityTooLarge()\n        else:\n            self.buffer.extend(data)\n\n"
    },
    {
      "function": "conn.receive_data",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/werkzeug/sansio/multipart.py",
      "line": 136,
      "caller": "test_protocol_switch",
      "source_code": "    def receive_data(self, data: bytes | None) -> None:\n        if data is None:\n            self.complete = True\n        elif (\n            self.max_form_memory_size is not None\n            and len(self.buffer) + len(data) > self.max_form_memory_size\n        ):\n            # Ensure that data within single event does not exceed limit.\n            # Also checked across accumulated events in MultiPartParser.\n            raise RequestEntityTooLarge()\n        else:\n            self.buffer.extend(data)\n\n"
    },
    {
      "function": "sc.next_event",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/werkzeug/sansio/multipart.py",
      "line": 149,
      "caller": "test_protocol_switch",
      "source_code": "    def next_event(self) -> Event:\n        event: Event = NEED_DATA\n\n        if self.state == State.PREAMBLE:\n            match = self.preamble_re.search(self.buffer, self._search_position)\n            if match is not None:\n                if match.group(1).startswith(b\"--\"):\n                    self.state = State.EPILOGUE\n                else:\n                    self.state = State.PART\n                data = bytes(self.buffer[: match.start()])\n                del self.buffer[: match.end()]\n                event = Preamble(data=data)\n                self._search_position = 0\n            else:\n                # Update the search start position to be equal to the\n                # current buffer length (already searched) minus a\n                # safe buffer for part of the search target.\n                self._search_position = max(\n                    0, len(self.buffer) - len(self.boundary) - SEARCH_EXTRA_LENGTH\n                )\n\n        elif self.state == State.PART:\n            match = BLANK_LINE_RE.search(self.buffer, self._search_position)\n            if match is not None:\n                headers = self._parse_headers(self.buffer[: match.start()])\n                # The final header ends with a single CRLF, however a\n                # blank line indicates the start of the\n                # body. Therefore the end is after the first CRLF.\n                headers_end = (match.start() + match.end()) // 2\n                del self.buffer[:headers_end]\n\n                if \"content-disposition\" not in headers:\n                    raise ValueError(\"Missing Content-Disposition header\")\n\n                disposition, extra = parse_options_header(\n                    headers[\"content-disposition\"]\n                )\n                name = t.cast(str, extra.get(\"name\"))\n                filename = extra.get(\"filename\")\n                if filename is not None:\n                    event = File(\n                        filename=filename,\n                        headers=headers,\n                        name=name,\n                    )\n                else:\n                    event = Field(\n                        headers=headers,\n                        name=name,\n                    )\n                self.state = State.DATA_START\n                self._search_position = 0\n                self._parts_decoded += 1\n\n                if self.max_parts is not None and self._parts_decoded > self.max_parts:\n                    raise RequestEntityTooLarge()\n            else:\n                # Update the search start position to be equal to the\n                # current buffer length (already searched) minus a\n                # safe buffer for part of the search target.\n                self._search_position = max(0, len(self.buffer) - SEARCH_EXTRA_LENGTH)\n\n        elif self.state == State.DATA_START:\n            data, del_index, more_data = self._parse_data(self.buffer, start=True)\n            del self.buffer[:del_index]\n            event = Data(data=data, more_data=more_data)\n            if more_data:\n                self.state = State.DATA\n\n        elif self.state == State.DATA:\n            data, del_index, more_data = self._parse_data(self.buffer, start=False)\n            del self.buffer[:del_index]\n            if data or not more_data:\n                event = Data(data=data, more_data=more_data)\n\n        elif self.state == State.EPILOGUE and self.complete:\n            event = Epilogue(data=bytes(self.buffer))\n            del self.buffer[:]\n            self.state = State.COMPLETE\n\n        if self.complete and isinstance(event, NeedData):\n            raise ValueError(f\"Invalid form-data cannot parse beyond {self.state}\")\n\n        return event\n\n"
    },
    {
      "function": "sc.next_event",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/werkzeug/sansio/multipart.py",
      "line": 149,
      "caller": "test_protocol_switch",
      "source_code": "    def next_event(self) -> Event:\n        event: Event = NEED_DATA\n\n        if self.state == State.PREAMBLE:\n            match = self.preamble_re.search(self.buffer, self._search_position)\n            if match is not None:\n                if match.group(1).startswith(b\"--\"):\n                    self.state = State.EPILOGUE\n                else:\n                    self.state = State.PART\n                data = bytes(self.buffer[: match.start()])\n                del self.buffer[: match.end()]\n                event = Preamble(data=data)\n                self._search_position = 0\n            else:\n                # Update the search start position to be equal to the\n                # current buffer length (already searched) minus a\n                # safe buffer for part of the search target.\n                self._search_position = max(\n                    0, len(self.buffer) - len(self.boundary) - SEARCH_EXTRA_LENGTH\n                )\n\n        elif self.state == State.PART:\n            match = BLANK_LINE_RE.search(self.buffer, self._search_position)\n            if match is not None:\n                headers = self._parse_headers(self.buffer[: match.start()])\n                # The final header ends with a single CRLF, however a\n                # blank line indicates the start of the\n                # body. Therefore the end is after the first CRLF.\n                headers_end = (match.start() + match.end()) // 2\n                del self.buffer[:headers_end]\n\n                if \"content-disposition\" not in headers:\n                    raise ValueError(\"Missing Content-Disposition header\")\n\n                disposition, extra = parse_options_header(\n                    headers[\"content-disposition\"]\n                )\n                name = t.cast(str, extra.get(\"name\"))\n                filename = extra.get(\"filename\")\n                if filename is not None:\n                    event = File(\n                        filename=filename,\n                        headers=headers,\n                        name=name,\n                    )\n                else:\n                    event = Field(\n                        headers=headers,\n                        name=name,\n                    )\n                self.state = State.DATA_START\n                self._search_position = 0\n                self._parts_decoded += 1\n\n                if self.max_parts is not None and self._parts_decoded > self.max_parts:\n                    raise RequestEntityTooLarge()\n            else:\n                # Update the search start position to be equal to the\n                # current buffer length (already searched) minus a\n                # safe buffer for part of the search target.\n                self._search_position = max(0, len(self.buffer) - SEARCH_EXTRA_LENGTH)\n\n        elif self.state == State.DATA_START:\n            data, del_index, more_data = self._parse_data(self.buffer, start=True)\n            del self.buffer[:del_index]\n            event = Data(data=data, more_data=more_data)\n            if more_data:\n                self.state = State.DATA\n\n        elif self.state == State.DATA:\n            data, del_index, more_data = self._parse_data(self.buffer, start=False)\n            del self.buffer[:del_index]\n            if data or not more_data:\n                event = Data(data=data, more_data=more_data)\n\n        elif self.state == State.EPILOGUE and self.complete:\n            event = Epilogue(data=bytes(self.buffer))\n            del self.buffer[:]\n            self.state = State.COMPLETE\n\n        if self.complete and isinstance(event, NeedData):\n            raise ValueError(f\"Invalid form-data cannot parse beyond {self.state}\")\n\n        return event\n\n"
    },
    {
      "function": "EndOfMessage",
      "filename": "",
      "line": 0,
      "caller": "test_protocol_switch",
      "source_code": ""
    },
    {
      "function": "get_all_events",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/tests/helpers.py",
      "line": 22,
      "caller": "test_protocol_switch",
      "source_code": "def get_all_events(conn: Connection) -> List[Event]:\n    got_events = []\n    while True:\n        event = conn.next_event()\n        if event in (NEED_DATA, PAUSED):\n            break\n        event = cast(Event, event)\n        got_events.append(event)\n        if type(event) is ConnectionClosed:\n            break\n    return got_events\n\n\n"
    },
    {
      "function": "sc.next_event",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/werkzeug/sansio/multipart.py",
      "line": 149,
      "caller": "test_protocol_switch",
      "source_code": "    def next_event(self) -> Event:\n        event: Event = NEED_DATA\n\n        if self.state == State.PREAMBLE:\n            match = self.preamble_re.search(self.buffer, self._search_position)\n            if match is not None:\n                if match.group(1).startswith(b\"--\"):\n                    self.state = State.EPILOGUE\n                else:\n                    self.state = State.PART\n                data = bytes(self.buffer[: match.start()])\n                del self.buffer[: match.end()]\n                event = Preamble(data=data)\n                self._search_position = 0\n            else:\n                # Update the search start position to be equal to the\n                # current buffer length (already searched) minus a\n                # safe buffer for part of the search target.\n                self._search_position = max(\n                    0, len(self.buffer) - len(self.boundary) - SEARCH_EXTRA_LENGTH\n                )\n\n        elif self.state == State.PART:\n            match = BLANK_LINE_RE.search(self.buffer, self._search_position)\n            if match is not None:\n                headers = self._parse_headers(self.buffer[: match.start()])\n                # The final header ends with a single CRLF, however a\n                # blank line indicates the start of the\n                # body. Therefore the end is after the first CRLF.\n                headers_end = (match.start() + match.end()) // 2\n                del self.buffer[:headers_end]\n\n                if \"content-disposition\" not in headers:\n                    raise ValueError(\"Missing Content-Disposition header\")\n\n                disposition, extra = parse_options_header(\n                    headers[\"content-disposition\"]\n                )\n                name = t.cast(str, extra.get(\"name\"))\n                filename = extra.get(\"filename\")\n                if filename is not None:\n                    event = File(\n                        filename=filename,\n                        headers=headers,\n                        name=name,\n                    )\n                else:\n                    event = Field(\n                        headers=headers,\n                        name=name,\n                    )\n                self.state = State.DATA_START\n                self._search_position = 0\n                self._parts_decoded += 1\n\n                if self.max_parts is not None and self._parts_decoded > self.max_parts:\n                    raise RequestEntityTooLarge()\n            else:\n                # Update the search start position to be equal to the\n                # current buffer length (already searched) minus a\n                # safe buffer for part of the search target.\n                self._search_position = max(0, len(self.buffer) - SEARCH_EXTRA_LENGTH)\n\n        elif self.state == State.DATA_START:\n            data, del_index, more_data = self._parse_data(self.buffer, start=True)\n            del self.buffer[:del_index]\n            event = Data(data=data, more_data=more_data)\n            if more_data:\n                self.state = State.DATA\n\n        elif self.state == State.DATA:\n            data, del_index, more_data = self._parse_data(self.buffer, start=False)\n            del self.buffer[:del_index]\n            if data or not more_data:\n                event = Data(data=data, more_data=more_data)\n\n        elif self.state == State.EPILOGUE and self.complete:\n            event = Epilogue(data=bytes(self.buffer))\n            del self.buffer[:]\n            self.state = State.COMPLETE\n\n        if self.complete and isinstance(event, NeedData):\n            raise ValueError(f\"Invalid form-data cannot parse beyond {self.state}\")\n\n        return event\n\n"
    },
    {
      "function": "sc.next_event",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/werkzeug/sansio/multipart.py",
      "line": 149,
      "caller": "test_protocol_switch",
      "source_code": "    def next_event(self) -> Event:\n        event: Event = NEED_DATA\n\n        if self.state == State.PREAMBLE:\n            match = self.preamble_re.search(self.buffer, self._search_position)\n            if match is not None:\n                if match.group(1).startswith(b\"--\"):\n                    self.state = State.EPILOGUE\n                else:\n                    self.state = State.PART\n                data = bytes(self.buffer[: match.start()])\n                del self.buffer[: match.end()]\n                event = Preamble(data=data)\n                self._search_position = 0\n            else:\n                # Update the search start position to be equal to the\n                # current buffer length (already searched) minus a\n                # safe buffer for part of the search target.\n                self._search_position = max(\n                    0, len(self.buffer) - len(self.boundary) - SEARCH_EXTRA_LENGTH\n                )\n\n        elif self.state == State.PART:\n            match = BLANK_LINE_RE.search(self.buffer, self._search_position)\n            if match is not None:\n                headers = self._parse_headers(self.buffer[: match.start()])\n                # The final header ends with a single CRLF, however a\n                # blank line indicates the start of the\n                # body. Therefore the end is after the first CRLF.\n                headers_end = (match.start() + match.end()) // 2\n                del self.buffer[:headers_end]\n\n                if \"content-disposition\" not in headers:\n                    raise ValueError(\"Missing Content-Disposition header\")\n\n                disposition, extra = parse_options_header(\n                    headers[\"content-disposition\"]\n                )\n                name = t.cast(str, extra.get(\"name\"))\n                filename = extra.get(\"filename\")\n                if filename is not None:\n                    event = File(\n                        filename=filename,\n                        headers=headers,\n                        name=name,\n                    )\n                else:\n                    event = Field(\n                        headers=headers,\n                        name=name,\n                    )\n                self.state = State.DATA_START\n                self._search_position = 0\n                self._parts_decoded += 1\n\n                if self.max_parts is not None and self._parts_decoded > self.max_parts:\n                    raise RequestEntityTooLarge()\n            else:\n                # Update the search start position to be equal to the\n                # current buffer length (already searched) minus a\n                # safe buffer for part of the search target.\n                self._search_position = max(0, len(self.buffer) - SEARCH_EXTRA_LENGTH)\n\n        elif self.state == State.DATA_START:\n            data, del_index, more_data = self._parse_data(self.buffer, start=True)\n            del self.buffer[:del_index]\n            event = Data(data=data, more_data=more_data)\n            if more_data:\n                self.state = State.DATA\n\n        elif self.state == State.DATA:\n            data, del_index, more_data = self._parse_data(self.buffer, start=False)\n            del self.buffer[:del_index]\n            if data or not more_data:\n                event = Data(data=data, more_data=more_data)\n\n        elif self.state == State.EPILOGUE and self.complete:\n            event = Epilogue(data=bytes(self.buffer))\n            del self.buffer[:]\n            self.state = State.COMPLETE\n\n        if self.complete and isinstance(event, NeedData):\n            raise ValueError(f\"Invalid form-data cannot parse beyond {self.state}\")\n\n        return event\n\n"
    },
    {
      "function": "sc.next_event",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/werkzeug/sansio/multipart.py",
      "line": 149,
      "caller": "test_protocol_switch",
      "source_code": "    def next_event(self) -> Event:\n        event: Event = NEED_DATA\n\n        if self.state == State.PREAMBLE:\n            match = self.preamble_re.search(self.buffer, self._search_position)\n            if match is not None:\n                if match.group(1).startswith(b\"--\"):\n                    self.state = State.EPILOGUE\n                else:\n                    self.state = State.PART\n                data = bytes(self.buffer[: match.start()])\n                del self.buffer[: match.end()]\n                event = Preamble(data=data)\n                self._search_position = 0\n            else:\n                # Update the search start position to be equal to the\n                # current buffer length (already searched) minus a\n                # safe buffer for part of the search target.\n                self._search_position = max(\n                    0, len(self.buffer) - len(self.boundary) - SEARCH_EXTRA_LENGTH\n                )\n\n        elif self.state == State.PART:\n            match = BLANK_LINE_RE.search(self.buffer, self._search_position)\n            if match is not None:\n                headers = self._parse_headers(self.buffer[: match.start()])\n                # The final header ends with a single CRLF, however a\n                # blank line indicates the start of the\n                # body. Therefore the end is after the first CRLF.\n                headers_end = (match.start() + match.end()) // 2\n                del self.buffer[:headers_end]\n\n                if \"content-disposition\" not in headers:\n                    raise ValueError(\"Missing Content-Disposition header\")\n\n                disposition, extra = parse_options_header(\n                    headers[\"content-disposition\"]\n                )\n                name = t.cast(str, extra.get(\"name\"))\n                filename = extra.get(\"filename\")\n                if filename is not None:\n                    event = File(\n                        filename=filename,\n                        headers=headers,\n                        name=name,\n                    )\n                else:\n                    event = Field(\n                        headers=headers,\n                        name=name,\n                    )\n                self.state = State.DATA_START\n                self._search_position = 0\n                self._parts_decoded += 1\n\n                if self.max_parts is not None and self._parts_decoded > self.max_parts:\n                    raise RequestEntityTooLarge()\n            else:\n                # Update the search start position to be equal to the\n                # current buffer length (already searched) minus a\n                # safe buffer for part of the search target.\n                self._search_position = max(0, len(self.buffer) - SEARCH_EXTRA_LENGTH)\n\n        elif self.state == State.DATA_START:\n            data, del_index, more_data = self._parse_data(self.buffer, start=True)\n            del self.buffer[:del_index]\n            event = Data(data=data, more_data=more_data)\n            if more_data:\n                self.state = State.DATA\n\n        elif self.state == State.DATA:\n            data, del_index, more_data = self._parse_data(self.buffer, start=False)\n            del self.buffer[:del_index]\n            if data or not more_data:\n                event = Data(data=data, more_data=more_data)\n\n        elif self.state == State.EPILOGUE and self.complete:\n            event = Epilogue(data=bytes(self.buffer))\n            del self.buffer[:]\n            self.state = State.COMPLETE\n\n        if self.complete and isinstance(event, NeedData):\n            raise ValueError(f\"Invalid form-data cannot parse beyond {self.state}\")\n\n        return event\n\n"
    },
    {
      "function": "sc.next_event",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/werkzeug/sansio/multipart.py",
      "line": 149,
      "caller": "test_protocol_switch",
      "source_code": "    def next_event(self) -> Event:\n        event: Event = NEED_DATA\n\n        if self.state == State.PREAMBLE:\n            match = self.preamble_re.search(self.buffer, self._search_position)\n            if match is not None:\n                if match.group(1).startswith(b\"--\"):\n                    self.state = State.EPILOGUE\n                else:\n                    self.state = State.PART\n                data = bytes(self.buffer[: match.start()])\n                del self.buffer[: match.end()]\n                event = Preamble(data=data)\n                self._search_position = 0\n            else:\n                # Update the search start position to be equal to the\n                # current buffer length (already searched) minus a\n                # safe buffer for part of the search target.\n                self._search_position = max(\n                    0, len(self.buffer) - len(self.boundary) - SEARCH_EXTRA_LENGTH\n                )\n\n        elif self.state == State.PART:\n            match = BLANK_LINE_RE.search(self.buffer, self._search_position)\n            if match is not None:\n                headers = self._parse_headers(self.buffer[: match.start()])\n                # The final header ends with a single CRLF, however a\n                # blank line indicates the start of the\n                # body. Therefore the end is after the first CRLF.\n                headers_end = (match.start() + match.end()) // 2\n                del self.buffer[:headers_end]\n\n                if \"content-disposition\" not in headers:\n                    raise ValueError(\"Missing Content-Disposition header\")\n\n                disposition, extra = parse_options_header(\n                    headers[\"content-disposition\"]\n                )\n                name = t.cast(str, extra.get(\"name\"))\n                filename = extra.get(\"filename\")\n                if filename is not None:\n                    event = File(\n                        filename=filename,\n                        headers=headers,\n                        name=name,\n                    )\n                else:\n                    event = Field(\n                        headers=headers,\n                        name=name,\n                    )\n                self.state = State.DATA_START\n                self._search_position = 0\n                self._parts_decoded += 1\n\n                if self.max_parts is not None and self._parts_decoded > self.max_parts:\n                    raise RequestEntityTooLarge()\n            else:\n                # Update the search start position to be equal to the\n                # current buffer length (already searched) minus a\n                # safe buffer for part of the search target.\n                self._search_position = max(0, len(self.buffer) - SEARCH_EXTRA_LENGTH)\n\n        elif self.state == State.DATA_START:\n            data, del_index, more_data = self._parse_data(self.buffer, start=True)\n            del self.buffer[:del_index]\n            event = Data(data=data, more_data=more_data)\n            if more_data:\n                self.state = State.DATA\n\n        elif self.state == State.DATA:\n            data, del_index, more_data = self._parse_data(self.buffer, start=False)\n            del self.buffer[:del_index]\n            if data or not more_data:\n                event = Data(data=data, more_data=more_data)\n\n        elif self.state == State.EPILOGUE and self.complete:\n            event = Epilogue(data=bytes(self.buffer))\n            del self.buffer[:]\n            self.state = State.COMPLETE\n\n        if self.complete and isinstance(event, NeedData):\n            raise ValueError(f\"Invalid form-data cannot parse beyond {self.state}\")\n\n        return event\n\n"
    },
    {
      "function": "ConnectionClosed",
      "filename": "",
      "line": 0,
      "caller": "test_protocol_switch",
      "source_code": ""
    },
    {
      "function": "p.conn.send",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/starlette/testclient.py",
      "line": 183,
      "caller": "test_protocol_switch",
      "source_code": "    def send(self, message: Message) -> None:\n        self._receive_queue.put(message)\n        if hasattr(self, \"_queue_event\"):\n            self.portal.start_task_soon(self._queue_event.set)\n\n"
    },
    {
      "function": "p.conn.send",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/starlette/testclient.py",
      "line": 183,
      "caller": "test_protocol_switch",
      "source_code": "    def send(self, message: Message) -> None:\n        self._receive_queue.put(message)\n        if hasattr(self, \"_queue_event\"):\n            self.portal.start_task_soon(self._queue_event.set)\n\n"
    },
    {
      "function": "p.conn.next_event",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/werkzeug/sansio/multipart.py",
      "line": 149,
      "caller": "test_protocol_switch",
      "source_code": "    def next_event(self) -> Event:\n        event: Event = NEED_DATA\n\n        if self.state == State.PREAMBLE:\n            match = self.preamble_re.search(self.buffer, self._search_position)\n            if match is not None:\n                if match.group(1).startswith(b\"--\"):\n                    self.state = State.EPILOGUE\n                else:\n                    self.state = State.PART\n                data = bytes(self.buffer[: match.start()])\n                del self.buffer[: match.end()]\n                event = Preamble(data=data)\n                self._search_position = 0\n            else:\n                # Update the search start position to be equal to the\n                # current buffer length (already searched) minus a\n                # safe buffer for part of the search target.\n                self._search_position = max(\n                    0, len(self.buffer) - len(self.boundary) - SEARCH_EXTRA_LENGTH\n                )\n\n        elif self.state == State.PART:\n            match = BLANK_LINE_RE.search(self.buffer, self._search_position)\n            if match is not None:\n                headers = self._parse_headers(self.buffer[: match.start()])\n                # The final header ends with a single CRLF, however a\n                # blank line indicates the start of the\n                # body. Therefore the end is after the first CRLF.\n                headers_end = (match.start() + match.end()) // 2\n                del self.buffer[:headers_end]\n\n                if \"content-disposition\" not in headers:\n                    raise ValueError(\"Missing Content-Disposition header\")\n\n                disposition, extra = parse_options_header(\n                    headers[\"content-disposition\"]\n                )\n                name = t.cast(str, extra.get(\"name\"))\n                filename = extra.get(\"filename\")\n                if filename is not None:\n                    event = File(\n                        filename=filename,\n                        headers=headers,\n                        name=name,\n                    )\n                else:\n                    event = Field(\n                        headers=headers,\n                        name=name,\n                    )\n                self.state = State.DATA_START\n                self._search_position = 0\n                self._parts_decoded += 1\n\n                if self.max_parts is not None and self._parts_decoded > self.max_parts:\n                    raise RequestEntityTooLarge()\n            else:\n                # Update the search start position to be equal to the\n                # current buffer length (already searched) minus a\n                # safe buffer for part of the search target.\n                self._search_position = max(0, len(self.buffer) - SEARCH_EXTRA_LENGTH)\n\n        elif self.state == State.DATA_START:\n            data, del_index, more_data = self._parse_data(self.buffer, start=True)\n            del self.buffer[:del_index]\n            event = Data(data=data, more_data=more_data)\n            if more_data:\n                self.state = State.DATA\n\n        elif self.state == State.DATA:\n            data, del_index, more_data = self._parse_data(self.buffer, start=False)\n            del self.buffer[:del_index]\n            if data or not more_data:\n                event = Data(data=data, more_data=more_data)\n\n        elif self.state == State.EPILOGUE and self.complete:\n            event = Epilogue(data=bytes(self.buffer))\n            del self.buffer[:]\n            self.state = State.COMPLETE\n\n        if self.complete and isinstance(event, NeedData):\n            raise ValueError(f\"Invalid form-data cannot parse beyond {self.state}\")\n\n        return event\n\n"
    },
    {
      "function": "conn.next_event",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/werkzeug/sansio/multipart.py",
      "line": 149,
      "caller": "test_protocol_switch",
      "source_code": "    def next_event(self) -> Event:\n        event: Event = NEED_DATA\n\n        if self.state == State.PREAMBLE:\n            match = self.preamble_re.search(self.buffer, self._search_position)\n            if match is not None:\n                if match.group(1).startswith(b\"--\"):\n                    self.state = State.EPILOGUE\n                else:\n                    self.state = State.PART\n                data = bytes(self.buffer[: match.start()])\n                del self.buffer[: match.end()]\n                event = Preamble(data=data)\n                self._search_position = 0\n            else:\n                # Update the search start position to be equal to the\n                # current buffer length (already searched) minus a\n                # safe buffer for part of the search target.\n                self._search_position = max(\n                    0, len(self.buffer) - len(self.boundary) - SEARCH_EXTRA_LENGTH\n                )\n\n        elif self.state == State.PART:\n            match = BLANK_LINE_RE.search(self.buffer, self._search_position)\n            if match is not None:\n                headers = self._parse_headers(self.buffer[: match.start()])\n                # The final header ends with a single CRLF, however a\n                # blank line indicates the start of the\n                # body. Therefore the end is after the first CRLF.\n                headers_end = (match.start() + match.end()) // 2\n                del self.buffer[:headers_end]\n\n                if \"content-disposition\" not in headers:\n                    raise ValueError(\"Missing Content-Disposition header\")\n\n                disposition, extra = parse_options_header(\n                    headers[\"content-disposition\"]\n                )\n                name = t.cast(str, extra.get(\"name\"))\n                filename = extra.get(\"filename\")\n                if filename is not None:\n                    event = File(\n                        filename=filename,\n                        headers=headers,\n                        name=name,\n                    )\n                else:\n                    event = Field(\n                        headers=headers,\n                        name=name,\n                    )\n                self.state = State.DATA_START\n                self._search_position = 0\n                self._parts_decoded += 1\n\n                if self.max_parts is not None and self._parts_decoded > self.max_parts:\n                    raise RequestEntityTooLarge()\n            else:\n                # Update the search start position to be equal to the\n                # current buffer length (already searched) minus a\n                # safe buffer for part of the search target.\n                self._search_position = max(0, len(self.buffer) - SEARCH_EXTRA_LENGTH)\n\n        elif self.state == State.DATA_START:\n            data, del_index, more_data = self._parse_data(self.buffer, start=True)\n            del self.buffer[:del_index]\n            event = Data(data=data, more_data=more_data)\n            if more_data:\n                self.state = State.DATA\n\n        elif self.state == State.DATA:\n            data, del_index, more_data = self._parse_data(self.buffer, start=False)\n            del self.buffer[:del_index]\n            if data or not more_data:\n                event = Data(data=data, more_data=more_data)\n\n        elif self.state == State.EPILOGUE and self.complete:\n            event = Epilogue(data=bytes(self.buffer))\n            del self.buffer[:]\n            self.state = State.COMPLETE\n\n        if self.complete and isinstance(event, NeedData):\n            raise ValueError(f\"Invalid form-data cannot parse beyond {self.state}\")\n\n        return event\n\n"
    },
    {
      "function": "conn.next_event",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/werkzeug/sansio/multipart.py",
      "line": 149,
      "caller": "test_protocol_switch",
      "source_code": "    def next_event(self) -> Event:\n        event: Event = NEED_DATA\n\n        if self.state == State.PREAMBLE:\n            match = self.preamble_re.search(self.buffer, self._search_position)\n            if match is not None:\n                if match.group(1).startswith(b\"--\"):\n                    self.state = State.EPILOGUE\n                else:\n                    self.state = State.PART\n                data = bytes(self.buffer[: match.start()])\n                del self.buffer[: match.end()]\n                event = Preamble(data=data)\n                self._search_position = 0\n            else:\n                # Update the search start position to be equal to the\n                # current buffer length (already searched) minus a\n                # safe buffer for part of the search target.\n                self._search_position = max(\n                    0, len(self.buffer) - len(self.boundary) - SEARCH_EXTRA_LENGTH\n                )\n\n        elif self.state == State.PART:\n            match = BLANK_LINE_RE.search(self.buffer, self._search_position)\n            if match is not None:\n                headers = self._parse_headers(self.buffer[: match.start()])\n                # The final header ends with a single CRLF, however a\n                # blank line indicates the start of the\n                # body. Therefore the end is after the first CRLF.\n                headers_end = (match.start() + match.end()) // 2\n                del self.buffer[:headers_end]\n\n                if \"content-disposition\" not in headers:\n                    raise ValueError(\"Missing Content-Disposition header\")\n\n                disposition, extra = parse_options_header(\n                    headers[\"content-disposition\"]\n                )\n                name = t.cast(str, extra.get(\"name\"))\n                filename = extra.get(\"filename\")\n                if filename is not None:\n                    event = File(\n                        filename=filename,\n                        headers=headers,\n                        name=name,\n                    )\n                else:\n                    event = Field(\n                        headers=headers,\n                        name=name,\n                    )\n                self.state = State.DATA_START\n                self._search_position = 0\n                self._parts_decoded += 1\n\n                if self.max_parts is not None and self._parts_decoded > self.max_parts:\n                    raise RequestEntityTooLarge()\n            else:\n                # Update the search start position to be equal to the\n                # current buffer length (already searched) minus a\n                # safe buffer for part of the search target.\n                self._search_position = max(0, len(self.buffer) - SEARCH_EXTRA_LENGTH)\n\n        elif self.state == State.DATA_START:\n            data, del_index, more_data = self._parse_data(self.buffer, start=True)\n            del self.buffer[:del_index]\n            event = Data(data=data, more_data=more_data)\n            if more_data:\n                self.state = State.DATA\n\n        elif self.state == State.DATA:\n            data, del_index, more_data = self._parse_data(self.buffer, start=False)\n            del self.buffer[:del_index]\n            if data or not more_data:\n                event = Data(data=data, more_data=more_data)\n\n        elif self.state == State.EPILOGUE and self.complete:\n            event = Epilogue(data=bytes(self.buffer))\n            del self.buffer[:]\n            self.state = State.COMPLETE\n\n        if self.complete and isinstance(event, NeedData):\n            raise ValueError(f\"Invalid form-data cannot parse beyond {self.state}\")\n\n        return event\n\n"
    },
    {
      "function": "Request",
      "filename": "",
      "line": 0,
      "caller": "test_protocol_switch",
      "source_code": ""
    },
    {
      "function": "EndOfMessage",
      "filename": "",
      "line": 0,
      "caller": "test_protocol_switch",
      "source_code": ""
    },
    {
      "function": "Request",
      "filename": "",
      "line": 0,
      "caller": "test_protocol_switch",
      "source_code": ""
    },
    {
      "function": "Data",
      "filename": "",
      "line": 0,
      "caller": "test_protocol_switch",
      "source_code": ""
    },
    {
      "function": "Data",
      "filename": "",
      "line": 0,
      "caller": "test_protocol_switch",
      "source_code": ""
    },
    {
      "function": "EndOfMessage",
      "filename": "",
      "line": 0,
      "caller": "test_protocol_switch",
      "source_code": ""
    }
  ],
  "assertions": [
    "assert sc.next_event() is PAUSED",
    "assert sc.trailing_data == (b'GET / HTTP/1.0\\r\\n\\r\\n', False)",
    "assert sc.next_event() is PAUSED",
    "assert get_all_events(sc) == [Request(method='GET', target='/', headers=[], http_version='1.0'), EndOfMessage()]",
    "assert sc.next_event() is PAUSED",
    "assert sc.trailing_data == (b'', True)",
    "assert sc.next_event() is PAUSED",
    "assert sc.next_event() is PAUSED",
    "assert sc.next_event() == ConnectionClosed()",
    "assert p.conn[SERVER].next_event() is PAUSED",
    "assert conn.states == {CLIENT: DONE, SERVER: SEND_BODY}",
    "assert conn.states == {CLIENT: SWITCHED_PROTOCOL, SERVER: SWITCHED_PROTOCOL}",
    "assert conn.next_event() is PAUSED",
    "assert conn.next_event() is PAUSED",
    "assert conn.trailing_data == (b'123456', False)",
    "assert conn.states[CLIENT] is SEND_BODY",
    "assert conn.states[CLIENT] is MIGHT_SWITCH_PROTOCOL"
  ],
  "mocks": [],
  "success": true,
  "test_source_code": "def test_protocol_switch() -> None:\n    for (req, deny, accept) in [\n        (\n            Request(\n                method=\"CONNECT\",\n                target=\"example.com:443\",\n                headers=[(\"Host\", \"foo\"), (\"Content-Length\", \"1\")],\n            ),\n            Response(status_code=404, headers=[(b\"transfer-encoding\", b\"chunked\")]),\n            Response(status_code=200, headers=[(b\"transfer-encoding\", b\"chunked\")]),\n        ),\n        (\n            Request(\n                method=\"GET\",\n                target=\"/\",\n                headers=[(\"Host\", \"foo\"), (\"Content-Length\", \"1\"), (\"Upgrade\", \"a, b\")],\n            ),\n            Response(status_code=200, headers=[(b\"transfer-encoding\", b\"chunked\")]),\n            InformationalResponse(status_code=101, headers=[(\"Upgrade\", \"a\")]),\n        ),\n        (\n            Request(\n                method=\"CONNECT\",\n                target=\"example.com:443\",\n                headers=[(\"Host\", \"foo\"), (\"Content-Length\", \"1\"), (\"Upgrade\", \"a, b\")],\n            ),\n            Response(status_code=404, headers=[(b\"transfer-encoding\", b\"chunked\")]),\n            # Accept CONNECT, not upgrade\n            Response(status_code=200, headers=[(b\"transfer-encoding\", b\"chunked\")]),\n        ),\n        (\n            Request(\n                method=\"CONNECT\",\n                target=\"example.com:443\",\n                headers=[(\"Host\", \"foo\"), (\"Content-Length\", \"1\"), (\"Upgrade\", \"a, b\")],\n            ),\n            Response(status_code=404, headers=[(b\"transfer-encoding\", b\"chunked\")]),\n            # Accept Upgrade, not CONNECT\n            InformationalResponse(status_code=101, headers=[(\"Upgrade\", \"b\")]),\n        ),\n    ]:\n\n        def setup() -> ConnectionPair:\n            p = ConnectionPair()\n            p.send(CLIENT, req)\n            # No switch-related state change stuff yet; the client has to\n            # finish the request before that kicks in\n            for conn in p.conns:\n                assert conn.states[CLIENT] is SEND_BODY\n            p.send(CLIENT, [Data(data=b\"1\"), EndOfMessage()])\n            for conn in p.conns:\n                assert conn.states[CLIENT] is MIGHT_SWITCH_PROTOCOL\n            assert p.conn[SERVER].next_event() is PAUSED\n            return p\n\n        # Test deny case\n        p = setup()\n        p.send(SERVER, deny)\n        for conn in p.conns:\n            assert conn.states == {CLIENT: DONE, SERVER: SEND_BODY}\n        p.send(SERVER, EndOfMessage())\n        # Check that re-use is still allowed after a denial\n        for conn in p.conns:\n            conn.start_next_cycle()\n\n        # Test accept case\n        p = setup()\n        p.send(SERVER, accept)\n        for conn in p.conns:\n            assert conn.states == {CLIENT: SWITCHED_PROTOCOL, SERVER: SWITCHED_PROTOCOL}\n            conn.receive_data(b\"123\")\n            assert conn.next_event() is PAUSED\n            conn.receive_data(b\"456\")\n            assert conn.next_event() is PAUSED\n            assert conn.trailing_data == (b\"123456\", False)\n\n        # Pausing in might-switch, then recovery\n        # (weird artificial case where the trailing data actually is valid\n        # HTTP for some reason, because this makes it easier to test the state\n        # logic)\n        p = setup()\n        sc = p.conn[SERVER]\n        sc.receive_data(b\"GET / HTTP/1.0\\r\\n\\r\\n\")\n        assert sc.next_event() is PAUSED\n        assert sc.trailing_data == (b\"GET / HTTP/1.0\\r\\n\\r\\n\", False)\n        sc.send(deny)\n        assert sc.next_event() is PAUSED\n        sc.send(EndOfMessage())\n        sc.start_next_cycle()\n        assert get_all_events(sc) == [\n            Request(method=\"GET\", target=\"/\", headers=[], http_version=\"1.0\"),  # type: ignore[arg-type]\n            EndOfMessage(),\n        ]\n\n        # When we're DONE, have no trailing data, and the connection gets\n        # closed, we report ConnectionClosed(). When we're in might-switch or\n        # switched, we don't.\n        p = setup()\n        sc = p.conn[SERVER]\n        sc.receive_data(b\"\")\n        assert sc.next_event() is PAUSED\n        assert sc.trailing_data == (b\"\", True)\n        p.send(SERVER, accept)\n        assert sc.next_event() is PAUSED\n\n        p = setup()\n        sc = p.conn[SERVER]\n        sc.receive_data(b\"\")\n        assert sc.next_event() is PAUSED\n        sc.send(deny)\n        assert sc.next_event() == ConnectionClosed()\n\n        # You can't send after switching protocols, or while waiting for a\n        # protocol switch\n        p = setup()\n        with pytest.raises(LocalProtocolError):\n            p.conn[CLIENT].send(\n                Request(method=\"GET\", target=\"/\", headers=[(\"Host\", \"a\")])\n            )\n        p = setup()\n        p.send(SERVER, accept)\n        with pytest.raises(LocalProtocolError):\n            p.conn[SERVER].send(Data(data=b\"123\"))"
}