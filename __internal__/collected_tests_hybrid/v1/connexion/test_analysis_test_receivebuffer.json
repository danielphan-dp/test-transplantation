{
  "test_name": "test_receivebuffer",
  "test_file": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/tests/test_receivebuffer.py",
  "static_methods": [
    {
      "name": "ReceiveBuffer",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "b.maybe_extract_lines",
      "source_code": "    def maybe_extract_lines(self) -> Optional[List[bytearray]]:\n        \"\"\"\n        Extract everything up to the first blank line, and return a list of lines.\n        \"\"\"\n        # Handle the case where we have an immediate empty line.\n        if self._data[:1] == b\"\\n\":\n            self._extract(1)\n            return []",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/_receivebuffer.py",
      "line_number": 104
    },
    {
      "name": "len",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    },
    {
      "name": "bytes",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    },
    {
      "name": "len",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    },
    {
      "name": "bytes",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    },
    {
      "name": "bytes",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    },
    {
      "name": "b.maybe_extract_at_most",
      "source_code": "    def maybe_extract_at_most(self, count: int) -> Optional[bytearray]:\n        \"\"\"\n        Extract a fixed number of bytes from the buffer.\n        \"\"\"\n        out = self._data[:count]\n        if not out:\n            return None",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/_receivebuffer.py",
      "line_number": 77
    },
    {
      "name": "len",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    },
    {
      "name": "bytes",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    },
    {
      "name": "bytes",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    },
    {
      "name": "b.maybe_extract_at_most",
      "source_code": "    def maybe_extract_at_most(self, count: int) -> Optional[bytearray]:\n        \"\"\"\n        Extract a fixed number of bytes from the buffer.\n        \"\"\"\n        out = self._data[:count]\n        if not out:\n            return None",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/_receivebuffer.py",
      "line_number": 77
    },
    {
      "name": "bytes",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    },
    {
      "name": "b.maybe_extract_at_most",
      "source_code": "    def maybe_extract_at_most(self, count: int) -> Optional[bytearray]:\n        \"\"\"\n        Extract a fixed number of bytes from the buffer.\n        \"\"\"\n        out = self._data[:count]\n        if not out:\n            return None",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/_receivebuffer.py",
      "line_number": 77
    },
    {
      "name": "b.maybe_extract_next_line",
      "source_code": "    def maybe_extract_next_line(self) -> Optional[bytearray]:\n        \"\"\"\n        Extract the first line, if it is completed in the buffer.\n        \"\"\"\n        # Only search in buffer space that we've not already looked at.\n        search_start_index = max(0, self._next_line_search - 1)\n        partial_idx = self._data.find(b\"\\r\\n\", search_start_index)",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/_receivebuffer.py",
      "line_number": 87
    },
    {
      "name": "bytes",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    },
    {
      "name": "b.maybe_extract_next_line",
      "source_code": "    def maybe_extract_next_line(self) -> Optional[bytearray]:\n        \"\"\"\n        Extract the first line, if it is completed in the buffer.\n        \"\"\"\n        # Only search in buffer space that we've not already looked at.\n        search_start_index = max(0, self._next_line_search - 1)\n        partial_idx = self._data.find(b\"\\r\\n\", search_start_index)",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/_receivebuffer.py",
      "line_number": 87
    },
    {
      "name": "bytes",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    },
    {
      "name": "b.maybe_extract_next_line",
      "source_code": "    def maybe_extract_next_line(self) -> Optional[bytearray]:\n        \"\"\"\n        Extract the first line, if it is completed in the buffer.\n        \"\"\"\n        # Only search in buffer space that we've not already looked at.\n        search_start_index = max(0, self._next_line_search - 1)\n        partial_idx = self._data.find(b\"\\r\\n\", search_start_index)",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/_receivebuffer.py",
      "line_number": 87
    },
    {
      "name": "bytes",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    },
    {
      "name": "b.maybe_extract_next_line",
      "source_code": "    def maybe_extract_next_line(self) -> Optional[bytearray]:\n        \"\"\"\n        Extract the first line, if it is completed in the buffer.\n        \"\"\"\n        # Only search in buffer space that we've not already looked at.\n        search_start_index = max(0, self._next_line_search - 1)\n        partial_idx = self._data.find(b\"\\r\\n\", search_start_index)",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/_receivebuffer.py",
      "line_number": 87
    },
    {
      "name": "bytes",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    },
    {
      "name": "b.maybe_extract_next_line",
      "source_code": "    def maybe_extract_next_line(self) -> Optional[bytearray]:\n        \"\"\"\n        Extract the first line, if it is completed in the buffer.\n        \"\"\"\n        # Only search in buffer space that we've not already looked at.\n        search_start_index = max(0, self._next_line_search - 1)\n        partial_idx = self._data.find(b\"\\r\\n\", search_start_index)",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/_receivebuffer.py",
      "line_number": 87
    },
    {
      "name": "b.maybe_extract_next_line",
      "source_code": "    def maybe_extract_next_line(self) -> Optional[bytearray]:\n        \"\"\"\n        Extract the first line, if it is completed in the buffer.\n        \"\"\"\n        # Only search in buffer space that we've not already looked at.\n        search_start_index = max(0, self._next_line_search - 1)\n        partial_idx = self._data.find(b\"\\r\\n\", search_start_index)",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/_receivebuffer.py",
      "line_number": 87
    },
    {
      "name": "b.maybe_extract_next_line",
      "source_code": "    def maybe_extract_next_line(self) -> Optional[bytearray]:\n        \"\"\"\n        Extract the first line, if it is completed in the buffer.\n        \"\"\"\n        # Only search in buffer space that we've not already looked at.\n        search_start_index = max(0, self._next_line_search - 1)\n        partial_idx = self._data.find(b\"\\r\\n\", search_start_index)",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/_receivebuffer.py",
      "line_number": 87
    },
    {
      "name": "bytes",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    },
    {
      "name": "bytes",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    },
    {
      "name": "b.maybe_extract_lines",
      "source_code": "    def maybe_extract_lines(self) -> Optional[List[bytearray]]:\n        \"\"\"\n        Extract everything up to the first blank line, and return a list of lines.\n        \"\"\"\n        # Handle the case where we have an immediate empty line.\n        if self._data[:1] == b\"\\n\":\n            self._extract(1)\n            return []",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/_receivebuffer.py",
      "line_number": 104
    },
    {
      "name": "b.maybe_extract_lines",
      "source_code": "    def maybe_extract_lines(self) -> Optional[List[bytearray]]:\n        \"\"\"\n        Extract everything up to the first blank line, and return a list of lines.\n        \"\"\"\n        # Handle the case where we have an immediate empty line.\n        if self._data[:1] == b\"\\n\":\n            self._extract(1)\n            return []",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/_receivebuffer.py",
      "line_number": 104
    },
    {
      "name": "b.maybe_extract_at_most",
      "source_code": "    def maybe_extract_at_most(self, count: int) -> Optional[bytearray]:\n        \"\"\"\n        Extract a fixed number of bytes from the buffer.\n        \"\"\"\n        out = self._data[:count]\n        if not out:\n            return None",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/_receivebuffer.py",
      "line_number": 77
    },
    {
      "name": "b.maybe_extract_lines",
      "source_code": "    def maybe_extract_lines(self) -> Optional[List[bytearray]]:\n        \"\"\"\n        Extract everything up to the first blank line, and return a list of lines.\n        \"\"\"\n        # Handle the case where we have an immediate empty line.\n        if self._data[:1] == b\"\\n\":\n            self._extract(1)\n            return []",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/_receivebuffer.py",
      "line_number": 104
    },
    {
      "name": "bytes",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    }
  ],
  "dynamic_methods": [
    {
      "function": "ReceiveBuffer",
      "filename": "",
      "line": 0,
      "caller": "test_receivebuffer",
      "source_code": ""
    },
    {
      "function": "b.maybe_extract_lines",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/_receivebuffer.py",
      "line": 104,
      "caller": "test_receivebuffer",
      "source_code": "    def maybe_extract_lines(self) -> Optional[List[bytearray]]:\n        \"\"\"\n        Extract everything up to the first blank line, and return a list of lines.\n        \"\"\"\n        # Handle the case where we have an immediate empty line.\n        if self._data[:1] == b\"\\n\":\n            self._extract(1)\n            return []\n\n        if self._data[:2] == b\"\\r\\n\":\n            self._extract(2)\n            return []\n\n        # Only search in buffer space that we've not already looked at.\n        match = blank_line_regex.search(self._data, self._multiple_lines_search)\n        if match is None:\n            self._multiple_lines_search = max(0, len(self._data) - 2)\n            return None\n\n        # Truncate the buffer and return it.\n        idx = match.span(0)[-1]\n        out = self._extract(idx)\n        lines = out.split(b\"\\n\")\n\n        for line in lines:\n            if line.endswith(b\"\\r\"):\n                del line[-1]\n\n        assert lines[-2] == lines[-1] == b\"\"\n\n        del lines[-2:]\n\n        return lines\n\n"
    },
    {
      "function": "len",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_receivebuffer",
      "source_code": ""
    },
    {
      "function": "bytes",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_receivebuffer",
      "source_code": ""
    },
    {
      "function": "len",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_receivebuffer",
      "source_code": ""
    },
    {
      "function": "bytes",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_receivebuffer",
      "source_code": ""
    },
    {
      "function": "bytes",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_receivebuffer",
      "source_code": ""
    },
    {
      "function": "b.maybe_extract_at_most",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/_receivebuffer.py",
      "line": 77,
      "caller": "test_receivebuffer",
      "source_code": "    def maybe_extract_at_most(self, count: int) -> Optional[bytearray]:\n        \"\"\"\n        Extract a fixed number of bytes from the buffer.\n        \"\"\"\n        out = self._data[:count]\n        if not out:\n            return None\n\n        return self._extract(count)\n\n"
    },
    {
      "function": "len",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_receivebuffer",
      "source_code": ""
    },
    {
      "function": "bytes",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_receivebuffer",
      "source_code": ""
    },
    {
      "function": "bytes",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_receivebuffer",
      "source_code": ""
    },
    {
      "function": "b.maybe_extract_at_most",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/_receivebuffer.py",
      "line": 77,
      "caller": "test_receivebuffer",
      "source_code": "    def maybe_extract_at_most(self, count: int) -> Optional[bytearray]:\n        \"\"\"\n        Extract a fixed number of bytes from the buffer.\n        \"\"\"\n        out = self._data[:count]\n        if not out:\n            return None\n\n        return self._extract(count)\n\n"
    },
    {
      "function": "bytes",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_receivebuffer",
      "source_code": ""
    },
    {
      "function": "b.maybe_extract_at_most",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/_receivebuffer.py",
      "line": 77,
      "caller": "test_receivebuffer",
      "source_code": "    def maybe_extract_at_most(self, count: int) -> Optional[bytearray]:\n        \"\"\"\n        Extract a fixed number of bytes from the buffer.\n        \"\"\"\n        out = self._data[:count]\n        if not out:\n            return None\n\n        return self._extract(count)\n\n"
    },
    {
      "function": "b.maybe_extract_next_line",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/_receivebuffer.py",
      "line": 87,
      "caller": "test_receivebuffer",
      "source_code": "    def maybe_extract_next_line(self) -> Optional[bytearray]:\n        \"\"\"\n        Extract the first line, if it is completed in the buffer.\n        \"\"\"\n        # Only search in buffer space that we've not already looked at.\n        search_start_index = max(0, self._next_line_search - 1)\n        partial_idx = self._data.find(b\"\\r\\n\", search_start_index)\n\n        if partial_idx == -1:\n            self._next_line_search = len(self._data)\n            return None\n\n        # + 2 is to compensate len(b\"\\r\\n\")\n        idx = partial_idx + 2\n\n        return self._extract(idx)\n\n"
    },
    {
      "function": "bytes",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_receivebuffer",
      "source_code": ""
    },
    {
      "function": "b.maybe_extract_next_line",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/_receivebuffer.py",
      "line": 87,
      "caller": "test_receivebuffer",
      "source_code": "    def maybe_extract_next_line(self) -> Optional[bytearray]:\n        \"\"\"\n        Extract the first line, if it is completed in the buffer.\n        \"\"\"\n        # Only search in buffer space that we've not already looked at.\n        search_start_index = max(0, self._next_line_search - 1)\n        partial_idx = self._data.find(b\"\\r\\n\", search_start_index)\n\n        if partial_idx == -1:\n            self._next_line_search = len(self._data)\n            return None\n\n        # + 2 is to compensate len(b\"\\r\\n\")\n        idx = partial_idx + 2\n\n        return self._extract(idx)\n\n"
    },
    {
      "function": "bytes",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_receivebuffer",
      "source_code": ""
    },
    {
      "function": "b.maybe_extract_next_line",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/_receivebuffer.py",
      "line": 87,
      "caller": "test_receivebuffer",
      "source_code": "    def maybe_extract_next_line(self) -> Optional[bytearray]:\n        \"\"\"\n        Extract the first line, if it is completed in the buffer.\n        \"\"\"\n        # Only search in buffer space that we've not already looked at.\n        search_start_index = max(0, self._next_line_search - 1)\n        partial_idx = self._data.find(b\"\\r\\n\", search_start_index)\n\n        if partial_idx == -1:\n            self._next_line_search = len(self._data)\n            return None\n\n        # + 2 is to compensate len(b\"\\r\\n\")\n        idx = partial_idx + 2\n\n        return self._extract(idx)\n\n"
    },
    {
      "function": "bytes",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_receivebuffer",
      "source_code": ""
    },
    {
      "function": "b.maybe_extract_next_line",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/_receivebuffer.py",
      "line": 87,
      "caller": "test_receivebuffer",
      "source_code": "    def maybe_extract_next_line(self) -> Optional[bytearray]:\n        \"\"\"\n        Extract the first line, if it is completed in the buffer.\n        \"\"\"\n        # Only search in buffer space that we've not already looked at.\n        search_start_index = max(0, self._next_line_search - 1)\n        partial_idx = self._data.find(b\"\\r\\n\", search_start_index)\n\n        if partial_idx == -1:\n            self._next_line_search = len(self._data)\n            return None\n\n        # + 2 is to compensate len(b\"\\r\\n\")\n        idx = partial_idx + 2\n\n        return self._extract(idx)\n\n"
    },
    {
      "function": "bytes",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_receivebuffer",
      "source_code": ""
    },
    {
      "function": "b.maybe_extract_next_line",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/_receivebuffer.py",
      "line": 87,
      "caller": "test_receivebuffer",
      "source_code": "    def maybe_extract_next_line(self) -> Optional[bytearray]:\n        \"\"\"\n        Extract the first line, if it is completed in the buffer.\n        \"\"\"\n        # Only search in buffer space that we've not already looked at.\n        search_start_index = max(0, self._next_line_search - 1)\n        partial_idx = self._data.find(b\"\\r\\n\", search_start_index)\n\n        if partial_idx == -1:\n            self._next_line_search = len(self._data)\n            return None\n\n        # + 2 is to compensate len(b\"\\r\\n\")\n        idx = partial_idx + 2\n\n        return self._extract(idx)\n\n"
    },
    {
      "function": "b.maybe_extract_next_line",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/_receivebuffer.py",
      "line": 87,
      "caller": "test_receivebuffer",
      "source_code": "    def maybe_extract_next_line(self) -> Optional[bytearray]:\n        \"\"\"\n        Extract the first line, if it is completed in the buffer.\n        \"\"\"\n        # Only search in buffer space that we've not already looked at.\n        search_start_index = max(0, self._next_line_search - 1)\n        partial_idx = self._data.find(b\"\\r\\n\", search_start_index)\n\n        if partial_idx == -1:\n            self._next_line_search = len(self._data)\n            return None\n\n        # + 2 is to compensate len(b\"\\r\\n\")\n        idx = partial_idx + 2\n\n        return self._extract(idx)\n\n"
    },
    {
      "function": "b.maybe_extract_next_line",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/_receivebuffer.py",
      "line": 87,
      "caller": "test_receivebuffer",
      "source_code": "    def maybe_extract_next_line(self) -> Optional[bytearray]:\n        \"\"\"\n        Extract the first line, if it is completed in the buffer.\n        \"\"\"\n        # Only search in buffer space that we've not already looked at.\n        search_start_index = max(0, self._next_line_search - 1)\n        partial_idx = self._data.find(b\"\\r\\n\", search_start_index)\n\n        if partial_idx == -1:\n            self._next_line_search = len(self._data)\n            return None\n\n        # + 2 is to compensate len(b\"\\r\\n\")\n        idx = partial_idx + 2\n\n        return self._extract(idx)\n\n"
    },
    {
      "function": "bytes",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_receivebuffer",
      "source_code": ""
    },
    {
      "function": "bytes",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_receivebuffer",
      "source_code": ""
    },
    {
      "function": "b.maybe_extract_lines",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/_receivebuffer.py",
      "line": 104,
      "caller": "test_receivebuffer",
      "source_code": "    def maybe_extract_lines(self) -> Optional[List[bytearray]]:\n        \"\"\"\n        Extract everything up to the first blank line, and return a list of lines.\n        \"\"\"\n        # Handle the case where we have an immediate empty line.\n        if self._data[:1] == b\"\\n\":\n            self._extract(1)\n            return []\n\n        if self._data[:2] == b\"\\r\\n\":\n            self._extract(2)\n            return []\n\n        # Only search in buffer space that we've not already looked at.\n        match = blank_line_regex.search(self._data, self._multiple_lines_search)\n        if match is None:\n            self._multiple_lines_search = max(0, len(self._data) - 2)\n            return None\n\n        # Truncate the buffer and return it.\n        idx = match.span(0)[-1]\n        out = self._extract(idx)\n        lines = out.split(b\"\\n\")\n\n        for line in lines:\n            if line.endswith(b\"\\r\"):\n                del line[-1]\n\n        assert lines[-2] == lines[-1] == b\"\"\n\n        del lines[-2:]\n\n        return lines\n\n"
    },
    {
      "function": "b.maybe_extract_lines",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/_receivebuffer.py",
      "line": 104,
      "caller": "test_receivebuffer",
      "source_code": "    def maybe_extract_lines(self) -> Optional[List[bytearray]]:\n        \"\"\"\n        Extract everything up to the first blank line, and return a list of lines.\n        \"\"\"\n        # Handle the case where we have an immediate empty line.\n        if self._data[:1] == b\"\\n\":\n            self._extract(1)\n            return []\n\n        if self._data[:2] == b\"\\r\\n\":\n            self._extract(2)\n            return []\n\n        # Only search in buffer space that we've not already looked at.\n        match = blank_line_regex.search(self._data, self._multiple_lines_search)\n        if match is None:\n            self._multiple_lines_search = max(0, len(self._data) - 2)\n            return None\n\n        # Truncate the buffer and return it.\n        idx = match.span(0)[-1]\n        out = self._extract(idx)\n        lines = out.split(b\"\\n\")\n\n        for line in lines:\n            if line.endswith(b\"\\r\"):\n                del line[-1]\n\n        assert lines[-2] == lines[-1] == b\"\"\n\n        del lines[-2:]\n\n        return lines\n\n"
    },
    {
      "function": "b.maybe_extract_at_most",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/_receivebuffer.py",
      "line": 77,
      "caller": "test_receivebuffer",
      "source_code": "    def maybe_extract_at_most(self, count: int) -> Optional[bytearray]:\n        \"\"\"\n        Extract a fixed number of bytes from the buffer.\n        \"\"\"\n        out = self._data[:count]\n        if not out:\n            return None\n\n        return self._extract(count)\n\n"
    },
    {
      "function": "b.maybe_extract_lines",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/connexion/venv/lib/python3.9/site-packages/h11/_receivebuffer.py",
      "line": 104,
      "caller": "test_receivebuffer",
      "source_code": "    def maybe_extract_lines(self) -> Optional[List[bytearray]]:\n        \"\"\"\n        Extract everything up to the first blank line, and return a list of lines.\n        \"\"\"\n        # Handle the case where we have an immediate empty line.\n        if self._data[:1] == b\"\\n\":\n            self._extract(1)\n            return []\n\n        if self._data[:2] == b\"\\r\\n\":\n            self._extract(2)\n            return []\n\n        # Only search in buffer space that we've not already looked at.\n        match = blank_line_regex.search(self._data, self._multiple_lines_search)\n        if match is None:\n            self._multiple_lines_search = max(0, len(self._data) - 2)\n            return None\n\n        # Truncate the buffer and return it.\n        idx = match.span(0)[-1]\n        out = self._extract(idx)\n        lines = out.split(b\"\\n\")\n\n        for line in lines:\n            if line.endswith(b\"\\r\"):\n                del line[-1]\n\n        assert lines[-2] == lines[-1] == b\"\"\n\n        del lines[-2:]\n\n        return lines\n\n"
    },
    {
      "function": "bytes",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_receivebuffer",
      "source_code": ""
    }
  ],
  "assertions": [
    "assert not b",
    "assert len(b) == 0",
    "assert bytes(b) == b''",
    "assert b",
    "assert len(b) == 3",
    "assert bytes(b) == b'123'",
    "assert bytes(b) == b'123'",
    "assert b.maybe_extract_at_most(2) == b'12'",
    "assert b",
    "assert len(b) == 1",
    "assert bytes(b) == b'3'",
    "assert bytes(b) == b'3'",
    "assert b.maybe_extract_at_most(10) == b'3'",
    "assert bytes(b) == b''",
    "assert b.maybe_extract_at_most(10) is None",
    "assert not b",
    "assert b.maybe_extract_next_line() == b'123\\n456\\r\\n'",
    "assert bytes(b) == b'789\\r\\n'",
    "assert b.maybe_extract_next_line() == b'789\\r\\n'",
    "assert bytes(b) == b''",
    "assert b.maybe_extract_next_line() is None",
    "assert bytes(b) == b'12\\r'",
    "assert b.maybe_extract_next_line() is None",
    "assert bytes(b) == b'12\\r345\\n\\r'",
    "assert b.maybe_extract_next_line() == b'12\\r345\\n\\r\\n'",
    "assert b.maybe_extract_next_line() == b'6789aaa123\\r\\n'",
    "assert b.maybe_extract_next_line() is None",
    "assert bytes(b) == b''",
    "assert lines == [b'123', b'a: b', b'foo:bar']",
    "assert bytes(b) == b'trailing'",
    "assert b.maybe_extract_lines() is None",
    "assert b.maybe_extract_lines() is None",
    "assert b.maybe_extract_at_most(100) == b'trailing\\r\\n\\r'",
    "assert not b",
    "assert b.maybe_extract_lines() == []",
    "assert bytes(b) == b'trailing'"
  ],
  "mocks": [],
  "success": true,
  "test_source_code": "def test_receivebuffer() -> None:\n    b = ReceiveBuffer()\n    assert not b\n    assert len(b) == 0\n    assert bytes(b) == b\"\"\n\n    b += b\"123\"\n    assert b\n    assert len(b) == 3\n    assert bytes(b) == b\"123\"\n\n    assert bytes(b) == b\"123\"\n\n    assert b.maybe_extract_at_most(2) == b\"12\"\n    assert b\n    assert len(b) == 1\n    assert bytes(b) == b\"3\"\n\n    assert bytes(b) == b\"3\"\n\n    assert b.maybe_extract_at_most(10) == b\"3\"\n    assert bytes(b) == b\"\"\n\n    assert b.maybe_extract_at_most(10) is None\n    assert not b\n\n    ################################################################\n    # maybe_extract_until_next\n    ################################################################\n\n    b += b\"123\\n456\\r\\n789\\r\\n\"\n\n    assert b.maybe_extract_next_line() == b\"123\\n456\\r\\n\"\n    assert bytes(b) == b\"789\\r\\n\"\n\n    assert b.maybe_extract_next_line() == b\"789\\r\\n\"\n    assert bytes(b) == b\"\"\n\n    b += b\"12\\r\"\n    assert b.maybe_extract_next_line() is None\n    assert bytes(b) == b\"12\\r\"\n\n    b += b\"345\\n\\r\"\n    assert b.maybe_extract_next_line() is None\n    assert bytes(b) == b\"12\\r345\\n\\r\"\n\n    # here we stopped at the middle of b\"\\r\\n\" delimiter\n\n    b += b\"\\n6789aaa123\\r\\n\"\n    assert b.maybe_extract_next_line() == b\"12\\r345\\n\\r\\n\"\n    assert b.maybe_extract_next_line() == b\"6789aaa123\\r\\n\"\n    assert b.maybe_extract_next_line() is None\n    assert bytes(b) == b\"\"\n\n    ################################################################\n    # maybe_extract_lines\n    ################################################################\n\n    b += b\"123\\r\\na: b\\r\\nfoo:bar\\r\\n\\r\\ntrailing\"\n    lines = b.maybe_extract_lines()\n    assert lines == [b\"123\", b\"a: b\", b\"foo:bar\"]\n    assert bytes(b) == b\"trailing\"\n\n    assert b.maybe_extract_lines() is None\n\n    b += b\"\\r\\n\\r\"\n    assert b.maybe_extract_lines() is None\n\n    assert b.maybe_extract_at_most(100) == b\"trailing\\r\\n\\r\"\n    assert not b\n\n    # Empty body case (as happens at the end of chunked encoding if there are\n    # no trailing headers, e.g.)\n    b += b\"\\r\\ntrailing\"\n    assert b.maybe_extract_lines() == []\n    assert bytes(b) == b\"trailing\""
}