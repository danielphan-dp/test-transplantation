{
  "test_name": "test_is_bytes_sequence_annotation_union",
  "test_file": "__internal__/_data/fastapi/tests/test_compat.py",
  "static_methods": [
    {
      "name": "is_bytes_sequence_annotation",
      "source_code": "def is_bytes_sequence_annotation(annotation: Any) -> bool:\n    origin = get_origin(annotation)\n    if origin is Union or origin is UnionType:\n        at_least_one = False\n        for arg in get_args(annotation):\n            if is_bytes_sequence_annotation(arg):\n                at_least_one = True\n                continue\n        return at_least_one\n    return field_annotation_is_sequence(annotation) and all(\n        is_bytes_or_nonable_bytes_annotation(sub_annotation)\n        for sub_annotation in get_args(annotation)\n    )",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/fastapi/fastapi/_compat.py",
      "line_number": 626
    }
  ],
  "dynamic_methods": [
    {
      "function": "is_bytes_sequence_annotation",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/fastapi/fastapi/_compat.py",
      "line": 626,
      "caller": "test_is_bytes_sequence_annotation_union",
      "source_code": "def is_bytes_sequence_annotation(annotation: Any) -> bool:\n    origin = get_origin(annotation)\n    if origin is Union or origin is UnionType:\n        at_least_one = False\n        for arg in get_args(annotation):\n            if is_bytes_sequence_annotation(arg):\n                at_least_one = True\n                continue\n        return at_least_one\n    return field_annotation_is_sequence(annotation) and all(\n        is_bytes_or_nonable_bytes_annotation(sub_annotation)\n        for sub_annotation in get_args(annotation)\n    )\n\n\n"
    }
  ],
  "assertions": [
    "assert is_bytes_sequence_annotation(Union[List[str], List[bytes]])"
  ],
  "mocks": [],
  "success": true,
  "test_source_code": "def test_is_bytes_sequence_annotation_union():\n    # For coverage\n    # TODO: in theory this would allow declaring types that could be lists of bytes\n    # to be read from files and other types, but I'm not even sure it's a good idea\n    # to support it as a first class \"feature\"\n    assert is_bytes_sequence_annotation(Union[List[str], List[bytes]])"
}