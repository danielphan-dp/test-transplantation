{
  "test_name": "test_union_scalar_list",
  "test_file": "__internal__/_data/fastapi/tests/test_compat.py",
  "static_methods": [
    {
      "name": "FieldInfo",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "ModelField",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "is_pv1_scalar_field",
      "source_code": "    def is_pv1_scalar_field(field: ModelField) -> bool:\n        from fastapi import params",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/fastapi/fastapi/_compat.py",
      "line_number": 395
    },
    {
      "name": "needs_pydanticv1",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    }
  ],
  "dynamic_methods": [
    {
      "function": "FieldInfo",
      "filename": "",
      "line": 0,
      "caller": "test_union_scalar_list",
      "source_code": ""
    },
    {
      "function": "ModelField",
      "filename": "",
      "line": 0,
      "caller": "test_union_scalar_list",
      "source_code": ""
    },
    {
      "function": "is_pv1_scalar_field",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/fastapi/fastapi/_compat.py",
      "line": 395,
      "caller": "test_union_scalar_list",
      "source_code": "    def is_pv1_scalar_field(field: ModelField) -> bool:\n        from fastapi import params\n\n        field_info = field.field_info\n        if not (\n            field.shape == SHAPE_SINGLETON  # type: ignore[attr-defined]\n            and not lenient_issubclass(field.type_, BaseModel)\n            and not lenient_issubclass(field.type_, dict)\n            and not field_annotation_is_sequence(field.type_)\n            and not is_dataclass(field.type_)\n            and not isinstance(field_info, params.Body)\n        ):\n            return False\n        if field.sub_fields:  # type: ignore[attr-defined]\n            if not all(\n                is_pv1_scalar_field(f)\n                for f in field.sub_fields  # type: ignore[attr-defined]\n            ):\n                return False\n        return True\n\n"
    },
    {
      "function": "needs_pydanticv1",
      "filename": "",
      "line": 0,
      "caller": "test_union_scalar_list",
      "source_code": ""
    }
  ],
  "assertions": [
    "assert not is_pv1_scalar_field(field)"
  ],
  "mocks": [],
  "success": true,
  "test_source_code": "def test_union_scalar_list():\n    # For coverage\n    # TODO: there might not be a current valid code path that uses this, it would\n    # potentially enable query parameters defined as both a scalar and a list\n    # but that would require more refactors, also not sure it's really useful\n    from fastapi._compat import is_pv1_scalar_field\n\n    field_info = FieldInfo()\n    field = ModelField(\n        name=\"foo\",\n        field_info=field_info,\n        type_=Union[str, List[int]],\n        class_validators={},\n        model_config=BaseConfig,\n    )\n    assert not is_pv1_scalar_field(field)"
}