{
  "test_name": "test_default_accept",
  "test_file": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/tests/test_testing.py",
  "static_methods": [
    {
      "name": "self._makeOne",
      "source_code": "    def _makeOne(self, name=None):\n        if name is None:\n            name = self.DEFAULT_NAME\n        return self._getTargetClass()(name)",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/venv/lib/python3.9/site-packages/zope/interface/tests/test_interface.py",
      "line_number": 120
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "request.accept.acceptable_offers",
      "source_code": "    def acceptable_offers(self, offers):\n        \"\"\"\n        Return the offers that are acceptable according to the header.",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/venv/lib/python3.9/site-packages/webob/acceptparse.py",
      "line_number": 844
    },
    {
      "name": "request.accept.acceptable_offers",
      "source_code": "    def acceptable_offers(self, offers):\n        \"\"\"\n        Return the offers that are acceptable according to the header.",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/venv/lib/python3.9/site-packages/webob/acceptparse.py",
      "line_number": 844
    },
    {
      "name": "request.accept.acceptable_offers",
      "source_code": "    def acceptable_offers(self, offers):\n        \"\"\"\n        Return the offers that are acceptable according to the header.",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/venv/lib/python3.9/site-packages/webob/acceptparse.py",
      "line_number": 844
    }
  ],
  "dynamic_methods": [
    {
      "function": "self._makeOne",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/venv/lib/python3.9/site-packages/zope/interface/tests/test_interface.py",
      "line": 120,
      "caller": "test_default_accept",
      "source_code": "    def _makeOne(self, name=None):\n        if name is None:\n            name = self.DEFAULT_NAME\n        return self._getTargetClass()(name)\n\n"
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_default_accept",
      "source_code": ""
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_default_accept",
      "source_code": ""
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_default_accept",
      "source_code": ""
    },
    {
      "function": "request.accept.acceptable_offers",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/venv/lib/python3.9/site-packages/webob/acceptparse.py",
      "line": 844,
      "caller": "test_default_accept",
      "source_code": "    def acceptable_offers(self, offers):\n        \"\"\"\n        Return the offers that are acceptable according to the header.\n\n        The offers are returned in descending order of preference, where\n        preference is indicated by the qvalue of the media range in the header\n        that best matches the offer.\n\n        This uses the matching rules described in :rfc:`RFC 7231, section 5.3.2\n        <7231#section-5.3.2>`.\n\n        Any offers that cannot be parsed via\n        :meth:`.Accept.parse_offer` will be ignored.\n\n        :param offers: ``iterable`` of ``str`` media types (media types can\n                       include media type parameters) or pre-parsed instances\n                       of :class:`.AcceptOffer`.\n        :return: A list of tuples of the form (media type, qvalue), in\n                 descending order of qvalue. Where two offers have the same\n                 qvalue, they are returned in the same order as their order in\n                 `offers`.\n        \"\"\"\n        parsed = self.parsed\n\n        # RFC 7231, section 3.1.1.1 \"Media Type\":\n        # \"The type, subtype, and parameter name tokens are case-insensitive.\n        # Parameter values might or might not be case-sensitive, depending on\n        # the semantics of the parameter name.\"\n        lowercased_ranges = [\n            (\n                media_range.partition(';')[0].lower(),\n                qvalue,\n                tuple(\n                    (name.lower(), value)\n                    for name, value in media_type_params\n                ),\n            )\n            for media_range, qvalue, media_type_params, __ in\n            parsed\n        ]\n        lowercased_offers_parsed = self._parse_and_normalize_offers(offers)\n\n        acceptable_offers_n_quality_factors = {}\n        for offer_index, parsed_offer in lowercased_offers_parsed:\n            offer = offers[offer_index]\n            offer_type, offer_subtype, offer_media_type_params = parsed_offer\n            for (\n                range_type_subtype, range_qvalue, range_media_type_params,\n            ) in lowercased_ranges:\n                range_type, range_subtype = range_type_subtype.split('/', 1)\n\n                # The specificity values below are based on the list in the\n                # example in RFC 7231 section 5.3.2 explaining how \"media\n                # ranges can be overridden by more specific media ranges or\n                # specific media types\". We assign specificity to the list\n                # items in reverse order, so specificity 4, 3, 2, 1 correspond\n                # to 1, 2, 3, 4 in the list, respectively (so that higher\n                # specificity has higher precedence).\n                if (\n                    offer_type == range_type\n                    and offer_subtype == range_subtype\n                ):\n                    if range_media_type_params == ():\n                        # If offer_media_type_params == () the offer and the\n                        # range match exactly, with neither having media type\n                        # parameters.\n                        # If offer_media_type_params is not (), the offer and\n                        # the range are a match. See the table towards the end\n                        # of RFC 7231 section 5.3.2, where the media type\n                        # 'text/html;level=3' matches the range 'text/html' in\n                        # the header.\n                        # Both cases are a match with a specificity of 3.\n                        specificity = 3\n                    elif offer_media_type_params == range_media_type_params:\n                        specificity = 4\n                    else:  # pragma: no cover\n                        # no cover because of\n                        # https://bitbucket.org/ned/coveragepy/issues/254/incorrect-coverage-on-continue-statement\n                        continue\n                else:\n                    if range_subtype == '*' and offer_type == range_type:\n                        specificity = 2\n                    elif range_type_subtype == '*/*':\n                        specificity = 1\n                    else:  # pragma: no cover\n                        # no cover because of\n                        # https://bitbucket.org/ned/coveragepy/issues/254/incorrect-coverage-on-continue-statement\n                        continue\n                try:\n                    if specificity <= (\n                        acceptable_offers_n_quality_factors[offer][2]\n                    ):\n                        continue\n                except KeyError:\n                    # the entry for the offer is not already in\n                    # acceptable_offers_n_quality_factors\n                    pass\n                acceptable_offers_n_quality_factors[offer] = (\n                    range_qvalue,  # qvalue of matched range\n                    offer_index,\n                    specificity,  # specifity of matched range\n                )\n\n        acceptable_offers_n_quality_factors = [\n            # key is offer, value[0] is qvalue, value[1] is offer_index\n            (key, value[0], value[1])\n            for key, value in acceptable_offers_n_quality_factors.items()\n            if value[0]  # != 0.0\n            # We have to filter out the offers with qvalues of 0 here instead\n            # of just skipping them early in the large ``for`` loop because\n            # that would not work for e.g. when the header is 'text/html;q=0,\n            # text/html' (which does not make sense, but is nonetheless valid),\n            # and offers is ['text/html']\n        ]\n        # sort by offer_index, ascending\n        acceptable_offers_n_quality_factors.sort(key=lambda tuple_: tuple_[2])\n        # (stable) sort by qvalue, descending\n        acceptable_offers_n_quality_factors.sort(\n            key=lambda tuple_: tuple_[1], reverse=True,\n        )\n        # drop offer_index\n        acceptable_offers_n_quality_factors = [\n            (item[0], item[1]) for item in acceptable_offers_n_quality_factors\n        ]\n        return acceptable_offers_n_quality_factors\n        # If a media range is repeated in the header (which would not make\n        # sense, but would be valid according to the rules in the RFC), an\n        # offer for which the media range is the most specific match would take\n        # its qvalue from the first appearance of the range in the header.\n\n"
    },
    {
      "function": "request.accept.acceptable_offers",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/venv/lib/python3.9/site-packages/webob/acceptparse.py",
      "line": 844,
      "caller": "test_default_accept",
      "source_code": "    def acceptable_offers(self, offers):\n        \"\"\"\n        Return the offers that are acceptable according to the header.\n\n        The offers are returned in descending order of preference, where\n        preference is indicated by the qvalue of the media range in the header\n        that best matches the offer.\n\n        This uses the matching rules described in :rfc:`RFC 7231, section 5.3.2\n        <7231#section-5.3.2>`.\n\n        Any offers that cannot be parsed via\n        :meth:`.Accept.parse_offer` will be ignored.\n\n        :param offers: ``iterable`` of ``str`` media types (media types can\n                       include media type parameters) or pre-parsed instances\n                       of :class:`.AcceptOffer`.\n        :return: A list of tuples of the form (media type, qvalue), in\n                 descending order of qvalue. Where two offers have the same\n                 qvalue, they are returned in the same order as their order in\n                 `offers`.\n        \"\"\"\n        parsed = self.parsed\n\n        # RFC 7231, section 3.1.1.1 \"Media Type\":\n        # \"The type, subtype, and parameter name tokens are case-insensitive.\n        # Parameter values might or might not be case-sensitive, depending on\n        # the semantics of the parameter name.\"\n        lowercased_ranges = [\n            (\n                media_range.partition(';')[0].lower(),\n                qvalue,\n                tuple(\n                    (name.lower(), value)\n                    for name, value in media_type_params\n                ),\n            )\n            for media_range, qvalue, media_type_params, __ in\n            parsed\n        ]\n        lowercased_offers_parsed = self._parse_and_normalize_offers(offers)\n\n        acceptable_offers_n_quality_factors = {}\n        for offer_index, parsed_offer in lowercased_offers_parsed:\n            offer = offers[offer_index]\n            offer_type, offer_subtype, offer_media_type_params = parsed_offer\n            for (\n                range_type_subtype, range_qvalue, range_media_type_params,\n            ) in lowercased_ranges:\n                range_type, range_subtype = range_type_subtype.split('/', 1)\n\n                # The specificity values below are based on the list in the\n                # example in RFC 7231 section 5.3.2 explaining how \"media\n                # ranges can be overridden by more specific media ranges or\n                # specific media types\". We assign specificity to the list\n                # items in reverse order, so specificity 4, 3, 2, 1 correspond\n                # to 1, 2, 3, 4 in the list, respectively (so that higher\n                # specificity has higher precedence).\n                if (\n                    offer_type == range_type\n                    and offer_subtype == range_subtype\n                ):\n                    if range_media_type_params == ():\n                        # If offer_media_type_params == () the offer and the\n                        # range match exactly, with neither having media type\n                        # parameters.\n                        # If offer_media_type_params is not (), the offer and\n                        # the range are a match. See the table towards the end\n                        # of RFC 7231 section 5.3.2, where the media type\n                        # 'text/html;level=3' matches the range 'text/html' in\n                        # the header.\n                        # Both cases are a match with a specificity of 3.\n                        specificity = 3\n                    elif offer_media_type_params == range_media_type_params:\n                        specificity = 4\n                    else:  # pragma: no cover\n                        # no cover because of\n                        # https://bitbucket.org/ned/coveragepy/issues/254/incorrect-coverage-on-continue-statement\n                        continue\n                else:\n                    if range_subtype == '*' and offer_type == range_type:\n                        specificity = 2\n                    elif range_type_subtype == '*/*':\n                        specificity = 1\n                    else:  # pragma: no cover\n                        # no cover because of\n                        # https://bitbucket.org/ned/coveragepy/issues/254/incorrect-coverage-on-continue-statement\n                        continue\n                try:\n                    if specificity <= (\n                        acceptable_offers_n_quality_factors[offer][2]\n                    ):\n                        continue\n                except KeyError:\n                    # the entry for the offer is not already in\n                    # acceptable_offers_n_quality_factors\n                    pass\n                acceptable_offers_n_quality_factors[offer] = (\n                    range_qvalue,  # qvalue of matched range\n                    offer_index,\n                    specificity,  # specifity of matched range\n                )\n\n        acceptable_offers_n_quality_factors = [\n            # key is offer, value[0] is qvalue, value[1] is offer_index\n            (key, value[0], value[1])\n            for key, value in acceptable_offers_n_quality_factors.items()\n            if value[0]  # != 0.0\n            # We have to filter out the offers with qvalues of 0 here instead\n            # of just skipping them early in the large ``for`` loop because\n            # that would not work for e.g. when the header is 'text/html;q=0,\n            # text/html' (which does not make sense, but is nonetheless valid),\n            # and offers is ['text/html']\n        ]\n        # sort by offer_index, ascending\n        acceptable_offers_n_quality_factors.sort(key=lambda tuple_: tuple_[2])\n        # (stable) sort by qvalue, descending\n        acceptable_offers_n_quality_factors.sort(\n            key=lambda tuple_: tuple_[1], reverse=True,\n        )\n        # drop offer_index\n        acceptable_offers_n_quality_factors = [\n            (item[0], item[1]) for item in acceptable_offers_n_quality_factors\n        ]\n        return acceptable_offers_n_quality_factors\n        # If a media range is repeated in the header (which would not make\n        # sense, but would be valid according to the rules in the RFC), an\n        # offer for which the media range is the most specific match would take\n        # its qvalue from the first appearance of the range in the header.\n\n"
    },
    {
      "function": "request.accept.acceptable_offers",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/pyramid/venv/lib/python3.9/site-packages/webob/acceptparse.py",
      "line": 844,
      "caller": "test_default_accept",
      "source_code": "    def acceptable_offers(self, offers):\n        \"\"\"\n        Return the offers that are acceptable according to the header.\n\n        The offers are returned in descending order of preference, where\n        preference is indicated by the qvalue of the media range in the header\n        that best matches the offer.\n\n        This uses the matching rules described in :rfc:`RFC 7231, section 5.3.2\n        <7231#section-5.3.2>`.\n\n        Any offers that cannot be parsed via\n        :meth:`.Accept.parse_offer` will be ignored.\n\n        :param offers: ``iterable`` of ``str`` media types (media types can\n                       include media type parameters) or pre-parsed instances\n                       of :class:`.AcceptOffer`.\n        :return: A list of tuples of the form (media type, qvalue), in\n                 descending order of qvalue. Where two offers have the same\n                 qvalue, they are returned in the same order as their order in\n                 `offers`.\n        \"\"\"\n        parsed = self.parsed\n\n        # RFC 7231, section 3.1.1.1 \"Media Type\":\n        # \"The type, subtype, and parameter name tokens are case-insensitive.\n        # Parameter values might or might not be case-sensitive, depending on\n        # the semantics of the parameter name.\"\n        lowercased_ranges = [\n            (\n                media_range.partition(';')[0].lower(),\n                qvalue,\n                tuple(\n                    (name.lower(), value)\n                    for name, value in media_type_params\n                ),\n            )\n            for media_range, qvalue, media_type_params, __ in\n            parsed\n        ]\n        lowercased_offers_parsed = self._parse_and_normalize_offers(offers)\n\n        acceptable_offers_n_quality_factors = {}\n        for offer_index, parsed_offer in lowercased_offers_parsed:\n            offer = offers[offer_index]\n            offer_type, offer_subtype, offer_media_type_params = parsed_offer\n            for (\n                range_type_subtype, range_qvalue, range_media_type_params,\n            ) in lowercased_ranges:\n                range_type, range_subtype = range_type_subtype.split('/', 1)\n\n                # The specificity values below are based on the list in the\n                # example in RFC 7231 section 5.3.2 explaining how \"media\n                # ranges can be overridden by more specific media ranges or\n                # specific media types\". We assign specificity to the list\n                # items in reverse order, so specificity 4, 3, 2, 1 correspond\n                # to 1, 2, 3, 4 in the list, respectively (so that higher\n                # specificity has higher precedence).\n                if (\n                    offer_type == range_type\n                    and offer_subtype == range_subtype\n                ):\n                    if range_media_type_params == ():\n                        # If offer_media_type_params == () the offer and the\n                        # range match exactly, with neither having media type\n                        # parameters.\n                        # If offer_media_type_params is not (), the offer and\n                        # the range are a match. See the table towards the end\n                        # of RFC 7231 section 5.3.2, where the media type\n                        # 'text/html;level=3' matches the range 'text/html' in\n                        # the header.\n                        # Both cases are a match with a specificity of 3.\n                        specificity = 3\n                    elif offer_media_type_params == range_media_type_params:\n                        specificity = 4\n                    else:  # pragma: no cover\n                        # no cover because of\n                        # https://bitbucket.org/ned/coveragepy/issues/254/incorrect-coverage-on-continue-statement\n                        continue\n                else:\n                    if range_subtype == '*' and offer_type == range_type:\n                        specificity = 2\n                    elif range_type_subtype == '*/*':\n                        specificity = 1\n                    else:  # pragma: no cover\n                        # no cover because of\n                        # https://bitbucket.org/ned/coveragepy/issues/254/incorrect-coverage-on-continue-statement\n                        continue\n                try:\n                    if specificity <= (\n                        acceptable_offers_n_quality_factors[offer][2]\n                    ):\n                        continue\n                except KeyError:\n                    # the entry for the offer is not already in\n                    # acceptable_offers_n_quality_factors\n                    pass\n                acceptable_offers_n_quality_factors[offer] = (\n                    range_qvalue,  # qvalue of matched range\n                    offer_index,\n                    specificity,  # specifity of matched range\n                )\n\n        acceptable_offers_n_quality_factors = [\n            # key is offer, value[0] is qvalue, value[1] is offer_index\n            (key, value[0], value[1])\n            for key, value in acceptable_offers_n_quality_factors.items()\n            if value[0]  # != 0.0\n            # We have to filter out the offers with qvalues of 0 here instead\n            # of just skipping them early in the large ``for`` loop because\n            # that would not work for e.g. when the header is 'text/html;q=0,\n            # text/html' (which does not make sense, but is nonetheless valid),\n            # and offers is ['text/html']\n        ]\n        # sort by offer_index, ascending\n        acceptable_offers_n_quality_factors.sort(key=lambda tuple_: tuple_[2])\n        # (stable) sort by qvalue, descending\n        acceptable_offers_n_quality_factors.sort(\n            key=lambda tuple_: tuple_[1], reverse=True,\n        )\n        # drop offer_index\n        acceptable_offers_n_quality_factors = [\n            (item[0], item[1]) for item in acceptable_offers_n_quality_factors\n        ]\n        return acceptable_offers_n_quality_factors\n        # If a media range is repeated in the header (which would not make\n        # sense, but would be valid according to the rules in the RFC), an\n        # offer for which the media range is the most specific match would take\n        # its qvalue from the first appearance of the range in the header.\n\n"
    }
  ],
  "assertions": [],
  "mocks": [],
  "success": false,
  "test_source_code": "def test_default_accept(self):\n        request = self._makeOne()\n        self.assertEqual(\n            request.accept.acceptable_offers(['text/html']),\n            [('text/html', 1.0)],\n        )\n\n        request.accept = 'text/plain'\n        self.assertEqual(request.accept.acceptable_offers(['text/html']), [])\n\n        del request.accept\n        self.assertEqual(\n            request.accept.acceptable_offers(['text/html']),\n            [('text/html', 1.0)],\n        )"
}