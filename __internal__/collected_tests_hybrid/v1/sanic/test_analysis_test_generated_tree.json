{
  "test_name": "test_generated_tree",
  "test_file": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/setuptools/tests/test_editable_install.py",
  "static_methods": [
    {
      "name": "_Path",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "jaraco.path.build",
      "source_code": "    def build(self, paths, tags=None, wheel_version=None):\n        \"\"\"\n        Build a wheel from files in specified paths, and use any specified tags\n        when determining the name of the wheel.\n        \"\"\"\n        if tags is None:\n            tags = {}",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/pip/_vendor/distlib/wheel.py",
      "line_number": 363
    },
    {
      "name": "_Path",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "Distribution",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "dist.parse_config_files",
      "source_code": "    def parse_config_files(\n        self,\n        filenames: Iterable[StrPath] | None = None,\n        ignore_option_errors: bool = False,\n    ) -> None:\n        \"\"\"Parses configuration files from various levels\n        and loads configuration.\n        \"\"\"\n        inifiles, tomlfiles = self._get_project_config_files(filenames)",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/setuptools/dist.py",
      "line_number": 632
    },
    {
      "name": "Mock",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "aux.mkdir",
      "source_code": "            def mkdir(self, *args, **kwargs):\n                raise OSError(\"Failed to create directory\")",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/setuptools/_distutils/tests/test_dir_util.py",
      "line_number": 123
    },
    {
      "name": "build.mkdir",
      "source_code": "            def mkdir(self, *args, **kwargs):\n                raise OSError(\"Failed to create directory\")",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/setuptools/_distutils/tests/test_dir_util.py",
      "line_number": 123
    },
    {
      "name": "dist.get_command_obj",
      "source_code": "    def get_command_obj(self, command, create=True):\n        \"\"\"Return the command object for 'command'.  Normally this object\n        is cached on a previous call to 'get_command_obj()'; if no command\n        object for 'command' is in the cache, then we either create and\n        return it (if 'create' is true) or return None.\n        \"\"\"\n        cmd_obj = self.command_obj.get(command)\n        if not cmd_obj and create:\n            if DEBUG:\n                self.announce(\n                    \"Distribution.get_command_obj(): \"\n                    f\"creating '{command}' command object\"\n                )",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/setuptools/_distutils/dist.py",
      "line_number": 832
    },
    {
      "name": "str",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    },
    {
      "name": "build_py.ensure_finalized",
      "source_code": "    def ensure_finalized(self):\n        if not self.finalized:\n            self.finalize_options()\n        self.finalized = True",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/setuptools/_distutils/cmd.py",
      "line_number": 109
    },
    {
      "name": "build_py.get_outputs",
      "source_code": "def get_outputs(build_py):\n    build_dir = Path(build_py.build_lib)\n    return {\n        os.path.relpath(x, build_dir).replace(os.sep, \"/\")\n        for x in build_py.get_outputs()\n    }",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/setuptools/tests/test_build_py.py",
      "line_number": 475
    },
    {
      "name": "build_py.get_output_mapping",
      "source_code": "    def get_output_mapping(self) -> dict[str, str]:\n        \"\"\"\n        Return a mapping between destination files as they would be produced by the\n        build (dict keys) into the respective existing (source) files (dict values).\n        Existing (source) files should be represented as strings relative to the project\n        root directory.\n        Destination files should be strings in the form of\n        ``\"{build_lib}/destination/file/path\"``.\n        \"\"\"\n        ...",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/setuptools/command/build.py",
      "line_number": 126
    },
    {
      "name": "_LinkTree",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "make_tree",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "next",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    },
    {
      "name": "assert_link_to",
      "source_code": "def assert_link_to(file: Path, other: Path) -> None:\n    if file.is_symlink():\n        assert str(file.resolve()) == str(other.resolve())\n    else:\n        file_stat = file.stat()\n        other_stat = other.stat()\n        assert file_stat[stat.ST_INO] == other_stat[stat.ST_INO]\n        assert file_stat[stat.ST_DEV] == other_stat[stat.ST_DEV]",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/setuptools/tests/test_editable_install.py",
      "line_number": 1278
    },
    {
      "name": "aux.glob",
      "source_code": "def glob(pathname: AnyStr, recursive: bool = False) -> list[AnyStr]:\n    \"\"\"Return a list of paths matching a pathname pattern.",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/setuptools/glob.py",
      "line_number": 23
    },
    {
      "name": "next",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    },
    {
      "name": "next",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    },
    {
      "name": "next",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    },
    {
      "name": "next",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    },
    {
      "name": "aux.glob",
      "source_code": "def glob(pathname: AnyStr, recursive: bool = False) -> list[AnyStr]:\n    \"\"\"Return a list of paths matching a pathname pattern.",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/setuptools/glob.py",
      "line_number": 23
    },
    {
      "name": "aux.glob",
      "source_code": "def glob(pathname: AnyStr, recursive: bool = False) -> list[AnyStr]:\n    \"\"\"Return a list of paths matching a pathname pattern.",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/setuptools/glob.py",
      "line_number": 23
    },
    {
      "name": "aux.glob",
      "source_code": "def glob(pathname: AnyStr, recursive: bool = False) -> list[AnyStr]:\n    \"\"\"Return a list of paths matching a pathname pattern.",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/setuptools/glob.py",
      "line_number": 23
    },
    {
      "name": "aux.glob",
      "source_code": "def glob(pathname: AnyStr, recursive: bool = False) -> list[AnyStr]:\n    \"\"\"Return a list of paths matching a pathname pattern.",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/setuptools/glob.py",
      "line_number": 23
    }
  ],
  "dynamic_methods": [
    {
      "function": "_Path",
      "filename": "",
      "line": 0,
      "caller": "test_generated_tree",
      "source_code": ""
    },
    {
      "function": "jaraco.path.build",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/pip/_vendor/distlib/wheel.py",
      "line": 363,
      "caller": "test_generated_tree",
      "source_code": "    def build(self, paths, tags=None, wheel_version=None):\n        \"\"\"\n        Build a wheel from files in specified paths, and use any specified tags\n        when determining the name of the wheel.\n        \"\"\"\n        if tags is None:\n            tags = {}\n\n        libkey = list(filter(lambda o: o in paths, ('purelib', 'platlib')))[0]\n        if libkey == 'platlib':\n            is_pure = 'false'\n            default_pyver = [IMPVER]\n            default_abi = [ABI]\n            default_arch = [ARCH]\n        else:\n            is_pure = 'true'\n            default_pyver = [PYVER]\n            default_abi = ['none']\n            default_arch = ['any']\n\n        self.pyver = tags.get('pyver', default_pyver)\n        self.abi = tags.get('abi', default_abi)\n        self.arch = tags.get('arch', default_arch)\n\n        libdir = paths[libkey]\n\n        name_ver = '%s-%s' % (self.name, self.version)\n        data_dir = '%s.data' % name_ver\n        info_dir = '%s.dist-info' % name_ver\n\n        archive_paths = []\n\n        # First, stuff which is not in site-packages\n        for key in ('data', 'headers', 'scripts'):\n            if key not in paths:\n                continue\n            path = paths[key]\n            if os.path.isdir(path):\n                for root, dirs, files in os.walk(path):\n                    for fn in files:\n                        p = fsdecode(os.path.join(root, fn))\n                        rp = os.path.relpath(p, path)\n                        ap = to_posix(os.path.join(data_dir, key, rp))\n                        archive_paths.append((ap, p))\n                        if key == 'scripts' and not p.endswith('.exe'):\n                            with open(p, 'rb') as f:\n                                data = f.read()\n                            data = self.process_shebang(data)\n                            with open(p, 'wb') as f:\n                                f.write(data)\n\n        # Now, stuff which is in site-packages, other than the\n        # distinfo stuff.\n        path = libdir\n        distinfo = None\n        for root, dirs, files in os.walk(path):\n            if root == path:\n                # At the top level only, save distinfo for later\n                # and skip it for now\n                for i, dn in enumerate(dirs):\n                    dn = fsdecode(dn)\n                    if dn.endswith('.dist-info'):\n                        distinfo = os.path.join(root, dn)\n                        del dirs[i]\n                        break\n                assert distinfo, '.dist-info directory expected, not found'\n\n            for fn in files:\n                # comment out next suite to leave .pyc files in\n                if fsdecode(fn).endswith(('.pyc', '.pyo')):\n                    continue\n                p = os.path.join(root, fn)\n                rp = to_posix(os.path.relpath(p, path))\n                archive_paths.append((rp, p))\n\n        # Now distinfo. Assumed to be flat, i.e. os.listdir is enough.\n        files = os.listdir(distinfo)\n        for fn in files:\n            if fn not in ('RECORD', 'INSTALLER', 'SHARED', 'WHEEL'):\n                p = fsdecode(os.path.join(distinfo, fn))\n                ap = to_posix(os.path.join(info_dir, fn))\n                archive_paths.append((ap, p))\n\n        wheel_metadata = [\n            'Wheel-Version: %d.%d' % (wheel_version or self.wheel_version),\n            'Generator: distlib %s' % __version__,\n            'Root-Is-Purelib: %s' % is_pure,\n        ]\n        for pyver, abi, arch in self.tags:\n            wheel_metadata.append('Tag: %s-%s-%s' % (pyver, abi, arch))\n        p = os.path.join(distinfo, 'WHEEL')\n        with open(p, 'w') as f:\n            f.write('\\n'.join(wheel_metadata))\n        ap = to_posix(os.path.join(info_dir, 'WHEEL'))\n        archive_paths.append((ap, p))\n\n        # sort the entries by archive path. Not needed by any spec, but it\n        # keeps the archive listing and RECORD tidier than they would otherwise\n        # be. Use the number of path segments to keep directory entries together,\n        # and keep the dist-info stuff at the end.\n        def sorter(t):\n            ap = t[0]\n            n = ap.count('/')\n            if '.dist-info' in ap:\n                n += 10000\n            return (n, ap)\n        archive_paths = sorted(archive_paths, key=sorter)\n\n        # Now, at last, RECORD.\n        # Paths in here are archive paths - nothing else makes sense.\n        self.write_records((distinfo, info_dir), libdir, archive_paths)\n        # Now, ready to build the zip file\n        pathname = os.path.join(self.dirname, self.filename)\n        self.build_zip(pathname, archive_paths)\n        return pathname\n\n"
    },
    {
      "function": "_Path",
      "filename": "",
      "line": 0,
      "caller": "test_generated_tree",
      "source_code": ""
    },
    {
      "function": "Distribution",
      "filename": "",
      "line": 0,
      "caller": "test_generated_tree",
      "source_code": ""
    },
    {
      "function": "dist.parse_config_files",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/setuptools/dist.py",
      "line": 632,
      "caller": "test_generated_tree",
      "source_code": "    def parse_config_files(\n        self,\n        filenames: Iterable[StrPath] | None = None,\n        ignore_option_errors: bool = False,\n"
    },
    {
      "function": "Mock",
      "filename": "",
      "line": 0,
      "caller": "test_generated_tree",
      "source_code": ""
    },
    {
      "function": "aux.mkdir",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/setuptools/_distutils/tests/test_dir_util.py",
      "line": 123,
      "caller": "test_generated_tree",
      "source_code": "            def mkdir(self, *args, **kwargs):\n                raise OSError(\"Failed to create directory\")\n\n"
    },
    {
      "function": "build.mkdir",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/setuptools/_distutils/tests/test_dir_util.py",
      "line": 123,
      "caller": "test_generated_tree",
      "source_code": "            def mkdir(self, *args, **kwargs):\n                raise OSError(\"Failed to create directory\")\n\n"
    },
    {
      "function": "dist.get_command_obj",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/setuptools/_distutils/dist.py",
      "line": 832,
      "caller": "test_generated_tree",
      "source_code": "    def get_command_obj(self, command, create=True):\n        \"\"\"Return the command object for 'command'.  Normally this object\n        is cached on a previous call to 'get_command_obj()'; if no command\n        object for 'command' is in the cache, then we either create and\n        return it (if 'create' is true) or return None.\n        \"\"\"\n        cmd_obj = self.command_obj.get(command)\n        if not cmd_obj and create:\n            if DEBUG:\n                self.announce(\n                    \"Distribution.get_command_obj(): \"\n                    f\"creating '{command}' command object\"\n                )\n\n            klass = self.get_command_class(command)\n            cmd_obj = self.command_obj[command] = klass(self)\n            self.have_run[command] = False\n\n            # Set any options that were supplied in config files\n            # or on the command line.  (NB. support for error\n            # reporting is lame here: any errors aren't reported\n            # until 'finalize_options()' is called, which means\n            # we won't report the source of the error.)\n            options = self.command_options.get(command)\n            if options:\n                self._set_command_options(cmd_obj, options)\n\n        return cmd_obj\n\n"
    },
    {
      "function": "str",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_generated_tree",
      "source_code": ""
    },
    {
      "function": "build_py.ensure_finalized",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/setuptools/_distutils/cmd.py",
      "line": 109,
      "caller": "test_generated_tree",
      "source_code": "    def ensure_finalized(self):\n        if not self.finalized:\n            self.finalize_options()\n        self.finalized = True\n\n"
    },
    {
      "function": "build_py.get_outputs",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/setuptools/tests/test_build_py.py",
      "line": 475,
      "caller": "test_generated_tree",
      "source_code": "def get_outputs(build_py):\n    build_dir = Path(build_py.build_lib)\n    return {\n        os.path.relpath(x, build_dir).replace(os.sep, \"/\")\n        for x in build_py.get_outputs()\n    }\n"
    },
    {
      "function": "build_py.get_output_mapping",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/setuptools/command/build.py",
      "line": 126,
      "caller": "test_generated_tree",
      "source_code": "    def get_output_mapping(self) -> dict[str, str]:\n        \"\"\"\n        Return a mapping between destination files as they would be produced by the\n        build (dict keys) into the respective existing (source) files (dict values).\n        Existing (source) files should be represented as strings relative to the project\n        root directory.\n        Destination files should be strings in the form of\n        ``\"{build_lib}/destination/file/path\"``.\n        \"\"\"\n        ...\n"
    },
    {
      "function": "_LinkTree",
      "filename": "",
      "line": 0,
      "caller": "test_generated_tree",
      "source_code": ""
    },
    {
      "function": "make_tree",
      "filename": "",
      "line": 0,
      "caller": "test_generated_tree",
      "source_code": ""
    },
    {
      "function": "next",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_generated_tree",
      "source_code": ""
    },
    {
      "function": "assert_link_to",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/setuptools/tests/test_editable_install.py",
      "line": 1278,
      "caller": "test_generated_tree",
      "source_code": "def assert_link_to(file: Path, other: Path) -> None:\n    if file.is_symlink():\n        assert str(file.resolve()) == str(other.resolve())\n    else:\n        file_stat = file.stat()\n        other_stat = other.stat()\n        assert file_stat[stat.ST_INO] == other_stat[stat.ST_INO]\n        assert file_stat[stat.ST_DEV] == other_stat[stat.ST_DEV]\n\n\n"
    },
    {
      "function": "aux.glob",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/setuptools/glob.py",
      "line": 23,
      "caller": "test_generated_tree",
      "source_code": "def glob(pathname: AnyStr, recursive: bool = False) -> list[AnyStr]:\n    \"\"\"Return a list of paths matching a pathname pattern.\n\n    The pattern may contain simple shell-style wildcards a la\n    fnmatch. However, unlike fnmatch, filenames starting with a\n    dot are special cases that are not matched by '*' and '?'\n    patterns.\n\n    If recursive is true, the pattern '**' will match any files and\n    zero or more directories and subdirectories.\n    \"\"\"\n    return list(iglob(pathname, recursive=recursive))\n\n\n"
    },
    {
      "function": "next",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_generated_tree",
      "source_code": ""
    },
    {
      "function": "next",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_generated_tree",
      "source_code": ""
    },
    {
      "function": "next",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_generated_tree",
      "source_code": ""
    },
    {
      "function": "next",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_generated_tree",
      "source_code": ""
    },
    {
      "function": "aux.glob",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/setuptools/glob.py",
      "line": 23,
      "caller": "test_generated_tree",
      "source_code": "def glob(pathname: AnyStr, recursive: bool = False) -> list[AnyStr]:\n    \"\"\"Return a list of paths matching a pathname pattern.\n\n    The pattern may contain simple shell-style wildcards a la\n    fnmatch. However, unlike fnmatch, filenames starting with a\n    dot are special cases that are not matched by '*' and '?'\n    patterns.\n\n    If recursive is true, the pattern '**' will match any files and\n    zero or more directories and subdirectories.\n    \"\"\"\n    return list(iglob(pathname, recursive=recursive))\n\n\n"
    },
    {
      "function": "aux.glob",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/setuptools/glob.py",
      "line": 23,
      "caller": "test_generated_tree",
      "source_code": "def glob(pathname: AnyStr, recursive: bool = False) -> list[AnyStr]:\n    \"\"\"Return a list of paths matching a pathname pattern.\n\n    The pattern may contain simple shell-style wildcards a la\n    fnmatch. However, unlike fnmatch, filenames starting with a\n    dot are special cases that are not matched by '*' and '?'\n    patterns.\n\n    If recursive is true, the pattern '**' will match any files and\n    zero or more directories and subdirectories.\n    \"\"\"\n    return list(iglob(pathname, recursive=recursive))\n\n\n"
    },
    {
      "function": "aux.glob",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/setuptools/glob.py",
      "line": 23,
      "caller": "test_generated_tree",
      "source_code": "def glob(pathname: AnyStr, recursive: bool = False) -> list[AnyStr]:\n    \"\"\"Return a list of paths matching a pathname pattern.\n\n    The pattern may contain simple shell-style wildcards a la\n    fnmatch. However, unlike fnmatch, filenames starting with a\n    dot are special cases that are not matched by '*' and '?'\n    patterns.\n\n    If recursive is true, the pattern '**' will match any files and\n    zero or more directories and subdirectories.\n    \"\"\"\n    return list(iglob(pathname, recursive=recursive))\n\n\n"
    },
    {
      "function": "aux.glob",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/sanic/venv/lib/python3.9/site-packages/setuptools/glob.py",
      "line": 23,
      "caller": "test_generated_tree",
      "source_code": "def glob(pathname: AnyStr, recursive: bool = False) -> list[AnyStr]:\n    \"\"\"Return a list of paths matching a pathname pattern.\n\n    The pattern may contain simple shell-style wildcards a la\n    fnmatch. However, unlike fnmatch, filenames starting with a\n    dot are special cases that are not matched by '*' and '?'\n    patterns.\n\n    If recursive is true, the pattern '**' will match any files and\n    zero or more directories and subdirectories.\n    \"\"\"\n    return list(iglob(pathname, recursive=recursive))\n\n\n"
    }
  ],
  "assertions": [
    "assert next(aux.glob('**/subpackage'), None) is None",
    "assert next(aux.glob('**/mod2.py'), None) is None",
    "assert next(aux.glob('**/resource_file.txt'), None) is None",
    "assert next(aux.glob('**/resource.not_in_manifest'), None) is None",
    "assert_link_to(mod1, expected)"
  ],
  "mocks": [],
  "success": false,
  "test_source_code": "def test_generated_tree(self, tmp_path):\n        jaraco.path.build(self.FILES, prefix=tmp_path)\n\n        with _Path(tmp_path):\n            name = \"mypkg-3.14159\"\n            dist = Distribution({\"script_name\": \"%PEP 517%\"})\n            dist.parse_config_files()\n\n            wheel = Mock()\n            aux = tmp_path / \".aux\"\n            build = tmp_path / \".build\"\n            aux.mkdir()\n            build.mkdir()\n\n            build_py = dist.get_command_obj(\"build_py\")\n            build_py.editable_mode = True\n            build_py.build_lib = str(build)\n            build_py.ensure_finalized()\n            outputs = build_py.get_outputs()\n            output_mapping = build_py.get_output_mapping()\n\n            make_tree = _LinkTree(dist, name, aux, build)\n            make_tree(wheel, outputs, output_mapping)\n\n            mod1 = next(aux.glob(\"**/mod1.py\"))\n            expected = tmp_path / \"src/mypkg/mod1.py\"\n            assert_link_to(mod1, expected)\n\n            assert next(aux.glob(\"**/subpackage\"), None) is None\n            assert next(aux.glob(\"**/mod2.py\"), None) is None\n            assert next(aux.glob(\"**/resource_file.txt\"), None) is None\n\n            assert next(aux.glob(\"**/resource.not_in_manifest\"), None) is None"
}