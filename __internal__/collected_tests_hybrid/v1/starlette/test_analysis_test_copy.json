{
  "test_name": "test_copy",
  "test_file": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/regex/test_regex.py",
  "static_methods": [
    {
      "name": "regex.compile",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    },
    {
      "name": "self.assertTrue",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "self.assertTrue",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "r.match",
      "source_code": "    def match(self, regexp: str | Pattern[str]) -> Literal[True]:\n        \"\"\"Check whether the regular expression `regexp` matches the string\n        representation of the exception using :func:`python:re.search`.",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/_pytest/_code/code.py",
      "line_number": 711
    },
    {
      "name": "self.assertTrue",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "self.assertTrue",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "self.assertTrue",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "m2.detach_string",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "self.assertTrue",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "self.assertTrue",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "regex.finditer",
      "source_code": "def finditer(pattern, string, flags=0, pos=None, endpos=None, overlapped=False,",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/regex/regex.py",
      "line_number": 340
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "regex.finditer",
      "source_code": "def finditer(pattern, string, flags=0, pos=None, endpos=None, overlapped=False,",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/regex/regex.py",
      "line_number": 340
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "regex.splititer",
      "source_code": "def splititer(pattern, string, maxsplit=0, flags=0, concurrent=None,",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/regex/regex.py",
      "line_number": 325
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "regex.splititer",
      "source_code": "def splititer(pattern, string, maxsplit=0, flags=0, concurrent=None,",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/regex/regex.py",
      "line_number": 325
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "next.group",
      "source_code": "    def group(self):\n        \"\"\"Return group name of file.\"\"\"\n        if iswin32:\n            raise NotImplementedError(\"XXX win32\")\n        import grp",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/_pytest/_py/path.py",
      "line_number": 229
    },
    {
      "name": "next.group",
      "source_code": "    def group(self):\n        \"\"\"Return group name of file.\"\"\"\n        if iswin32:\n            raise NotImplementedError(\"XXX win32\")\n        import grp",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/_pytest/_py/path.py",
      "line_number": 229
    },
    {
      "name": "next.group",
      "source_code": "    def group(self):\n        \"\"\"Return group name of file.\"\"\"\n        if iswin32:\n            raise NotImplementedError(\"XXX win32\")\n        import grp",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/_pytest/_py/path.py",
      "line_number": 229
    },
    {
      "name": "next.group",
      "source_code": "    def group(self):\n        \"\"\"Return group name of file.\"\"\"\n        if iswin32:\n            raise NotImplementedError(\"XXX win32\")\n        import grp",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/_pytest/_py/path.py",
      "line_number": 229
    },
    {
      "name": "next",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    },
    {
      "name": "next",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    },
    {
      "name": "next",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    },
    {
      "name": "next",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    },
    {
      "name": "next",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    },
    {
      "name": "next",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    },
    {
      "name": "next",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    },
    {
      "name": "next",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    }
  ],
  "dynamic_methods": [
    {
      "function": "regex.compile",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_copy",
      "source_code": ""
    },
    {
      "function": "self.assertTrue",
      "filename": "",
      "line": 0,
      "caller": "test_copy",
      "source_code": ""
    },
    {
      "function": "self.assertTrue",
      "filename": "",
      "line": 0,
      "caller": "test_copy",
      "source_code": ""
    },
    {
      "function": "r.match",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/_pytest/_code/code.py",
      "line": 711,
      "caller": "test_copy",
      "source_code": "    def match(self, regexp: str | Pattern[str]) -> Literal[True]:\n        \"\"\"Check whether the regular expression `regexp` matches the string\n        representation of the exception using :func:`python:re.search`.\n\n        If it matches `True` is returned, otherwise an `AssertionError` is raised.\n        \"\"\"\n        __tracebackhide__ = True\n        value = self._stringify_exception(self.value)\n        msg = f\"Regex pattern did not match.\\n Regex: {regexp!r}\\n Input: {value!r}\"\n        if regexp == value:\n            msg += \"\\n Did you mean to `re.escape()` the regex?\"\n        assert re.search(regexp, value), msg\n        # Return True to allow for \"assert excinfo.match()\".\n        return True\n\n"
    },
    {
      "function": "self.assertTrue",
      "filename": "",
      "line": 0,
      "caller": "test_copy",
      "source_code": ""
    },
    {
      "function": "self.assertTrue",
      "filename": "",
      "line": 0,
      "caller": "test_copy",
      "source_code": ""
    },
    {
      "function": "self.assertTrue",
      "filename": "",
      "line": 0,
      "caller": "test_copy",
      "source_code": ""
    },
    {
      "function": "m2.detach_string",
      "filename": "",
      "line": 0,
      "caller": "test_copy",
      "source_code": ""
    },
    {
      "function": "self.assertTrue",
      "filename": "",
      "line": 0,
      "caller": "test_copy",
      "source_code": ""
    },
    {
      "function": "self.assertTrue",
      "filename": "",
      "line": 0,
      "caller": "test_copy",
      "source_code": ""
    },
    {
      "function": "regex.finditer",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/regex/regex.py",
      "line": 340,
      "caller": "test_copy",
      "source_code": "def finditer(pattern, string, flags=0, pos=None, endpos=None, overlapped=False,\n  partial=False, concurrent=None, timeout=None, ignore_unused=False, **kwargs):\n    \"\"\"Return an iterator over all matches in the string. The matches may be\n    overlapped if overlapped is True. For each match, the iterator returns a\n    match object. Empty matches are included in the result.\"\"\"\n    pat = _compile(pattern, flags, ignore_unused, kwargs, True)\n    return pat.finditer(string, pos, endpos, overlapped, concurrent, partial,\n      timeout)\n\n"
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_copy",
      "source_code": ""
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_copy",
      "source_code": ""
    },
    {
      "function": "regex.finditer",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/regex/regex.py",
      "line": 340,
      "caller": "test_copy",
      "source_code": "def finditer(pattern, string, flags=0, pos=None, endpos=None, overlapped=False,\n  partial=False, concurrent=None, timeout=None, ignore_unused=False, **kwargs):\n    \"\"\"Return an iterator over all matches in the string. The matches may be\n    overlapped if overlapped is True. For each match, the iterator returns a\n    match object. Empty matches are included in the result.\"\"\"\n    pat = _compile(pattern, flags, ignore_unused, kwargs, True)\n    return pat.finditer(string, pos, endpos, overlapped, concurrent, partial,\n      timeout)\n\n"
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_copy",
      "source_code": ""
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_copy",
      "source_code": ""
    },
    {
      "function": "regex.splititer",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/regex/regex.py",
      "line": 325,
      "caller": "test_copy",
      "source_code": "def splititer(pattern, string, maxsplit=0, flags=0, concurrent=None,\n  timeout=None, ignore_unused=False, **kwargs):\n    \"Return an iterator yielding the parts of a split string.\"\n    pat = _compile(pattern, flags, ignore_unused, kwargs, True)\n    return pat.splititer(string, maxsplit, concurrent, timeout)\n\n"
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_copy",
      "source_code": ""
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_copy",
      "source_code": ""
    },
    {
      "function": "regex.splititer",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/regex/regex.py",
      "line": 325,
      "caller": "test_copy",
      "source_code": "def splititer(pattern, string, maxsplit=0, flags=0, concurrent=None,\n  timeout=None, ignore_unused=False, **kwargs):\n    \"Return an iterator yielding the parts of a split string.\"\n    pat = _compile(pattern, flags, ignore_unused, kwargs, True)\n    return pat.splititer(string, maxsplit, concurrent, timeout)\n\n"
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_copy",
      "source_code": ""
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_copy",
      "source_code": ""
    },
    {
      "function": "next.group",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/_pytest/_py/path.py",
      "line": 229,
      "caller": "test_copy",
      "source_code": "    @property\n    def group(self):\n        \"\"\"Return group name of file.\"\"\"\n        if iswin32:\n            raise NotImplementedError(\"XXX win32\")\n        import grp\n\n        entry = error.checked_call(grp.getgrgid, self.gid)  # type:ignore[attr-defined,unused-ignore]\n        return entry[0]\n\n"
    },
    {
      "function": "next.group",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/_pytest/_py/path.py",
      "line": 229,
      "caller": "test_copy",
      "source_code": "    @property\n    def group(self):\n        \"\"\"Return group name of file.\"\"\"\n        if iswin32:\n            raise NotImplementedError(\"XXX win32\")\n        import grp\n\n        entry = error.checked_call(grp.getgrgid, self.gid)  # type:ignore[attr-defined,unused-ignore]\n        return entry[0]\n\n"
    },
    {
      "function": "next.group",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/_pytest/_py/path.py",
      "line": 229,
      "caller": "test_copy",
      "source_code": "    @property\n    def group(self):\n        \"\"\"Return group name of file.\"\"\"\n        if iswin32:\n            raise NotImplementedError(\"XXX win32\")\n        import grp\n\n        entry = error.checked_call(grp.getgrgid, self.gid)  # type:ignore[attr-defined,unused-ignore]\n        return entry[0]\n\n"
    },
    {
      "function": "next.group",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/_pytest/_py/path.py",
      "line": 229,
      "caller": "test_copy",
      "source_code": "    @property\n    def group(self):\n        \"\"\"Return group name of file.\"\"\"\n        if iswin32:\n            raise NotImplementedError(\"XXX win32\")\n        import grp\n\n        entry = error.checked_call(grp.getgrgid, self.gid)  # type:ignore[attr-defined,unused-ignore]\n        return entry[0]\n\n"
    },
    {
      "function": "next",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_copy",
      "source_code": ""
    },
    {
      "function": "next",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_copy",
      "source_code": ""
    },
    {
      "function": "next",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_copy",
      "source_code": ""
    },
    {
      "function": "next",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_copy",
      "source_code": ""
    },
    {
      "function": "next",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_copy",
      "source_code": ""
    },
    {
      "function": "next",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_copy",
      "source_code": ""
    },
    {
      "function": "next",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_copy",
      "source_code": ""
    },
    {
      "function": "next",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_copy",
      "source_code": ""
    }
  ],
  "assertions": [],
  "mocks": [],
  "success": false,
  "test_source_code": "def test_copy(self):\n        # PatternObjects are immutable, therefore there's no need to clone them.\n        r = regex.compile(\"a\")\n        self.assertTrue(copy.copy(r) is r)\n        self.assertTrue(copy.deepcopy(r) is r)\n\n        # MatchObjects are normally mutable because the target string can be\n        # detached. However, after the target string has been detached, a\n        # MatchObject becomes immutable, so there's no need to clone it.\n        m = r.match(\"a\")\n        self.assertTrue(copy.copy(m) is not m)\n        self.assertTrue(copy.deepcopy(m) is not m)\n\n        self.assertTrue(m.string is not None)\n        m2 = copy.copy(m)\n        m2.detach_string()\n        self.assertTrue(m.string is not None)\n        self.assertTrue(m2.string is None)\n\n        # The following behaviour matches that of the re module.\n        it = regex.finditer(\".\", \"ab\")\n        it2 = copy.copy(it)\n        self.assertEqual(next(it).group(), \"a\")\n        self.assertEqual(next(it2).group(), \"b\")\n\n        # The following behaviour matches that of the re module.\n        it = regex.finditer(\".\", \"ab\")\n        it2 = copy.deepcopy(it)\n        self.assertEqual(next(it).group(), \"a\")\n        self.assertEqual(next(it2).group(), \"b\")\n\n        # The following behaviour is designed to match that of copying 'finditer'.\n        it = regex.splititer(\" \", \"a b\")\n        it2 = copy.copy(it)\n        self.assertEqual(next(it), \"a\")\n        self.assertEqual(next(it2), \"b\")\n\n        # The following behaviour is designed to match that of copying 'finditer'.\n        it = regex.splititer(\" \", \"a b\")\n        it2 = copy.deepcopy(it)\n        self.assertEqual(next(it), \"a\")\n        self.assertEqual(next(it2), \"b\")"
}