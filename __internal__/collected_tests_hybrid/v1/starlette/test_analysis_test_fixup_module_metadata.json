{
  "test_name": "test_fixup_module_metadata",
  "test_file": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/trio/_tests/test_util.py",
  "static_methods": [
    {
      "name": "fixup_module_metadata",
      "source_code": "def fixup_module_metadata(\n    module_name: str, namespace: collections.abc.Mapping[str, object]",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/trio/_util.py",
      "line_number": 255
    },
    {
      "name": "type",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    },
    {
      "name": "fixup_module_metadata",
      "source_code": "def fixup_module_metadata(\n    module_name: str, namespace: collections.abc.Mapping[str, object]",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/trio/_util.py",
      "line_number": 255
    },
    {
      "name": "non_trio_module.some_func",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "mod.some_func",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "mod._private",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "mod.SomeClass.method",
      "source_code": "    def method(self) -> int:\n        return 7",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/trio/_tests/test_deprecate.py",
      "line_number": 111
    },
    {
      "name": "vars",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    },
    {
      "name": "vars",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    },
    {
      "name": "hasattr",
      "source_code": "",
      "file_path": "<built-in>",
      "line_number": 0
    },
    {
      "name": "mod.SomeClass",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    }
  ],
  "dynamic_methods": [
    {
      "function": "fixup_module_metadata",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/trio/_util.py",
      "line": 255,
      "caller": "test_fixup_module_metadata",
      "source_code": "def fixup_module_metadata(\n    module_name: str, namespace: collections.abc.Mapping[str, object]\n"
    },
    {
      "function": "type",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_fixup_module_metadata",
      "source_code": ""
    },
    {
      "function": "fixup_module_metadata",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/trio/_util.py",
      "line": 255,
      "caller": "test_fixup_module_metadata",
      "source_code": "def fixup_module_metadata(\n    module_name: str, namespace: collections.abc.Mapping[str, object]\n"
    },
    {
      "function": "non_trio_module.some_func",
      "filename": "",
      "line": 0,
      "caller": "test_fixup_module_metadata",
      "source_code": ""
    },
    {
      "function": "mod.some_func",
      "filename": "",
      "line": 0,
      "caller": "test_fixup_module_metadata",
      "source_code": ""
    },
    {
      "function": "mod._private",
      "filename": "",
      "line": 0,
      "caller": "test_fixup_module_metadata",
      "source_code": ""
    },
    {
      "function": "mod.SomeClass.method",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/trio/_tests/test_deprecate.py",
      "line": 111,
      "caller": "test_fixup_module_metadata",
      "source_code": "    @deprecated(\"1.0\", issue=123, instead=\"crying\")\n    def method(self) -> int:\n        return 7\n\n\n"
    },
    {
      "function": "vars",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_fixup_module_metadata",
      "source_code": ""
    },
    {
      "function": "vars",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_fixup_module_metadata",
      "source_code": ""
    },
    {
      "function": "hasattr",
      "filename": "<built-in>",
      "line": 0,
      "caller": "test_fixup_module_metadata",
      "source_code": ""
    },
    {
      "function": "mod.SomeClass",
      "filename": "",
      "line": 0,
      "caller": "test_fixup_module_metadata",
      "source_code": ""
    }
  ],
  "assertions": [
    "assert non_trio_module.some_func.__name__ == 'some_func'",
    "assert non_trio_module.some_func.__qualname__ == 'some_func'",
    "assert mod.some_func.__name__ == 'some_func'",
    "assert mod.some_func.__module__ == 'trio.somemodule'",
    "assert mod.some_func.__qualname__ == 'some_func'",
    "assert mod.not_funclike.__name__ == 'not_funclike'",
    "assert mod._private.__name__ == '_private'",
    "assert mod._private.__module__ == 'trio._somemodule_impl'",
    "assert mod._private.__qualname__ == '_private'",
    "assert mod.only_has_name.__name__ == 'only_has_name'",
    "assert mod.only_has_name.__module__ == 'trio.somemodule'",
    "assert not hasattr(mod.only_has_name, '__qualname__')",
    "assert mod.SomeClass.method.__name__ == 'method'",
    "assert mod.SomeClass.method.__module__ == 'trio.somemodule'",
    "assert mod.SomeClass.method.__qualname__ == 'SomeClass.method'"
  ],
  "mocks": [],
  "success": true,
  "test_source_code": "def test_fixup_module_metadata() -> None:\n    # Ignores modules not in the trio.X tree.\n    non_trio_module = types.ModuleType(\"not_trio\")\n    non_trio_module.some_func = lambda: None  # type: ignore[attr-defined]\n    non_trio_module.some_func.__name__ = \"some_func\"\n    non_trio_module.some_func.__qualname__ = \"some_func\"\n\n    fixup_module_metadata(non_trio_module.__name__, vars(non_trio_module))\n\n    assert non_trio_module.some_func.__name__ == \"some_func\"\n    assert non_trio_module.some_func.__qualname__ == \"some_func\"\n\n    # Bulild up a fake module to test. Just use lambdas since all we care about is the names.\n    mod = types.ModuleType(\"trio._somemodule_impl\")\n    mod.some_func = lambda: None  # type: ignore[attr-defined]\n    mod.some_func.__name__ = \"_something_else\"\n    mod.some_func.__qualname__ = \"_something_else\"\n\n    # No __module__ means it's unchanged.\n    mod.not_funclike = types.SimpleNamespace()  # type: ignore[attr-defined]\n    mod.not_funclike.__name__ = \"not_funclike\"\n\n    # Check __qualname__ being absent works.\n    mod.only_has_name = types.SimpleNamespace()  # type: ignore[attr-defined]\n    mod.only_has_name.__module__ = \"trio._somemodule_impl\"\n    mod.only_has_name.__name__ = \"only_name\"\n\n    # Underscored names are unchanged.\n    mod._private = lambda: None  # type: ignore[attr-defined]\n    mod._private.__module__ = \"trio._somemodule_impl\"\n    mod._private.__name__ = mod._private.__qualname__ = \"_private\"\n\n    # We recurse into classes.\n    mod.SomeClass = type(  # type: ignore[attr-defined]\n        \"SomeClass\",\n        (),\n        {\n            \"__init__\": lambda self: None,\n            \"method\": lambda self: None,\n        },\n    )\n    # Reference loop is fine.\n    mod.SomeClass.recursion = mod.SomeClass  # type: ignore[attr-defined]\n\n    fixup_module_metadata(\"trio.somemodule\", vars(mod))\n    assert mod.some_func.__name__ == \"some_func\"\n    assert mod.some_func.__module__ == \"trio.somemodule\"\n    assert mod.some_func.__qualname__ == \"some_func\"\n\n    assert mod.not_funclike.__name__ == \"not_funclike\"\n    assert mod._private.__name__ == \"_private\"\n    assert mod._private.__module__ == \"trio._somemodule_impl\"\n    assert mod._private.__qualname__ == \"_private\"\n\n    assert mod.only_has_name.__name__ == \"only_has_name\"\n    assert mod.only_has_name.__module__ == \"trio.somemodule\"\n    assert not hasattr(mod.only_has_name, \"__qualname__\")\n\n    assert mod.SomeClass.method.__name__ == \"method\"  # type: ignore[attr-defined]\n    assert mod.SomeClass.method.__module__ == \"trio.somemodule\"  # type: ignore[attr-defined]\n    assert mod.SomeClass.method.__qualname__ == \"SomeClass.method\"  # type: ignore[attr-defined]\n    # Make coverage happy.\n    non_trio_module.some_func()\n    mod.some_func()\n    mod._private()\n    mod.SomeClass().method()"
}