{
  "test_name": "test_pipelined_close",
  "test_file": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/tests/test_connection.py",
  "static_methods": [
    {
      "name": "Connection",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "c.receive_data",
      "source_code": "    def receive_data(self, data: bytes) -> None:\n        \"\"\"Add data to our internal receive buffer.",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/_connection.py",
      "line_number": 352
    },
    {
      "name": "c.receive_data",
      "source_code": "    def receive_data(self, data: bytes) -> None:\n        \"\"\"Add data to our internal receive buffer.",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/_connection.py",
      "line_number": 352
    },
    {
      "name": "c.send",
      "source_code": "    def send(self, event: Event) -> Optional[bytes]:\n        \"\"\"Convert a high-level event into bytes that can be sent to the peer,\n        while updating our internal state machine.",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/_connection.py",
      "line_number": 491
    },
    {
      "name": "c.send",
      "source_code": "    def send(self, event: Event) -> Optional[bytes]:\n        \"\"\"Convert a high-level event into bytes that can be sent to the peer,\n        while updating our internal state machine.",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/_connection.py",
      "line_number": 491
    },
    {
      "name": "c.start_next_cycle",
      "source_code": "    def start_next_cycle(self) -> None:\n        if self.states != {CLIENT: DONE, SERVER: DONE}:\n            raise LocalProtocolError(\n                \"not in a reusable state. self.states={}\".format(self.states)\n            )\n        # Can't reach DONE/DONE with any of these active, but still, let's be\n        # sure.\n        assert self.keep_alive\n        assert not self.pending_switch_proposals\n        self.states = {CLIENT: IDLE, SERVER: IDLE}",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/_state.py",
      "line_number": 358
    },
    {
      "name": "c.send",
      "source_code": "    def send(self, event: Event) -> Optional[bytes]:\n        \"\"\"Convert a high-level event into bytes that can be sent to the peer,\n        while updating our internal state machine.",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/_connection.py",
      "line_number": 491
    },
    {
      "name": "c.send",
      "source_code": "    def send(self, event: Event) -> Optional[bytes]:\n        \"\"\"Convert a high-level event into bytes that can be sent to the peer,\n        while updating our internal state machine.",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/_connection.py",
      "line_number": 491
    },
    {
      "name": "c.send",
      "source_code": "    def send(self, event: Event) -> Optional[bytes]:\n        \"\"\"Convert a high-level event into bytes that can be sent to the peer,\n        while updating our internal state machine.",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/_connection.py",
      "line_number": 491
    },
    {
      "name": "get_all_events",
      "source_code": "def get_all_events(conn: Connection) -> List[Event]:\n    got_events = []\n    while True:\n        event = conn.next_event()\n        if event in (NEED_DATA, PAUSED):\n            break\n        event = cast(Event, event)\n        got_events.append(event)\n        if type(event) is ConnectionClosed:\n            break\n    return got_events",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/tests/helpers.py",
      "line_number": 22
    },
    {
      "name": "Response",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "EndOfMessage",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "get_all_events",
      "source_code": "def get_all_events(conn: Connection) -> List[Event]:\n    got_events = []\n    while True:\n        event = conn.next_event()\n        if event in (NEED_DATA, PAUSED):\n            break\n        event = cast(Event, event)\n        got_events.append(event)\n        if type(event) is ConnectionClosed:\n            break\n    return got_events",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/tests/helpers.py",
      "line_number": 22
    },
    {
      "name": "Response",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "EndOfMessage",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "ConnectionClosed",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "Request",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "Data",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "EndOfMessage",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "Request",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "Data",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "EndOfMessage",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "ConnectionClosed",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    }
  ],
  "dynamic_methods": [
    {
      "function": "Connection",
      "filename": "",
      "line": 0,
      "caller": "test_pipelined_close",
      "source_code": ""
    },
    {
      "function": "c.receive_data",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/_connection.py",
      "line": 352,
      "caller": "test_pipelined_close",
      "source_code": "    def receive_data(self, data: bytes) -> None:\n        \"\"\"Add data to our internal receive buffer.\n\n        This does not actually do any processing on the data, just stores\n        it. To trigger processing, you have to call :meth:`next_event`.\n\n        Args:\n            data (:term:`bytes-like object`):\n                The new data that was just received.\n\n                Special case: If *data* is an empty byte-string like ``b\"\"``,\n                then this indicates that the remote side has closed the\n                connection (end of file). Normally this is convenient, because\n                standard Python APIs like :meth:`file.read` or\n                :meth:`socket.recv` use ``b\"\"`` to indicate end-of-file, while\n                other failures to read are indicated using other mechanisms\n                like raising :exc:`TimeoutError`. When using such an API you\n                can just blindly pass through whatever you get from ``read``\n                to :meth:`receive_data`, and everything will work.\n\n                But, if you have an API where reading an empty string is a\n                valid non-EOF condition, then you need to be aware of this and\n                make sure to check for such strings and avoid passing them to\n                :meth:`receive_data`.\n\n        Returns:\n            Nothing, but after calling this you should call :meth:`next_event`\n            to parse the newly received data.\n\n        Raises:\n            RuntimeError:\n                Raised if you pass an empty *data*, indicating EOF, and then\n                pass a non-empty *data*, indicating more data that somehow\n                arrived after the EOF.\n\n                (Calling ``receive_data(b\"\")`` multiple times is fine,\n                and equivalent to calling it once.)\n\n        \"\"\"\n        if data:\n            if self._receive_buffer_closed:\n                raise RuntimeError(\"received close, then received more data?\")\n            self._receive_buffer += data\n        else:\n            self._receive_buffer_closed = True\n\n"
    },
    {
      "function": "c.receive_data",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/_connection.py",
      "line": 352,
      "caller": "test_pipelined_close",
      "source_code": "    def receive_data(self, data: bytes) -> None:\n        \"\"\"Add data to our internal receive buffer.\n\n        This does not actually do any processing on the data, just stores\n        it. To trigger processing, you have to call :meth:`next_event`.\n\n        Args:\n            data (:term:`bytes-like object`):\n                The new data that was just received.\n\n                Special case: If *data* is an empty byte-string like ``b\"\"``,\n                then this indicates that the remote side has closed the\n                connection (end of file). Normally this is convenient, because\n                standard Python APIs like :meth:`file.read` or\n                :meth:`socket.recv` use ``b\"\"`` to indicate end-of-file, while\n                other failures to read are indicated using other mechanisms\n                like raising :exc:`TimeoutError`. When using such an API you\n                can just blindly pass through whatever you get from ``read``\n                to :meth:`receive_data`, and everything will work.\n\n                But, if you have an API where reading an empty string is a\n                valid non-EOF condition, then you need to be aware of this and\n                make sure to check for such strings and avoid passing them to\n                :meth:`receive_data`.\n\n        Returns:\n            Nothing, but after calling this you should call :meth:`next_event`\n            to parse the newly received data.\n\n        Raises:\n            RuntimeError:\n                Raised if you pass an empty *data*, indicating EOF, and then\n                pass a non-empty *data*, indicating more data that somehow\n                arrived after the EOF.\n\n                (Calling ``receive_data(b\"\")`` multiple times is fine,\n                and equivalent to calling it once.)\n\n        \"\"\"\n        if data:\n            if self._receive_buffer_closed:\n                raise RuntimeError(\"received close, then received more data?\")\n            self._receive_buffer += data\n        else:\n            self._receive_buffer_closed = True\n\n"
    },
    {
      "function": "c.send",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/_connection.py",
      "line": 491,
      "caller": "test_pipelined_close",
      "source_code": "    def send(self, event: Event) -> Optional[bytes]:\n        \"\"\"Convert a high-level event into bytes that can be sent to the peer,\n        while updating our internal state machine.\n\n        Args:\n            event: The :ref:`event <events>` to send.\n\n        Returns:\n            If ``type(event) is ConnectionClosed``, then returns\n            ``None``. Otherwise, returns a :term:`bytes-like object`.\n\n        Raises:\n            LocalProtocolError:\n                Sending this event at this time would violate our\n                understanding of the HTTP/1.1 protocol.\n\n        If this method raises any exception then it also sets\n        :attr:`Connection.our_state` to :data:`ERROR` -- see\n        :ref:`error-handling` for discussion.\n\n        \"\"\"\n        data_list = self.send_with_data_passthrough(event)\n        if data_list is None:\n            return None\n        else:\n            return b\"\".join(data_list)\n\n"
    },
    {
      "function": "c.send",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/_connection.py",
      "line": 491,
      "caller": "test_pipelined_close",
      "source_code": "    def send(self, event: Event) -> Optional[bytes]:\n        \"\"\"Convert a high-level event into bytes that can be sent to the peer,\n        while updating our internal state machine.\n\n        Args:\n            event: The :ref:`event <events>` to send.\n\n        Returns:\n            If ``type(event) is ConnectionClosed``, then returns\n            ``None``. Otherwise, returns a :term:`bytes-like object`.\n\n        Raises:\n            LocalProtocolError:\n                Sending this event at this time would violate our\n                understanding of the HTTP/1.1 protocol.\n\n        If this method raises any exception then it also sets\n        :attr:`Connection.our_state` to :data:`ERROR` -- see\n        :ref:`error-handling` for discussion.\n\n        \"\"\"\n        data_list = self.send_with_data_passthrough(event)\n        if data_list is None:\n            return None\n        else:\n            return b\"\".join(data_list)\n\n"
    },
    {
      "function": "c.start_next_cycle",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/_state.py",
      "line": 358,
      "caller": "test_pipelined_close",
      "source_code": "    def start_next_cycle(self) -> None:\n        if self.states != {CLIENT: DONE, SERVER: DONE}:\n            raise LocalProtocolError(\n                \"not in a reusable state. self.states={}\".format(self.states)\n            )\n        # Can't reach DONE/DONE with any of these active, but still, let's be\n        # sure.\n        assert self.keep_alive\n        assert not self.pending_switch_proposals\n        self.states = {CLIENT: IDLE, SERVER: IDLE}\n"
    },
    {
      "function": "c.send",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/_connection.py",
      "line": 491,
      "caller": "test_pipelined_close",
      "source_code": "    def send(self, event: Event) -> Optional[bytes]:\n        \"\"\"Convert a high-level event into bytes that can be sent to the peer,\n        while updating our internal state machine.\n\n        Args:\n            event: The :ref:`event <events>` to send.\n\n        Returns:\n            If ``type(event) is ConnectionClosed``, then returns\n            ``None``. Otherwise, returns a :term:`bytes-like object`.\n\n        Raises:\n            LocalProtocolError:\n                Sending this event at this time would violate our\n                understanding of the HTTP/1.1 protocol.\n\n        If this method raises any exception then it also sets\n        :attr:`Connection.our_state` to :data:`ERROR` -- see\n        :ref:`error-handling` for discussion.\n\n        \"\"\"\n        data_list = self.send_with_data_passthrough(event)\n        if data_list is None:\n            return None\n        else:\n            return b\"\".join(data_list)\n\n"
    },
    {
      "function": "c.send",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/_connection.py",
      "line": 491,
      "caller": "test_pipelined_close",
      "source_code": "    def send(self, event: Event) -> Optional[bytes]:\n        \"\"\"Convert a high-level event into bytes that can be sent to the peer,\n        while updating our internal state machine.\n\n        Args:\n            event: The :ref:`event <events>` to send.\n\n        Returns:\n            If ``type(event) is ConnectionClosed``, then returns\n            ``None``. Otherwise, returns a :term:`bytes-like object`.\n\n        Raises:\n            LocalProtocolError:\n                Sending this event at this time would violate our\n                understanding of the HTTP/1.1 protocol.\n\n        If this method raises any exception then it also sets\n        :attr:`Connection.our_state` to :data:`ERROR` -- see\n        :ref:`error-handling` for discussion.\n\n        \"\"\"\n        data_list = self.send_with_data_passthrough(event)\n        if data_list is None:\n            return None\n        else:\n            return b\"\".join(data_list)\n\n"
    },
    {
      "function": "c.send",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/_connection.py",
      "line": 491,
      "caller": "test_pipelined_close",
      "source_code": "    def send(self, event: Event) -> Optional[bytes]:\n        \"\"\"Convert a high-level event into bytes that can be sent to the peer,\n        while updating our internal state machine.\n\n        Args:\n            event: The :ref:`event <events>` to send.\n\n        Returns:\n            If ``type(event) is ConnectionClosed``, then returns\n            ``None``. Otherwise, returns a :term:`bytes-like object`.\n\n        Raises:\n            LocalProtocolError:\n                Sending this event at this time would violate our\n                understanding of the HTTP/1.1 protocol.\n\n        If this method raises any exception then it also sets\n        :attr:`Connection.our_state` to :data:`ERROR` -- see\n        :ref:`error-handling` for discussion.\n\n        \"\"\"\n        data_list = self.send_with_data_passthrough(event)\n        if data_list is None:\n            return None\n        else:\n            return b\"\".join(data_list)\n\n"
    },
    {
      "function": "get_all_events",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/tests/helpers.py",
      "line": 22,
      "caller": "test_pipelined_close",
      "source_code": "def get_all_events(conn: Connection) -> List[Event]:\n    got_events = []\n    while True:\n        event = conn.next_event()\n        if event in (NEED_DATA, PAUSED):\n            break\n        event = cast(Event, event)\n        got_events.append(event)\n        if type(event) is ConnectionClosed:\n            break\n    return got_events\n\n\n"
    },
    {
      "function": "Response",
      "filename": "",
      "line": 0,
      "caller": "test_pipelined_close",
      "source_code": ""
    },
    {
      "function": "EndOfMessage",
      "filename": "",
      "line": 0,
      "caller": "test_pipelined_close",
      "source_code": ""
    },
    {
      "function": "get_all_events",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/h11/tests/helpers.py",
      "line": 22,
      "caller": "test_pipelined_close",
      "source_code": "def get_all_events(conn: Connection) -> List[Event]:\n    got_events = []\n    while True:\n        event = conn.next_event()\n        if event in (NEED_DATA, PAUSED):\n            break\n        event = cast(Event, event)\n        got_events.append(event)\n        if type(event) is ConnectionClosed:\n            break\n    return got_events\n\n\n"
    },
    {
      "function": "Response",
      "filename": "",
      "line": 0,
      "caller": "test_pipelined_close",
      "source_code": ""
    },
    {
      "function": "EndOfMessage",
      "filename": "",
      "line": 0,
      "caller": "test_pipelined_close",
      "source_code": ""
    },
    {
      "function": "ConnectionClosed",
      "filename": "",
      "line": 0,
      "caller": "test_pipelined_close",
      "source_code": ""
    },
    {
      "function": "Request",
      "filename": "",
      "line": 0,
      "caller": "test_pipelined_close",
      "source_code": ""
    },
    {
      "function": "Data",
      "filename": "",
      "line": 0,
      "caller": "test_pipelined_close",
      "source_code": ""
    },
    {
      "function": "EndOfMessage",
      "filename": "",
      "line": 0,
      "caller": "test_pipelined_close",
      "source_code": ""
    },
    {
      "function": "Request",
      "filename": "",
      "line": 0,
      "caller": "test_pipelined_close",
      "source_code": ""
    },
    {
      "function": "Data",
      "filename": "",
      "line": 0,
      "caller": "test_pipelined_close",
      "source_code": ""
    },
    {
      "function": "EndOfMessage",
      "filename": "",
      "line": 0,
      "caller": "test_pipelined_close",
      "source_code": ""
    },
    {
      "function": "ConnectionClosed",
      "filename": "",
      "line": 0,
      "caller": "test_pipelined_close",
      "source_code": ""
    }
  ],
  "assertions": [
    "assert get_all_events(c) == [Request(method='GET', target='/1', headers=[('host', 'a.com'), ('content-length', '5')]), Data(data=b'12345'), EndOfMessage()]",
    "assert c.states[CLIENT] is DONE",
    "assert c.states[SERVER] is DONE",
    "assert get_all_events(c) == [Request(method='GET', target='/2', headers=[('host', 'a.com'), ('content-length', '5')]), Data(data=b'67890'), EndOfMessage(), ConnectionClosed()]",
    "assert c.states == {CLIENT: CLOSED, SERVER: SEND_RESPONSE}",
    "assert c.states == {CLIENT: CLOSED, SERVER: MUST_CLOSE}",
    "assert c.states == {CLIENT: CLOSED, SERVER: CLOSED}"
  ],
  "mocks": [],
  "success": true,
  "test_source_code": "def test_pipelined_close() -> None:\n    c = Connection(SERVER)\n    # 2 requests then a close\n    c.receive_data(\n        b\"GET /1 HTTP/1.1\\r\\nHost: a.com\\r\\nContent-Length: 5\\r\\n\\r\\n\"\n        b\"12345\"\n        b\"GET /2 HTTP/1.1\\r\\nHost: a.com\\r\\nContent-Length: 5\\r\\n\\r\\n\"\n        b\"67890\"\n    )\n    c.receive_data(b\"\")\n    assert get_all_events(c) == [\n        Request(\n            method=\"GET\",\n            target=\"/1\",\n            headers=[(\"host\", \"a.com\"), (\"content-length\", \"5\")],\n        ),\n        Data(data=b\"12345\"),\n        EndOfMessage(),\n    ]\n    assert c.states[CLIENT] is DONE\n    c.send(Response(status_code=200, headers=[]))  # type: ignore[arg-type]\n    c.send(EndOfMessage())\n    assert c.states[SERVER] is DONE\n    c.start_next_cycle()\n    assert get_all_events(c) == [\n        Request(\n            method=\"GET\",\n            target=\"/2\",\n            headers=[(\"host\", \"a.com\"), (\"content-length\", \"5\")],\n        ),\n        Data(data=b\"67890\"),\n        EndOfMessage(),\n        ConnectionClosed(),\n    ]\n    assert c.states == {CLIENT: CLOSED, SERVER: SEND_RESPONSE}\n    c.send(Response(status_code=200, headers=[]))  # type: ignore[arg-type]\n    c.send(EndOfMessage())\n    assert c.states == {CLIENT: CLOSED, SERVER: MUST_CLOSE}\n    c.send(ConnectionClosed())\n    assert c.states == {CLIENT: CLOSED, SERVER: CLOSED}"
}