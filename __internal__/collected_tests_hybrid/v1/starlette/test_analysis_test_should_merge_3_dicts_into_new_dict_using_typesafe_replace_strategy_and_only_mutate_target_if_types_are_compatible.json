{
  "test_name": "test_should_merge_3_dicts_into_new_dict_using_typesafe_replace_strategy_and_only_mutate_target_if_types_are_compatible",
  "test_file": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/mergedeep/test_mergedeep.py",
  "static_methods": [
    {
      "name": "deepcopy",
      "source_code": "    def deepcopy(self):\n        \"\"\"Return a deep copy of self (also copying children).\"\"\"\n        raise NotImplementedError",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/docutils/nodes.py",
      "line_number": 96
    },
    {
      "name": "deepcopy",
      "source_code": "    def deepcopy(self):\n        \"\"\"Return a deep copy of self (also copying children).\"\"\"\n        raise NotImplementedError",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/docutils/nodes.py",
      "line_number": 96
    },
    {
      "name": "deepcopy",
      "source_code": "    def deepcopy(self):\n        \"\"\"Return a deep copy of self (also copying children).\"\"\"\n        raise NotImplementedError",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/docutils/nodes.py",
      "line_number": 96
    },
    {
      "name": "merge",
      "source_code": "    def merge(self, params: QueryParamTypes | None = None) -> QueryParams:\n        \"\"\"\n        Return a new QueryParams instance, updated with.",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/httpx/_urls.py",
      "line_number": 582
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "self.assertEqual",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "Counter",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "Counter",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    },
    {
      "name": "Counter",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    }
  ],
  "dynamic_methods": [
    {
      "function": "deepcopy",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/docutils/nodes.py",
      "line": 96,
      "caller": "test_should_merge_3_dicts_into_new_dict_using_typesafe_replace_strategy_and_only_mutate_target_if_types_are_compatible",
      "source_code": "    def deepcopy(self):\n        \"\"\"Return a deep copy of self (also copying children).\"\"\"\n        raise NotImplementedError\n\n"
    },
    {
      "function": "deepcopy",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/docutils/nodes.py",
      "line": 96,
      "caller": "test_should_merge_3_dicts_into_new_dict_using_typesafe_replace_strategy_and_only_mutate_target_if_types_are_compatible",
      "source_code": "    def deepcopy(self):\n        \"\"\"Return a deep copy of self (also copying children).\"\"\"\n        raise NotImplementedError\n\n"
    },
    {
      "function": "deepcopy",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/docutils/nodes.py",
      "line": 96,
      "caller": "test_should_merge_3_dicts_into_new_dict_using_typesafe_replace_strategy_and_only_mutate_target_if_types_are_compatible",
      "source_code": "    def deepcopy(self):\n        \"\"\"Return a deep copy of self (also copying children).\"\"\"\n        raise NotImplementedError\n\n"
    },
    {
      "function": "merge",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/httpx/_urls.py",
      "line": 582,
      "caller": "test_should_merge_3_dicts_into_new_dict_using_typesafe_replace_strategy_and_only_mutate_target_if_types_are_compatible",
      "source_code": "    def merge(self, params: QueryParamTypes | None = None) -> QueryParams:\n        \"\"\"\n        Return a new QueryParams instance, updated with.\n\n        Usage:\n\n        q = httpx.QueryParams(\"a=123\")\n        q = q.merge({\"b\": \"456\"})\n        assert q == httpx.QueryParams(\"a=123&b=456\")\n\n        q = httpx.QueryParams(\"a=123\")\n        q = q.merge({\"a\": \"456\", \"b\": \"789\"})\n        assert q == httpx.QueryParams(\"a=456&b=789\")\n        \"\"\"\n        q = QueryParams(params)\n        q._dict = {**self._dict, **q._dict}\n        return q\n\n"
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_should_merge_3_dicts_into_new_dict_using_typesafe_replace_strategy_and_only_mutate_target_if_types_are_compatible",
      "source_code": ""
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_should_merge_3_dicts_into_new_dict_using_typesafe_replace_strategy_and_only_mutate_target_if_types_are_compatible",
      "source_code": ""
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_should_merge_3_dicts_into_new_dict_using_typesafe_replace_strategy_and_only_mutate_target_if_types_are_compatible",
      "source_code": ""
    },
    {
      "function": "self.assertEqual",
      "filename": "",
      "line": 0,
      "caller": "test_should_merge_3_dicts_into_new_dict_using_typesafe_replace_strategy_and_only_mutate_target_if_types_are_compatible",
      "source_code": ""
    },
    {
      "function": "Counter",
      "filename": "",
      "line": 0,
      "caller": "test_should_merge_3_dicts_into_new_dict_using_typesafe_replace_strategy_and_only_mutate_target_if_types_are_compatible",
      "source_code": ""
    },
    {
      "function": "Counter",
      "filename": "",
      "line": 0,
      "caller": "test_should_merge_3_dicts_into_new_dict_using_typesafe_replace_strategy_and_only_mutate_target_if_types_are_compatible",
      "source_code": ""
    },
    {
      "function": "Counter",
      "filename": "",
      "line": 0,
      "caller": "test_should_merge_3_dicts_into_new_dict_using_typesafe_replace_strategy_and_only_mutate_target_if_types_are_compatible",
      "source_code": ""
    }
  ],
  "assertions": [],
  "mocks": [],
  "success": false,
  "test_source_code": "def test_should_merge_3_dicts_into_new_dict_using_typesafe_replace_strategy_and_only_mutate_target_if_types_are_compatible(\n        self,\n    ):\n        expected = {\n            \"a\": {\"b\": {\"c\": 5, \"_c\": 15}, \"B\": {\"C\": 10}},\n            \"d\": 3,\n            \"f\": [4, 5, 6],\n            \"g\": {2, 3, 4},\n            \"h\": (1, 3),\n            \"z\": Counter({\"a\": 1, \"b\": 1, \"c\": 1}),\n        }\n\n        a = {\"a\": {\"b\": {\"c\": 5}}, \"d\": 1, \"f\": [1, 2, 3], \"g\": {1, 2, 3}, \"z\": Counter({\"a\": 1, \"b\": 1})}\n        a_copy = deepcopy(a)\n\n        b = {\"a\": {\"B\": {\"C\": 10}}, \"d\": 2, \"f\": [4, 5, 6], \"g\": {2, 3, 4}, \"h\": (1,)}\n        b_copy = deepcopy(b)\n\n        c = {\"a\": {\"b\": {\"_c\": 15}}, \"d\": 3, \"h\": (1, 3), \"z\": Counter({\"a\": 1, \"c\": 1})}\n        c_copy = deepcopy(c)\n\n        actual = merge({}, a, b, c, strategy=Strategy.TYPESAFE_REPLACE)\n\n        self.assertEqual(actual, expected)\n        self.assertEqual(a, a_copy)\n        self.assertEqual(b, b_copy)\n        self.assertEqual(c, c_copy)"
}