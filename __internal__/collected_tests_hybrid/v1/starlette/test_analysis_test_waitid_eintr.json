{
  "test_name": "test_waitid_eintr",
  "test_file": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/trio/_tests/test_subprocess.py",
  "static_methods": [
    {
      "name": "wait_child_exiting.__module__.endswith",
      "source_code": "    def endswith(self, arg):\n        return str(self.path).endswith(arg)",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/_pytest/_py/path.py",
      "line_number": 67
    },
    {
      "name": "sleeper.kill",
      "source_code": "    def kill(self) -> None:\n        \"\"\"Immediately terminate the process.",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/trio/_subprocess.py",
      "line_number": 290
    },
    {
      "name": "sync_wait_reapable",
      "source_code": "    def sync_wait_reapable(pid: int) -> None:\n        waitid(os.P_PID, pid, os.WEXITED | os.WNOWAIT)",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/trio/_subprocess_platform/waitid.py",
      "line_number": 16
    },
    {
      "name": "sleeper.wait",
      "source_code": "    def wait(self, timeout: float | None = None) -> None:\n        if timeout == float(\"inf\"):  # pragma: no cover\n            timeout = None\n        if not self._event.wait(timeout=timeout):\n            raise PoolTimeout()  # pragma: nocover",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/httpcore/_synchronization.py",
      "line_number": 287
    },
    {
      "name": "sleeper.kill",
      "source_code": "    def kill(self) -> None:\n        \"\"\"Immediately terminate the process.",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/trio/_subprocess.py",
      "line_number": 290
    },
    {
      "name": "sleeper.wait",
      "source_code": "    def wait(self, timeout: float | None = None) -> None:\n        if timeout == float(\"inf\"):  # pragma: no cover\n            timeout = None\n        if not self._event.wait(timeout=timeout):\n            raise PoolTimeout()  # pragma: nocover",
      "file_path": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/httpcore/_synchronization.py",
      "line_number": 287
    },
    {
      "name": "slow",
      "source_code": "",
      "file_path": "",
      "line_number": 0
    }
  ],
  "dynamic_methods": [
    {
      "function": "wait_child_exiting.__module__.endswith",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/_pytest/_py/path.py",
      "line": 67,
      "caller": "test_waitid_eintr",
      "source_code": "    def endswith(self, arg):\n        return str(self.path).endswith(arg)\n\n"
    },
    {
      "function": "sleeper.kill",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/trio/_subprocess.py",
      "line": 290,
      "caller": "test_waitid_eintr",
      "source_code": "    def kill(self) -> None:\n        \"\"\"Immediately terminate the process.\n\n        On UNIX, this is equivalent to\n        ``send_signal(signal.SIGKILL)``.  On Windows, it calls\n        ``TerminateProcess``. In both cases, the process cannot\n        prevent itself from being killed, but the termination will be\n        delivered asynchronously; use :meth:`wait` if you want to\n        ensure the process is actually dead before proceeding.\n        \"\"\"\n        self._proc.kill()\n\n\n"
    },
    {
      "function": "sync_wait_reapable",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/trio/_subprocess_platform/waitid.py",
      "line": 16,
      "caller": "test_waitid_eintr",
      "source_code": "    def sync_wait_reapable(pid: int) -> None:\n        waitid(os.P_PID, pid, os.WEXITED | os.WNOWAIT)\n\n"
    },
    {
      "function": "sleeper.wait",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/httpcore/_synchronization.py",
      "line": 287,
      "caller": "test_waitid_eintr",
      "source_code": "    def wait(self, timeout: float | None = None) -> None:\n        if timeout == float(\"inf\"):  # pragma: no cover\n            timeout = None\n        if not self._event.wait(timeout=timeout):\n            raise PoolTimeout()  # pragma: nocover\n\n\n"
    },
    {
      "function": "sleeper.kill",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/trio/_subprocess.py",
      "line": 290,
      "caller": "test_waitid_eintr",
      "source_code": "    def kill(self) -> None:\n        \"\"\"Immediately terminate the process.\n\n        On UNIX, this is equivalent to\n        ``send_signal(signal.SIGKILL)``.  On Windows, it calls\n        ``TerminateProcess``. In both cases, the process cannot\n        prevent itself from being killed, but the termination will be\n        delivered asynchronously; use :meth:`wait` if you want to\n        ensure the process is actually dead before proceeding.\n        \"\"\"\n        self._proc.kill()\n\n\n"
    },
    {
      "function": "sleeper.wait",
      "filename": "/home/quark-ubuntu-wsl/test_transplantation_cs846_f24/test-transplantation/__internal__/_data/starlette/venv/lib/python3.9/site-packages/httpcore/_synchronization.py",
      "line": 287,
      "caller": "test_waitid_eintr",
      "source_code": "    def wait(self, timeout: float | None = None) -> None:\n        if timeout == float(\"inf\"):  # pragma: no cover\n            timeout = None\n        if not self._event.wait(timeout=timeout):\n            raise PoolTimeout()  # pragma: nocover\n\n\n"
    },
    {
      "function": "slow",
      "filename": "",
      "line": 0,
      "caller": "test_waitid_eintr",
      "source_code": ""
    }
  ],
  "assertions": [
    "assert sleeper.wait(timeout=1) == -9"
  ],
  "mocks": [],
  "success": true,
  "test_source_code": "def test_waitid_eintr() -> None:\n    # This only matters on PyPy (where we're coding EINTR handling\n    # ourselves) but the test works on all waitid platforms.\n    from .._subprocess_platform import wait_child_exiting\n\n    if TYPE_CHECKING and (sys.platform == \"win32\" or sys.platform == \"darwin\"):\n        return\n\n    if not wait_child_exiting.__module__.endswith(\"waitid\"):\n        pytest.skip(\"waitid only\")\n\n    # despite the TYPE_CHECKING early return silencing warnings about signal.SIGALRM etc\n    # this import is still checked on win32&darwin and raises [attr-defined].\n    # Linux doesn't raise [attr-defined] though, so we need [unused-ignore]\n    from .._subprocess_platform.waitid import (  # type: ignore[attr-defined, unused-ignore]\n        sync_wait_reapable,\n    )\n\n    got_alarm = False\n    sleeper = subprocess.Popen([\"sleep\", \"3600\"])\n\n    def on_alarm(sig: int, frame: FrameType | None) -> None:\n        nonlocal got_alarm\n        got_alarm = True\n        sleeper.kill()\n\n    old_sigalrm = signal.signal(signal.SIGALRM, on_alarm)\n    try:\n        signal.alarm(1)\n        sync_wait_reapable(sleeper.pid)\n        assert sleeper.wait(timeout=1) == -9\n    finally:\n        if sleeper.returncode is None:  # pragma: no cover\n            # We only get here if something fails in the above;\n            # if the test passes, wait() will reap the process\n            sleeper.kill()\n            sleeper.wait()\n        signal.signal(signal.SIGALRM, old_sigalrm)"
}