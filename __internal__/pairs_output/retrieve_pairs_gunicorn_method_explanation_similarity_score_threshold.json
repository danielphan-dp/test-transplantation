{
  "pairs": [
    {
      "host_test": {
        "repo_name": "gunicorn",
        "name": "test_http_parser",
        "module": "test_invalid_requests",
        "class_name": null,
        "file_path": "__internal__/data/gunicorn/tests/test_invalid_requests.py",
        "line_number": 18,
        "end_line_number": 26,
        "source_code": "def test_http_parser(fname):\n    env = treq.load_py(os.path.splitext(fname)[0] + \".py\")\n\n    expect = env[\"request\"]\n    cfg = env[\"cfg\"]\n    req = treq.badrequest(fname)\n\n    with pytest.raises(expect):\n        req.check(cfg)",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('fname', httpfiles)"
        ],
        "arguments": [
          "fname"
        ],
        "imports": [
          "glob",
          "os",
          "pytest",
          "treq"
        ],
        "fixtures": [],
        "assertions": [],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "treq.load_py",
            "body": "def load_py(fname):\n    module_name = '__config__'\n    mod = types.ModuleType(module_name)\n    setattr(mod, 'uri', uri)\n    setattr(mod, 'cfg', Config())\n    loader = importlib.machinery.SourceFileLoader(module_name, fname)\n    loader.exec_module(mod)\n    return vars(mod)",
            "method_explanation": "**Main Purpose of the Method**:\nThe `load_py` method is designed to load a Python module from a specified file, execute its code, and return its attributes as a dictionary. This is useful for dynamically loading configuration or other Python code at runtime.\n\n**How It Works**:\n1. It creates a new module named `__config__` using `types.ModuleType`.\n2. It sets two attributes on this module: `uri` and `cfg`, where `cfg` is an instance of the `Config` class.\n3. It uses `importlib.machinery.SourceFileLoader` to load the specified Python file (`fname`) into the newly created module.\n4. The module's code is executed with `loader.exec_module(mod)`, which runs the file in the context of the new module.\n5. Finally, it returns the module's attributes as a dictionary using `vars(mod)`, allowing access to any variables or functions defined in the loaded module."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "pyramid",
          "name": "test_get_source_pkg_has___loader__",
          "module": "test_assets",
          "class_name": "TestPackageOverrides",
          "file_path": "__internal__/data/pyramid/tests/test_config/test_assets.py",
          "line_number": 819,
          "end_line_number": 824,
          "source_code": "def test_get_source_pkg_has___loader__(self):\n        package = DummyPackage('package')\n        loader = package.__loader__ = DummyLoader()\n        po = self._makeOne(package)\n        self.assertEqual(po.get_source('whatever'), 'def foo():\\n    pass')\n        self.assertEqual(loader._got_source, 'whatever')",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self"
          ],
          "imports": [
            "os.path",
            "unittest",
            "pyramid.testing.cleanUp",
            "pyramid.config.Configurator",
            "pyramid.exceptions.ConfigurationError",
            "pyramid.exceptions.ConfigurationError",
            "pyramid.exceptions.ConfigurationError",
            "pyramid.exceptions.ConfigurationError",
            "pyramid.config.assets.PackageAssetSource",
            "tests.test_config.pkgs.asset",
            "tests.test_config.pkgs.asset.subpackage",
            "pyramid.config.assets.PackageAssetSource",
            "tests.test_config.pkgs.asset",
            "tests.test_config.pkgs.asset.subpackage",
            "pyramid.config.assets.PackageAssetSource",
            "tests.test_config.pkgs.asset",
            "tests.test_config.pkgs.asset.subpackage",
            "pyramid.config.assets.PackageAssetSource",
            "tests.test_config.pkgs.asset",
            "tests.test_config.pkgs.asset.subpackage",
            "pyramid.config.assets.PackageAssetSource",
            "tests.test_config.pkgs.asset",
            "tests.test_config.pkgs.asset.subpackage",
            "pyramid.exceptions.ConfigurationError",
            "pyramid.exceptions.ConfigurationError",
            "pyramid.exceptions.ConfigurationError",
            "pyramid.config.assets.FSAssetSource",
            "tests.test_config.pkgs.asset",
            "pyramid.config.assets.FSAssetSource",
            "tests.test_config.pkgs.asset",
            "pyramid.config.assets.FSAssetSource",
            "tests.test_config.pkgs.asset",
            "pyramid.interfaces.IPackageOverrides",
            "pyramid.interfaces.IPackageOverrides",
            "pyramid.config.assets.OverrideProvider",
            "pyramid.interfaces.IPackageOverrides",
            "pyramid.threadlocal.get_current_registry",
            "tests.test_config",
            "tests.test_config",
            "tests.test_config",
            "tests.test_config",
            "tests.test_config",
            "tests.test_config",
            "tests.test_config",
            "tests.test_config",
            "tests.test_config",
            "tests.test_config",
            "tests.test_config",
            "tests.test_config",
            "tests.test_config",
            "io.BytesIO",
            "tests.test_config",
            "tests.test_config",
            "tests.test_config",
            "tests.test_config",
            "tests.test_config",
            "pyramid.config.assets.PackageOverrides",
            "zope.interface.verify.verifyClass",
            "pyramid.interfaces.IPackageOverrides",
            "zope.interface.verify.verifyObject",
            "pyramid.interfaces.IPackageOverrides",
            "zope.interface.verify.verifyClass",
            "pyramid.interfaces.IPEP302Loader",
            "zope.interface.verify.verifyObject",
            "pyramid.interfaces.IPEP302Loader",
            "pyramid.config.assets.OverrideProvider",
            "pyramid.config.assets.DirectoryOverride",
            "pyramid.config.assets.FileOverride",
            "pyramid.config.assets.DirectoryOverride",
            "pyramid.config.assets.PackageAssetSource",
            "pyramid.config.assets.FSAssetSource",
            "pyramid.config.assets.DirectoryOverride",
            "pyramid.config.assets.FileOverride"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "po.get_source",
              "body": "def get_source(self, fullname):\n    self._got_source = fullname\n    return 'def foo():\\n    pass'",
              "method_explanation": "**Main Purpose of the Method**:\nThe `get_source` method is designed to retrieve the source code of a specified module or object identified by its `fullname`. It sets an internal attribute `_got_source` to the provided `fullname` and returns a placeholder string representing a function definition.\n\n**How It Works**:\nWhen `get_source` is called with a `fullname`, it assigns this value to the instance variable `self._got_source`. The method then returns a hardcoded string `'def foo():\\n    pass'`, which simulates the source code of a function named `foo`. This method is likely part of a loader or resource management system that interacts with modules, and it adheres to the interface defined by IPEP302, which standardizes how Python loaders should behave."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "gunicorn",
        "name": "test_http_parser",
        "module": "test_invalid_requests",
        "class_name": null,
        "file_path": "__internal__/data/gunicorn/tests/test_invalid_requests.py",
        "line_number": 18,
        "end_line_number": 26,
        "source_code": "def test_http_parser(fname):\n    env = treq.load_py(os.path.splitext(fname)[0] + \".py\")\n\n    expect = env[\"request\"]\n    cfg = env[\"cfg\"]\n    req = treq.badrequest(fname)\n\n    with pytest.raises(expect):\n        req.check(cfg)",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('fname', httpfiles)"
        ],
        "arguments": [
          "fname"
        ],
        "imports": [
          "glob",
          "os",
          "pytest",
          "treq"
        ],
        "fixtures": [],
        "assertions": [],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "req.check",
            "body": "def check(self, cfg, sender, sizer, matcher):\n    cases = self.expect[:]\n    p = RequestParser(cfg, sender(), None)\n    parsed_request_idx = -1\n    for (parsed_request_idx, req) in enumerate(p):\n        self.same(req, sizer, matcher, cases.pop(0))\n    assert len(self.expect) == parsed_request_idx + 1\n    assert not cases",
            "method_explanation": "**Main Purpose of the Method**:\nThe `check` method is designed to validate a series of parsed HTTP requests against expected values. It ensures that the requests conform to specified configurations and match the expected attributes, such as method, URI, headers, and body content.\n\n**How It Works**:\n1. It initializes a list of expected cases from `self.expect`.\n2. A `RequestParser` instance is created using the provided configuration (`cfg`) and a sender function (`sender()`).\n3. The method iterates over the parsed requests generated by the `RequestParser`.\n4. For each parsed request, it calls the `same` method to compare the request's attributes with the expected values, popping the first case from the `cases` list.\n5. After processing all requests, it asserts that the number of expected cases matches the number of parsed requests and that there are no remaining cases to validate, ensuring complete and accurate validation of the requests."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "flask",
          "name": "test_session_vary_cookie",
          "module": "test_basic",
          "class_name": null,
          "file_path": "__internal__/data/flask/tests/test_basic.py",
          "line_number": 513,
          "end_line_number": 571,
          "source_code": "def test_session_vary_cookie(app, client):\n    @app.route(\"/set\")\n    def set_session():\n        flask.session[\"test\"] = \"test\"\n        return \"\"\n\n    @app.route(\"/get\")\n    def get():\n        return flask.session.get(\"test\")\n\n    @app.route(\"/getitem\")\n    def getitem():\n        return flask.session[\"test\"]\n\n    @app.route(\"/setdefault\")\n    def setdefault():\n        return flask.session.setdefault(\"test\", \"default\")\n\n    @app.route(\"/clear\")\n    def clear():\n        flask.session.clear()\n        return \"\"\n\n    @app.route(\"/vary-cookie-header-set\")\n    def vary_cookie_header_set():\n        response = flask.Response()\n        response.vary.add(\"Cookie\")\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/vary-header-set\")\n    def vary_header_set():\n        response = flask.Response()\n        response.vary.update((\"Accept-Encoding\", \"Accept-Language\"))\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/no-vary-header\")\n    def no_vary_header():\n        return \"\"\n\n    def expect(path, header_value=\"Cookie\"):\n        rv = client.get(path)\n\n        if header_value:\n            # The 'Vary' key should exist in the headers only once.\n            assert len(rv.headers.get_all(\"Vary\")) == 1\n            assert rv.headers[\"Vary\"] == header_value\n        else:\n            assert \"Vary\" not in rv.headers\n\n    expect(\"/set\")\n    expect(\"/get\")\n    expect(\"/getitem\")\n    expect(\"/setdefault\")\n    expect(\"/clear\")\n    expect(\"/vary-cookie-header-set\")\n    expect(\"/vary-header-set\", \"Accept-Encoding, Accept-Language, Cookie\")\n    expect(\"/no-vary-header\", None)",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "client"
          ],
          "imports": [
            "gc",
            "re",
            "typing",
            "uuid",
            "warnings",
            "weakref",
            "contextlib.nullcontext",
            "datetime.datetime",
            "datetime.timezone",
            "platform.python_implementation",
            "pytest",
            "werkzeug.serving",
            "markupsafe.Markup",
            "werkzeug.exceptions.BadRequest",
            "werkzeug.exceptions.Forbidden",
            "werkzeug.exceptions.NotFound",
            "werkzeug.http.parse_date",
            "werkzeug.routing.BuildError",
            "werkzeug.routing.RequestRedirect",
            "flask",
            "werkzeug.routing.Rule",
            "werkzeug.routing.Submount",
            "werkzeug.routing.Rule",
            "werkzeug.routing.Submount",
            "flask.debughelpers.DebugFilesKeyError",
            "dataclasses.make_dataclass",
            "pathlib.Path"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(rv.headers.get_all('Vary')) == 1",
            "assert rv.headers['Vary'] == header_value",
            "assert 'Vary' not in rv.headers"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "expect",
              "body": "def expect(path, header_value='Cookie'):\n    rv = client.get(path)\n    if header_value:\n        assert len(rv.headers.get_all('Vary')) == 1\n        assert rv.headers['Vary'] == header_value\n    else:\n        assert 'Vary' not in rv.headers",
              "method_explanation": "**Main Purpose of the Method**:\nThe `expect` method is designed to verify the presence and correctness of the `Vary` header in the HTTP response received from a specified path. It checks whether the response headers vary based on a specified header value, which is typically used for caching mechanisms.\n\n**How It Works**:\n1. The method takes two parameters: `path`, which is the URL endpoint to be tested, and `header_value`, which defaults to `'Cookie'`.\n2. It sends a GET request to the specified `path` using a test client.\n3. If `header_value` is provided, it asserts that the `Vary` header is present and matches the expected value. Specifically, it checks that there is exactly one entry in the `Vary` header.\n4. If `header_value` is not provided (i.e., it is `None`), it asserts that the `Vary` header is absent from the response.\nThis method is useful in testing scenarios where the behavior of responses may change based on certain headers, ensuring that caching and content negotiation work as intended."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_session_vary_cookie",
          "module": "test_basic",
          "class_name": null,
          "file_path": "__internal__/data/flask/tests/test_basic.py",
          "line_number": 513,
          "end_line_number": 571,
          "source_code": "def test_session_vary_cookie(app, client):\n    @app.route(\"/set\")\n    def set_session():\n        flask.session[\"test\"] = \"test\"\n        return \"\"\n\n    @app.route(\"/get\")\n    def get():\n        return flask.session.get(\"test\")\n\n    @app.route(\"/getitem\")\n    def getitem():\n        return flask.session[\"test\"]\n\n    @app.route(\"/setdefault\")\n    def setdefault():\n        return flask.session.setdefault(\"test\", \"default\")\n\n    @app.route(\"/clear\")\n    def clear():\n        flask.session.clear()\n        return \"\"\n\n    @app.route(\"/vary-cookie-header-set\")\n    def vary_cookie_header_set():\n        response = flask.Response()\n        response.vary.add(\"Cookie\")\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/vary-header-set\")\n    def vary_header_set():\n        response = flask.Response()\n        response.vary.update((\"Accept-Encoding\", \"Accept-Language\"))\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/no-vary-header\")\n    def no_vary_header():\n        return \"\"\n\n    def expect(path, header_value=\"Cookie\"):\n        rv = client.get(path)\n\n        if header_value:\n            # The 'Vary' key should exist in the headers only once.\n            assert len(rv.headers.get_all(\"Vary\")) == 1\n            assert rv.headers[\"Vary\"] == header_value\n        else:\n            assert \"Vary\" not in rv.headers\n\n    expect(\"/set\")\n    expect(\"/get\")\n    expect(\"/getitem\")\n    expect(\"/setdefault\")\n    expect(\"/clear\")\n    expect(\"/vary-cookie-header-set\")\n    expect(\"/vary-header-set\", \"Accept-Encoding, Accept-Language, Cookie\")\n    expect(\"/no-vary-header\", None)",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "client"
          ],
          "imports": [
            "gc",
            "re",
            "typing",
            "uuid",
            "warnings",
            "weakref",
            "contextlib.nullcontext",
            "datetime.datetime",
            "datetime.timezone",
            "platform.python_implementation",
            "pytest",
            "werkzeug.serving",
            "markupsafe.Markup",
            "werkzeug.exceptions.BadRequest",
            "werkzeug.exceptions.Forbidden",
            "werkzeug.exceptions.NotFound",
            "werkzeug.http.parse_date",
            "werkzeug.routing.BuildError",
            "werkzeug.routing.RequestRedirect",
            "flask",
            "werkzeug.routing.Rule",
            "werkzeug.routing.Submount",
            "werkzeug.routing.Rule",
            "werkzeug.routing.Submount",
            "flask.debughelpers.DebugFilesKeyError",
            "dataclasses.make_dataclass",
            "pathlib.Path"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(rv.headers.get_all('Vary')) == 1",
            "assert rv.headers['Vary'] == header_value",
            "assert 'Vary' not in rv.headers"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "expect",
              "body": "def expect(path, header_value='Cookie'):\n    rv = client.get(path)\n    if header_value:\n        assert len(rv.headers.get_all('Vary')) == 1\n        assert rv.headers['Vary'] == header_value\n    else:\n        assert 'Vary' not in rv.headers",
              "method_explanation": "**Main Purpose of the Method**:\nThe `expect` method is designed to verify the presence and correctness of the `Vary` header in the HTTP response received from a specified path. It checks whether the response varies based on a specified header value, which is typically used in caching mechanisms.\n\n**How It Works**:\n1. The method takes two parameters: `path`, which is the URL endpoint to be tested, and `header_value`, which defaults to `'Cookie'`.\n2. It sends a GET request to the specified `path` using a test client.\n3. If `header_value` is provided, it asserts that the `Vary` header is present and matches the expected value. Specifically, it checks that there is exactly one entry in the `Vary` header and that it equals `header_value`.\n4. If `header_value` is not provided (i.e., it is `None` or an empty string), it asserts that the `Vary` header is absent from the response. \n\nThis method is useful for ensuring that responses are correctly configured for caching based on specific request headers."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_session_vary_cookie",
          "module": "test_basic",
          "class_name": null,
          "file_path": "__internal__/data/flask/tests/test_basic.py",
          "line_number": 513,
          "end_line_number": 571,
          "source_code": "def test_session_vary_cookie(app, client):\n    @app.route(\"/set\")\n    def set_session():\n        flask.session[\"test\"] = \"test\"\n        return \"\"\n\n    @app.route(\"/get\")\n    def get():\n        return flask.session.get(\"test\")\n\n    @app.route(\"/getitem\")\n    def getitem():\n        return flask.session[\"test\"]\n\n    @app.route(\"/setdefault\")\n    def setdefault():\n        return flask.session.setdefault(\"test\", \"default\")\n\n    @app.route(\"/clear\")\n    def clear():\n        flask.session.clear()\n        return \"\"\n\n    @app.route(\"/vary-cookie-header-set\")\n    def vary_cookie_header_set():\n        response = flask.Response()\n        response.vary.add(\"Cookie\")\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/vary-header-set\")\n    def vary_header_set():\n        response = flask.Response()\n        response.vary.update((\"Accept-Encoding\", \"Accept-Language\"))\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/no-vary-header\")\n    def no_vary_header():\n        return \"\"\n\n    def expect(path, header_value=\"Cookie\"):\n        rv = client.get(path)\n\n        if header_value:\n            # The 'Vary' key should exist in the headers only once.\n            assert len(rv.headers.get_all(\"Vary\")) == 1\n            assert rv.headers[\"Vary\"] == header_value\n        else:\n            assert \"Vary\" not in rv.headers\n\n    expect(\"/set\")\n    expect(\"/get\")\n    expect(\"/getitem\")\n    expect(\"/setdefault\")\n    expect(\"/clear\")\n    expect(\"/vary-cookie-header-set\")\n    expect(\"/vary-header-set\", \"Accept-Encoding, Accept-Language, Cookie\")\n    expect(\"/no-vary-header\", None)",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "client"
          ],
          "imports": [
            "gc",
            "re",
            "typing",
            "uuid",
            "warnings",
            "weakref",
            "contextlib.nullcontext",
            "datetime.datetime",
            "datetime.timezone",
            "platform.python_implementation",
            "pytest",
            "werkzeug.serving",
            "markupsafe.Markup",
            "werkzeug.exceptions.BadRequest",
            "werkzeug.exceptions.Forbidden",
            "werkzeug.exceptions.NotFound",
            "werkzeug.http.parse_date",
            "werkzeug.routing.BuildError",
            "werkzeug.routing.RequestRedirect",
            "flask",
            "werkzeug.routing.Rule",
            "werkzeug.routing.Submount",
            "werkzeug.routing.Rule",
            "werkzeug.routing.Submount",
            "flask.debughelpers.DebugFilesKeyError",
            "dataclasses.make_dataclass",
            "pathlib.Path"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(rv.headers.get_all('Vary')) == 1",
            "assert rv.headers['Vary'] == header_value",
            "assert 'Vary' not in rv.headers"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "expect",
              "body": "def expect(path, header_value='Cookie'):\n    rv = client.get(path)\n    if header_value:\n        assert len(rv.headers.get_all('Vary')) == 1\n        assert rv.headers['Vary'] == header_value\n    else:\n        assert 'Vary' not in rv.headers",
              "method_explanation": "**Main Purpose of the Method**:\nThe `expect` method is designed to verify the presence and correctness of the `Vary` header in the HTTP response received from a specified path. It checks whether the response headers vary based on a specified header value, which is typically used in caching mechanisms.\n\n**How It Works**:\n1. The method takes two parameters: `path`, which is the URL endpoint to be tested, and `header_value`, which defaults to `'Cookie'`.\n2. It sends a GET request to the specified `path` using a test client.\n3. If `header_value` is provided, it asserts that the `Vary` header is present and matches the expected value. Specifically, it checks that there is exactly one entry in the `Vary` header.\n4. If `header_value` is not provided, it asserts that the `Vary` header is absent from the response.\nThis method is useful for ensuring that responses are correctly configured for caching based on specific request headers."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "gunicorn",
        "name": "test_http_parser",
        "module": "test_valid_requests",
        "class_name": null,
        "file_path": "__internal__/data/gunicorn/tests/test_valid_requests.py",
        "line_number": 18,
        "end_line_number": 26,
        "source_code": "def test_http_parser(fname):\n    env = treq.load_py(os.path.splitext(fname)[0] + \".py\")\n\n    expect = env['request']\n    cfg = env['cfg']\n    req = treq.request(fname, expect)\n\n    for case in req.gen_cases(cfg):\n        case[0](*case[1:])",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('fname', httpfiles)"
        ],
        "arguments": [
          "fname"
        ],
        "imports": [
          "glob",
          "os",
          "pytest",
          "treq"
        ],
        "fixtures": [],
        "assertions": [],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "treq.load_py",
            "body": "def load_py(fname):\n    module_name = '__config__'\n    mod = types.ModuleType(module_name)\n    setattr(mod, 'uri', uri)\n    setattr(mod, 'cfg', Config())\n    loader = importlib.machinery.SourceFileLoader(module_name, fname)\n    loader.exec_module(mod)\n    return vars(mod)",
            "method_explanation": "**Main Purpose of the Method**:\nThe `load_py` method is designed to load a Python module from a specified file, execute its code, and return its attributes as a dictionary. This is useful for dynamically loading configuration or other Python code at runtime.\n\n**How It Works**:\n1. It creates a new module named `__config__` using `types.ModuleType`.\n2. It sets two attributes on this module: `uri` and `cfg`, where `cfg` is an instance of the `Config` class.\n3. It uses `importlib.machinery.SourceFileLoader` to load the specified Python file (`fname`) into the newly created module.\n4. The module's code is executed with `loader.exec_module(mod)`, which runs the file in the context of the new module.\n5. Finally, it returns the module's attributes as a dictionary using `vars(mod)`, allowing access to any variables or functions defined in the loaded file."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "pyramid",
          "name": "test_get_source_pkg_has___loader__",
          "module": "test_assets",
          "class_name": "TestPackageOverrides",
          "file_path": "__internal__/data/pyramid/tests/test_config/test_assets.py",
          "line_number": 819,
          "end_line_number": 824,
          "source_code": "def test_get_source_pkg_has___loader__(self):\n        package = DummyPackage('package')\n        loader = package.__loader__ = DummyLoader()\n        po = self._makeOne(package)\n        self.assertEqual(po.get_source('whatever'), 'def foo():\\n    pass')\n        self.assertEqual(loader._got_source, 'whatever')",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self"
          ],
          "imports": [
            "os.path",
            "unittest",
            "pyramid.testing.cleanUp",
            "pyramid.config.Configurator",
            "pyramid.exceptions.ConfigurationError",
            "pyramid.exceptions.ConfigurationError",
            "pyramid.exceptions.ConfigurationError",
            "pyramid.exceptions.ConfigurationError",
            "pyramid.config.assets.PackageAssetSource",
            "tests.test_config.pkgs.asset",
            "tests.test_config.pkgs.asset.subpackage",
            "pyramid.config.assets.PackageAssetSource",
            "tests.test_config.pkgs.asset",
            "tests.test_config.pkgs.asset.subpackage",
            "pyramid.config.assets.PackageAssetSource",
            "tests.test_config.pkgs.asset",
            "tests.test_config.pkgs.asset.subpackage",
            "pyramid.config.assets.PackageAssetSource",
            "tests.test_config.pkgs.asset",
            "tests.test_config.pkgs.asset.subpackage",
            "pyramid.config.assets.PackageAssetSource",
            "tests.test_config.pkgs.asset",
            "tests.test_config.pkgs.asset.subpackage",
            "pyramid.exceptions.ConfigurationError",
            "pyramid.exceptions.ConfigurationError",
            "pyramid.exceptions.ConfigurationError",
            "pyramid.config.assets.FSAssetSource",
            "tests.test_config.pkgs.asset",
            "pyramid.config.assets.FSAssetSource",
            "tests.test_config.pkgs.asset",
            "pyramid.config.assets.FSAssetSource",
            "tests.test_config.pkgs.asset",
            "pyramid.interfaces.IPackageOverrides",
            "pyramid.interfaces.IPackageOverrides",
            "pyramid.config.assets.OverrideProvider",
            "pyramid.interfaces.IPackageOverrides",
            "pyramid.threadlocal.get_current_registry",
            "tests.test_config",
            "tests.test_config",
            "tests.test_config",
            "tests.test_config",
            "tests.test_config",
            "tests.test_config",
            "tests.test_config",
            "tests.test_config",
            "tests.test_config",
            "tests.test_config",
            "tests.test_config",
            "tests.test_config",
            "tests.test_config",
            "io.BytesIO",
            "tests.test_config",
            "tests.test_config",
            "tests.test_config",
            "tests.test_config",
            "tests.test_config",
            "pyramid.config.assets.PackageOverrides",
            "zope.interface.verify.verifyClass",
            "pyramid.interfaces.IPackageOverrides",
            "zope.interface.verify.verifyObject",
            "pyramid.interfaces.IPackageOverrides",
            "zope.interface.verify.verifyClass",
            "pyramid.interfaces.IPEP302Loader",
            "zope.interface.verify.verifyObject",
            "pyramid.interfaces.IPEP302Loader",
            "pyramid.config.assets.OverrideProvider",
            "pyramid.config.assets.DirectoryOverride",
            "pyramid.config.assets.FileOverride",
            "pyramid.config.assets.DirectoryOverride",
            "pyramid.config.assets.PackageAssetSource",
            "pyramid.config.assets.FSAssetSource",
            "pyramid.config.assets.DirectoryOverride",
            "pyramid.config.assets.FileOverride"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "po.get_source",
              "body": "def get_source(self, fullname):\n    self._got_source = fullname\n    return 'def foo():\\n    pass'",
              "method_explanation": "**Main Purpose of the Method**:\nThe `get_source` method is designed to retrieve the source code of a specified module or object identified by its `fullname`. It sets an internal attribute `_got_source` to the provided `fullname` and returns a placeholder string representing a function definition.\n\n**How It Works**:\nWhen `get_source` is called with a `fullname`, it assigns this value to the instance variable `self._got_source`. The method then returns a hardcoded string `'def foo():\\n    pass'`, which simulates the source code of a function named `foo`. This method is likely part of a loader or resource management system that interacts with modules, and it adheres to the interface defined by IPEP302, which standardizes how Python loaders should behave."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "gunicorn",
        "name": "test_readline_empty_body",
        "module": "test_http",
        "class_name": null,
        "file_path": "__internal__/data/gunicorn/tests/test_http.py",
        "line_number": 29,
        "end_line_number": 31,
        "source_code": "def test_readline_empty_body():\n    assert_readline(b\"\", None, b\"\")\n    assert_readline(b\"\", 1, b\"\")",
        "docstring": null,
        "decorators": [],
        "arguments": [],
        "imports": [
          "io",
          "t",
          "pytest",
          "unittest.mock",
          "gunicorn.util",
          "gunicorn.http.body.Body",
          "gunicorn.http.body.LengthReader",
          "gunicorn.http.body.EOFReader",
          "gunicorn.http.wsgi.Response",
          "gunicorn.http.unreader.Unreader",
          "gunicorn.http.unreader.IterUnreader",
          "gunicorn.http.unreader.SocketUnreader",
          "gunicorn.http.errors.InvalidHeader",
          "gunicorn.http.errors.InvalidHeaderName",
          "gunicorn.http.errors.InvalidHTTPVersion",
          "gunicorn.http.message.TOKEN_RE"
        ],
        "fixtures": [],
        "assertions": [],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "assert_readline",
            "body": "def assert_readline(payload, size, expected):\n    body = Body(io.BytesIO(payload))\n    assert body.readline(size) == expected",
            "method_explanation": "**Main Purpose of the Method**:\nThe `assert_readline` method is designed to verify that a specific number of bytes can be read from a given payload using the `readline` method of a `Body` object, and that the result matches an expected byte string.\n\n**How It Works**:\n1. It takes three parameters: `payload` (the byte data to be read), `size` (the number of bytes to read), and `expected` (the expected output after reading).\n2. A `Body` object is instantiated with the `payload` wrapped in a `BytesIO` stream, allowing for buffered reading.\n3. The method then calls `body.readline(size)`, which reads up to `size` bytes from the stream until a newline character is encountered or the end of the stream is reached.\n4. Finally, it asserts that the result of the `readline` call matches the `expected` value, raising an `AssertionError` if they do not match. This is useful for testing and validating the behavior of the `readline` method in various scenarios."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "pyramid",
          "name": "test_accept_gzip",
          "module": "test_integration",
          "class_name": "TestStaticAppWithEncodings",
          "file_path": "__internal__/data/pyramid/tests/test_integration.py",
          "line_number": 285,
          "end_line_number": 294,
          "source_code": "def test_accept_gzip(self):\n        res = self._getResponse(\n            '/static/encoded.html',\n            headers={'Accept-Encoding': 'br, foo, gzip'},\n        )\n        self.assertEqual(res.headers['Vary'], 'Accept-Encoding')\n        self.assertEqual(res.headers['Content-Encoding'], 'gzip')\n        _assertBody(\n            res.body, os.path.join(here, 'fixtures/static/encoded.html.gz')\n        )",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self"
          ],
          "imports": [
            "datetime",
            "gc",
            "locale",
            "os",
            "unittest",
            "urllib.parse.quote",
            "webtest.TestApp",
            "zope.interface.Interface",
            "pyramid.static.static_view",
            "pyramid.testing.skip_on",
            "pyramid.util.text_",
            "pyramid.view.view_config",
            "pyramid.wsgi.wsgiapp",
            "pkgs.exceptionviewapp.models.AnException",
            "pkgs.exceptionviewapp.models.NotAnException",
            "types",
            "venusian.ATTACH_ATTR",
            "pyramid.config.Configurator",
            "pyramid.interfaces.IRequest",
            "pyramid.interfaces.IView",
            "pyramid.interfaces.IViewClassifier",
            ".test_integration",
            "pyramid.config.Configurator",
            "pyramid.request.Request",
            "io.BytesIO",
            "pyramid.request.Request",
            "pyramid.config.Configurator",
            "pyramid.response.Response",
            "pyramid.response.Response",
            "pyramid.config.Configurator",
            "pkgs.includeapp1.root.configure",
            "test_config.pkgs.selfscan.main",
            "pkgs.wsgiapp2app.main",
            "pkgs.subrequestapp.main",
            "pyramid.config.Configurator",
            "pyramid.config.Configurator",
            "pyramid.config",
            "pyramid.config",
            "pyramid.config.Configurator"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "_assertBody",
              "body": "def _assertBody(body, filename):\n    if defaultlocale is None:\n        filename = filename.encode('utf-8')\n    body = body.replace(b'\\r', b'')\n    body = body.replace(b'\\n', b'')\n    data = read_(filename)\n    data = data.replace(b'\\r', b'')\n    data = data.replace(b'\\n', b'')\n    assert body == data",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_assertBody` method is designed to verify that the content of a given `body` matches the content read from a specified file, after normalizing both by removing carriage return (`\\r`) and newline (`\\n`) characters. This is useful for ensuring that the response body from a request matches the expected content from a file, which is often used in testing scenarios.\n\n**How It Works**:\n1. **Encoding Check**: If `defaultlocale` is `None`, the method encodes the `filename` to UTF-8.\n2. **Body Normalization**: The method replaces all occurrences of carriage return and newline characters in the `body` with empty bytes, effectively removing them.\n3. **File Reading**: It reads the content of the file specified by `filename` using the `read_` function, which is assumed to return the file's content as bytes.\n4. **File Normalization**: Similar to the `body`, it removes carriage return and newline characters from the file content.\n5. **Assertion**: Finally, it asserts that the normalized `body` is equal to the normalized data read from the file. If they are not equal, an `AssertionError` is raised, indicating a mismatch."
            }
          ]
        },
        {
          "repo_name": "pyramid",
          "name": "test_directory_withslash",
          "module": "test_integration",
          "class_name": null,
          "file_path": "__internal__/data/pyramid/tests/test_integration.py",
          "line_number": 160,
          "end_line_number": 163,
          "source_code": "def test_directory_withslash(self):\n        fn = os.path.join(here, 'fixtures/static/index.html')\n        res = self.testapp.get('/static/', status=200)\n        _assertBody(res.body, fn)",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self"
          ],
          "imports": [
            "datetime",
            "gc",
            "locale",
            "os",
            "unittest",
            "urllib.parse.quote",
            "webtest.TestApp",
            "zope.interface.Interface",
            "pyramid.static.static_view",
            "pyramid.testing.skip_on",
            "pyramid.util.text_",
            "pyramid.view.view_config",
            "pyramid.wsgi.wsgiapp",
            "pkgs.exceptionviewapp.models.AnException",
            "pkgs.exceptionviewapp.models.NotAnException",
            "types",
            "venusian.ATTACH_ATTR",
            "pyramid.config.Configurator",
            "pyramid.interfaces.IRequest",
            "pyramid.interfaces.IView",
            "pyramid.interfaces.IViewClassifier",
            ".test_integration",
            "pyramid.config.Configurator",
            "pyramid.request.Request",
            "io.BytesIO",
            "pyramid.request.Request",
            "pyramid.config.Configurator",
            "pyramid.response.Response",
            "pyramid.response.Response",
            "pyramid.config.Configurator",
            "pkgs.includeapp1.root.configure",
            "test_config.pkgs.selfscan.main",
            "pkgs.wsgiapp2app.main",
            "pkgs.subrequestapp.main",
            "pyramid.config.Configurator",
            "pyramid.config.Configurator",
            "pyramid.config",
            "pyramid.config",
            "pyramid.config.Configurator"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "_assertBody",
              "body": "def _assertBody(body, filename):\n    if defaultlocale is None:\n        filename = filename.encode('utf-8')\n    body = body.replace(b'\\r', b'')\n    body = body.replace(b'\\n', b'')\n    data = read_(filename)\n    data = data.replace(b'\\r', b'')\n    data = data.replace(b'\\n', b'')\n    assert body == data",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_assertBody` method is designed to verify that the content of a given `body` matches the content read from a specified file, after normalizing both by removing carriage return (`\\r`) and newline (`\\n`) characters. This is useful for ensuring that the response body from a request matches the expected content from a file, which is often used in testing scenarios.\n\n**How It Works**:\n1. **Encoding Check**: If `defaultlocale` is `None`, the method encodes the `filename` to UTF-8.\n2. **Body Normalization**: It removes all carriage return and newline characters from the `body` using the `replace` method.\n3. **File Reading**: The method reads the content of the file specified by `filename` using a `read_` function (assumed to be defined elsewhere).\n4. **File Normalization**: Similar to the `body`, it removes carriage return and newline characters from the file content.\n5. **Assertion**: Finally, it asserts that the normalized `body` is equal to the normalized data read from the file. If they are not equal, an `AssertionError` is raised, indicating a mismatch. \n\nThis method is typically used in test cases to ensure that the output of a function or endpoint matches expected results stored in files."
            }
          ]
        },
        {
          "repo_name": "pyramid",
          "name": "test_basic",
          "module": "test_integration",
          "class_name": null,
          "file_path": "__internal__/data/pyramid/tests/test_integration.py",
          "line_number": 327,
          "end_line_number": 332,
          "source_code": "def test_basic(self):\n        request = self._makeRequest({'PATH_INFO': '/minimal.txt'})\n        context = DummyContext()\n        result = self.staticapp(context, request)\n        self.assertEqual(result.status, '200 OK')\n        _assertBody(result.body, os.path.join(here, 'fixtures/minimal.txt'))",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self"
          ],
          "imports": [
            "datetime",
            "gc",
            "locale",
            "os",
            "unittest",
            "urllib.parse.quote",
            "webtest.TestApp",
            "zope.interface.Interface",
            "pyramid.static.static_view",
            "pyramid.testing.skip_on",
            "pyramid.util.text_",
            "pyramid.view.view_config",
            "pyramid.wsgi.wsgiapp",
            "pkgs.exceptionviewapp.models.AnException",
            "pkgs.exceptionviewapp.models.NotAnException",
            "types",
            "venusian.ATTACH_ATTR",
            "pyramid.config.Configurator",
            "pyramid.interfaces.IRequest",
            "pyramid.interfaces.IView",
            "pyramid.interfaces.IViewClassifier",
            ".test_integration",
            "pyramid.config.Configurator",
            "pyramid.request.Request",
            "io.BytesIO",
            "pyramid.request.Request",
            "pyramid.config.Configurator",
            "pyramid.response.Response",
            "pyramid.response.Response",
            "pyramid.config.Configurator",
            "pkgs.includeapp1.root.configure",
            "test_config.pkgs.selfscan.main",
            "pkgs.wsgiapp2app.main",
            "pkgs.subrequestapp.main",
            "pyramid.config.Configurator",
            "pyramid.config.Configurator",
            "pyramid.config",
            "pyramid.config",
            "pyramid.config.Configurator"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "_assertBody",
              "body": "def _assertBody(body, filename):\n    if defaultlocale is None:\n        filename = filename.encode('utf-8')\n    body = body.replace(b'\\r', b'')\n    body = body.replace(b'\\n', b'')\n    data = read_(filename)\n    data = data.replace(b'\\r', b'')\n    data = data.replace(b'\\n', b'')\n    assert body == data",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_assertBody` method is designed to compare the content of a given byte string (`body`) with the contents of a file specified by `filename`. It ensures that both the `body` and the file's data are free of carriage return (`\\r`) and newline (`\\n`) characters before performing the comparison.\n\n**How It Works**:\n1. If `defaultlocale` is `None`, the method encodes the `filename` to UTF-8.\n2. It removes all carriage return and newline characters from the `body` byte string.\n3. It reads the contents of the file specified by `filename`, also removing any carriage return and newline characters.\n4. Finally, it asserts that the cleaned `body` is equal to the cleaned data read from the file. If they are not equal, an `AssertionError` is raised, indicating a mismatch."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "gunicorn",
        "name": "test_readline_empty_body",
        "module": "test_http",
        "class_name": null,
        "file_path": "__internal__/data/gunicorn/tests/test_http.py",
        "line_number": 29,
        "end_line_number": 31,
        "source_code": "def test_readline_empty_body():\n    assert_readline(b\"\", None, b\"\")\n    assert_readline(b\"\", 1, b\"\")",
        "docstring": null,
        "decorators": [],
        "arguments": [],
        "imports": [
          "io",
          "t",
          "pytest",
          "unittest.mock",
          "gunicorn.util",
          "gunicorn.http.body.Body",
          "gunicorn.http.body.LengthReader",
          "gunicorn.http.body.EOFReader",
          "gunicorn.http.wsgi.Response",
          "gunicorn.http.unreader.Unreader",
          "gunicorn.http.unreader.IterUnreader",
          "gunicorn.http.unreader.SocketUnreader",
          "gunicorn.http.errors.InvalidHeader",
          "gunicorn.http.errors.InvalidHeaderName",
          "gunicorn.http.errors.InvalidHTTPVersion",
          "gunicorn.http.message.TOKEN_RE"
        ],
        "fixtures": [],
        "assertions": [],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "assert_readline",
            "body": "def assert_readline(payload, size, expected):\n    body = Body(io.BytesIO(payload))\n    assert body.readline(size) == expected",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `assert_readline` method is designed to verify that a specific number of bytes can be read from a given payload using the `readline` method of a `Body` object, and that the result matches an expected byte sequence.\n\n**How It Works**:  \nThe method takes three parameters: `payload`, `size`, and `expected`. It initializes a `Body` object with the `payload` wrapped in a `BytesIO` stream. It then calls the `readline` method of the `Body` object with the specified `size` and asserts that the returned value is equal to the `expected` byte sequence. If the assertion fails, an `AssertionError` is raised, indicating that the actual output did not match the expected output. This method is useful for testing the behavior of the `readline` function under controlled conditions."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "pyramid",
          "name": "test_accept_gzip",
          "module": "test_integration",
          "class_name": "TestStaticAppWithEncodings",
          "file_path": "__internal__/data/pyramid/tests/test_integration.py",
          "line_number": 285,
          "end_line_number": 294,
          "source_code": "def test_accept_gzip(self):\n        res = self._getResponse(\n            '/static/encoded.html',\n            headers={'Accept-Encoding': 'br, foo, gzip'},\n        )\n        self.assertEqual(res.headers['Vary'], 'Accept-Encoding')\n        self.assertEqual(res.headers['Content-Encoding'], 'gzip')\n        _assertBody(\n            res.body, os.path.join(here, 'fixtures/static/encoded.html.gz')\n        )",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self"
          ],
          "imports": [
            "datetime",
            "gc",
            "locale",
            "os",
            "unittest",
            "urllib.parse.quote",
            "webtest.TestApp",
            "zope.interface.Interface",
            "pyramid.static.static_view",
            "pyramid.testing.skip_on",
            "pyramid.util.text_",
            "pyramid.view.view_config",
            "pyramid.wsgi.wsgiapp",
            "pkgs.exceptionviewapp.models.AnException",
            "pkgs.exceptionviewapp.models.NotAnException",
            "types",
            "venusian.ATTACH_ATTR",
            "pyramid.config.Configurator",
            "pyramid.interfaces.IRequest",
            "pyramid.interfaces.IView",
            "pyramid.interfaces.IViewClassifier",
            ".test_integration",
            "pyramid.config.Configurator",
            "pyramid.request.Request",
            "io.BytesIO",
            "pyramid.request.Request",
            "pyramid.config.Configurator",
            "pyramid.response.Response",
            "pyramid.response.Response",
            "pyramid.config.Configurator",
            "pkgs.includeapp1.root.configure",
            "test_config.pkgs.selfscan.main",
            "pkgs.wsgiapp2app.main",
            "pkgs.subrequestapp.main",
            "pyramid.config.Configurator",
            "pyramid.config.Configurator",
            "pyramid.config",
            "pyramid.config",
            "pyramid.config.Configurator"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "_assertBody",
              "body": "def _assertBody(body, filename):\n    if defaultlocale is None:\n        filename = filename.encode('utf-8')\n    body = body.replace(b'\\r', b'')\n    body = body.replace(b'\\n', b'')\n    data = read_(filename)\n    data = data.replace(b'\\r', b'')\n    data = data.replace(b'\\n', b'')\n    assert body == data",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_assertBody` method is designed to verify that the content of a given `body` matches the content read from a specified file, after normalizing both by removing carriage return (`\\r`) and newline (`\\n`) characters. This is useful for ensuring that the response body from a request matches the expected content from a file, which is often used in testing scenarios.\n\n**How It Works**:\n1. **Encoding Check**: If `defaultlocale` is `None`, the method encodes the `filename` to UTF-8.\n2. **Body Normalization**: The method replaces all occurrences of carriage return and newline characters in the `body` with empty bytes, effectively removing them.\n3. **File Reading**: It reads the content of the file specified by `filename` using the `read_` function, which is assumed to return the file's content as bytes.\n4. **File Normalization**: Similar to the `body`, it removes carriage return and newline characters from the file content.\n5. **Assertion**: Finally, it asserts that the normalized `body` is equal to the normalized data read from the file. If they are not equal, an `AssertionError` is raised, indicating a mismatch."
            }
          ]
        },
        {
          "repo_name": "pyramid",
          "name": "test_directory_withslash",
          "module": "test_integration",
          "class_name": null,
          "file_path": "__internal__/data/pyramid/tests/test_integration.py",
          "line_number": 160,
          "end_line_number": 163,
          "source_code": "def test_directory_withslash(self):\n        fn = os.path.join(here, 'fixtures/static/index.html')\n        res = self.testapp.get('/static/', status=200)\n        _assertBody(res.body, fn)",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self"
          ],
          "imports": [
            "datetime",
            "gc",
            "locale",
            "os",
            "unittest",
            "urllib.parse.quote",
            "webtest.TestApp",
            "zope.interface.Interface",
            "pyramid.static.static_view",
            "pyramid.testing.skip_on",
            "pyramid.util.text_",
            "pyramid.view.view_config",
            "pyramid.wsgi.wsgiapp",
            "pkgs.exceptionviewapp.models.AnException",
            "pkgs.exceptionviewapp.models.NotAnException",
            "types",
            "venusian.ATTACH_ATTR",
            "pyramid.config.Configurator",
            "pyramid.interfaces.IRequest",
            "pyramid.interfaces.IView",
            "pyramid.interfaces.IViewClassifier",
            ".test_integration",
            "pyramid.config.Configurator",
            "pyramid.request.Request",
            "io.BytesIO",
            "pyramid.request.Request",
            "pyramid.config.Configurator",
            "pyramid.response.Response",
            "pyramid.response.Response",
            "pyramid.config.Configurator",
            "pkgs.includeapp1.root.configure",
            "test_config.pkgs.selfscan.main",
            "pkgs.wsgiapp2app.main",
            "pkgs.subrequestapp.main",
            "pyramid.config.Configurator",
            "pyramid.config.Configurator",
            "pyramid.config",
            "pyramid.config",
            "pyramid.config.Configurator"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "_assertBody",
              "body": "def _assertBody(body, filename):\n    if defaultlocale is None:\n        filename = filename.encode('utf-8')\n    body = body.replace(b'\\r', b'')\n    body = body.replace(b'\\n', b'')\n    data = read_(filename)\n    data = data.replace(b'\\r', b'')\n    data = data.replace(b'\\n', b'')\n    assert body == data",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_assertBody` method is designed to verify that the content of a given `body` matches the content read from a specified file, after normalizing both by removing carriage return (`\\r`) and newline (`\\n`) characters. This is useful for ensuring that the response body from a request matches the expected content from a file, which is often used in testing scenarios.\n\n**How It Works**:\n1. **Encoding Check**: If `defaultlocale` is `None`, the method encodes the `filename` to UTF-8.\n2. **Body Normalization**: It removes all carriage return and newline characters from the `body` using the `replace` method.\n3. **File Reading**: The method reads the content of the file specified by `filename` using a `read_` function (assumed to be defined elsewhere).\n4. **File Normalization**: Similar to the `body`, it removes carriage return and newline characters from the file content.\n5. **Assertion**: Finally, it asserts that the normalized `body` is equal to the normalized data read from the file. If they are not equal, an `AssertionError` is raised, indicating a mismatch. \n\nThis method is typically used in test cases to ensure that the output of a function or endpoint matches expected results stored in files."
            }
          ]
        },
        {
          "repo_name": "pyramid",
          "name": "test_includelevel1",
          "module": "test_integration",
          "class_name": null,
          "file_path": "__internal__/data/pyramid/tests/test_integration.py",
          "line_number": 338,
          "end_line_number": 340,
          "source_code": "def test_includelevel1(self):\n        res = self.testapp.get('/static/minimal.txt', status=200)\n        _assertBody(res.body, os.path.join(here, 'fixtures/minimal.txt'))",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self"
          ],
          "imports": [
            "datetime",
            "gc",
            "locale",
            "os",
            "unittest",
            "urllib.parse.quote",
            "webtest.TestApp",
            "zope.interface.Interface",
            "pyramid.static.static_view",
            "pyramid.testing.skip_on",
            "pyramid.util.text_",
            "pyramid.view.view_config",
            "pyramid.wsgi.wsgiapp",
            "pkgs.exceptionviewapp.models.AnException",
            "pkgs.exceptionviewapp.models.NotAnException",
            "types",
            "venusian.ATTACH_ATTR",
            "pyramid.config.Configurator",
            "pyramid.interfaces.IRequest",
            "pyramid.interfaces.IView",
            "pyramid.interfaces.IViewClassifier",
            ".test_integration",
            "pyramid.config.Configurator",
            "pyramid.request.Request",
            "io.BytesIO",
            "pyramid.request.Request",
            "pyramid.config.Configurator",
            "pyramid.response.Response",
            "pyramid.response.Response",
            "pyramid.config.Configurator",
            "pkgs.includeapp1.root.configure",
            "test_config.pkgs.selfscan.main",
            "pkgs.wsgiapp2app.main",
            "pkgs.subrequestapp.main",
            "pyramid.config.Configurator",
            "pyramid.config.Configurator",
            "pyramid.config",
            "pyramid.config",
            "pyramid.config.Configurator"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "_assertBody",
              "body": "def _assertBody(body, filename):\n    if defaultlocale is None:\n        filename = filename.encode('utf-8')\n    body = body.replace(b'\\r', b'')\n    body = body.replace(b'\\n', b'')\n    data = read_(filename)\n    data = data.replace(b'\\r', b'')\n    data = data.replace(b'\\n', b'')\n    assert body == data",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_assertBody` method is designed to verify that the content of a given `body` matches the content read from a specified file, after normalizing both by removing carriage return (`\\r`) and newline (`\\n`) characters. This is useful for ensuring that the response body from a request matches the expected content from a file, which is often used in testing scenarios.\n\n**How It Works**:\n1. **Encoding Check**: If `defaultlocale` is `None`, the method encodes the `filename` to UTF-8.\n2. **Body Normalization**: The method removes all carriage return and newline characters from the `body` using the `replace` method.\n3. **File Reading**: It reads the content of the file specified by `filename` into the `data` variable.\n4. **Data Normalization**: Similar to the `body`, it also removes carriage return and newline characters from the `data`.\n5. **Assertion**: Finally, it asserts that the normalized `body` is equal to the normalized `data`. If they are not equal, an `AssertionError` is raised, indicating a mismatch. \n\nThis method is typically used in test cases to ensure that the output of a function or endpoint matches the expected output defined in a file."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "gunicorn",
        "name": "test_readline_zero_size",
        "module": "test_http",
        "class_name": null,
        "file_path": "__internal__/data/gunicorn/tests/test_http.py",
        "line_number": 34,
        "end_line_number": 36,
        "source_code": "def test_readline_zero_size():\n    assert_readline(b\"abc\", 0, b\"\")\n    assert_readline(b\"\\n\", 0, b\"\")",
        "docstring": null,
        "decorators": [],
        "arguments": [],
        "imports": [
          "io",
          "t",
          "pytest",
          "unittest.mock",
          "gunicorn.util",
          "gunicorn.http.body.Body",
          "gunicorn.http.body.LengthReader",
          "gunicorn.http.body.EOFReader",
          "gunicorn.http.wsgi.Response",
          "gunicorn.http.unreader.Unreader",
          "gunicorn.http.unreader.IterUnreader",
          "gunicorn.http.unreader.SocketUnreader",
          "gunicorn.http.errors.InvalidHeader",
          "gunicorn.http.errors.InvalidHeaderName",
          "gunicorn.http.errors.InvalidHTTPVersion",
          "gunicorn.http.message.TOKEN_RE"
        ],
        "fixtures": [],
        "assertions": [],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "assert_readline",
            "body": "def assert_readline(payload, size, expected):\n    body = Body(io.BytesIO(payload))\n    assert body.readline(size) == expected",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `assert_readline` method is designed to verify that a specific number of bytes can be read from a given payload and that the result matches an expected byte string. It is primarily used for testing the behavior of reading lines from a byte stream.\n\n**How It Works**:  \nThe method takes three parameters: `payload`, `size`, and `expected`. It creates a `Body` object initialized with a `BytesIO` stream containing the `payload`. It then calls the `readline` method of the `Body` object with the specified `size` and asserts that the result equals the `expected` byte string. If the assertion fails, it raises an `AssertionError`, indicating that the actual output did not match the expected output. This method is useful in unit tests to ensure that the reading functionality behaves as intended."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "pyramid",
          "name": "test_accept_gzip",
          "module": "test_integration",
          "class_name": "TestStaticAppWithEncodings",
          "file_path": "__internal__/data/pyramid/tests/test_integration.py",
          "line_number": 285,
          "end_line_number": 294,
          "source_code": "def test_accept_gzip(self):\n        res = self._getResponse(\n            '/static/encoded.html',\n            headers={'Accept-Encoding': 'br, foo, gzip'},\n        )\n        self.assertEqual(res.headers['Vary'], 'Accept-Encoding')\n        self.assertEqual(res.headers['Content-Encoding'], 'gzip')\n        _assertBody(\n            res.body, os.path.join(here, 'fixtures/static/encoded.html.gz')\n        )",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self"
          ],
          "imports": [
            "datetime",
            "gc",
            "locale",
            "os",
            "unittest",
            "urllib.parse.quote",
            "webtest.TestApp",
            "zope.interface.Interface",
            "pyramid.static.static_view",
            "pyramid.testing.skip_on",
            "pyramid.util.text_",
            "pyramid.view.view_config",
            "pyramid.wsgi.wsgiapp",
            "pkgs.exceptionviewapp.models.AnException",
            "pkgs.exceptionviewapp.models.NotAnException",
            "types",
            "venusian.ATTACH_ATTR",
            "pyramid.config.Configurator",
            "pyramid.interfaces.IRequest",
            "pyramid.interfaces.IView",
            "pyramid.interfaces.IViewClassifier",
            ".test_integration",
            "pyramid.config.Configurator",
            "pyramid.request.Request",
            "io.BytesIO",
            "pyramid.request.Request",
            "pyramid.config.Configurator",
            "pyramid.response.Response",
            "pyramid.response.Response",
            "pyramid.config.Configurator",
            "pkgs.includeapp1.root.configure",
            "test_config.pkgs.selfscan.main",
            "pkgs.wsgiapp2app.main",
            "pkgs.subrequestapp.main",
            "pyramid.config.Configurator",
            "pyramid.config.Configurator",
            "pyramid.config",
            "pyramid.config",
            "pyramid.config.Configurator"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "_assertBody",
              "body": "def _assertBody(body, filename):\n    if defaultlocale is None:\n        filename = filename.encode('utf-8')\n    body = body.replace(b'\\r', b'')\n    body = body.replace(b'\\n', b'')\n    data = read_(filename)\n    data = data.replace(b'\\r', b'')\n    data = data.replace(b'\\n', b'')\n    assert body == data",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_assertBody` method is designed to verify that the content of a given `body` matches the content read from a specified file, after normalizing both by removing carriage return (`\\r`) and newline (`\\n`) characters. This is useful for ensuring that the response body from a request matches the expected content from a file, which is often used in testing scenarios.\n\n**How It Works**:\n1. **Encoding Check**: If `defaultlocale` is `None`, the method encodes the `filename` to UTF-8.\n2. **Body Normalization**: The method replaces all occurrences of carriage return and newline characters in the `body` with empty bytes, effectively removing them.\n3. **File Reading**: It reads the content of the file specified by `filename` using the `read_` function, which is assumed to return the file's content as bytes.\n4. **File Normalization**: Similar to the `body`, it removes carriage return and newline characters from the file content.\n5. **Assertion**: Finally, it asserts that the normalized `body` is equal to the normalized data read from the file. If they are not equal, an `AssertionError` is raised, indicating a mismatch."
            }
          ]
        },
        {
          "repo_name": "pyramid",
          "name": "test_directory_withslash",
          "module": "test_integration",
          "class_name": null,
          "file_path": "__internal__/data/pyramid/tests/test_integration.py",
          "line_number": 160,
          "end_line_number": 163,
          "source_code": "def test_directory_withslash(self):\n        fn = os.path.join(here, 'fixtures/static/index.html')\n        res = self.testapp.get('/static/', status=200)\n        _assertBody(res.body, fn)",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self"
          ],
          "imports": [
            "datetime",
            "gc",
            "locale",
            "os",
            "unittest",
            "urllib.parse.quote",
            "webtest.TestApp",
            "zope.interface.Interface",
            "pyramid.static.static_view",
            "pyramid.testing.skip_on",
            "pyramid.util.text_",
            "pyramid.view.view_config",
            "pyramid.wsgi.wsgiapp",
            "pkgs.exceptionviewapp.models.AnException",
            "pkgs.exceptionviewapp.models.NotAnException",
            "types",
            "venusian.ATTACH_ATTR",
            "pyramid.config.Configurator",
            "pyramid.interfaces.IRequest",
            "pyramid.interfaces.IView",
            "pyramid.interfaces.IViewClassifier",
            ".test_integration",
            "pyramid.config.Configurator",
            "pyramid.request.Request",
            "io.BytesIO",
            "pyramid.request.Request",
            "pyramid.config.Configurator",
            "pyramid.response.Response",
            "pyramid.response.Response",
            "pyramid.config.Configurator",
            "pkgs.includeapp1.root.configure",
            "test_config.pkgs.selfscan.main",
            "pkgs.wsgiapp2app.main",
            "pkgs.subrequestapp.main",
            "pyramid.config.Configurator",
            "pyramid.config.Configurator",
            "pyramid.config",
            "pyramid.config",
            "pyramid.config.Configurator"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "_assertBody",
              "body": "def _assertBody(body, filename):\n    if defaultlocale is None:\n        filename = filename.encode('utf-8')\n    body = body.replace(b'\\r', b'')\n    body = body.replace(b'\\n', b'')\n    data = read_(filename)\n    data = data.replace(b'\\r', b'')\n    data = data.replace(b'\\n', b'')\n    assert body == data",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_assertBody` method is designed to verify that the content of a given `body` matches the content read from a specified file, after normalizing both by removing carriage return (`\\r`) and newline (`\\n`) characters. This is useful for ensuring that the response body from a request matches the expected content from a file, which is often used in testing scenarios.\n\n**How It Works**:\n1. **Encoding Check**: If `defaultlocale` is `None`, the method encodes the `filename` to UTF-8.\n2. **Body Normalization**: It removes all carriage return and newline characters from the `body` using the `replace` method.\n3. **File Reading**: The method reads the content of the file specified by `filename` using a `read_` function (assumed to be defined elsewhere).\n4. **File Normalization**: Similar to the `body`, it removes carriage return and newline characters from the file content.\n5. **Assertion**: Finally, it asserts that the normalized `body` is equal to the normalized data read from the file. If they are not equal, an `AssertionError` is raised, indicating a mismatch. \n\nThis method is typically used in test cases to ensure that the output of a function or endpoint matches expected results stored in files."
            }
          ]
        },
        {
          "repo_name": "pyramid",
          "name": "test_includelevel1",
          "module": "test_integration",
          "class_name": "TestStaticAppWithRoutePrefix",
          "file_path": "__internal__/data/pyramid/tests/test_integration.py",
          "line_number": 338,
          "end_line_number": 340,
          "source_code": "def test_includelevel1(self):\n        res = self.testapp.get('/static/minimal.txt', status=200)\n        _assertBody(res.body, os.path.join(here, 'fixtures/minimal.txt'))",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self"
          ],
          "imports": [
            "datetime",
            "gc",
            "locale",
            "os",
            "unittest",
            "urllib.parse.quote",
            "webtest.TestApp",
            "zope.interface.Interface",
            "pyramid.static.static_view",
            "pyramid.testing.skip_on",
            "pyramid.util.text_",
            "pyramid.view.view_config",
            "pyramid.wsgi.wsgiapp",
            "pkgs.exceptionviewapp.models.AnException",
            "pkgs.exceptionviewapp.models.NotAnException",
            "types",
            "venusian.ATTACH_ATTR",
            "pyramid.config.Configurator",
            "pyramid.interfaces.IRequest",
            "pyramid.interfaces.IView",
            "pyramid.interfaces.IViewClassifier",
            ".test_integration",
            "pyramid.config.Configurator",
            "pyramid.request.Request",
            "io.BytesIO",
            "pyramid.request.Request",
            "pyramid.config.Configurator",
            "pyramid.response.Response",
            "pyramid.response.Response",
            "pyramid.config.Configurator",
            "pkgs.includeapp1.root.configure",
            "test_config.pkgs.selfscan.main",
            "pkgs.wsgiapp2app.main",
            "pkgs.subrequestapp.main",
            "pyramid.config.Configurator",
            "pyramid.config.Configurator",
            "pyramid.config",
            "pyramid.config",
            "pyramid.config.Configurator"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "_assertBody",
              "body": "def _assertBody(body, filename):\n    if defaultlocale is None:\n        filename = filename.encode('utf-8')\n    body = body.replace(b'\\r', b'')\n    body = body.replace(b'\\n', b'')\n    data = read_(filename)\n    data = data.replace(b'\\r', b'')\n    data = data.replace(b'\\n', b'')\n    assert body == data",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_assertBody` method is designed to verify that the content of a given `body` matches the content read from a specified file, after normalizing both by removing carriage return (`\\r`) and newline (`\\n`) characters. This is useful for ensuring that the response body from a request matches the expected content from a file, which is often used in testing scenarios.\n\n**How It Works**:\n1. **Encoding Check**: If `defaultlocale` is `None`, the method encodes the `filename` to UTF-8.\n2. **Body Normalization**: It removes all carriage return and newline characters from the `body` using the `replace` method.\n3. **File Reading**: The method reads the content of the file specified by `filename` using a function `read_`, which is assumed to return the file's content as bytes.\n4. **File Normalization**: Similar to the `body`, it normalizes the file content by removing carriage return and newline characters.\n5. **Assertion**: Finally, it asserts that the normalized `body` is equal to the normalized data read from the file. If they are not equal, an `AssertionError` is raised, indicating a mismatch. \n\nThis method is typically used in tests to ensure that the output of a web response matches the expected output defined in a file."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "gunicorn",
        "name": "test_readline_zero_size",
        "module": "test_http",
        "class_name": null,
        "file_path": "__internal__/data/gunicorn/tests/test_http.py",
        "line_number": 34,
        "end_line_number": 36,
        "source_code": "def test_readline_zero_size():\n    assert_readline(b\"abc\", 0, b\"\")\n    assert_readline(b\"\\n\", 0, b\"\")",
        "docstring": null,
        "decorators": [],
        "arguments": [],
        "imports": [
          "io",
          "t",
          "pytest",
          "unittest.mock",
          "gunicorn.util",
          "gunicorn.http.body.Body",
          "gunicorn.http.body.LengthReader",
          "gunicorn.http.body.EOFReader",
          "gunicorn.http.wsgi.Response",
          "gunicorn.http.unreader.Unreader",
          "gunicorn.http.unreader.IterUnreader",
          "gunicorn.http.unreader.SocketUnreader",
          "gunicorn.http.errors.InvalidHeader",
          "gunicorn.http.errors.InvalidHeaderName",
          "gunicorn.http.errors.InvalidHTTPVersion",
          "gunicorn.http.message.TOKEN_RE"
        ],
        "fixtures": [],
        "assertions": [],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "assert_readline",
            "body": "def assert_readline(payload, size, expected):\n    body = Body(io.BytesIO(payload))\n    assert body.readline(size) == expected",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `assert_readline` method is designed to verify that a specific number of bytes can be read from a given payload using the `readline` method of a `Body` object, and that the result matches an expected byte sequence.\n\n**How It Works**:  \nThe method takes three parameters: `payload`, which is the byte data to be read; `size`, which specifies the number of bytes to read; and `expected`, the expected byte output. It creates a `Body` instance initialized with the `payload` wrapped in a `BytesIO` stream. It then calls the `readline` method of the `Body` instance with the specified `size` and asserts that the result equals the `expected` value. If the assertion fails, an `AssertionError` is raised, indicating that the actual output did not match the expected output."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "pyramid",
          "name": "test_accept_gzip",
          "module": "test_integration",
          "class_name": "TestStaticAppWithEncodings",
          "file_path": "__internal__/data/pyramid/tests/test_integration.py",
          "line_number": 285,
          "end_line_number": 294,
          "source_code": "def test_accept_gzip(self):\n        res = self._getResponse(\n            '/static/encoded.html',\n            headers={'Accept-Encoding': 'br, foo, gzip'},\n        )\n        self.assertEqual(res.headers['Vary'], 'Accept-Encoding')\n        self.assertEqual(res.headers['Content-Encoding'], 'gzip')\n        _assertBody(\n            res.body, os.path.join(here, 'fixtures/static/encoded.html.gz')\n        )",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self"
          ],
          "imports": [
            "datetime",
            "gc",
            "locale",
            "os",
            "unittest",
            "urllib.parse.quote",
            "webtest.TestApp",
            "zope.interface.Interface",
            "pyramid.static.static_view",
            "pyramid.testing.skip_on",
            "pyramid.util.text_",
            "pyramid.view.view_config",
            "pyramid.wsgi.wsgiapp",
            "pkgs.exceptionviewapp.models.AnException",
            "pkgs.exceptionviewapp.models.NotAnException",
            "types",
            "venusian.ATTACH_ATTR",
            "pyramid.config.Configurator",
            "pyramid.interfaces.IRequest",
            "pyramid.interfaces.IView",
            "pyramid.interfaces.IViewClassifier",
            ".test_integration",
            "pyramid.config.Configurator",
            "pyramid.request.Request",
            "io.BytesIO",
            "pyramid.request.Request",
            "pyramid.config.Configurator",
            "pyramid.response.Response",
            "pyramid.response.Response",
            "pyramid.config.Configurator",
            "pkgs.includeapp1.root.configure",
            "test_config.pkgs.selfscan.main",
            "pkgs.wsgiapp2app.main",
            "pkgs.subrequestapp.main",
            "pyramid.config.Configurator",
            "pyramid.config.Configurator",
            "pyramid.config",
            "pyramid.config",
            "pyramid.config.Configurator"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "_assertBody",
              "body": "def _assertBody(body, filename):\n    if defaultlocale is None:\n        filename = filename.encode('utf-8')\n    body = body.replace(b'\\r', b'')\n    body = body.replace(b'\\n', b'')\n    data = read_(filename)\n    data = data.replace(b'\\r', b'')\n    data = data.replace(b'\\n', b'')\n    assert body == data",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_assertBody` method is designed to verify that the content of a given `body` matches the content read from a specified file, after normalizing both by removing carriage return (`\\r`) and newline (`\\n`) characters. This is useful for ensuring that the response body from a request matches the expected content from a file, which is often used in testing scenarios.\n\n**How It Works**:\n1. **Encoding Check**: If `defaultlocale` is `None`, the method encodes the `filename` to UTF-8.\n2. **Body Normalization**: The method replaces all occurrences of carriage return and newline characters in the `body` with empty bytes, effectively removing them.\n3. **File Reading**: It reads the content of the file specified by `filename` using the `read_` function, which is assumed to return the file's content as bytes.\n4. **File Normalization**: Similar to the `body`, it removes carriage return and newline characters from the file content.\n5. **Assertion**: Finally, it asserts that the normalized `body` is equal to the normalized data read from the file. If they are not equal, an `AssertionError` is raised, indicating a mismatch."
            }
          ]
        },
        {
          "repo_name": "pyramid",
          "name": "test_directory_withslash",
          "module": "test_integration",
          "class_name": null,
          "file_path": "__internal__/data/pyramid/tests/test_integration.py",
          "line_number": 160,
          "end_line_number": 163,
          "source_code": "def test_directory_withslash(self):\n        fn = os.path.join(here, 'fixtures/static/index.html')\n        res = self.testapp.get('/static/', status=200)\n        _assertBody(res.body, fn)",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self"
          ],
          "imports": [
            "datetime",
            "gc",
            "locale",
            "os",
            "unittest",
            "urllib.parse.quote",
            "webtest.TestApp",
            "zope.interface.Interface",
            "pyramid.static.static_view",
            "pyramid.testing.skip_on",
            "pyramid.util.text_",
            "pyramid.view.view_config",
            "pyramid.wsgi.wsgiapp",
            "pkgs.exceptionviewapp.models.AnException",
            "pkgs.exceptionviewapp.models.NotAnException",
            "types",
            "venusian.ATTACH_ATTR",
            "pyramid.config.Configurator",
            "pyramid.interfaces.IRequest",
            "pyramid.interfaces.IView",
            "pyramid.interfaces.IViewClassifier",
            ".test_integration",
            "pyramid.config.Configurator",
            "pyramid.request.Request",
            "io.BytesIO",
            "pyramid.request.Request",
            "pyramid.config.Configurator",
            "pyramid.response.Response",
            "pyramid.response.Response",
            "pyramid.config.Configurator",
            "pkgs.includeapp1.root.configure",
            "test_config.pkgs.selfscan.main",
            "pkgs.wsgiapp2app.main",
            "pkgs.subrequestapp.main",
            "pyramid.config.Configurator",
            "pyramid.config.Configurator",
            "pyramid.config",
            "pyramid.config",
            "pyramid.config.Configurator"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "_assertBody",
              "body": "def _assertBody(body, filename):\n    if defaultlocale is None:\n        filename = filename.encode('utf-8')\n    body = body.replace(b'\\r', b'')\n    body = body.replace(b'\\n', b'')\n    data = read_(filename)\n    data = data.replace(b'\\r', b'')\n    data = data.replace(b'\\n', b'')\n    assert body == data",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_assertBody` method is designed to verify that the content of a given `body` matches the content read from a specified file, after normalizing both by removing carriage return (`\\r`) and newline (`\\n`) characters. This is useful for ensuring that the response body from a request matches the expected content from a file, which is often used in testing scenarios.\n\n**How It Works**:\n1. **Encoding Check**: If `defaultlocale` is `None`, the method encodes the `filename` to UTF-8.\n2. **Body Normalization**: It removes all carriage return and newline characters from the `body` using the `replace` method.\n3. **File Reading**: The method reads the content of the file specified by `filename` using a `read_` function (assumed to be defined elsewhere).\n4. **File Normalization**: Similar to the `body`, it removes carriage return and newline characters from the file content.\n5. **Assertion**: Finally, it asserts that the normalized `body` is equal to the normalized data read from the file. If they are not equal, an `AssertionError` is raised, indicating a mismatch. \n\nThis method is typically used in test cases to ensure that the output of a function or endpoint matches expected results stored in files."
            }
          ]
        },
        {
          "repo_name": "pyramid",
          "name": "test_includelevel1",
          "module": "test_integration",
          "class_name": null,
          "file_path": "__internal__/data/pyramid/tests/test_integration.py",
          "line_number": 338,
          "end_line_number": 340,
          "source_code": "def test_includelevel1(self):\n        res = self.testapp.get('/static/minimal.txt', status=200)\n        _assertBody(res.body, os.path.join(here, 'fixtures/minimal.txt'))",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self"
          ],
          "imports": [
            "datetime",
            "gc",
            "locale",
            "os",
            "unittest",
            "urllib.parse.quote",
            "webtest.TestApp",
            "zope.interface.Interface",
            "pyramid.static.static_view",
            "pyramid.testing.skip_on",
            "pyramid.util.text_",
            "pyramid.view.view_config",
            "pyramid.wsgi.wsgiapp",
            "pkgs.exceptionviewapp.models.AnException",
            "pkgs.exceptionviewapp.models.NotAnException",
            "types",
            "venusian.ATTACH_ATTR",
            "pyramid.config.Configurator",
            "pyramid.interfaces.IRequest",
            "pyramid.interfaces.IView",
            "pyramid.interfaces.IViewClassifier",
            ".test_integration",
            "pyramid.config.Configurator",
            "pyramid.request.Request",
            "io.BytesIO",
            "pyramid.request.Request",
            "pyramid.config.Configurator",
            "pyramid.response.Response",
            "pyramid.response.Response",
            "pyramid.config.Configurator",
            "pkgs.includeapp1.root.configure",
            "test_config.pkgs.selfscan.main",
            "pkgs.wsgiapp2app.main",
            "pkgs.subrequestapp.main",
            "pyramid.config.Configurator",
            "pyramid.config.Configurator",
            "pyramid.config",
            "pyramid.config",
            "pyramid.config.Configurator"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "_assertBody",
              "body": "def _assertBody(body, filename):\n    if defaultlocale is None:\n        filename = filename.encode('utf-8')\n    body = body.replace(b'\\r', b'')\n    body = body.replace(b'\\n', b'')\n    data = read_(filename)\n    data = data.replace(b'\\r', b'')\n    data = data.replace(b'\\n', b'')\n    assert body == data",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_assertBody` method is designed to verify that the content of a given `body` matches the content read from a specified file, after normalizing both by removing carriage return (`\\r`) and newline (`\\n`) characters. This is useful for ensuring that the response body from a request matches the expected content from a file, which is often used in testing scenarios.\n\n**How It Works**:\n1. **Encoding Check**: If `defaultlocale` is `None`, the method encodes the `filename` to UTF-8.\n2. **Body Normalization**: The method removes all carriage return and newline characters from the `body` using the `replace` method.\n3. **File Reading**: It reads the content of the file specified by `filename` into the `data` variable.\n4. **Data Normalization**: Similar to the `body`, it also removes carriage return and newline characters from the `data`.\n5. **Assertion**: Finally, it asserts that the normalized `body` is equal to the normalized `data`. If they are not equal, an `AssertionError` is raised, indicating a mismatch. \n\nThis method is typically used in test cases to ensure that the output of a function or endpoint matches the expected output defined in a file."
            }
          ]
        }
      ]
    }
  ]
}